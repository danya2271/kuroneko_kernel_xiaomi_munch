base/power/power.h:extern int msm_show_resume_irq_mask;
base/power/power.h:#define msm_show_resume_irq_mask 0
bluetooth/Makefile:obj-$(CONFIG_BT_QCOMSMD)	+= btqcomsmd.o
bluetooth/btqcomsmd.c:struct btqcomsmd {
bluetooth/btqcomsmd.c:static int btqcomsmd_recv(struct hci_dev *hdev, unsigned int type,
bluetooth/btqcomsmd.c:static int btqcomsmd_acl_callback(struct rpmsg_device *rpdev, void *data,
bluetooth/btqcomsmd.c:	struct btqcomsmd *btq = priv;
bluetooth/btqcomsmd.c:	return btqcomsmd_recv(btq->hdev, HCI_ACLDATA_PKT, data, count);
bluetooth/btqcomsmd.c:static int btqcomsmd_cmd_callback(struct rpmsg_device *rpdev, void *data,
bluetooth/btqcomsmd.c:	struct btqcomsmd *btq = priv;
bluetooth/btqcomsmd.c:	return btqcomsmd_recv(btq->hdev, HCI_EVENT_PKT, data, count);
bluetooth/btqcomsmd.c:static int btqcomsmd_send(struct hci_dev *hdev, struct sk_buff *skb)
bluetooth/btqcomsmd.c:	struct btqcomsmd *btq = hci_get_drvdata(hdev);
bluetooth/btqcomsmd.c:static int btqcomsmd_open(struct hci_dev *hdev)
bluetooth/btqcomsmd.c:static int btqcomsmd_close(struct hci_dev *hdev)
bluetooth/btqcomsmd.c:static int btqcomsmd_setup(struct hci_dev *hdev)
bluetooth/btqcomsmd.c:	struct btqcomsmd *btq = hci_get_drvdata(hdev);
bluetooth/btqcomsmd.c:static int btqcomsmd_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)
bluetooth/btqcomsmd.c:static int btqcomsmd_probe(struct platform_device *pdev)
bluetooth/btqcomsmd.c:	struct btqcomsmd *btq;
bluetooth/btqcomsmd.c:						   btqcomsmd_acl_callback, btq);
bluetooth/btqcomsmd.c:						   btqcomsmd_cmd_callback, btq);
bluetooth/btqcomsmd.c:	hdev->open = btqcomsmd_open;
bluetooth/btqcomsmd.c:	hdev->close = btqcomsmd_close;
bluetooth/btqcomsmd.c:	hdev->send = btqcomsmd_send;
bluetooth/btqcomsmd.c:	hdev->setup = btqcomsmd_setup;
bluetooth/btqcomsmd.c:	hdev->set_bdaddr = btqcomsmd_set_bdaddr;
bluetooth/btqcomsmd.c:static int btqcomsmd_remove(struct platform_device *pdev)
bluetooth/btqcomsmd.c:	struct btqcomsmd *btq = platform_get_drvdata(pdev);
bluetooth/btqcomsmd.c:static const struct of_device_id btqcomsmd_of_match[] = {
bluetooth/btqcomsmd.c:MODULE_DEVICE_TABLE(of, btqcomsmd_of_match);
bluetooth/btqcomsmd.c:static struct platform_driver btqcomsmd_driver = {
bluetooth/btqcomsmd.c:	.probe = btqcomsmd_probe,
bluetooth/btqcomsmd.c:	.remove = btqcomsmd_remove,
bluetooth/btqcomsmd.c:		.name  = "btqcomsmd",
bluetooth/btqcomsmd.c:		.of_match_table = btqcomsmd_of_match,
bluetooth/btqcomsmd.c:module_platform_driver(btqcomsmd_driver);
bus/mhi/controllers/mhi_arch_qcom.c:#include <linux/msm-bus.h>
bus/mhi/controllers/mhi_arch_qcom.c:#include <linux/msm_pcie.h>
bus/mhi/controllers/mhi_arch_qcom.c:	struct msm_bus_scale_pdata *msm_bus_pdata;
bus/mhi/controllers/mhi_arch_qcom.c:	struct msm_pcie_register_event pcie_reg_event;
bus/mhi/controllers/mhi_arch_qcom.c:	if (msm_pcie_prevent_l1(pci_dev))
bus/mhi/controllers/mhi_arch_qcom.c:	msm_pcie_allow_l1(pci_dev);
bus/mhi/controllers/mhi_arch_qcom.c:		return msm_bus_scale_client_update_request(
bus/mhi/controllers/mhi_arch_qcom.c:static void mhi_arch_pci_link_state_cb(struct msm_pcie_notify *notify)
bus/mhi/controllers/mhi_arch_qcom.c:	ret = msm_pcie_pm_control(MSM_PCIE_RESUME, pci_dev->bus->number,
bus/mhi/controllers/mhi_arch_qcom.c:	msm_pcie_pm_control(MSM_PCIE_SUSPEND, mhi_cntrl->bus, pci_dev, NULL, 0);
bus/mhi/controllers/mhi_arch_qcom.c:	ret = msm_pcie_set_link_bandwidth(pci_dev, link_info->target_link_speed,
bus/mhi/controllers/mhi_arch_qcom.c:		struct msm_pcie_register_event *reg_event;
bus/mhi/controllers/mhi_arch_qcom.c:		arch_info->msm_bus_pdata = msm_bus_cl_get_pdata_from_dev(
bus/mhi/controllers/mhi_arch_qcom.c:		if (arch_info->msm_bus_pdata) {
bus/mhi/controllers/mhi_arch_qcom.c:				msm_bus_scale_register_client(
bus/mhi/controllers/mhi_arch_qcom.c:						arch_info->msm_bus_pdata);
bus/mhi/controllers/mhi_arch_qcom.c:		ret = msm_pcie_register_event(reg_event);
bus/mhi/controllers/mhi_arch_qcom.c:		msm_pcie_pm_control(MSM_PCIE_DISABLE_PC, mhi_cntrl->bus,
bus/mhi/controllers/mhi_arch_qcom.c:		ret = msm_pcie_set_link_bandwidth(pci_dev,
bus/mhi/controllers/mhi_arch_qcom.c:	ret = msm_pcie_pm_control(MSM_PCIE_DRV_SUSPEND, mhi_cntrl->bus,
bus/mhi/controllers/mhi_arch_qcom.c:	msm_pcie_l1ss_timeout_disable(pci_dev);
bus/mhi/controllers/mhi_arch_qcom.c:		msm_pcie_pm_control(MSM_PCIE_SUSPEND, mhi_cntrl->bus, pci_dev,
bus/mhi/controllers/mhi_arch_qcom.c:		msm_pcie_l1ss_timeout_enable(pci_dev);
bus/mhi/controllers/mhi_arch_qcom.c:	ret = msm_pcie_pm_control(MSM_PCIE_RESUME, mhi_cntrl->bus, pci_dev,
bus/mhi/controllers/mhi_arch_qcom.c:		ret = msm_pcie_pm_control(MSM_PCIE_RESUME, mhi_cntrl->bus,
bus/mhi/controllers/mhi_arch_qcom.c:		msm_pcie_l1ss_timeout_enable(pci_dev);
bus/mhi/controllers/mhi_arch_qcom.c:	return msm_pcie_prevent_l1(mhi_dev->pci_dev);
bus/mhi/controllers/mhi_arch_qcom.c:	msm_pcie_allow_l1(mhi_dev->pci_dev);
bus/mhi/devices/mhi_netdev.c:#include <linux/msm_rmnet.h>
bus/qcom-ebi2.c:	{ .compatible = "qcom,msm8660-ebi2", },
char/Makefile:obj-$(CONFIG_MSM_SMD_PKT)       += msm_smd_pkt.o
char/adsprpc_compat.c:#include <linux/msm_ion.h>
char/diag/diag_dci.c:			msm_set_restart_mode(RESTART_DLOAD);
char/diag/diagfwd.c:	switch (socinfo_get_msm_cpu()) {
char/diag/diagfwd.c:			if (machine_is_msm8974())
char/diag/diagfwd.c:	switch (socinfo_get_msm_cpu()) {
char/diag/diagfwd.c:		msm_set_restart_mode(RESTART_DLOAD);
char/diag/diagfwd_hsic.c:static struct platform_driver msm_hsic_ch_driver = {
char/diag/diagfwd_hsic.c:	err = platform_driver_register(&msm_hsic_ch_driver);
char/diag/diagfwd_hsic.c:	platform_driver_unregister(&msm_hsic_ch_driver);
char/diag/diagfwd_smux.c:		msm_smux_close(ch->lcid);
char/diag/diagfwd_smux.c:	err = msm_smux_open(ch->lcid, (void *)ch->id, diag_smux_event,
char/diag/diagfwd_smux.c:	msm_smux_tiocm_set(ch->lcid, TIOCM_DTR, 0);
char/diag/diagfwd_smux.c:	msm_smux_close(ch->lcid);
char/diag/diagfwd_smux.c:	return  msm_smux_write(ch->lcid, NULL, buf, len);
char/diag/diagfwd_smux.c:static struct platform_driver msm_diagfwd_smux_driver = {
char/diag/diagfwd_smux.c:	err = platform_driver_register(&msm_diagfwd_smux_driver);
char/diag/diagfwd_smux.c:	platform_driver_unregister(&msm_diagfwd_smux_driver);
char/fastcvpd.c:		.name = "qcom,msm_fastcvpd_rpmsg",
char/hw_random/Kconfig:	  module will be called msm_rng.
char/hw_random/Makefile:obj-$(CONFIG_HW_RANDOM_MSM_LEGACY) += msm_rng.o
char/hw_random/msm_rng.c:#include <linux/msm-bus.h>
char/hw_random/msm_rng.c:#define DRIVER_NAME "msm_rng"
char/hw_random/msm_rng.c:struct msm_rng_device {
char/hw_random/msm_rng.c:struct msm_rng_device msm_rng_device_info;
char/hw_random/msm_rng.c:static struct msm_rng_device *msm_rng_dev_cached;
char/hw_random/msm_rng.c:static long msm_rng_ioctl(struct file *filp, unsigned int cmd,
char/hw_random/msm_rng.c:		pr_debug("calling msm_rng_bus_scale(LOW)\n");
char/hw_random/msm_rng.c:		ret = msm_bus_scale_client_update_request(
char/hw_random/msm_rng.c:				msm_rng_device_info.qrng_perf_client, 0);
char/hw_random/msm_rng.c:static int msm_rng_direct_read(struct msm_rng_device *msm_rng_dev,
char/hw_random/msm_rng.c:	pdev = msm_rng_dev->pdev;
char/hw_random/msm_rng.c:	base = msm_rng_dev->base;
char/hw_random/msm_rng.c:	mutex_lock(&msm_rng_dev->rng_lock);
char/hw_random/msm_rng.c:	if (msm_rng_dev->qrng_perf_client) {
char/hw_random/msm_rng.c:		ret = msm_bus_scale_client_update_request(
char/hw_random/msm_rng.c:				msm_rng_dev->qrng_perf_client, 1);
char/hw_random/msm_rng.c:	if (msm_rng_dev->prng_clk) {
char/hw_random/msm_rng.c:		ret = clk_prepare_enable(msm_rng_dev->prng_clk);
char/hw_random/msm_rng.c:	if (msm_rng_dev->prng_clk)
char/hw_random/msm_rng.c:		clk_disable_unprepare(msm_rng_dev->prng_clk);
char/hw_random/msm_rng.c:	if (msm_rng_dev->qrng_perf_client) {
char/hw_random/msm_rng.c:		ret = msm_bus_scale_client_update_request(
char/hw_random/msm_rng.c:				msm_rng_dev->qrng_perf_client, 0);
char/hw_random/msm_rng.c:	mutex_unlock(&msm_rng_dev->rng_lock);
char/hw_random/msm_rng.c:static int msm_rng_read(struct hwrng *rng, void *data, size_t max, bool wait)
char/hw_random/msm_rng.c:	struct msm_rng_device *msm_rng_dev;
char/hw_random/msm_rng.c:	msm_rng_dev = (struct msm_rng_device *)rng->priv;
char/hw_random/msm_rng.c:	rv = msm_rng_direct_read(msm_rng_dev, data, max);
char/hw_random/msm_rng.c:static struct hwrng msm_rng = {
char/hw_random/msm_rng.c:	.read = msm_rng_read,
char/hw_random/msm_rng.c:static int msm_rng_enable_hw(struct msm_rng_device *msm_rng_dev)
char/hw_random/msm_rng.c:	if (msm_rng_dev->qrng_perf_client) {
char/hw_random/msm_rng.c:		ret = msm_bus_scale_client_update_request(
char/hw_random/msm_rng.c:				msm_rng_dev->qrng_perf_client, 1);
char/hw_random/msm_rng.c:	if (msm_rng_dev->prng_clk) {
char/hw_random/msm_rng.c:		ret = clk_prepare_enable(msm_rng_dev->prng_clk);
char/hw_random/msm_rng.c:			dev_err(&(msm_rng_dev->pdev)->dev,
char/hw_random/msm_rng.c:	val = readl_relaxed(msm_rng_dev->base + PRNG_CONFIG_OFFSET) &
char/hw_random/msm_rng.c:		val = readl_relaxed(msm_rng_dev->base + PRNG_LFSR_CFG_OFFSET);
char/hw_random/msm_rng.c:		writel_relaxed(val, msm_rng_dev->base + PRNG_LFSR_CFG_OFFSET);
char/hw_random/msm_rng.c:		reg_val = readl_relaxed(msm_rng_dev->base + PRNG_CONFIG_OFFSET)
char/hw_random/msm_rng.c:		writel_relaxed(reg_val, msm_rng_dev->base + PRNG_CONFIG_OFFSET);
char/hw_random/msm_rng.c:	if (msm_rng_dev->prng_clk)
char/hw_random/msm_rng.c:		clk_disable_unprepare(msm_rng_dev->prng_clk);
char/hw_random/msm_rng.c:	if (msm_rng_dev->qrng_perf_client) {
char/hw_random/msm_rng.c:		ret = msm_bus_scale_client_update_request(
char/hw_random/msm_rng.c:				msm_rng_dev->qrng_perf_client, 0);
char/hw_random/msm_rng.c:static const struct file_operations msm_rng_fops = {
char/hw_random/msm_rng.c:	.unlocked_ioctl = msm_rng_ioctl,
char/hw_random/msm_rng.c:static struct class *msm_rng_class;
char/hw_random/msm_rng.c:static struct cdev msm_rng_cdev;
char/hw_random/msm_rng.c:static int msm_rng_probe(struct platform_device *pdev)
char/hw_random/msm_rng.c:	struct msm_rng_device *msm_rng_dev = NULL;
char/hw_random/msm_rng.c:	struct msm_bus_scale_pdata *qrng_platform_support = NULL;
char/hw_random/msm_rng.c:	msm_rng_dev = kzalloc(sizeof(struct msm_rng_device), GFP_KERNEL);
char/hw_random/msm_rng.c:	if (!msm_rng_dev) {
char/hw_random/msm_rng.c:	msm_rng_dev->base = base;
char/hw_random/msm_rng.c:			msm_rng_dev->prng_clk = NULL;
char/hw_random/msm_rng.c:					"qcom,msm-rng-iface-clk")) {
char/hw_random/msm_rng.c:				msm_rng_dev->prng_clk = clk_get(&pdev->dev,
char/hw_random/msm_rng.c:					"qcom,msm-rng-hwkm-clk")) {
char/hw_random/msm_rng.c:				msm_rng_dev->prng_clk = clk_get(&pdev->dev,
char/hw_random/msm_rng.c:				msm_rng_dev->prng_clk = clk_get(&pdev->dev,
char/hw_random/msm_rng.c:	if (IS_ERR(msm_rng_dev->prng_clk)) {
char/hw_random/msm_rng.c:	msm_rng_dev->pdev = pdev;
char/hw_random/msm_rng.c:	platform_set_drvdata(pdev, msm_rng_dev);
char/hw_random/msm_rng.c:		qrng_platform_support = msm_bus_cl_get_pdata(pdev);
char/hw_random/msm_rng.c:		msm_rng_dev->qrng_perf_client = msm_bus_scale_register_client(
char/hw_random/msm_rng.c:		msm_rng_device_info.qrng_perf_client =
char/hw_random/msm_rng.c:					msm_rng_dev->qrng_perf_client;
char/hw_random/msm_rng.c:		if (!msm_rng_dev->qrng_perf_client)
char/hw_random/msm_rng.c:		error = msm_rng_enable_hw(msm_rng_dev);
char/hw_random/msm_rng.c:	mutex_init(&msm_rng_dev->rng_lock);
char/hw_random/msm_rng.c:	msm_rng.priv = (unsigned long) msm_rng_dev;
char/hw_random/msm_rng.c:	error = hwrng_register(&msm_rng);
char/hw_random/msm_rng.c:	ret = register_chrdev(QRNG_IOC_MAGIC, DRIVER_NAME, &msm_rng_fops);
char/hw_random/msm_rng.c:	msm_rng_class = class_create(THIS_MODULE, "msm-rng");
char/hw_random/msm_rng.c:	if (IS_ERR(msm_rng_class)) {
char/hw_random/msm_rng.c:		return PTR_ERR(msm_rng_class);
char/hw_random/msm_rng.c:	dev = device_create(msm_rng_class, NULL, MKDEV(QRNG_IOC_MAGIC, 0),
char/hw_random/msm_rng.c:				NULL, "msm-rng");
char/hw_random/msm_rng.c:	cdev_init(&msm_rng_cdev, &msm_rng_fops);
char/hw_random/msm_rng.c:	msm_rng_dev_cached = msm_rng_dev;
char/hw_random/msm_rng.c:	if (msm_rng_dev->prng_clk)
char/hw_random/msm_rng.c:		clk_put(msm_rng_dev->prng_clk);
char/hw_random/msm_rng.c:	iounmap(msm_rng_dev->base);
char/hw_random/msm_rng.c:	kzfree(msm_rng_dev);
char/hw_random/msm_rng.c:static int msm_rng_remove(struct platform_device *pdev)
char/hw_random/msm_rng.c:	struct msm_rng_device *msm_rng_dev = platform_get_drvdata(pdev);
char/hw_random/msm_rng.c:	hwrng_unregister(&msm_rng);
char/hw_random/msm_rng.c:	if (msm_rng_dev->prng_clk)
char/hw_random/msm_rng.c:		clk_put(msm_rng_dev->prng_clk);
char/hw_random/msm_rng.c:	iounmap(msm_rng_dev->base);
char/hw_random/msm_rng.c:	if (msm_rng_dev->qrng_perf_client)
char/hw_random/msm_rng.c:		msm_bus_scale_unregister_client(msm_rng_dev->qrng_perf_client);
char/hw_random/msm_rng.c:	kzfree(msm_rng_dev);
char/hw_random/msm_rng.c:	msm_rng_dev_cached = NULL;
char/hw_random/msm_rng.c:	if (!msm_rng_dev_cached) {
char/hw_random/msm_rng.c:		pr_err("%s: msm_rng_dev is not initialized\n", __func__);
char/hw_random/msm_rng.c:	sizeread = msm_rng_direct_read(msm_rng_dev_cached, rdata, dlen);
char/hw_random/msm_rng.c:	{	.compatible = "qcom,msm-rng",
char/hw_random/msm_rng.c:	.probe      = msm_rng_probe,
char/hw_random/msm_rng.c:	.remove     = msm_rng_remove,
char/hw_random/msm_rng.c:static int __init msm_rng_init(void)
char/hw_random/msm_rng.c:	msm_rng_dev_cached = NULL;
char/hw_random/msm_rng.c:module_init(msm_rng_init);
char/hw_random/msm_rng.c:static void __exit msm_rng_exit(void)
char/hw_random/msm_rng.c:module_exit(msm_rng_exit);
char/msm_smd_pkt.c:#include <linux/msm_smd_pkt.h>
char/msm_smd_pkt.c:#define MODULE_NAME "msm_smdpkt"
char/msm_smd_pkt.c:			"%s_%s", "msm_smd_pkt", smd_pkt_devp->dev_name);
char/msm_smd_pkt.c:static int msm_smd_pkt_probe(struct platform_device *pdev)
char/msm_smd_pkt.c:static const struct of_device_id msm_smd_pkt_match_table[] = {
char/msm_smd_pkt.c:static struct platform_driver msm_smd_pkt_driver = {
char/msm_smd_pkt.c:	.probe = msm_smd_pkt_probe,
char/msm_smd_pkt.c:		.of_match_table = msm_smd_pkt_match_table,
char/msm_smd_pkt.c:	rc = platform_driver_register(&msm_smd_pkt_driver);
char/msm_smd_pkt.c:		SMD_PKT_ERR("msm_smd_pkt driver register failed %d\n", rc);
char/adsprpc.c:#include <linux/msm_ion.h>
char/adsprpc.c:#include <linux/msm_dma_iommu_mapping.h>
char/adsprpc.c:#define ADSP_AUDIOPD_NAME                        "msm/adsp/audio_pd"
char/adsprpc.c:#define ADSP_SENSORPD_NAME                       "msm/adsp/sensor_pd"
char/adsprpc.c:#define SLPI_SENSORPD_NAME                       "msm/slpi/sensor_pd"
char/adsprpc.c:	{ .compatible = "qcom,msm-fastrpc-adsp", },
char/adsprpc.c:	{ .compatible = "qcom,msm-fastrpc-compute", },
char/adsprpc.c:	{ .compatible = "qcom,msm-fastrpc-compute-cb", },
char/adsprpc.c:	{ .compatible = "qcom,msm-fastrpc-legacy-compute", },
char/adsprpc.c:	{ .compatible = "qcom,msm-fastrpc-legacy-compute-cb", },
char/adsprpc.c:	{ .compatible = "qcom,msm-adsprpc-mem-region", },
char/adsprpc.c:					"qcom,msm-fastrpc-compute")) {
char/adsprpc.c:					"qcom,msm-fastrpc-compute-cb"))
char/adsprpc.c:					"qcom,msm-fastrpc-legacy-compute-cb"))
char/adsprpc.c:					"qcom,msm-adsprpc-mem-region")) {
char/adsprpc.c:		ion_node = of_find_compatible_node(NULL, NULL, "qcom,msm-ion");
char/adsprpc.c:	{ .compatible = "qcom,msm-fastrpc-rpmsg" },
char/adsprpc.c:		.name = "qcom,msm_fastrpc_rpmsg",
clk/qcom/Kconfig:	  Support for the APCS Clock Controller on msm8916 devices. The
clk/qcom/Kconfig:	  such as msm8916.
clk/qcom/Kconfig:	  platforms such as apq8064, msm8660, msm8960 etc.
clk/qcom/Kconfig:	  platforms such as apq8016, apq8084, msm8974 etc.
clk/qcom/Kconfig:	  Support for the global clock controller on msm8660 devices.
clk/qcom/Kconfig:	  Support for the global clock controller on msm8916 devices.
clk/qcom/Kconfig:	  Support for the global clock controller on apq8064/msm8960 devices.
clk/qcom/Kconfig:	  Support for the LPASS clock controller on apq8064/msm8960 devices.
clk/qcom/Kconfig:	  Support for the multimedia clock controller on msm8960 devices.
clk/qcom/Kconfig:	  Support for the global clock controller on msm8974 devices.
clk/qcom/Kconfig:	  Support for the multimedia clock controller on msm8974 devices.
clk/qcom/Kconfig:	  Support for the global clock controller on msm8994 devices.
clk/qcom/Kconfig:	  Support for the global clock controller on msm8996 devices.
clk/qcom/Kconfig:	  Support for the multimedia clock controller on msm8996 devices.
clk/qcom/Kconfig:	  Support for the global clock controller on msm8998 devices.
clk/qcom/Makefile:obj-$(CONFIG_MSM_GCC_8660) += gcc-msm8660.o
clk/qcom/Makefile:obj-$(CONFIG_MSM_GCC_8916) += gcc-msm8916.o
clk/qcom/Makefile:obj-$(CONFIG_MSM_GCC_8960) += gcc-msm8960.o
clk/qcom/Makefile:obj-$(CONFIG_MSM_GCC_8974) += gcc-msm8974.o
clk/qcom/Makefile:obj-$(CONFIG_MSM_GCC_8994) += gcc-msm8994.o
clk/qcom/Makefile:obj-$(CONFIG_MSM_GCC_8996) += gcc-msm8996.o
clk/qcom/Makefile:obj-$(CONFIG_MSM_LCC_8960) += lcc-msm8960.o
clk/qcom/Makefile:obj-$(CONFIG_MSM_GCC_8998) += gcc-msm8998.o
clk/qcom/Makefile:obj-$(CONFIG_MSM_MMCC_8960) += mmcc-msm8960.o
clk/qcom/Makefile:obj-$(CONFIG_MSM_MMCC_8974) += mmcc-msm8974.o
clk/qcom/Makefile:obj-$(CONFIG_MSM_MMCC_8996) += mmcc-msm8996.o
clk/qcom/Makefile:obj-$(CONFIG_QCOM_CLK_APCS_MSM8916) += apcs-msm8916.o
clk/qcom/a53-pll.c:	{ .compatible = "qcom,msm8916-a53pll" },
clk/qcom/apcs-msm8916.c:static int qcom_apcs_msm8916_clk_probe(struct platform_device *pdev)
clk/qcom/apcs-msm8916.c:static int qcom_apcs_msm8916_clk_remove(struct platform_device *pdev)
clk/qcom/apcs-msm8916.c:static struct platform_driver qcom_apcs_msm8916_clk_driver = {
clk/qcom/apcs-msm8916.c:	.probe = qcom_apcs_msm8916_clk_probe,
clk/qcom/apcs-msm8916.c:	.remove = qcom_apcs_msm8916_clk_remove,
clk/qcom/apcs-msm8916.c:		.name = "qcom-apcs-msm8916-clk",
clk/qcom/apcs-msm8916.c:module_platform_driver(qcom_apcs_msm8916_clk_driver);
clk/qcom/camcc-kona.c:#include <linux/msm-bus.h>
clk/qcom/camcc-kona.c:#include <dt-bindings/msm/msm-bus-ids.h>
clk/qcom/camcc-kona.c:static struct msm_bus_vectors clk_debugfs_vectors[] = {
clk/qcom/camcc-kona.c:static struct msm_bus_paths clk_debugfs_usecases[] = {
clk/qcom/camcc-kona.c:static struct msm_bus_scale_pdata clk_debugfs_scale_table = {
clk/qcom/camcc-kona.c:	camcc_bus_id = msm_bus_scale_register_client(&clk_debugfs_scale_table);
clk/qcom/clk-debug.c:#include <linux/msm-bus.h>
clk/qcom/clk-debug.c:		msm_bus_scale_client_update_request(meas->bus_cl_id, 1);
clk/qcom/clk-debug.c:		msm_bus_scale_client_update_request(meas->bus_cl_id, 0);
clk/qcom/clk-debug.c:		msm_bus_scale_client_update_request(meas->bus_cl_id, 1);
clk/qcom/clk-debug.c:		msm_bus_scale_client_update_request(meas->bus_cl_id, 0);
clk/qcom/clk-debug.c:		msm_bus_scale_client_update_request(hw->init->bus_cl_id,
clk/qcom/clk-rpm.c:DEFINE_CLK_RPM(msm8660, afab_clk, afab_a_clk, QCOM_RPM_APPS_FABRIC_CLK);
clk/qcom/clk-rpm.c:DEFINE_CLK_RPM(msm8660, sfab_clk, sfab_a_clk, QCOM_RPM_SYS_FABRIC_CLK);
clk/qcom/clk-rpm.c:DEFINE_CLK_RPM(msm8660, mmfab_clk, mmfab_a_clk, QCOM_RPM_MM_FABRIC_CLK);
clk/qcom/clk-rpm.c:DEFINE_CLK_RPM(msm8660, daytona_clk, daytona_a_clk, QCOM_RPM_DAYTONA_FABRIC_CLK);
clk/qcom/clk-rpm.c:DEFINE_CLK_RPM(msm8660, sfpb_clk, sfpb_a_clk, QCOM_RPM_SFPB_CLK);
clk/qcom/clk-rpm.c:DEFINE_CLK_RPM(msm8660, cfpb_clk, cfpb_a_clk, QCOM_RPM_CFPB_CLK);
clk/qcom/clk-rpm.c:DEFINE_CLK_RPM(msm8660, mmfpb_clk, mmfpb_a_clk, QCOM_RPM_MMFPB_CLK);
clk/qcom/clk-rpm.c:DEFINE_CLK_RPM(msm8660, smi_clk, smi_a_clk, QCOM_RPM_SMI_CLK);
clk/qcom/clk-rpm.c:DEFINE_CLK_RPM(msm8660, ebi1_clk, ebi1_a_clk, QCOM_RPM_EBI1_CLK);
clk/qcom/clk-rpm.c:DEFINE_CLK_RPM_FIXED(msm8660, pll4_clk, pll4_a_clk, QCOM_RPM_PLL_4, 540672000);
clk/qcom/clk-rpm.c:static struct clk_rpm *msm8660_clks[] = {
clk/qcom/clk-rpm.c:	[RPM_APPS_FABRIC_CLK] = &msm8660_afab_clk,
clk/qcom/clk-rpm.c:	[RPM_APPS_FABRIC_A_CLK] = &msm8660_afab_a_clk,
clk/qcom/clk-rpm.c:	[RPM_SYS_FABRIC_CLK] = &msm8660_sfab_clk,
clk/qcom/clk-rpm.c:	[RPM_SYS_FABRIC_A_CLK] = &msm8660_sfab_a_clk,
clk/qcom/clk-rpm.c:	[RPM_MM_FABRIC_CLK] = &msm8660_mmfab_clk,
clk/qcom/clk-rpm.c:	[RPM_MM_FABRIC_A_CLK] = &msm8660_mmfab_a_clk,
clk/qcom/clk-rpm.c:	[RPM_DAYTONA_FABRIC_CLK] = &msm8660_daytona_clk,
clk/qcom/clk-rpm.c:	[RPM_DAYTONA_FABRIC_A_CLK] = &msm8660_daytona_a_clk,
clk/qcom/clk-rpm.c:	[RPM_SFPB_CLK] = &msm8660_sfpb_clk,
clk/qcom/clk-rpm.c:	[RPM_SFPB_A_CLK] = &msm8660_sfpb_a_clk,
clk/qcom/clk-rpm.c:	[RPM_CFPB_CLK] = &msm8660_cfpb_clk,
clk/qcom/clk-rpm.c:	[RPM_CFPB_A_CLK] = &msm8660_cfpb_a_clk,
clk/qcom/clk-rpm.c:	[RPM_MMFPB_CLK] = &msm8660_mmfpb_clk,
clk/qcom/clk-rpm.c:	[RPM_MMFPB_A_CLK] = &msm8660_mmfpb_a_clk,
clk/qcom/clk-rpm.c:	[RPM_SMI_CLK] = &msm8660_smi_clk,
clk/qcom/clk-rpm.c:	[RPM_SMI_A_CLK] = &msm8660_smi_a_clk,
clk/qcom/clk-rpm.c:	[RPM_EBI1_CLK] = &msm8660_ebi1_clk,
clk/qcom/clk-rpm.c:	[RPM_EBI1_A_CLK] = &msm8660_ebi1_a_clk,
clk/qcom/clk-rpm.c:	[RPM_PLL4_CLK] = &msm8660_pll4_clk,
clk/qcom/clk-rpm.c:static const struct rpm_clk_desc rpm_clk_msm8660 = {
clk/qcom/clk-rpm.c:	.clks = msm8660_clks,
clk/qcom/clk-rpm.c:	.num_clks = ARRAY_SIZE(msm8660_clks),
clk/qcom/clk-rpm.c:	{ .compatible = "qcom,rpmcc-msm8660", .data = &rpm_clk_msm8660 },
clk/qcom/clk-rpm.c:	{ .compatible = "qcom,rpmcc-apq8060", .data = &rpm_clk_msm8660 },
clk/qcom/clk-smd-rpm.c:	struct msm_rpm_kvp req = {
clk/qcom/clk-smd-rpm.c:	ret = msm_rpm_send_message(QCOM_SMD_RPM_ACTIVE_STATE, r->rpm_res_type,
clk/qcom/clk-smd-rpm.c:	struct msm_rpm_kvp req = {
clk/qcom/clk-smd-rpm.c:	ret = msm_rpm_send_message(QCOM_SMD_RPM_SLEEP_STATE, r->rpm_res_type,
clk/qcom/clk-smd-rpm.c:	struct msm_rpm_kvp req = {
clk/qcom/clk-smd-rpm.c:	ret = msm_rpm_send_message(QCOM_SMD_RPM_SLEEP_STATE,
clk/qcom/clk-smd-rpm.c:	ret = msm_rpm_send_message(QCOM_SMD_RPM_ACTIVE_STATE,
clk/qcom/clk-smd-rpm.c:	struct msm_rpm_kvp req = {
clk/qcom/clk-smd-rpm.c:	ret = msm_rpm_send_message(QCOM_SMD_RPM_ACTIVE_STATE,
clk/qcom/clk-smd-rpm.c:/* msm8916 */
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8916, pcnoc_clk, pcnoc_a_clk, QCOM_SMD_RPM_BUS_CLK, 0);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8916, snoc_clk, snoc_a_clk, QCOM_SMD_RPM_BUS_CLK, 1);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8916, bimc_clk, bimc_a_clk, QCOM_SMD_RPM_MEM_CLK, 0);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_QDSS(msm8916, qdss_clk, qdss_a_clk, QCOM_SMD_RPM_MISC_CLK, 1);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8916, bb_clk1, bb_clk1_a, 1);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8916, bb_clk2, bb_clk2_a, 2);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8916, rf_clk1, rf_clk1_a, 4);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8916, rf_clk2, rf_clk2_a, 5);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER_PINCTRL(msm8916, bb_clk1_pin, bb_clk1_a_pin, 1);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER_PINCTRL(msm8916, bb_clk2_pin, bb_clk2_a_pin, 2);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER_PINCTRL(msm8916, rf_clk1_pin, rf_clk1_a_pin, 4);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER_PINCTRL(msm8916, rf_clk2_pin, rf_clk2_a_pin, 5);
clk/qcom/clk-smd-rpm.c:static struct clk_hw *msm8916_clks[] = {
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_PCNOC_CLK]		= &msm8916_pcnoc_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_PCNOC_A_CLK]		= &msm8916_pcnoc_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_SNOC_CLK]		= &msm8916_snoc_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_SNOC_A_CLK]		= &msm8916_snoc_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BIMC_CLK]		= &msm8916_bimc_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BIMC_A_CLK]		= &msm8916_bimc_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_QDSS_CLK]		= &msm8916_qdss_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_QDSS_A_CLK]		= &msm8916_qdss_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK1]		= &msm8916_bb_clk1.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK1_A]		= &msm8916_bb_clk1_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK2]		= &msm8916_bb_clk2.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK2_A]		= &msm8916_bb_clk2_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK1]		= &msm8916_rf_clk1.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK1_A]		= &msm8916_rf_clk1_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK2]		= &msm8916_rf_clk2.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK2_A]		= &msm8916_rf_clk2_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK1_PIN]		= &msm8916_bb_clk1_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK1_A_PIN]		= &msm8916_bb_clk1_a_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK2_PIN]		= &msm8916_bb_clk2_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK2_A_PIN]		= &msm8916_bb_clk2_a_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK1_PIN]		= &msm8916_rf_clk1_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK1_A_PIN]		= &msm8916_rf_clk1_a_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK2_PIN]		= &msm8916_rf_clk2_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK2_A_PIN]		= &msm8916_rf_clk2_a_pin.hw,
clk/qcom/clk-smd-rpm.c:static const struct rpm_smd_clk_desc rpm_clk_msm8916 = {
clk/qcom/clk-smd-rpm.c:	.clks = msm8916_clks,
clk/qcom/clk-smd-rpm.c:	.num_clks = ARRAY_SIZE(msm8916_clks),
clk/qcom/clk-smd-rpm.c:/* msm8974 */
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8974, pnoc_clk, pnoc_a_clk, QCOM_SMD_RPM_BUS_CLK, 0);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8974, snoc_clk, snoc_a_clk, QCOM_SMD_RPM_BUS_CLK, 1);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8974, cnoc_clk, cnoc_a_clk, QCOM_SMD_RPM_BUS_CLK, 2);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8974, mmssnoc_ahb_clk, mmssnoc_ahb_a_clk, QCOM_SMD_RPM_BUS_CLK, 3);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8974, bimc_clk, bimc_a_clk, QCOM_SMD_RPM_MEM_CLK, 0);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8974, gfx3d_clk_src, gfx3d_a_clk_src, QCOM_SMD_RPM_MEM_CLK, 1);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8974, ocmemgx_clk, ocmemgx_a_clk, QCOM_SMD_RPM_MEM_CLK, 2);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_QDSS(msm8974, qdss_clk, qdss_a_clk, QCOM_SMD_RPM_MISC_CLK, 1);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8974, cxo_d0, cxo_d0_a, 1);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8974, cxo_d1, cxo_d1_a, 2);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8974, cxo_a0, cxo_a0_a, 4);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8974, cxo_a1, cxo_a1_a, 5);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8974, cxo_a2, cxo_a2_a, 6);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8974, diff_clk, diff_a_clk, 7);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8974, div_clk1, div_a_clk1, 11);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8974, div_clk2, div_a_clk2, 12);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER_PINCTRL(msm8974, cxo_d0_pin, cxo_d0_a_pin, 1);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER_PINCTRL(msm8974, cxo_d1_pin, cxo_d1_a_pin, 2);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER_PINCTRL(msm8974, cxo_a0_pin, cxo_a0_a_pin, 4);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER_PINCTRL(msm8974, cxo_a1_pin, cxo_a1_a_pin, 5);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER_PINCTRL(msm8974, cxo_a2_pin, cxo_a2_a_pin, 6);
clk/qcom/clk-smd-rpm.c:static struct clk_hw *msm8974_clks[] = {
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_PNOC_CLK]		= &msm8974_pnoc_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_PNOC_A_CLK]		= &msm8974_pnoc_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_SNOC_CLK]		= &msm8974_snoc_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_SNOC_A_CLK]		= &msm8974_snoc_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CNOC_CLK]		= &msm8974_cnoc_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CNOC_A_CLK]		= &msm8974_cnoc_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_MMSSNOC_AHB_CLK]	= &msm8974_mmssnoc_ahb_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_MMSSNOC_AHB_A_CLK]	= &msm8974_mmssnoc_ahb_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BIMC_CLK]		= &msm8974_bimc_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BIMC_A_CLK]		= &msm8974_bimc_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_OCMEMGX_CLK]		= &msm8974_ocmemgx_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_OCMEMGX_A_CLK]		= &msm8974_ocmemgx_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_QDSS_CLK]		= &msm8974_qdss_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_QDSS_A_CLK]		= &msm8974_qdss_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_D0]		= &msm8974_cxo_d0.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_D0_A]		= &msm8974_cxo_d0_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_D1]		= &msm8974_cxo_d1.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_D1_A]		= &msm8974_cxo_d1_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_A0]		= &msm8974_cxo_a0.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_A0_A]		= &msm8974_cxo_a0_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_A1]		= &msm8974_cxo_a1.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_A1_A]		= &msm8974_cxo_a1_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_A2]		= &msm8974_cxo_a2.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_A2_A]		= &msm8974_cxo_a2_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_DIFF_CLK]		= &msm8974_diff_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_DIFF_A_CLK]		= &msm8974_diff_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_DIV_CLK1]		= &msm8974_div_clk1.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_DIV_A_CLK1]		= &msm8974_div_a_clk1.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_DIV_CLK2]		= &msm8974_div_clk2.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_DIV_A_CLK2]		= &msm8974_div_a_clk2.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_D0_PIN]		= &msm8974_cxo_d0_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_D0_A_PIN]		= &msm8974_cxo_d0_a_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_D1_PIN]		= &msm8974_cxo_d1_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_D1_A_PIN]		= &msm8974_cxo_d1_a_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_A0_PIN]		= &msm8974_cxo_a0_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_A0_A_PIN]		= &msm8974_cxo_a0_a_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_A1_PIN]		= &msm8974_cxo_a1_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_A1_A_PIN]		= &msm8974_cxo_a1_a_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_A2_PIN]		= &msm8974_cxo_a2_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CXO_A2_A_PIN]		= &msm8974_cxo_a2_a_pin.hw,
clk/qcom/clk-smd-rpm.c:static const struct rpm_smd_clk_desc rpm_clk_msm8974 = {
clk/qcom/clk-smd-rpm.c:	.clks = msm8974_clks,
clk/qcom/clk-smd-rpm.c:	.num_clks = ARRAY_SIZE(msm8974_clks),
clk/qcom/clk-smd-rpm.c:/* msm8996 */
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8996, pcnoc_clk, pcnoc_a_clk, QCOM_SMD_RPM_BUS_CLK, 0);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8996, snoc_clk, snoc_a_clk, QCOM_SMD_RPM_BUS_CLK, 1);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8996, cnoc_clk, cnoc_a_clk, QCOM_SMD_RPM_BUS_CLK, 2);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8996, bimc_clk, bimc_a_clk, QCOM_SMD_RPM_MEM_CLK, 0);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8996, mmssnoc_axi_rpm_clk, mmssnoc_axi_rpm_a_clk,
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8996, ipa_clk, ipa_a_clk, QCOM_SMD_RPM_IPA_CLK, 0);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM(msm8996, ce1_clk, ce1_a_clk, QCOM_SMD_RPM_CE_CLK, 0);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_BRANCH(msm8996, aggre1_noc_clk, aggre1_noc_a_clk,
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_BRANCH(msm8996, aggre2_noc_clk, aggre2_noc_a_clk,
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_QDSS(msm8996, qdss_clk, qdss_a_clk,
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8996, bb_clk1, bb_clk1_a, 1);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8996, bb_clk2, bb_clk2_a, 2);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8996, rf_clk1, rf_clk1_a, 4);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8996, rf_clk2, rf_clk2_a, 5);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8996, ln_bb_clk, ln_bb_a_clk, 8);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8996, div_clk1, div_clk1_a, 0xb);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8996, div_clk2, div_clk2_a, 0xc);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER(msm8996, div_clk3, div_clk3_a, 0xd);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER_PINCTRL(msm8996, bb_clk1_pin, bb_clk1_a_pin, 1);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER_PINCTRL(msm8996, bb_clk2_pin, bb_clk2_a_pin, 2);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER_PINCTRL(msm8996, rf_clk1_pin, rf_clk1_a_pin, 4);
clk/qcom/clk-smd-rpm.c:DEFINE_CLK_SMD_RPM_XO_BUFFER_PINCTRL(msm8996, rf_clk2_pin, rf_clk2_a_pin, 5);
clk/qcom/clk-smd-rpm.c:static struct clk_hw *msm8996_clks[] = {
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_PCNOC_CLK] = &msm8996_pcnoc_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_PCNOC_A_CLK] = &msm8996_pcnoc_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_SNOC_CLK] = &msm8996_snoc_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_SNOC_A_CLK] = &msm8996_snoc_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CNOC_CLK] = &msm8996_cnoc_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CNOC_A_CLK] = &msm8996_cnoc_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BIMC_CLK] = &msm8996_bimc_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BIMC_A_CLK] = &msm8996_bimc_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_MMAXI_CLK] = &msm8996_mmssnoc_axi_rpm_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_MMAXI_A_CLK] = &msm8996_mmssnoc_axi_rpm_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_IPA_CLK] = &msm8996_ipa_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_IPA_A_CLK] = &msm8996_ipa_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CE1_CLK] = &msm8996_ce1_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_CE1_A_CLK] = &msm8996_ce1_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_AGGR1_NOC_CLK] = &msm8996_aggre1_noc_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_AGGR1_NOC_A_CLK] = &msm8996_aggre1_noc_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_AGGR2_NOC_CLK] = &msm8996_aggre2_noc_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_AGGR2_NOC_A_CLK] = &msm8996_aggre2_noc_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_QDSS_CLK] = &msm8996_qdss_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_QDSS_A_CLK] = &msm8996_qdss_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK1] = &msm8996_bb_clk1.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK1_A] = &msm8996_bb_clk1_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK2] = &msm8996_bb_clk2.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK2_A] = &msm8996_bb_clk2_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK1] = &msm8996_rf_clk1.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK1_A] = &msm8996_rf_clk1_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK2] = &msm8996_rf_clk2.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK2_A] = &msm8996_rf_clk2_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_LN_BB_CLK] = &msm8996_ln_bb_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_LN_BB_CLK_A] = &msm8996_ln_bb_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_DIV_CLK1] = &msm8996_div_clk1.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_DIV_A_CLK1] = &msm8996_div_clk1_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_DIV_CLK2] = &msm8996_div_clk2.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_DIV_A_CLK2] = &msm8996_div_clk2_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_DIV_CLK3] = &msm8996_div_clk3.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_DIV_A_CLK3] = &msm8996_div_clk3_a.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK1_PIN] = &msm8996_bb_clk1_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK1_A_PIN] = &msm8996_bb_clk1_a_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK2_PIN] = &msm8996_bb_clk2_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_BB_CLK2_A_PIN] = &msm8996_bb_clk2_a_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK1_PIN] = &msm8996_rf_clk1_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK1_A_PIN] = &msm8996_rf_clk1_a_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK2_PIN] = &msm8996_rf_clk2_pin.hw,
clk/qcom/clk-smd-rpm.c:	[RPM_SMD_RF_CLK2_A_PIN] = &msm8996_rf_clk2_a_pin.hw,
clk/qcom/clk-smd-rpm.c:static const struct rpm_smd_clk_desc rpm_clk_msm8996 = {
clk/qcom/clk-smd-rpm.c:	.clks = msm8996_clks,
clk/qcom/clk-smd-rpm.c:	.num_clks = ARRAY_SIZE(msm8996_clks),
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(snoc_msmbus_clk, snoc_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(bimc_msmbus_clk, bimc_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(snoc_msmbus_a_clk, snoc_a_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(bimc_msmbus_a_clk, bimc_a_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(cnoc_msmbus_clk, cnoc_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(cnoc_msmbus_a_clk, cnoc_a_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(vfe_mmrt_msmbus_clk, mmrt_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(vfe_mmrt_msmbus_a_clk, mmrt_a_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(mdp_mmrt_msmbus_clk, mmrt_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(mdp_mmrt_msmbus_a_clk, mmrt_a_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(cpp_mmnrt_msmbus_clk, mmnrt_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(cpp_mmnrt_msmbus_a_clk, mmnrt_a_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(jpeg_mmnrt_msmbus_clk, mmnrt_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(jpeg_mmnrt_msmbus_a_clk, mmnrt_a_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(venus_mmnrt_msmbus_clk, mmnrt_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(venus_mmnrt_msmbus_a_clk, mmnrt_a_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(arm9_mmnrt_msmbus_clk, mmnrt_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(arm9_mmnrt_msmbus_a_clk, mmnrt_a_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(qup0_msmbus_snoc_periph_clk, snoc_periph_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(qup0_msmbus_snoc_periph_a_clk, snoc_periph_a_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(qup1_msmbus_snoc_periph_clk, snoc_periph_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(qup1_msmbus_snoc_periph_a_clk, snoc_periph_a_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(dap_msmbus_snoc_periph_clk, snoc_periph_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(dap_msmbus_snoc_periph_a_clk, snoc_periph_a_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(sdc1_msmbus_snoc_periph_clk, snoc_periph_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(sdc1_msmbus_snoc_periph_a_clk, snoc_periph_a_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(sdc2_msmbus_snoc_periph_clk, snoc_periph_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(sdc2_msmbus_snoc_periph_a_clk, snoc_periph_a_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(crypto_msmbus_snoc_periph_clk, snoc_periph_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(crypto_msmbus_snoc_periph_a_clk, snoc_periph_a_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(sdc1_slv_msmbus_snoc_periph_clk, snoc_periph_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(sdc1_slv_msmbus_snoc_periph_a_clk, snoc_periph_a_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(sdc2_slv_msmbus_snoc_periph_clk, snoc_periph_clk,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(sdc2_slv_msmbus_snoc_periph_a_clk, snoc_periph_a_clk,
clk/qcom/clk-smd-rpm.c:	[CNOC_MSMBUS_CLK] = &cnoc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[CNOC_MSMBUS_A_CLK] = &cnoc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SNOC_MSMBUS_CLK] = &snoc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SNOC_MSMBUS_A_CLK] = &snoc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[BIMC_MSMBUS_CLK] = &bimc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[BIMC_MSMBUS_A_CLK] = &bimc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[CPP_MMNRT_MSMBUS_CLK] = &cpp_mmnrt_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[CPP_MMNRT_MSMBUS_A_CLK] = &cpp_mmnrt_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[JPEG_MMNRT_MSMBUS_CLK] = &jpeg_mmnrt_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[JPEG_MMNRT_MSMBUS_A_CLK] = &jpeg_mmnrt_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[VENUS_MMNRT_MSMBUS_CLK] = &venus_mmnrt_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[VENUS_MMNRT_MSMBUS_A_CLK] = &venus_mmnrt_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[ARM9_MMNRT_MSMBUS_CLK] = &arm9_mmnrt_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[ARM9_MMNRT_MSMBUS_A_CLK] = &arm9_mmnrt_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[VFE_MMRT_MSMBUS_CLK] = &vfe_mmrt_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[VFE_MMRT_MSMBUS_A_CLK] = &vfe_mmrt_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[MDP_MMRT_MSMBUS_CLK] = &mdp_mmrt_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[MDP_MMRT_MSMBUS_A_CLK] = &mdp_mmrt_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[QUP0_MSMBUS_SNOC_PERIPH_CLK] = &qup0_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:	[QUP0_MSMBUS_SNOC_PERIPH_A_CLK] = &qup0_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[QUP1_MSMBUS_SNOC_PERIPH_CLK] = &qup1_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:	[QUP1_MSMBUS_SNOC_PERIPH_A_CLK] = &qup1_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[DAP_MSMBUS_SNOC_PERIPH_CLK] = &dap_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:	[DAP_MSMBUS_SNOC_PERIPH_A_CLK] = &dap_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SDC1_MSMBUS_SNOC_PERIPH_CLK] = &sdc1_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SDC1_MSMBUS_SNOC_PERIPH_A_CLK] = &sdc1_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SDC2_MSMBUS_SNOC_PERIPH_CLK] = &sdc2_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SDC2_MSMBUS_SNOC_PERIPH_A_CLK] = &sdc2_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[CRYPTO_MSMBUS_SNOC_PERIPH_CLK] = &crypto_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:				&crypto_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:				&sdc1_slv_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:				&sdc1_slv_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:				&sdc2_slv_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:				&sdc2_slv_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[CNOC_MSMBUS_CLK] = &cnoc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[CNOC_MSMBUS_A_CLK] = &cnoc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SNOC_MSMBUS_CLK] = &snoc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SNOC_MSMBUS_A_CLK] = &snoc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[BIMC_MSMBUS_CLK] = &bimc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[BIMC_MSMBUS_A_CLK] = &bimc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[CPP_MMNRT_MSMBUS_CLK] = &cpp_mmnrt_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[CPP_MMNRT_MSMBUS_A_CLK] = &cpp_mmnrt_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[JPEG_MMNRT_MSMBUS_CLK] = &jpeg_mmnrt_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[JPEG_MMNRT_MSMBUS_A_CLK] = &jpeg_mmnrt_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[VENUS_MMNRT_MSMBUS_CLK] = &venus_mmnrt_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[VENUS_MMNRT_MSMBUS_A_CLK] = &venus_mmnrt_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[ARM9_MMNRT_MSMBUS_CLK] = &arm9_mmnrt_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[ARM9_MMNRT_MSMBUS_A_CLK] = &arm9_mmnrt_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[VFE_MMRT_MSMBUS_CLK] = &vfe_mmrt_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[VFE_MMRT_MSMBUS_A_CLK] = &vfe_mmrt_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[MDP_MMRT_MSMBUS_CLK] = &mdp_mmrt_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[MDP_MMRT_MSMBUS_A_CLK] = &mdp_mmrt_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[QUP0_MSMBUS_SNOC_PERIPH_CLK] = &qup0_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:	[QUP0_MSMBUS_SNOC_PERIPH_A_CLK] = &qup0_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[QUP1_MSMBUS_SNOC_PERIPH_CLK] = &qup1_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:	[QUP1_MSMBUS_SNOC_PERIPH_A_CLK] = &qup1_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[DAP_MSMBUS_SNOC_PERIPH_CLK] = &dap_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:	[DAP_MSMBUS_SNOC_PERIPH_A_CLK] = &dap_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SDC1_MSMBUS_SNOC_PERIPH_CLK] = &sdc1_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SDC1_MSMBUS_SNOC_PERIPH_A_CLK] = &sdc1_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SDC2_MSMBUS_SNOC_PERIPH_CLK] = &sdc2_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SDC2_MSMBUS_SNOC_PERIPH_A_CLK] = &sdc2_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[CRYPTO_MSMBUS_SNOC_PERIPH_CLK] = &crypto_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:				&crypto_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:				&sdc1_slv_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:				&sdc1_slv_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:				&sdc2_slv_msmbus_snoc_periph_clk.hw,
clk/qcom/clk-smd-rpm.c:				&sdc2_slv_msmbus_snoc_periph_a_clk.hw,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(aggre2_noc_msmbus_clk, aggre2_noc_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(aggre2_noc_msmbus_a_clk, aggre2_noc_a_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:	[BIMC_MSMBUS_CLK]       = &bimc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[BIMC_MSMBUS_A_CLK]     = &bimc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[CNOC_MSMBUS_CLK]       = &cnoc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[CNOC_MSMBUS_A_CLK]     = &cnoc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SNOC_MSMBUS_CLK]       = &snoc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SNOC_MSMBUS_A_CLK]     = &snoc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[AGGR2_NOC_MSMBUS_CLK]  = &aggre2_noc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[AGGR2_NOC_MSMBUS_A_CLK] = &aggre2_noc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(pnoc_msmbus_clk, pnoc_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(pnoc_msmbus_a_clk, pnoc_a_clk, LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(sysmmnoc_msmbus_clk, sysmmnoc_clk,  LONG_MAX);
clk/qcom/clk-smd-rpm.c:static DEFINE_CLK_VOTER(sysmmnoc_msmbus_a_clk, sysmmnoc_a_clk,  LONG_MAX);
clk/qcom/clk-smd-rpm.c:	[PNOC_MSMBUS_CLK] = &pnoc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[PNOC_MSMBUS_A_CLK] = &pnoc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SNOC_MSMBUS_CLK] = &snoc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SNOC_MSMBUS_A_CLK] = &snoc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[BIMC_MSMBUS_CLK] = &bimc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[BIMC_MSMBUS_A_CLK] = &bimc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SYSMMNOC_MSMBUS_CLK] = &sysmmnoc_msmbus_clk.hw,
clk/qcom/clk-smd-rpm.c:	[SYSMMNOC_MSMBUS_A_CLK] = &sysmmnoc_msmbus_a_clk.hw,
clk/qcom/clk-smd-rpm.c:	{ .compatible = "qcom,rpmcc-msm8916", .data = &rpm_clk_msm8916 },
clk/qcom/clk-smd-rpm.c:	{ .compatible = "qcom,rpmcc-msm8974", .data = &rpm_clk_msm8974 },
clk/qcom/clk-smd-rpm.c:	{ .compatible = "qcom,rpmcc-msm8996", .data = &rpm_clk_msm8996 },
clk/qcom/debugcc-kona.c:#include <linux/msm-bus.h>
clk/qcom/debugcc-kona.c:#include <dt-bindings/msm/msm-bus-ids.h>
clk/qcom/debugcc-kona.c:static struct msm_bus_vectors clk_measure_vectors[] = {
clk/qcom/debugcc-kona.c:static struct msm_bus_paths clk_measure_usecases[] = {
clk/qcom/debugcc-kona.c:static struct msm_bus_scale_pdata clk_measure_scale_table = {
clk/qcom/debugcc-kona.c:		msm_bus_scale_register_client(&clk_measure_scale_table);
clk/qcom/dispcc-kona.c:#include <linux/msm-bus.h>
clk/qcom/dispcc-kona.c:#include <dt-bindings/msm/msm-bus-ids.h>
clk/qcom/dispcc-kona.c:static struct msm_bus_vectors clk_debugfs_vectors[] = {
clk/qcom/dispcc-kona.c:static struct msm_bus_paths clk_debugfs_usecases[] = {
clk/qcom/dispcc-kona.c:static struct msm_bus_scale_pdata clk_debugfs_scale_table = {
clk/qcom/dispcc-kona.c:	dispcc_bus_id = msm_bus_scale_register_client(&clk_debugfs_scale_table);
clk/qcom/gcc-msm8660.c:#include <dt-bindings/clock/qcom,gcc-msm8660.h>
clk/qcom/gcc-msm8660.c:#include <dt-bindings/reset/qcom,gcc-msm8660.h>
clk/qcom/gcc-msm8660.c:static struct clk_regmap *gcc_msm8660_clks[] = {
clk/qcom/gcc-msm8660.c:static const struct qcom_reset_map gcc_msm8660_resets[] = {
clk/qcom/gcc-msm8660.c:static const struct regmap_config gcc_msm8660_regmap_config = {
clk/qcom/gcc-msm8660.c:static const struct qcom_cc_desc gcc_msm8660_desc = {
clk/qcom/gcc-msm8660.c:	.config = &gcc_msm8660_regmap_config,
clk/qcom/gcc-msm8660.c:	.clks = gcc_msm8660_clks,
clk/qcom/gcc-msm8660.c:	.num_clks = ARRAY_SIZE(gcc_msm8660_clks),
clk/qcom/gcc-msm8660.c:	.resets = gcc_msm8660_resets,
clk/qcom/gcc-msm8660.c:	.num_resets = ARRAY_SIZE(gcc_msm8660_resets),
clk/qcom/gcc-msm8660.c:static const struct of_device_id gcc_msm8660_match_table[] = {
clk/qcom/gcc-msm8660.c:	{ .compatible = "qcom,gcc-msm8660" },
clk/qcom/gcc-msm8660.c:MODULE_DEVICE_TABLE(of, gcc_msm8660_match_table);
clk/qcom/gcc-msm8660.c:static int gcc_msm8660_probe(struct platform_device *pdev)
clk/qcom/gcc-msm8660.c:	return qcom_cc_probe(pdev, &gcc_msm8660_desc);
clk/qcom/gcc-msm8660.c:static struct platform_driver gcc_msm8660_driver = {
clk/qcom/gcc-msm8660.c:	.probe		= gcc_msm8660_probe,
clk/qcom/gcc-msm8660.c:		.name	= "gcc-msm8660",
clk/qcom/gcc-msm8660.c:		.of_match_table = gcc_msm8660_match_table,
clk/qcom/gcc-msm8660.c:static int __init gcc_msm8660_init(void)
clk/qcom/gcc-msm8660.c:	return platform_driver_register(&gcc_msm8660_driver);
clk/qcom/gcc-msm8660.c:core_initcall(gcc_msm8660_init);
clk/qcom/gcc-msm8660.c:static void __exit gcc_msm8660_exit(void)
clk/qcom/gcc-msm8660.c:	platform_driver_unregister(&gcc_msm8660_driver);
clk/qcom/gcc-msm8660.c:module_exit(gcc_msm8660_exit);
clk/qcom/gcc-msm8660.c:MODULE_ALIAS("platform:gcc-msm8660");
clk/qcom/gcc-msm8916.c:#include <dt-bindings/clock/qcom,gcc-msm8916.h>
clk/qcom/gcc-msm8916.c:#include <dt-bindings/reset/qcom,gcc-msm8916.h>
clk/qcom/gcc-msm8916.c:static struct clk_regmap *gcc_msm8916_clocks[] = {
clk/qcom/gcc-msm8916.c:static struct gdsc *gcc_msm8916_gdscs[] = {
clk/qcom/gcc-msm8916.c:static const struct qcom_reset_map gcc_msm8916_resets[] = {
clk/qcom/gcc-msm8916.c:static const struct regmap_config gcc_msm8916_regmap_config = {
clk/qcom/gcc-msm8916.c:static const struct qcom_cc_desc gcc_msm8916_desc = {
clk/qcom/gcc-msm8916.c:	.config = &gcc_msm8916_regmap_config,
clk/qcom/gcc-msm8916.c:	.clks = gcc_msm8916_clocks,
clk/qcom/gcc-msm8916.c:	.num_clks = ARRAY_SIZE(gcc_msm8916_clocks),
clk/qcom/gcc-msm8916.c:	.resets = gcc_msm8916_resets,
clk/qcom/gcc-msm8916.c:	.num_resets = ARRAY_SIZE(gcc_msm8916_resets),
clk/qcom/gcc-msm8916.c:	.gdscs = gcc_msm8916_gdscs,
clk/qcom/gcc-msm8916.c:	.num_gdscs = ARRAY_SIZE(gcc_msm8916_gdscs),
clk/qcom/gcc-msm8916.c:static const struct of_device_id gcc_msm8916_match_table[] = {
clk/qcom/gcc-msm8916.c:	{ .compatible = "qcom,gcc-msm8916" },
clk/qcom/gcc-msm8916.c:MODULE_DEVICE_TABLE(of, gcc_msm8916_match_table);
clk/qcom/gcc-msm8916.c:static int gcc_msm8916_probe(struct platform_device *pdev)
clk/qcom/gcc-msm8916.c:	return qcom_cc_probe(pdev, &gcc_msm8916_desc);
clk/qcom/gcc-msm8916.c:static struct platform_driver gcc_msm8916_driver = {
clk/qcom/gcc-msm8916.c:	.probe		= gcc_msm8916_probe,
clk/qcom/gcc-msm8916.c:		.name	= "gcc-msm8916",
clk/qcom/gcc-msm8916.c:		.of_match_table = gcc_msm8916_match_table,
clk/qcom/gcc-msm8916.c:static int __init gcc_msm8916_init(void)
clk/qcom/gcc-msm8916.c:	return platform_driver_register(&gcc_msm8916_driver);
clk/qcom/gcc-msm8916.c:core_initcall(gcc_msm8916_init);
clk/qcom/gcc-msm8916.c:static void __exit gcc_msm8916_exit(void)
clk/qcom/gcc-msm8916.c:	platform_driver_unregister(&gcc_msm8916_driver);
clk/qcom/gcc-msm8916.c:module_exit(gcc_msm8916_exit);
clk/qcom/gcc-msm8916.c:MODULE_ALIAS("platform:gcc-msm8916");
clk/qcom/gcc-msm8960.c:#include <dt-bindings/clock/qcom,gcc-msm8960.h>
clk/qcom/gcc-msm8960.c:#include <dt-bindings/reset/qcom,gcc-msm8960.h>
clk/qcom/gcc-msm8960.c:static struct clk_regmap *gcc_msm8960_clks[] = {
clk/qcom/gcc-msm8960.c:static const struct qcom_reset_map gcc_msm8960_resets[] = {
clk/qcom/gcc-msm8960.c:static const struct regmap_config gcc_msm8960_regmap_config = {
clk/qcom/gcc-msm8960.c:static const struct qcom_cc_desc gcc_msm8960_desc = {
clk/qcom/gcc-msm8960.c:	.config = &gcc_msm8960_regmap_config,
clk/qcom/gcc-msm8960.c:	.clks = gcc_msm8960_clks,
clk/qcom/gcc-msm8960.c:	.num_clks = ARRAY_SIZE(gcc_msm8960_clks),
clk/qcom/gcc-msm8960.c:	.resets = gcc_msm8960_resets,
clk/qcom/gcc-msm8960.c:	.num_resets = ARRAY_SIZE(gcc_msm8960_resets),
clk/qcom/gcc-msm8960.c:static const struct of_device_id gcc_msm8960_match_table[] = {
clk/qcom/gcc-msm8960.c:	{ .compatible = "qcom,gcc-msm8960", .data = &gcc_msm8960_desc },
clk/qcom/gcc-msm8960.c:MODULE_DEVICE_TABLE(of, gcc_msm8960_match_table);
clk/qcom/gcc-msm8960.c:static int gcc_msm8960_probe(struct platform_device *pdev)
clk/qcom/gcc-msm8960.c:	match = of_match_device(gcc_msm8960_match_table, &pdev->dev);
clk/qcom/gcc-msm8960.c:static int gcc_msm8960_remove(struct platform_device *pdev)
clk/qcom/gcc-msm8960.c:static struct platform_driver gcc_msm8960_driver = {
clk/qcom/gcc-msm8960.c:	.probe		= gcc_msm8960_probe,
clk/qcom/gcc-msm8960.c:	.remove		= gcc_msm8960_remove,
clk/qcom/gcc-msm8960.c:		.name	= "gcc-msm8960",
clk/qcom/gcc-msm8960.c:		.of_match_table = gcc_msm8960_match_table,
clk/qcom/gcc-msm8960.c:static int __init gcc_msm8960_init(void)
clk/qcom/gcc-msm8960.c:	return platform_driver_register(&gcc_msm8960_driver);
clk/qcom/gcc-msm8960.c:core_initcall(gcc_msm8960_init);
clk/qcom/gcc-msm8960.c:static void __exit gcc_msm8960_exit(void)
clk/qcom/gcc-msm8960.c:	platform_driver_unregister(&gcc_msm8960_driver);
clk/qcom/gcc-msm8960.c:module_exit(gcc_msm8960_exit);
clk/qcom/gcc-msm8960.c:MODULE_ALIAS("platform:gcc-msm8960");
clk/qcom/gcc-msm8974.c:#include <dt-bindings/clock/qcom,gcc-msm8974.h>
clk/qcom/gcc-msm8974.c:#include <dt-bindings/reset/qcom,gcc-msm8974.h>
clk/qcom/gcc-msm8974.c:static struct clk_regmap *gcc_msm8974_clocks[] = {
clk/qcom/gcc-msm8974.c:static const struct qcom_reset_map gcc_msm8974_resets[] = {
clk/qcom/gcc-msm8974.c:static struct gdsc *gcc_msm8974_gdscs[] = {
clk/qcom/gcc-msm8974.c:static const struct regmap_config gcc_msm8974_regmap_config = {
clk/qcom/gcc-msm8974.c:static const struct qcom_cc_desc gcc_msm8974_desc = {
clk/qcom/gcc-msm8974.c:	.config = &gcc_msm8974_regmap_config,
clk/qcom/gcc-msm8974.c:	.clks = gcc_msm8974_clocks,
clk/qcom/gcc-msm8974.c:	.num_clks = ARRAY_SIZE(gcc_msm8974_clocks),
clk/qcom/gcc-msm8974.c:	.resets = gcc_msm8974_resets,
clk/qcom/gcc-msm8974.c:	.num_resets = ARRAY_SIZE(gcc_msm8974_resets),
clk/qcom/gcc-msm8974.c:	.gdscs = gcc_msm8974_gdscs,
clk/qcom/gcc-msm8974.c:	.num_gdscs = ARRAY_SIZE(gcc_msm8974_gdscs),
clk/qcom/gcc-msm8974.c:static const struct of_device_id gcc_msm8974_match_table[] = {
clk/qcom/gcc-msm8974.c:	{ .compatible = "qcom,gcc-msm8974" },
clk/qcom/gcc-msm8974.c:	{ .compatible = "qcom,gcc-msm8974pro" , .data = (void *)1UL },
clk/qcom/gcc-msm8974.c:	{ .compatible = "qcom,gcc-msm8974pro-ac", .data = (void *)1UL },
clk/qcom/gcc-msm8974.c:MODULE_DEVICE_TABLE(of, gcc_msm8974_match_table);
clk/qcom/gcc-msm8974.c:static void msm8974_pro_clock_override(void)
clk/qcom/gcc-msm8974.c:	gcc_msm8974_clocks[GPLL4] = &gpll4.clkr;
clk/qcom/gcc-msm8974.c:	gcc_msm8974_clocks[GPLL4_VOTE] = &gpll4_vote;
clk/qcom/gcc-msm8974.c:	gcc_msm8974_clocks[GCC_SDCC1_CDCCAL_SLEEP_CLK] =
clk/qcom/gcc-msm8974.c:	gcc_msm8974_clocks[GCC_SDCC1_CDCCAL_FF_CLK] =
clk/qcom/gcc-msm8974.c:static int gcc_msm8974_probe(struct platform_device *pdev)
clk/qcom/gcc-msm8974.c:	id = of_match_device(gcc_msm8974_match_table, dev);
clk/qcom/gcc-msm8974.c:		msm8974_pro_clock_override();
clk/qcom/gcc-msm8974.c:	return qcom_cc_probe(pdev, &gcc_msm8974_desc);
clk/qcom/gcc-msm8974.c:static struct platform_driver gcc_msm8974_driver = {
clk/qcom/gcc-msm8974.c:	.probe		= gcc_msm8974_probe,
clk/qcom/gcc-msm8974.c:		.name	= "gcc-msm8974",
clk/qcom/gcc-msm8974.c:		.of_match_table = gcc_msm8974_match_table,
clk/qcom/gcc-msm8974.c:static int __init gcc_msm8974_init(void)
clk/qcom/gcc-msm8974.c:	return platform_driver_register(&gcc_msm8974_driver);
clk/qcom/gcc-msm8974.c:core_initcall(gcc_msm8974_init);
clk/qcom/gcc-msm8974.c:static void __exit gcc_msm8974_exit(void)
clk/qcom/gcc-msm8974.c:	platform_driver_unregister(&gcc_msm8974_driver);
clk/qcom/gcc-msm8974.c:module_exit(gcc_msm8974_exit);
clk/qcom/gcc-msm8974.c:MODULE_ALIAS("platform:gcc-msm8974");
clk/qcom/gcc-msm8994.c:#include <dt-bindings/clock/qcom,gcc-msm8994.h>
clk/qcom/gcc-msm8994.c:static struct clk_regmap *gcc_msm8994_clocks[] = {
clk/qcom/gcc-msm8994.c:static const struct regmap_config gcc_msm8994_regmap_config = {
clk/qcom/gcc-msm8994.c:static const struct qcom_cc_desc gcc_msm8994_desc = {
clk/qcom/gcc-msm8994.c:	.config = &gcc_msm8994_regmap_config,
clk/qcom/gcc-msm8994.c:	.clks = gcc_msm8994_clocks,
clk/qcom/gcc-msm8994.c:	.num_clks = ARRAY_SIZE(gcc_msm8994_clocks),
clk/qcom/gcc-msm8994.c:static const struct of_device_id gcc_msm8994_match_table[] = {
clk/qcom/gcc-msm8994.c:	{ .compatible = "qcom,gcc-msm8994" },
clk/qcom/gcc-msm8994.c:MODULE_DEVICE_TABLE(of, gcc_msm8994_match_table);
clk/qcom/gcc-msm8994.c:static int gcc_msm8994_probe(struct platform_device *pdev)
clk/qcom/gcc-msm8994.c:	return qcom_cc_probe(pdev, &gcc_msm8994_desc);
clk/qcom/gcc-msm8994.c:static struct platform_driver gcc_msm8994_driver = {
clk/qcom/gcc-msm8994.c:	.probe		= gcc_msm8994_probe,
clk/qcom/gcc-msm8994.c:		.name	= "gcc-msm8994",
clk/qcom/gcc-msm8994.c:		.of_match_table = gcc_msm8994_match_table,
clk/qcom/gcc-msm8994.c:static int __init gcc_msm8994_init(void)
clk/qcom/gcc-msm8994.c:	return platform_driver_register(&gcc_msm8994_driver);
clk/qcom/gcc-msm8994.c:core_initcall(gcc_msm8994_init);
clk/qcom/gcc-msm8994.c:static void __exit gcc_msm8994_exit(void)
clk/qcom/gcc-msm8994.c:	platform_driver_unregister(&gcc_msm8994_driver);
clk/qcom/gcc-msm8994.c:module_exit(gcc_msm8994_exit);
clk/qcom/gcc-msm8994.c:MODULE_ALIAS("platform:gcc-msm8994");
clk/qcom/gcc-msm8996.c:#include <dt-bindings/clock/qcom,gcc-msm8996.h>
clk/qcom/gcc-msm8996.c:static struct clk_hw *gcc_msm8996_hws[] = {
clk/qcom/gcc-msm8996.c:static struct clk_regmap *gcc_msm8996_clocks[] = {
clk/qcom/gcc-msm8996.c:static struct gdsc *gcc_msm8996_gdscs[] = {
clk/qcom/gcc-msm8996.c:static const struct qcom_reset_map gcc_msm8996_resets[] = {
clk/qcom/gcc-msm8996.c:static const struct regmap_config gcc_msm8996_regmap_config = {
clk/qcom/gcc-msm8996.c:static const struct qcom_cc_desc gcc_msm8996_desc = {
clk/qcom/gcc-msm8996.c:	.config = &gcc_msm8996_regmap_config,
clk/qcom/gcc-msm8996.c:	.clks = gcc_msm8996_clocks,
clk/qcom/gcc-msm8996.c:	.num_clks = ARRAY_SIZE(gcc_msm8996_clocks),
clk/qcom/gcc-msm8996.c:	.resets = gcc_msm8996_resets,
clk/qcom/gcc-msm8996.c:	.num_resets = ARRAY_SIZE(gcc_msm8996_resets),
clk/qcom/gcc-msm8996.c:	.gdscs = gcc_msm8996_gdscs,
clk/qcom/gcc-msm8996.c:	.num_gdscs = ARRAY_SIZE(gcc_msm8996_gdscs),
clk/qcom/gcc-msm8996.c:static const struct of_device_id gcc_msm8996_match_table[] = {
clk/qcom/gcc-msm8996.c:	{ .compatible = "qcom,gcc-msm8996" },
clk/qcom/gcc-msm8996.c:MODULE_DEVICE_TABLE(of, gcc_msm8996_match_table);
clk/qcom/gcc-msm8996.c:static int gcc_msm8996_probe(struct platform_device *pdev)
clk/qcom/gcc-msm8996.c:	regmap = qcom_cc_map(pdev, &gcc_msm8996_desc);
clk/qcom/gcc-msm8996.c:	for (i = 0; i < ARRAY_SIZE(gcc_msm8996_hws); i++) {
clk/qcom/gcc-msm8996.c:		ret = devm_clk_hw_register(dev, gcc_msm8996_hws[i]);
clk/qcom/gcc-msm8996.c:	return qcom_cc_really_probe(pdev, &gcc_msm8996_desc, regmap);
clk/qcom/gcc-msm8996.c:static struct platform_driver gcc_msm8996_driver = {
clk/qcom/gcc-msm8996.c:	.probe		= gcc_msm8996_probe,
clk/qcom/gcc-msm8996.c:		.name	= "gcc-msm8996",
clk/qcom/gcc-msm8996.c:		.of_match_table = gcc_msm8996_match_table,
clk/qcom/gcc-msm8996.c:static int __init gcc_msm8996_init(void)
clk/qcom/gcc-msm8996.c:	return platform_driver_register(&gcc_msm8996_driver);
clk/qcom/gcc-msm8996.c:core_initcall(gcc_msm8996_init);
clk/qcom/gcc-msm8996.c:static void __exit gcc_msm8996_exit(void)
clk/qcom/gcc-msm8996.c:	platform_driver_unregister(&gcc_msm8996_driver);
clk/qcom/gcc-msm8996.c:module_exit(gcc_msm8996_exit);
clk/qcom/gcc-msm8996.c:MODULE_ALIAS("platform:gcc-msm8996");
clk/qcom/gcc-msm8998.c:#include <dt-bindings/clock/qcom,gcc-msm8998.h>
clk/qcom/gcc-msm8998.c:static struct clk_regmap *gcc_msm8998_clocks[] = {
clk/qcom/gcc-msm8998.c:static struct gdsc *gcc_msm8998_gdscs[] = {
clk/qcom/gcc-msm8998.c:static const struct qcom_reset_map gcc_msm8998_resets[] = {
clk/qcom/gcc-msm8998.c:static const struct regmap_config gcc_msm8998_regmap_config = {
clk/qcom/gcc-msm8998.c:static const struct qcom_cc_desc gcc_msm8998_desc = {
clk/qcom/gcc-msm8998.c:	.config = &gcc_msm8998_regmap_config,
clk/qcom/gcc-msm8998.c:	.clks = gcc_msm8998_clocks,
clk/qcom/gcc-msm8998.c:	.num_clks = ARRAY_SIZE(gcc_msm8998_clocks),
clk/qcom/gcc-msm8998.c:	.resets = gcc_msm8998_resets,
clk/qcom/gcc-msm8998.c:	.num_resets = ARRAY_SIZE(gcc_msm8998_resets),
clk/qcom/gcc-msm8998.c:	.gdscs = gcc_msm8998_gdscs,
clk/qcom/gcc-msm8998.c:	.num_gdscs = ARRAY_SIZE(gcc_msm8998_gdscs),
clk/qcom/gcc-msm8998.c:static int gcc_msm8998_probe(struct platform_device *pdev)
clk/qcom/gcc-msm8998.c:	regmap = qcom_cc_map(pdev, &gcc_msm8998_desc);
clk/qcom/gcc-msm8998.c:	return qcom_cc_really_probe(pdev, &gcc_msm8998_desc, regmap);
clk/qcom/gcc-msm8998.c:static const struct of_device_id gcc_msm8998_match_table[] = {
clk/qcom/gcc-msm8998.c:	{ .compatible = "qcom,gcc-msm8998" },
clk/qcom/gcc-msm8998.c:MODULE_DEVICE_TABLE(of, gcc_msm8998_match_table);
clk/qcom/gcc-msm8998.c:static struct platform_driver gcc_msm8998_driver = {
clk/qcom/gcc-msm8998.c:	.probe		= gcc_msm8998_probe,
clk/qcom/gcc-msm8998.c:		.name	= "gcc-msm8998",
clk/qcom/gcc-msm8998.c:		.of_match_table = gcc_msm8998_match_table,
clk/qcom/gcc-msm8998.c:static int __init gcc_msm8998_init(void)
clk/qcom/gcc-msm8998.c:	return platform_driver_register(&gcc_msm8998_driver);
clk/qcom/gcc-msm8998.c:core_initcall(gcc_msm8998_init);
clk/qcom/gcc-msm8998.c:static void __exit gcc_msm8998_exit(void)
clk/qcom/gcc-msm8998.c:	platform_driver_unregister(&gcc_msm8998_driver);
clk/qcom/gcc-msm8998.c:module_exit(gcc_msm8998_exit);
clk/qcom/gcc-msm8998.c:MODULE_DESCRIPTION("QCOM GCC msm8998 Driver");
clk/qcom/gcc-msm8998.c:MODULE_ALIAS("platform:gcc-msm8998");
clk/qcom/gdsc-regulator.c:#include <linux/msm-bus.h>
clk/qcom/gdsc-regulator.c:	struct msm_bus_scale_pdata *bus_pdata;
clk/qcom/gdsc-regulator.c:		ret = msm_bus_scale_client_update_request(sc->bus_handle, 1);
clk/qcom/gdsc-regulator.c:		msm_bus_scale_client_update_request(sc->bus_handle, 0);
clk/qcom/gdsc-regulator.c:		ret = msm_bus_scale_client_update_request(sc->bus_handle, 1);
clk/qcom/gdsc-regulator.c:		msm_bus_scale_client_update_request(sc->bus_handle, 0);
clk/qcom/gdsc-regulator.c:		ret = msm_bus_scale_client_update_request(sc->bus_handle, 0);
clk/qcom/gdsc-regulator.c:		ret = msm_bus_scale_client_update_request(sc->bus_handle, 1);
clk/qcom/gdsc-regulator.c:		msm_bus_scale_client_update_request(sc->bus_handle, 0);
clk/qcom/gdsc-regulator.c:		ret = msm_bus_scale_client_update_request(sc->bus_handle, 1);
clk/qcom/gdsc-regulator.c:		msm_bus_scale_client_update_request(sc->bus_handle, 0);
clk/qcom/gdsc-regulator.c:	if (of_find_property(pdev->dev.of_node, "qcom,msm-bus,name", NULL)) {
clk/qcom/gdsc-regulator.c:		sc->bus_pdata = msm_bus_cl_get_pdata(pdev);
clk/qcom/gdsc-regulator.c:		sc->bus_handle = msm_bus_scale_register_client(sc->bus_pdata);
clk/qcom/gdsc-regulator.c:			 * msm_bus_scale_register_client() returns 0 for all
clk/qcom/gdsc-regulator.c:		ret = msm_bus_scale_client_update_request(sc->bus_handle, 1);
clk/qcom/gdsc-regulator.c:			msm_bus_scale_client_update_request(sc->bus_handle, 0);
clk/qcom/gdsc-regulator.c:			msm_bus_scale_client_update_request(sc->bus_handle, 0);
clk/qcom/gdsc-regulator.c:		msm_bus_scale_unregister_client(sc->bus_handle);
clk/qcom/gdsc-regulator.c:			msm_bus_scale_client_update_request(sc->bus_handle, 0);
clk/qcom/gdsc-regulator.c:		msm_bus_scale_unregister_client(sc->bus_handle);
clk/qcom/lcc-msm8960.c:#include <dt-bindings/clock/qcom,lcc-msm8960.h>
clk/qcom/lcc-msm8960.c:static struct clk_regmap *lcc_msm8960_clks[] = {
clk/qcom/lcc-msm8960.c:static const struct regmap_config lcc_msm8960_regmap_config = {
clk/qcom/lcc-msm8960.c:static const struct qcom_cc_desc lcc_msm8960_desc = {
clk/qcom/lcc-msm8960.c:	.config = &lcc_msm8960_regmap_config,
clk/qcom/lcc-msm8960.c:	.clks = lcc_msm8960_clks,
clk/qcom/lcc-msm8960.c:	.num_clks = ARRAY_SIZE(lcc_msm8960_clks),
clk/qcom/lcc-msm8960.c:static const struct of_device_id lcc_msm8960_match_table[] = {
clk/qcom/lcc-msm8960.c:	{ .compatible = "qcom,lcc-msm8960" },
clk/qcom/lcc-msm8960.c:MODULE_DEVICE_TABLE(of, lcc_msm8960_match_table);
clk/qcom/lcc-msm8960.c:static int lcc_msm8960_probe(struct platform_device *pdev)
clk/qcom/lcc-msm8960.c:	regmap = qcom_cc_map(pdev, &lcc_msm8960_desc);
clk/qcom/lcc-msm8960.c:	return qcom_cc_really_probe(pdev, &lcc_msm8960_desc, regmap);
clk/qcom/lcc-msm8960.c:static struct platform_driver lcc_msm8960_driver = {
clk/qcom/lcc-msm8960.c:	.probe		= lcc_msm8960_probe,
clk/qcom/lcc-msm8960.c:		.name	= "lcc-msm8960",
clk/qcom/lcc-msm8960.c:		.of_match_table = lcc_msm8960_match_table,
clk/qcom/lcc-msm8960.c:module_platform_driver(lcc_msm8960_driver);
clk/qcom/lcc-msm8960.c:MODULE_ALIAS("platform:lcc-msm8960");
clk/qcom/mdss/mdss-hdmi-pll-8996.c:#include <linux/clk/msm-clk-provider.h>
clk/qcom/mdss/mdss-hdmi-pll-8996.c:#include <linux/clk/msm-clk.h>
clk/qcom/mdss/mdss-hdmi-pll-8996.c:#include <linux/clk/msm-clock-generic.h>
clk/qcom/mdss/mdss-hdmi-pll-8996.c:#include <dt-bindings/clock/msm-clocks-8996.h>
clk/qcom/mdss/mdss-hdmi-pll-8996.c:	rc = of_msm_clock_register(pdev->dev.of_node, hdmipllcc_8996,
clk/qcom/mdss/mdss-hdmi-pll-8998.c:#include <linux/clk/msm-clk-provider.h>
clk/qcom/mdss/mdss-hdmi-pll-8998.c:#include <linux/clk/msm-clk.h>
clk/qcom/mdss/mdss-hdmi-pll-8998.c:#include <linux/clk/msm-clock-generic.h>
clk/qcom/mdss/mdss-hdmi-pll-8998.c:#include <dt-bindings/clock/msm-clocks-8998.h>
clk/qcom/mdss/mdss-hdmi-pll-8998.c:	rc = of_msm_clock_register(pdev->dev.of_node, hdmipllcc_8998,
clk/qcom/mdss/mdss-pll-util.c:	rc = msm_dss_config_vreg(&pdev->dev,
clk/qcom/mdss/mdss-pll-util.c:	rc = msm_dss_get_clk(&pdev->dev, mp->clk_config, mp->num_clk);
clk/qcom/mdss/mdss-pll-util.c:	msm_dss_config_vreg(&pdev->dev, mp->vreg_config, mp->num_vreg, 0);
clk/qcom/mdss/mdss-pll-util.c:	msm_dss_put_clk(mp->clk_config, mp->num_clk);
clk/qcom/mdss/mdss-pll-util.c:	msm_dss_config_vreg(&pdev->dev, mp->vreg_config, mp->num_vreg, 0);
clk/qcom/mdss/mdss-pll-util.c:		rc = msm_dss_enable_vreg(mp->vreg_config, mp->num_vreg, enable);
clk/qcom/mdss/mdss-pll-util.c:		rc = msm_dss_clk_set_rate(mp->clk_config, mp->num_clk);
clk/qcom/mdss/mdss-pll-util.c:		rc = msm_dss_enable_clk(mp->clk_config, mp->num_clk, enable);
clk/qcom/mdss/mdss-pll-util.c:		msm_dss_enable_clk(mp->clk_config, mp->num_clk, enable);
clk/qcom/mdss/mdss-pll-util.c:		msm_dss_enable_vreg(mp->vreg_config, mp->num_vreg, enable);
clk/qcom/mdss/mdss-pll-util.c:	msm_dss_enable_vreg(mp->vreg_config, mp->num_vreg, 0);
clk/qcom/mmcc-msm8960.c:#include <dt-bindings/clock/qcom,mmcc-msm8960.h>
clk/qcom/mmcc-msm8960.c:#include <dt-bindings/reset/qcom,mmcc-msm8960.h>
clk/qcom/mmcc-msm8960.c:static struct clk_regmap *mmcc_msm8960_clks[] = {
clk/qcom/mmcc-msm8960.c:static const struct qcom_reset_map mmcc_msm8960_resets[] = {
clk/qcom/mmcc-msm8960.c:static const struct regmap_config mmcc_msm8960_regmap_config = {
clk/qcom/mmcc-msm8960.c:static const struct qcom_cc_desc mmcc_msm8960_desc = {
clk/qcom/mmcc-msm8960.c:	.config = &mmcc_msm8960_regmap_config,
clk/qcom/mmcc-msm8960.c:	.clks = mmcc_msm8960_clks,
clk/qcom/mmcc-msm8960.c:	.num_clks = ARRAY_SIZE(mmcc_msm8960_clks),
clk/qcom/mmcc-msm8960.c:	.resets = mmcc_msm8960_resets,
clk/qcom/mmcc-msm8960.c:	.num_resets = ARRAY_SIZE(mmcc_msm8960_resets),
clk/qcom/mmcc-msm8960.c:static const struct of_device_id mmcc_msm8960_match_table[] = {
clk/qcom/mmcc-msm8960.c:	{ .compatible = "qcom,mmcc-msm8960", .data = &mmcc_msm8960_desc },
clk/qcom/mmcc-msm8960.c:MODULE_DEVICE_TABLE(of, mmcc_msm8960_match_table);
clk/qcom/mmcc-msm8960.c:static int mmcc_msm8960_probe(struct platform_device *pdev)
clk/qcom/mmcc-msm8960.c:	match = of_match_device(mmcc_msm8960_match_table, dev);
clk/qcom/mmcc-msm8960.c:static struct platform_driver mmcc_msm8960_driver = {
clk/qcom/mmcc-msm8960.c:	.probe		= mmcc_msm8960_probe,
clk/qcom/mmcc-msm8960.c:		.name	= "mmcc-msm8960",
clk/qcom/mmcc-msm8960.c:		.of_match_table = mmcc_msm8960_match_table,
clk/qcom/mmcc-msm8960.c:module_platform_driver(mmcc_msm8960_driver);
clk/qcom/mmcc-msm8960.c:MODULE_ALIAS("platform:mmcc-msm8960");
clk/qcom/mmcc-msm8974.c:#include <dt-bindings/clock/qcom,mmcc-msm8974.h>
clk/qcom/mmcc-msm8974.c:#include <dt-bindings/reset/qcom,mmcc-msm8974.h>
clk/qcom/mmcc-msm8974.c:static struct clk_regmap *mmcc_msm8974_clocks[] = {
clk/qcom/mmcc-msm8974.c:static const struct qcom_reset_map mmcc_msm8974_resets[] = {
clk/qcom/mmcc-msm8974.c:static struct gdsc *mmcc_msm8974_gdscs[] = {
clk/qcom/mmcc-msm8974.c:static const struct regmap_config mmcc_msm8974_regmap_config = {
clk/qcom/mmcc-msm8974.c:static const struct qcom_cc_desc mmcc_msm8974_desc = {
clk/qcom/mmcc-msm8974.c:	.config = &mmcc_msm8974_regmap_config,
clk/qcom/mmcc-msm8974.c:	.clks = mmcc_msm8974_clocks,
clk/qcom/mmcc-msm8974.c:	.num_clks = ARRAY_SIZE(mmcc_msm8974_clocks),
clk/qcom/mmcc-msm8974.c:	.resets = mmcc_msm8974_resets,
clk/qcom/mmcc-msm8974.c:	.num_resets = ARRAY_SIZE(mmcc_msm8974_resets),
clk/qcom/mmcc-msm8974.c:	.gdscs = mmcc_msm8974_gdscs,
clk/qcom/mmcc-msm8974.c:	.num_gdscs = ARRAY_SIZE(mmcc_msm8974_gdscs),
clk/qcom/mmcc-msm8974.c:static const struct of_device_id mmcc_msm8974_match_table[] = {
clk/qcom/mmcc-msm8974.c:	{ .compatible = "qcom,mmcc-msm8974" },
clk/qcom/mmcc-msm8974.c:MODULE_DEVICE_TABLE(of, mmcc_msm8974_match_table);
clk/qcom/mmcc-msm8974.c:static int mmcc_msm8974_probe(struct platform_device *pdev)
clk/qcom/mmcc-msm8974.c:	regmap = qcom_cc_map(pdev, &mmcc_msm8974_desc);
clk/qcom/mmcc-msm8974.c:	return qcom_cc_really_probe(pdev, &mmcc_msm8974_desc, regmap);
clk/qcom/mmcc-msm8974.c:static struct platform_driver mmcc_msm8974_driver = {
clk/qcom/mmcc-msm8974.c:	.probe		= mmcc_msm8974_probe,
clk/qcom/mmcc-msm8974.c:		.name	= "mmcc-msm8974",
clk/qcom/mmcc-msm8974.c:		.of_match_table = mmcc_msm8974_match_table,
clk/qcom/mmcc-msm8974.c:module_platform_driver(mmcc_msm8974_driver);
clk/qcom/mmcc-msm8974.c:MODULE_ALIAS("platform:mmcc-msm8974");
clk/qcom/mmcc-msm8996.c:#include <dt-bindings/clock/qcom,mmcc-msm8996.h>
clk/qcom/mmcc-msm8996.c:static struct clk_hw *mmcc_msm8996_hws[] = {
clk/qcom/mmcc-msm8996.c:static struct clk_regmap *mmcc_msm8996_clocks[] = {
clk/qcom/mmcc-msm8996.c:static struct gdsc *mmcc_msm8996_gdscs[] = {
clk/qcom/mmcc-msm8996.c:static const struct qcom_reset_map mmcc_msm8996_resets[] = {
clk/qcom/mmcc-msm8996.c:static const struct regmap_config mmcc_msm8996_regmap_config = {
clk/qcom/mmcc-msm8996.c:static const struct qcom_cc_desc mmcc_msm8996_desc = {
clk/qcom/mmcc-msm8996.c:	.config = &mmcc_msm8996_regmap_config,
clk/qcom/mmcc-msm8996.c:	.clks = mmcc_msm8996_clocks,
clk/qcom/mmcc-msm8996.c:	.num_clks = ARRAY_SIZE(mmcc_msm8996_clocks),
clk/qcom/mmcc-msm8996.c:	.resets = mmcc_msm8996_resets,
clk/qcom/mmcc-msm8996.c:	.num_resets = ARRAY_SIZE(mmcc_msm8996_resets),
clk/qcom/mmcc-msm8996.c:	.gdscs = mmcc_msm8996_gdscs,
clk/qcom/mmcc-msm8996.c:	.num_gdscs = ARRAY_SIZE(mmcc_msm8996_gdscs),
clk/qcom/mmcc-msm8996.c:static const struct of_device_id mmcc_msm8996_match_table[] = {
clk/qcom/mmcc-msm8996.c:	{ .compatible = "qcom,mmcc-msm8996" },
clk/qcom/mmcc-msm8996.c:MODULE_DEVICE_TABLE(of, mmcc_msm8996_match_table);
clk/qcom/mmcc-msm8996.c:static int mmcc_msm8996_probe(struct platform_device *pdev)
clk/qcom/mmcc-msm8996.c:	regmap = qcom_cc_map(pdev, &mmcc_msm8996_desc);
clk/qcom/mmcc-msm8996.c:	for (i = 0; i < ARRAY_SIZE(mmcc_msm8996_hws); i++) {
clk/qcom/mmcc-msm8996.c:		ret = devm_clk_hw_register(dev, mmcc_msm8996_hws[i]);
clk/qcom/mmcc-msm8996.c:	return qcom_cc_really_probe(pdev, &mmcc_msm8996_desc, regmap);
clk/qcom/mmcc-msm8996.c:static struct platform_driver mmcc_msm8996_driver = {
clk/qcom/mmcc-msm8996.c:	.probe		= mmcc_msm8996_probe,
clk/qcom/mmcc-msm8996.c:		.name	= "mmcc-msm8996",
clk/qcom/mmcc-msm8996.c:		.of_match_table = mmcc_msm8996_match_table,
clk/qcom/mmcc-msm8996.c:module_platform_driver(mmcc_msm8996_driver);
clk/qcom/mmcc-msm8996.c:MODULE_ALIAS("platform:mmcc-msm8996");
clk/qcom/videocc-kona.c:#include <linux/msm-bus.h>
clk/qcom/videocc-kona.c:#include <dt-bindings/msm/msm-bus-ids.h>
clk/qcom/videocc-kona.c:static struct msm_bus_vectors clk_debugfs_vectors[] = {
clk/qcom/videocc-kona.c:static struct msm_bus_paths clk_debugfs_usecases[] = {
clk/qcom/videocc-kona.c:static struct msm_bus_scale_pdata clk_debugfs_scale_table = {
clk/qcom/videocc-kona.c:		msm_bus_scale_register_client(&clk_debugfs_scale_table);
clocksource/qcom-timer.c:static irqreturn_t msm_timer_interrupt(int irq, void *dev_id)
clocksource/qcom-timer.c:static int msm_timer_set_next_event(unsigned long cycles,
clocksource/qcom-timer.c:static int msm_timer_shutdown(struct clock_event_device *evt)
clocksource/qcom-timer.c:static struct clock_event_device __percpu *msm_evt;
clocksource/qcom-timer.c:static notrace u64 msm_read_timer_count(struct clocksource *cs)
clocksource/qcom-timer.c:static struct clocksource msm_clocksource = {
clocksource/qcom-timer.c:	.read	= msm_read_timer_count,
clocksource/qcom-timer.c:static int msm_timer_irq;
clocksource/qcom-timer.c:static int msm_timer_has_ppi;
clocksource/qcom-timer.c:static int msm_local_timer_starting_cpu(unsigned int cpu)
clocksource/qcom-timer.c:	struct clock_event_device *evt = per_cpu_ptr(msm_evt, cpu);
clocksource/qcom-timer.c:	evt->irq = msm_timer_irq;
clocksource/qcom-timer.c:	evt->name = "msm_timer";
clocksource/qcom-timer.c:	evt->set_state_shutdown = msm_timer_shutdown;
clocksource/qcom-timer.c:	evt->set_state_oneshot = msm_timer_shutdown;
clocksource/qcom-timer.c:	evt->tick_resume = msm_timer_shutdown;
clocksource/qcom-timer.c:	evt->set_next_event = msm_timer_set_next_event;
clocksource/qcom-timer.c:	if (msm_timer_has_ppi) {
clocksource/qcom-timer.c:		err = request_irq(evt->irq, msm_timer_interrupt,
clocksource/qcom-timer.c:static int msm_local_timer_dying_cpu(unsigned int cpu)
clocksource/qcom-timer.c:	struct clock_event_device *evt = per_cpu_ptr(msm_evt, cpu);
clocksource/qcom-timer.c:static u64 notrace msm_sched_clock_read(void)
clocksource/qcom-timer.c:	return msm_clocksource.read(&msm_clocksource);
clocksource/qcom-timer.c:static unsigned long msm_read_current_timer(void)
clocksource/qcom-timer.c:	return msm_clocksource.read(&msm_clocksource);
clocksource/qcom-timer.c:static struct delay_timer msm_delay_timer = {
clocksource/qcom-timer.c:	.read_current_timer = msm_read_current_timer,
clocksource/qcom-timer.c:static int __init msm_timer_init(u32 dgt_hz, int sched_bits, int irq,
clocksource/qcom-timer.c:	struct clocksource *cs = &msm_clocksource;
clocksource/qcom-timer.c:	msm_timer_irq = irq;
clocksource/qcom-timer.c:	msm_timer_has_ppi = percpu;
clocksource/qcom-timer.c:	msm_evt = alloc_percpu(struct clock_event_device);
clocksource/qcom-timer.c:	if (!msm_evt) {
clocksource/qcom-timer.c:		res = request_percpu_irq(irq, msm_timer_interrupt,
clocksource/qcom-timer.c:					 "gp_timer", msm_evt);
clocksource/qcom-timer.c:					msm_local_timer_starting_cpu,
clocksource/qcom-timer.c:					msm_local_timer_dying_cpu);
clocksource/qcom-timer.c:			free_percpu_irq(irq, msm_evt);
clocksource/qcom-timer.c:	sched_clock_register(msm_sched_clock_read, sched_bits, dgt_hz);
clocksource/qcom-timer.c:	msm_delay_timer.freq = dgt_hz;
clocksource/qcom-timer.c:	register_current_timer_delay(&msm_delay_timer);
clocksource/qcom-timer.c:static int __init msm_dt_timer_init(struct device_node *np)
clocksource/qcom-timer.c:	return msm_timer_init(freq, 32, irq, !!percpu_offset);
clocksource/qcom-timer.c:TIMER_OF_DECLARE(kpss_timer, "qcom,kpss-timer", msm_dt_timer_init);
clocksource/qcom-timer.c:TIMER_OF_DECLARE(scss_timer, "qcom,scss-timer", msm_dt_timer_init);
cpufreq/cpufreq-dt-platdev.c:	{ .compatible = "qcom,msm8996", },
cpufreq/qcom-cpufreq-kryo.c: * In Certain QCOM SoCs like apq8096 and msm8996 that have KRYO processors,
cpufreq/qcom-cpufreq-kryo.c: * defines the voltage and frequency value based on the msm-id in SMEM
cpufreq/qcom-cpufreq-kryo.c: * The qcom-cpufreq-kryo driver reads the msm-id and efuse value from the SoC
cpufreq/qcom-cpufreq-kryo.c:enum _msm_id {
cpufreq/qcom-cpufreq-kryo.c:enum _msm8996_version {
cpufreq/qcom-cpufreq-kryo.c:static enum _msm8996_version qcom_cpufreq_kryo_get_msm_id(void)
cpufreq/qcom-cpufreq-kryo.c:	u32 *msm_id;
cpufreq/qcom-cpufreq-kryo.c:	enum _msm8996_version version;
cpufreq/qcom-cpufreq-kryo.c:	msm_id = qcom_smem_get(QCOM_SMEM_HOST_ANY, MSM_ID_SMEM, &len);
cpufreq/qcom-cpufreq-kryo.c:	if (IS_ERR(msm_id))
cpufreq/qcom-cpufreq-kryo.c:	/* The first 4 bytes are format, next to them is the actual msm-id */
cpufreq/qcom-cpufreq-kryo.c:	msm_id++;
cpufreq/qcom-cpufreq-kryo.c:	switch ((enum _msm_id)*msm_id) {
cpufreq/qcom-cpufreq-kryo.c:	enum _msm8996_version msm8996_version;
cpufreq/qcom-cpufreq-kryo.c:	msm8996_version = qcom_cpufreq_kryo_get_msm_id();
cpufreq/qcom-cpufreq-kryo.c:	if (NUM_OF_MSM8996_VERSIONS == msm8996_version) {
cpufreq/qcom-cpufreq-kryo.c:	switch (msm8996_version) {
cpufreq/qcom-cpufreq-kryo.c:	{ .compatible = "qcom,msm8996", },
cpufreq/qcom-cpufreq.c:static int msm_cpufreq_target(struct cpufreq_policy *policy,
cpufreq/qcom-cpufreq.c:static unsigned int msm_cpufreq_resolve_freq(struct cpufreq_policy *policy,
cpufreq/qcom-cpufreq.c:static int msm_cpufreq_verify(struct cpufreq_policy *policy)
cpufreq/qcom-cpufreq.c:static unsigned int msm_cpufreq_get_freq(unsigned int cpu)
cpufreq/qcom-cpufreq.c:static int msm_cpufreq_init(struct cpufreq_policy *policy)
cpufreq/qcom-cpufreq.c:static int msm_cpufreq_suspend(void)
cpufreq/qcom-cpufreq.c:static int msm_cpufreq_resume(void)
cpufreq/qcom-cpufreq.c:static int msm_cpufreq_pm_event(struct notifier_block *this,
cpufreq/qcom-cpufreq.c:		return msm_cpufreq_resume();
cpufreq/qcom-cpufreq.c:		return msm_cpufreq_suspend();
cpufreq/qcom-cpufreq.c:static struct notifier_block msm_cpufreq_pm_notifier = {
cpufreq/qcom-cpufreq.c:	.notifier_call = msm_cpufreq_pm_event,
cpufreq/qcom-cpufreq.c:static struct freq_attr *msm_freq_attr[] = {
cpufreq/qcom-cpufreq.c:static void msm_cpufreq_ready(struct cpufreq_policy *policy)
cpufreq/qcom-cpufreq.c:static struct cpufreq_driver msm_cpufreq_driver = {
cpufreq/qcom-cpufreq.c:	.init		= msm_cpufreq_init,
cpufreq/qcom-cpufreq.c:	.verify		= msm_cpufreq_verify,
cpufreq/qcom-cpufreq.c:	.target		= msm_cpufreq_target,
cpufreq/qcom-cpufreq.c:	.resolve_freq	= msm_cpufreq_resolve_freq,
cpufreq/qcom-cpufreq.c:	.get		= msm_cpufreq_get_freq,
cpufreq/qcom-cpufreq.c:	.name		= "msm",
cpufreq/qcom-cpufreq.c:	.attr		= msm_freq_attr,
cpufreq/qcom-cpufreq.c:	.ready		= msm_cpufreq_ready,
cpufreq/qcom-cpufreq.c:static int msm_cpufreq_probe(struct platform_device *pdev)
cpufreq/qcom-cpufreq.c:		msm_cpufreq_driver.flags |= CPUFREQ_HAVE_GOVERNOR_PER_POLICY;
cpufreq/qcom-cpufreq.c:	ret = register_pm_notifier(&msm_cpufreq_pm_notifier);
cpufreq/qcom-cpufreq.c:	ret = cpufreq_register_driver(&msm_cpufreq_driver);
cpufreq/qcom-cpufreq.c:		unregister_pm_notifier(&msm_cpufreq_pm_notifier);
cpufreq/qcom-cpufreq.c:static const struct of_device_id msm_cpufreq_match_table[] = {
cpufreq/qcom-cpufreq.c:	{ .compatible = "qcom,msm-cpufreq" },
cpufreq/qcom-cpufreq.c:static struct platform_driver msm_cpufreq_plat_driver = {
cpufreq/qcom-cpufreq.c:	.probe = msm_cpufreq_probe,
cpufreq/qcom-cpufreq.c:		.name = "msm-cpufreq",
cpufreq/qcom-cpufreq.c:		.of_match_table = msm_cpufreq_match_table,
cpufreq/qcom-cpufreq.c:static int __init msm_cpufreq_register(void)
cpufreq/qcom-cpufreq.c:	rc = platform_driver_register(&msm_cpufreq_plat_driver);
cpufreq/qcom-cpufreq.c:		/* Unblock hotplug if msm-cpufreq probe fails */
cpufreq/qcom-cpufreq.c:subsys_initcall(msm_cpufreq_register);
cpufreq/qcom-cpufreq.c:static int __init msm_cpufreq_early_register(void)
cpufreq/qcom-cpufreq.c:core_initcall(msm_cpufreq_early_register);
cpufreq/cpu_input_boost.c:	struct notifier_block msm_drm_notif;
cpufreq/cpu_input_boost.c:static int msm_drm_notifier_cb(struct notifier_block *nb, unsigned long action,
cpufreq/cpu_input_boost.c:	struct boost_drv *b = container_of(nb, typeof(*b), msm_drm_notif);
cpufreq/cpu_input_boost.c:	b->msm_drm_notif.notifier_call = msm_drm_notifier_cb;
cpufreq/cpu_input_boost.c:	b->msm_drm_notif.priority = INT_MAX;
cpufreq/cpu_input_boost.c:	ret = mi_drm_register_client(&b->msm_drm_notif);
cpufreq/cpu_input_boost.c:	mi_drm_unregister_client(&b->msm_drm_notif);
cpuidle/lpm-levels.c:#include <trace/events/trace_msm_low_power.h>
cpuidle/lpm-levels.c: * msm_cpuidle_get_deep_idle_latency - Get deep idle latency value
cpuidle/lpm-levels.c:inline s32 msm_cpuidle_get_deep_idle_latency(void)
cpuidle/lpm-levels.c:EXPORT_SYMBOL(msm_cpuidle_get_deep_idle_latency);
cpuidle/lpm-levels.c:		lpm_cpu->drv->name = "msm_idle";
crypto/Makefile:obj-$(CONFIG_CRYPTO_DEV_QCOM_MSM_QCE) += msm/
crypto/msm/ice.c:#include <linux/msm-bus.h>
crypto/msm/ice.c:		err = msm_bus_scale_client_update_request(
crypto/msm/ice.c:	struct msm_bus_scale_pdata *bus_pdata;
crypto/msm/ice.c:	bus_pdata = msm_bus_cl_get_pdata(pdev);
crypto/msm/ice.c:			msm_bus_scale_register_client(bus_pdata);
crypto/msm/ice.c:		dev_err(dev, "%s: msm_bus_scale_register_client failed\n",
crypto/msm/qce50.h:#include <linux/msm-sps.h>
crypto/msm/qcedev.c:#include <linux/msm-bus.h>
crypto/msm/qcedev.c:		ret = msm_bus_scale_client_update_request(
crypto/msm/qcedev.c:		ret = msm_bus_scale_client_update_request(
crypto/msm/qcedev.c:			ret = msm_bus_scale_client_update_request(
crypto/msm/qcedev.c:		ret = msm_bus_scale_client_update_request(
crypto/msm/qcedev.c:		ret = msm_bus_scale_client_update_request(
crypto/msm/qcedev.c:			ret = msm_bus_scale_client_update_request(
crypto/msm/qcedev.c:	struct msm_ce_hw_support *platform_support;
crypto/msm/qcedev.c:	podev->platform_support.bus_scale_table = (struct msm_bus_scale_pdata *)
crypto/msm/qcedev.c:					msm_bus_cl_get_pdata(pdev);
crypto/msm/qcedev.c:	podev->bus_scale_handle = msm_bus_scale_register_client(
crypto/msm/qcedev.c:				(struct msm_bus_scale_pdata *)
crypto/msm/qcedev.c:	rc = msm_bus_scale_client_update_request(podev->bus_scale_handle, 1);
crypto/msm/qcedev.c:	rc = msm_bus_scale_client_update_request(podev->bus_scale_handle, 0);
crypto/msm/qcedev.c:			(struct msm_ce_hw_support *)pdev->dev.platform_data;
crypto/msm/qcedev.c:	msm_bus_scale_client_update_request(podev->bus_scale_handle, 0);
crypto/msm/qcedev.c:		msm_bus_scale_unregister_client(podev->bus_scale_handle);
crypto/msm/qcedev.c:		msm_bus_scale_unregister_client(podev->bus_scale_handle);
crypto/msm/qcedev_smmu.h:#include <linux/msm_dma_iommu_mapping.h>
crypto/msm/qcedev_smmu.h:#include <linux/msm_ion.h>
crypto/msm/qcedevi.h:	struct msm_ce_hw_support platform_support;
crypto/msm/qcrypto.c:#include <linux/msm-bus.h>
crypto/msm/qcrypto.c:	struct msm_ce_hw_support platform_support;
crypto/msm/qcrypto.c:		ret = msm_bus_scale_client_update_request(
crypto/msm/qcrypto.c:		ret = msm_bus_scale_client_update_request(
crypto/msm/qcrypto.c:			ret = msm_bus_scale_client_update_request(
crypto/msm/qcrypto.c:		ret = msm_bus_scale_client_update_request(
crypto/msm/qcrypto.c:		ret = msm_bus_scale_client_update_request(
crypto/msm/qcrypto.c:			ret = msm_bus_scale_client_update_request(
crypto/msm/qcrypto.c:		msm_bus_scale_unregister_client(pengine->bus_scale_handle);
crypto/msm/qcrypto.c:	struct msm_ce_hw_support *platform_support;
crypto/msm/qcrypto.c:	cp->platform_support.bus_scale_table = (struct msm_bus_scale_pdata *)
crypto/msm/qcrypto.c:					msm_bus_cl_get_pdata(pdev);
crypto/msm/qcrypto.c:		pengine->bus_scale_handle = msm_bus_scale_register_client(
crypto/msm/qcrypto.c:				(struct msm_bus_scale_pdata *)
crypto/msm/qcrypto.c:	rc = msm_bus_scale_client_update_request(pengine->bus_scale_handle, 1);
crypto/msm/qcrypto.c:	rc = msm_bus_scale_client_update_request(pengine->bus_scale_handle, 0);
crypto/msm/qcrypto.c:			(struct msm_ce_hw_support *)pdev->dev.platform_data;
crypto/msm/qcrypto.c:	msm_bus_scale_client_update_request(pengine->bus_scale_handle, 0);
crypto/qcom-rng.c:// Based on msm-rng.c and downstream driver
devfreq/bimc-bwmon.c:#include <linux/msm-bus.h>
devfreq/bimc-bwmon.c:#include <linux/msm-bus-board.h>
devfreq/bimc-bwmon.c:	struct msm_bus_client_handle *bus_client;
devfreq/bimc-bwmon.c:		ret = msm_bus_scale_update_bw(m->bus_client, 0, 1);
devfreq/bimc-bwmon.c:		ret = msm_bus_scale_update_bw(m->bus_client, 0, 0);
devfreq/bimc-bwmon.c:		ret = msm_bus_scale_update_bw(m->bus_client, 0, 0);
devfreq/bimc-bwmon.c:	if (of_find_property(dev->of_node, "qcom,msm_bus", &len)) {
devfreq/bimc-bwmon.c:		ret = of_property_read_u32_array(dev->of_node, "qcom,msm_bus",
devfreq/bimc-bwmon.c:					"qcom,msm_bus_name", &m->bus_name);
devfreq/bimc-bwmon.c:		m->bus_client = msm_bus_scale_register(ports[0], ports[1],
devfreq/bimc-bwmon.c:		msm_bus_scale_unregister(m->bus_client);
devfreq/governor_bw_vbif.c:#include <linux/msm_adreno_devfreq.h>
devfreq/governor_gpubw_mon.c:#include <linux/msm_adreno_devfreq.h>
devfreq/governor_gpubw_mon.c:static void _update_cutoff(struct devfreq_msm_adreno_tz_data *priv,
devfreq/governor_gpubw_mon.c:	struct msm_busmon_extended_profile *bus_profile = container_of(
devfreq/governor_gpubw_mon.c:					struct msm_busmon_extended_profile,
devfreq/governor_gpubw_mon.c:	struct msm_busmon_extended_profile *bus_profile = container_of(
devfreq/governor_gpubw_mon.c:					struct msm_busmon_extended_profile,
devfreq/governor_gpubw_mon.c:	struct msm_busmon_extended_profile *bus_profile = container_of(
devfreq/governor_gpubw_mon.c:					struct msm_busmon_extended_profile,
devfreq/governor_gpubw_mon.c:	struct devfreq_msm_adreno_tz_data *priv = df->data;
devfreq/governor_gpubw_mon.c:	struct msm_busmon_extended_profile *bus_profile = container_of(
devfreq/governor_gpubw_mon.c:			struct msm_busmon_extended_profile,
devfreq/governor_gpubw_mon.c:	struct devfreq_msm_adreno_tz_data *priv;
devfreq/governor_gpubw_mon.c:	struct msm_busmon_extended_profile *bus_profile = container_of(
devfreq/governor_gpubw_mon.c:					struct msm_busmon_extended_profile,
devfreq/governor_gpubw_mon.c:	struct devfreq_msm_adreno_tz_data *priv = devfreq->data;
devfreq/governor_gpubw_mon.c:			struct devfreq_msm_adreno_tz_data *priv = devfreq->data;
devfreq/devfreq_boost.c:	struct notifier_block msm_drm_notif;
devfreq/devfreq_boost.c:static int msm_drm_notifier_cb(struct notifier_block *nb, unsigned long action,
devfreq/devfreq_boost.c:	struct df_boost_drv *d = container_of(nb, typeof(*d), msm_drm_notif);
devfreq/devfreq_boost.c:	d->msm_drm_notif.notifier_call = msm_drm_notifier_cb;
devfreq/devfreq_boost.c:	d->msm_drm_notif.priority = INT_MAX;
devfreq/devfreq_boost.c:	ret = mi_drm_register_client(&d->msm_drm_notif);
devfreq/devfreq_devbw.c:#include <linux/msm-bus.h>
devfreq/devfreq_devbw.c:#include <linux/msm-bus-board.h>
devfreq/devfreq_devbw.c:	struct msm_bus_vectors vectors[MAX_PATHS * DBL_BUF];
devfreq/devfreq_devbw.c:	struct msm_bus_paths bw_levels[DBL_BUF];
devfreq/devfreq_devbw.c:	struct msm_bus_scale_pdata bw_data;
devfreq/devfreq_devbw.c:	ret = msm_bus_scale_client_update_request(d->bus_client, i);
devfreq/devfreq_devbw.c:	d->bus_client = msm_bus_scale_register_client(&d->bw_data);
devfreq/devfreq_devbw.c:		msm_bus_scale_unregister_client(d->bus_client);
devfreq/devfreq_devbw.c:	msm_bus_scale_unregister_client(d->bus_client);
devfreq/Makefile:obj-$(CONFIG_DEVFREQ_GOV_QCOM_ADRENO_TZ) += governor_msm_adreno_tz.o
devfreq/governor_msm_adreno_tz.c:#include <linux/msm_adreno_devfreq.h>
devfreq/governor_msm_adreno_tz.c:#define TAG "msm_adreno_tz: "
devfreq/governor_msm_adreno_tz.c:static struct msm_adreno_extended_profile *partner_gpu_profile;
devfreq/governor_msm_adreno_tz.c:		struct devfreq_msm_adreno_tz_data *priv,
devfreq/governor_msm_adreno_tz.c:		int *val, u32 size_val, struct devfreq_msm_adreno_tz_data *priv)
devfreq/governor_msm_adreno_tz.c:static int tz_init_ca(struct devfreq_msm_adreno_tz_data *priv)
devfreq/governor_msm_adreno_tz.c:static int tz_init(struct devfreq_msm_adreno_tz_data *priv,
devfreq/governor_msm_adreno_tz.c:	struct devfreq_msm_adreno_tz_data *priv = devfreq->data;
devfreq/governor_msm_adreno_tz.c:	struct devfreq_msm_adreno_tz_data *priv;
devfreq/governor_msm_adreno_tz.c:	struct msm_adreno_extended_profile *gpu_profile;
devfreq/governor_msm_adreno_tz.c:			struct msm_adreno_extended_profile,
devfreq/governor_msm_adreno_tz.c:	struct devfreq_msm_adreno_tz_data *priv = devfreq->data;
devfreq/governor_msm_adreno_tz.c:	struct devfreq_msm_adreno_tz_data *priv = devfreq->data;
devfreq/governor_msm_adreno_tz.c:	struct msm_adreno_extended_profile *gpu_profile;
devfreq/governor_msm_adreno_tz.c:		struct msm_adreno_extended_profile, profile);
devfreq/governor_msm_adreno_tz.c:static struct devfreq_governor msm_adreno_tz = {
devfreq/governor_msm_adreno_tz.c:	.name = "msm-adreno-tz",
devfreq/governor_msm_adreno_tz.c:static int __init msm_adreno_tz_init(void)
devfreq/governor_msm_adreno_tz.c:	workqueue = create_freezable_workqueue("governor_msm_adreno_tz_wq");
devfreq/governor_msm_adreno_tz.c:	return devfreq_add_governor(&msm_adreno_tz);
devfreq/governor_msm_adreno_tz.c:subsys_initcall(msm_adreno_tz_init);
devfreq/governor_msm_adreno_tz.c:static void __exit msm_adreno_tz_exit(void)
devfreq/governor_msm_adreno_tz.c:	int ret = devfreq_remove_governor(&msm_adreno_tz);
devfreq/governor_msm_adreno_tz.c:module_exit(msm_adreno_tz_exit);
dma/qcom-sps-dma.c:#include <linux/msm-sps.h>
dma/qcom/gpi.c:#include <linux/msm_gpi.h>
dma/qcom/gpi.c:#include "msm_gpi_mmio.h"
dma/qcom/gpi.c:				  enum msm_gpi_cb_event event,
dma/qcom/gpi.c:	struct msm_gpi_cb msm_gpi_cb = {0};
dma/qcom/gpi.c:	msm_gpi_cb.cb_event = event;
dma/qcom/gpi.c:	msm_gpi_cb.status = status;
dma/qcom/gpi.c:	msm_gpi_cb.timestamp = sched_clock();
dma/qcom/gpi.c:	client_info->callback(&gpii_chan->vc.chan, &msm_gpi_cb,
dma/qcom/gpi.c:	struct msm_gpi_cb msm_gpi_cb;
dma/qcom/gpi.c:	msm_gpi_cb.cb_event = MSM_GPI_QUP_ERROR;
dma/qcom/gpi.c:	msm_gpi_cb.error_log.routine = log_entry->routine;
dma/qcom/gpi.c:	msm_gpi_cb.error_log.type = log_entry->type;
dma/qcom/gpi.c:	msm_gpi_cb.error_log.error_code = log_entry->code;
dma/qcom/gpi.c:		  TO_GPI_CB_EVENT_STR(msm_gpi_cb.cb_event));
dma/qcom/gpi.c:		 msm_gpi_cb.error_log.routine,
dma/qcom/gpi.c:		 msm_gpi_cb.error_log.type,
dma/qcom/gpi.c:		 msm_gpi_cb.error_log.error_code);
dma/qcom/gpi.c:	client_info->callback(&gpii_chan->vc.chan, &msm_gpi_cb,
dma/qcom/gpi.c:	struct msm_gpi_cb msm_gpi_cb;
dma/qcom/gpi.c:	msm_gpi_cb.cb_event = MSM_GPI_QUP_NOTIFY;
dma/qcom/gpi.c:	msm_gpi_cb.status = notif_event->status;
dma/qcom/gpi.c:	msm_gpi_cb.timestamp = notif_event->time;
dma/qcom/gpi.c:	msm_gpi_cb.count = notif_event->count;
dma/qcom/gpi.c:		  TO_GPI_CB_EVENT_STR(msm_gpi_cb.cb_event));
dma/qcom/gpi.c:	client_info->callback(&gpii_chan->vc.chan, &msm_gpi_cb,
dma/qcom/gpi.c:	struct msm_gpi_dma_async_tx_cb_param *tx_cb_param;
dma/qcom/gpi.c:		struct msm_gpi_tre *gpi_tre;
dma/qcom/gpi.c:		struct msm_gpi_tre *imed_tre = &tx_cb_param->imed_tre;
dma/qcom/gpi.c:		*imed_tre = *((struct msm_gpi_tre *)imed_event);
dma/qcom/gpi.c:	struct msm_gpi_dma_async_tx_cb_param *tx_cb_param;
dma/qcom/gpi.c:			   struct msm_gpi_tre *gpi_tre,
dma/qcom/gpi.c:	struct msm_gpi_tre *ch_tre;
dma/qcom/gpi.c:			MSM_GPI_TRE_TYPE(((struct msm_gpi_tre *)tre));
dma/qcom/gpi.c:	struct msm_gpi_ctrl *gpi_ctrl = chan->private;
dma/qcom/gpi.c:		GPII_INFO(gpii, gpii_chan->chid, "cmd: msm_gpi_init\n");
dma/qcom/gpi.c:			     sizeof(struct msm_gpi_tre), gpii);
edac/cortex_arm64_edac.c:#include <linux/msm_rtb.h>
esoc/Kconfig:	  is connected to a primary msm. The primary soc can control/monitor
esoc/esoc-mdm-drv.c:static int esoc_msm_restart_handler(struct notifier_block *nb,
esoc/esoc-mdm-drv.c:	mdm_drv->esoc_restart.notifier_call = esoc_msm_restart_handler;
firmware/qcom/tz_log.c:#include <linux/msm_ion.h>
firmware/qcom_scm.c:	{ .compatible = "qcom,scm-msm8660",
firmware/qcom_scm.c:	{ .compatible = "qcom,scm-msm8960",
firmware/qcom_scm.c:	{ .compatible = "qcom,scm-msm8996",
gpu/drm/Kconfig:source "drivers/gpu/drm/msm/Kconfig"
gpu/drm/Makefile:obj-$(CONFIG_DRM_MSM) += msm/
gpu/drm/drm_notifier_mi.c: * to msm_drm_notifier_list, which would be called when
gpu/drm/drm_notifier_mi.c: * msm_drm_notifier_list.
gpu/drm/drm_sysfs.c:#include <drm/msm_drm_pp.h>
gpu/drm/drm_sysfs.c:struct drm_msm_pcc color_transform_pcc_cfg = {
gpu/drm/etnaviv/etnaviv_gem_prime.c:	/* TODO msm_gem_vunmap() */
gpu/drm/msm/Makefile:ccflags-y := -Idrivers/gpu/drm/msm
gpu/drm/msm/Makefile:ccflags-y += -Idrivers/gpu/drm/msm/disp/dpu1
gpu/drm/msm/Makefile:ccflags-$(CONFIG_DRM_MSM_DSI) += -Idrivers/gpu/drm/msm/dsi
gpu/drm/msm/Makefile:msm-y := \
gpu/drm/msm/Makefile:	msm_atomic.o \
gpu/drm/msm/Makefile:	msm_debugfs.o \
gpu/drm/msm/Makefile:	msm_drv.o \
gpu/drm/msm/Makefile:	msm_fb.o \
gpu/drm/msm/Makefile:	msm_fence.o \
gpu/drm/msm/Makefile:	msm_gem.o \
gpu/drm/msm/Makefile:	msm_gem_prime.o \
gpu/drm/msm/Makefile:	msm_gem_shrinker.o \
gpu/drm/msm/Makefile:	msm_gem_submit.o \
gpu/drm/msm/Makefile:	msm_gem_vma.o \
gpu/drm/msm/Makefile:	msm_gpu.o \
gpu/drm/msm/Makefile:	msm_iommu.o \
gpu/drm/msm/Makefile:	msm_perf.o \
gpu/drm/msm/Makefile:	msm_rd.o \
gpu/drm/msm/Makefile:	msm_ringbuffer.o \
gpu/drm/msm/Makefile:	msm_submitqueue.o
gpu/drm/msm/Makefile:msm_drm-y += adreno/adreno_device.o \
gpu/drm/msm/Makefile:msm-$(CONFIG_DEBUG_FS) += adreno/a5xx_debugfs.o \
gpu/drm/msm/Makefile:msm-$(CONFIG_DRM_FBDEV_EMULATION) += msm_fbdev.o
gpu/drm/msm/Makefile:msm-$(CONFIG_COMMON_CLK) += disp/mdp4/mdp4_lvds_pll.o
gpu/drm/msm/Makefile:msm-$(CONFIG_COMMON_CLK) += hdmi/hdmi_pll_8960.o
gpu/drm/msm/Makefile:msm-$(CONFIG_COMMON_CLK) += hdmi/hdmi_phy_8996.o
gpu/drm/msm/Makefile:msm-$(CONFIG_DRM_MSM_HDMI_HDCP) += hdmi/hdmi_hdcp.o
gpu/drm/msm/Makefile:msm-$(CONFIG_DRM_MSM_DSI) += dsi/dsi.o \
gpu/drm/msm/Makefile:msm-$(CONFIG_DRM_MSM_DSI_28NM_PHY) += dsi/phy/dsi_phy_28nm.o
gpu/drm/msm/Makefile:msm-$(CONFIG_DRM_MSM_DSI_20NM_PHY) += dsi/phy/dsi_phy_20nm.o
gpu/drm/msm/Makefile:msm-$(CONFIG_DRM_MSM_DSI_28NM_8960_PHY) += dsi/phy/dsi_phy_28nm_8960.o
gpu/drm/msm/Makefile:msm-$(CONFIG_DRM_MSM_DSI_14NM_PHY) += dsi/phy/dsi_phy_14nm.o
gpu/drm/msm/Makefile:msm-$(CONFIG_DRM_MSM_DSI_10NM_PHY) += dsi/phy/dsi_phy_10nm.o
gpu/drm/msm/Makefile:msm-y += dsi/pll/dsi_pll.o
gpu/drm/msm/Makefile:msm-$(CONFIG_DRM_MSM_DSI_28NM_PHY) += dsi/pll/dsi_pll_28nm.o
gpu/drm/msm/Makefile:msm-$(CONFIG_DRM_MSM_DSI_28NM_8960_PHY) += dsi/pll/dsi_pll_28nm_8960.o
gpu/drm/msm/Makefile:msm-$(CONFIG_DRM_MSM_DSI_14NM_PHY) += dsi/pll/dsi_pll_14nm.o
gpu/drm/msm/Makefile:msm-$(CONFIG_DRM_MSM_DSI_10NM_PHY) += dsi/pll/dsi_pll_10nm.o
gpu/drm/msm/Makefile:obj-$(CONFIG_DRM_MSM)	+= msm.o
gpu/drm/msm/NOTES:NOTES about msm drm/kms driver:
gpu/drm/msm/NOTES:'struct msm_kms' implementations, depending on display controller.
gpu/drm/msm/NOTES:And one or more 'struct msm_gpu' for the various different gpu sub-
gpu/drm/msm/NOTES:we'll let msm_mdp4_kms provide the irq install/uninstall/etc functions
gpu/drm/msm/adreno/a3xx_gpu.c:static void a3xx_dump(struct msm_gpu *gpu);
gpu/drm/msm/adreno/a3xx_gpu.c:static bool a3xx_idle(struct msm_gpu *gpu);
gpu/drm/msm/adreno/a3xx_gpu.c:static bool a3xx_me_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a3xx_gpu.c:	struct msm_ringbuffer *ring = gpu->rb[0];
gpu/drm/msm/adreno/a3xx_gpu.c:static int a3xx_hw_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a3xx_gpu.c:		const struct msm_gpu_perfcntr *perfcntr = &gpu->perfcntrs[i];
gpu/drm/msm/adreno/a3xx_gpu.c:static void a3xx_recover(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a3xx_gpu.c:static void a3xx_destroy(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a3xx_gpu.c:static bool a3xx_idle(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a3xx_gpu.c:static irqreturn_t a3xx_irq(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a3xx_gpu.c:	msm_gpu_retire(gpu);
gpu/drm/msm/adreno/a3xx_gpu.c:static void a3xx_dump(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a3xx_gpu.c:static struct msm_gpu_state *a3xx_gpu_state_get(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a3xx_gpu.c:	struct msm_gpu_state *state = kzalloc(sizeof(*state), GFP_KERNEL);
gpu/drm/msm/adreno/a3xx_gpu.c:		.pm_suspend = msm_gpu_pm_suspend,
gpu/drm/msm/adreno/a3xx_gpu.c:		.pm_resume = msm_gpu_pm_resume,
gpu/drm/msm/adreno/a3xx_gpu.c:static const struct msm_gpu_perfcntr perfcntrs[] = {
gpu/drm/msm/adreno/a3xx_gpu.c:struct msm_gpu *a3xx_gpu_init(struct drm_device *dev)
gpu/drm/msm/adreno/a3xx_gpu.c:	struct msm_gpu *gpu;
gpu/drm/msm/adreno/a3xx_gpu.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/adreno/a4xx_gpu.c:static void a4xx_dump(struct msm_gpu *gpu);
gpu/drm/msm/adreno/a4xx_gpu.c:static bool a4xx_idle(struct msm_gpu *gpu);
gpu/drm/msm/adreno/a4xx_gpu.c:static void a4xx_enable_hwcg(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a4xx_gpu.c:static bool a4xx_me_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a4xx_gpu.c:	struct msm_ringbuffer *ring = gpu->rb[0];
gpu/drm/msm/adreno/a4xx_gpu.c:static int a4xx_hw_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a4xx_gpu.c:static void a4xx_recover(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a4xx_gpu.c:static void a4xx_destroy(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a4xx_gpu.c:static bool a4xx_idle(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a4xx_gpu.c:static irqreturn_t a4xx_irq(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a4xx_gpu.c:	msm_gpu_retire(gpu);
gpu/drm/msm/adreno/a4xx_gpu.c:static struct msm_gpu_state *a4xx_gpu_state_get(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a4xx_gpu.c:	struct msm_gpu_state *state = kzalloc(sizeof(*state), GFP_KERNEL);
gpu/drm/msm/adreno/a4xx_gpu.c:static void a4xx_dump(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a4xx_gpu.c:static int a4xx_pm_resume(struct msm_gpu *gpu) {
gpu/drm/msm/adreno/a4xx_gpu.c:	ret = msm_gpu_pm_resume(gpu);
gpu/drm/msm/adreno/a4xx_gpu.c:static int a4xx_pm_suspend(struct msm_gpu *gpu) {
gpu/drm/msm/adreno/a4xx_gpu.c:	ret = msm_gpu_pm_suspend(gpu);
gpu/drm/msm/adreno/a4xx_gpu.c:static int a4xx_get_timestamp(struct msm_gpu *gpu, uint64_t *value)
gpu/drm/msm/adreno/a4xx_gpu.c:struct msm_gpu *a4xx_gpu_init(struct drm_device *dev)
gpu/drm/msm/adreno/a4xx_gpu.c:	struct msm_gpu *gpu;
gpu/drm/msm/adreno/a4xx_gpu.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/adreno/a5xx_debugfs.c:static int pfp_print(struct msm_gpu *gpu, struct drm_printer *p)
gpu/drm/msm/adreno/a5xx_debugfs.c:static int me_print(struct msm_gpu *gpu, struct drm_printer *p)
gpu/drm/msm/adreno/a5xx_debugfs.c:static int meq_print(struct msm_gpu *gpu, struct drm_printer *p)
gpu/drm/msm/adreno/a5xx_debugfs.c:static int roq_print(struct msm_gpu *gpu, struct drm_printer *p)
gpu/drm/msm/adreno/a5xx_debugfs.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/adreno/a5xx_debugfs.c:	int (*show)(struct msm_gpu *gpu, struct drm_printer *p) =
gpu/drm/msm/adreno/a5xx_debugfs.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/adreno/a5xx_debugfs.c:	struct msm_gpu *gpu = priv->gpu;
gpu/drm/msm/adreno/a5xx_debugfs.c:			msm_gem_put_iova(a5xx_gpu->pm4_bo, gpu->aspace);
gpu/drm/msm/adreno/a5xx_debugfs.c:			msm_gem_put_iova(a5xx_gpu->pfp_bo, gpu->aspace);
gpu/drm/msm/adreno/a5xx_debugfs.c:int a5xx_debugfs_init(struct msm_gpu *gpu, struct drm_minor *minor)
gpu/drm/msm/adreno/a5xx_gpu.c:#include "msm_gem.h"
gpu/drm/msm/adreno/a5xx_gpu.c:#include "msm_mmu.h"
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_dump(struct msm_gpu *gpu);
gpu/drm/msm/adreno/a5xx_gpu.c:static int zap_shader_load_mdt(struct msm_gpu *gpu, const char *fwname)
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_flush(struct msm_gpu *gpu, struct msm_ringbuffer *ring)
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_submit_in_rb(struct msm_gpu *gpu, struct msm_gem_submit *submit,
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_file_private *ctx)
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_drm_private *priv = gpu->dev->dev_private;
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_ringbuffer *ring = submit->ring;
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_gem_object *obj;
gpu/drm/msm/adreno/a5xx_gpu.c:			ptr = msm_gem_get_vaddr(&obj->base);
gpu/drm/msm/adreno/a5xx_gpu.c:			msm_gem_put_vaddr(&obj->base);
gpu/drm/msm/adreno/a5xx_gpu.c:	msm_gpu_retire(gpu);
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit,
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_file_private *ctx)
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_drm_private *priv = gpu->dev->dev_private;
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_ringbuffer *ring = submit->ring;
gpu/drm/msm/adreno/a5xx_gpu.c:void a5xx_set_hwcg(struct msm_gpu *gpu, bool state)
gpu/drm/msm/adreno/a5xx_gpu.c:static int a5xx_me_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_ringbuffer *ring = gpu->rb[0];
gpu/drm/msm/adreno/a5xx_gpu.c:static int a5xx_preempt_start(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_ringbuffer *ring = gpu->rb[0];
gpu/drm/msm/adreno/a5xx_gpu.c:static int a5xx_ucode_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:static int a5xx_zap_shader_resume(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:static int a5xx_zap_shader_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:static int a5xx_hw_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_recover(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_destroy(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:			msm_gem_put_iova(a5xx_gpu->pm4_bo, gpu->aspace);
gpu/drm/msm/adreno/a5xx_gpu.c:			msm_gem_put_iova(a5xx_gpu->pfp_bo, gpu->aspace);
gpu/drm/msm/adreno/a5xx_gpu.c:			msm_gem_put_iova(a5xx_gpu->gpmu_bo, gpu->aspace);
gpu/drm/msm/adreno/a5xx_gpu.c:static inline bool _a5xx_check_idle(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:bool a5xx_idle(struct msm_gpu *gpu, struct msm_ringbuffer *ring)
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_gpu *gpu = arg;
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_cp_err_irq(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_rbbm_err_irq(struct msm_gpu *gpu, u32 status)
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_uche_err_irq(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_gpmu_err_irq(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_fault_detect_irq(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_ringbuffer *ring = gpu->funcs->active_ring(gpu);
gpu/drm/msm/adreno/a5xx_gpu.c:static irqreturn_t a5xx_irq(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:		msm_gpu_retire(gpu);
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_dump(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:static int a5xx_pm_resume(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:	ret = msm_gpu_pm_resume(gpu);
gpu/drm/msm/adreno/a5xx_gpu.c:static int a5xx_pm_suspend(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:	return msm_gpu_pm_suspend(gpu);
gpu/drm/msm/adreno/a5xx_gpu.c:static int a5xx_get_timestamp(struct msm_gpu *gpu, uint64_t *value)
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_gpu_state base;
gpu/drm/msm/adreno/a5xx_gpu.c:static int a5xx_crashdumper_init(struct msm_gpu *gpu,
gpu/drm/msm/adreno/a5xx_gpu.c:	dumper->ptr = msm_gem_kernel_new_locked(gpu->dev,
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_crashdumper_free(struct msm_gpu *gpu,
gpu/drm/msm/adreno/a5xx_gpu.c:	msm_gem_put_iova(dumper->bo, gpu->aspace);
gpu/drm/msm/adreno/a5xx_gpu.c:	msm_gem_put_vaddr(dumper->bo);
gpu/drm/msm/adreno/a5xx_gpu.c:static int a5xx_crashdumper_run(struct msm_gpu *gpu,
gpu/drm/msm/adreno/a5xx_gpu.c:static void a5xx_gpu_state_get_hlsq_regs(struct msm_gpu *gpu,
gpu/drm/msm/adreno/a5xx_gpu.c:static struct msm_gpu_state *a5xx_gpu_state_get(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_gpu_state *state = container_of(kref,
gpu/drm/msm/adreno/a5xx_gpu.c:		struct msm_gpu_state, ref);
gpu/drm/msm/adreno/a5xx_gpu.c:int a5xx_gpu_state_put(struct msm_gpu_state *state)
gpu/drm/msm/adreno/a5xx_gpu.c:void a5xx_show(struct msm_gpu *gpu, struct msm_gpu_state *state,
gpu/drm/msm/adreno/a5xx_gpu.c:static struct msm_ringbuffer *a5xx_active_ring(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_gpu.c:static int a5xx_gpu_busy(struct msm_gpu *gpu, uint64_t *value)
gpu/drm/msm/adreno/a5xx_gpu.c:struct msm_gpu *a5xx_gpu_init(struct drm_device *dev)
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/adreno/a5xx_gpu.c:	struct msm_gpu *gpu;
gpu/drm/msm/adreno/a5xx_gpu.c:		msm_mmu_set_fault_handler(gpu->aspace->mmu, gpu, a5xx_fault_handler);
gpu/drm/msm/adreno/a5xx_gpu.h:	struct msm_ringbuffer *cur_ring;
gpu/drm/msm/adreno/a5xx_gpu.h:	struct msm_ringbuffer *next_ring;
gpu/drm/msm/adreno/a5xx_gpu.h:int a5xx_debugfs_init(struct msm_gpu *gpu, struct drm_minor *minor);
gpu/drm/msm/adreno/a5xx_gpu.h:int a5xx_power_init(struct msm_gpu *gpu);
gpu/drm/msm/adreno/a5xx_gpu.h:void a5xx_gpmu_ucode_init(struct msm_gpu *gpu);
gpu/drm/msm/adreno/a5xx_gpu.h:static inline int spin_usecs(struct msm_gpu *gpu, uint32_t usecs,
gpu/drm/msm/adreno/a5xx_gpu.h:bool a5xx_idle(struct msm_gpu *gpu, struct msm_ringbuffer *ring);
gpu/drm/msm/adreno/a5xx_gpu.h:void a5xx_set_hwcg(struct msm_gpu *gpu, bool state);
gpu/drm/msm/adreno/a5xx_gpu.h:void a5xx_preempt_init(struct msm_gpu *gpu);
gpu/drm/msm/adreno/a5xx_gpu.h:void a5xx_preempt_hw_init(struct msm_gpu *gpu);
gpu/drm/msm/adreno/a5xx_gpu.h:void a5xx_preempt_trigger(struct msm_gpu *gpu);
gpu/drm/msm/adreno/a5xx_gpu.h:void a5xx_preempt_irq(struct msm_gpu *gpu);
gpu/drm/msm/adreno/a5xx_gpu.h:void a5xx_preempt_fini(struct msm_gpu *gpu);
gpu/drm/msm/adreno/a5xx_power.c:static inline uint32_t _get_mvolts(struct msm_gpu *gpu, uint32_t freq)
gpu/drm/msm/adreno/a5xx_power.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/adreno/a5xx_power.c:static void a5xx_lm_setup(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_power.c:static void a5xx_pc_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_power.c:static int a5xx_gpmu_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_power.c:	struct msm_ringbuffer *ring = gpu->rb[0];
gpu/drm/msm/adreno/a5xx_power.c:static void a5xx_lm_enable(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_power.c:int a5xx_power_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_power.c:void a5xx_gpmu_ucode_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_power.c:	ptr = msm_gem_kernel_new_locked(drm, bosize,
gpu/drm/msm/adreno/a5xx_power.c:	msm_gem_put_vaddr(a5xx_gpu->gpmu_bo);
gpu/drm/msm/adreno/a5xx_power.c:		msm_gem_put_iova(a5xx_gpu->gpmu_bo, gpu->aspace);
gpu/drm/msm/adreno/a5xx_preempt.c:#include "msm_gem.h"
gpu/drm/msm/adreno/a5xx_preempt.c:static inline void update_wptr(struct msm_gpu *gpu, struct msm_ringbuffer *ring)
gpu/drm/msm/adreno/a5xx_preempt.c:static struct msm_ringbuffer *get_next_ring(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_preempt.c:		struct msm_ringbuffer *ring = gpu->rb[i];
gpu/drm/msm/adreno/a5xx_preempt.c:	struct msm_gpu *gpu = &a5xx_gpu->base.base;
gpu/drm/msm/adreno/a5xx_preempt.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/adreno/a5xx_preempt.c:void a5xx_preempt_trigger(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_preempt.c:	struct msm_ringbuffer *ring;
gpu/drm/msm/adreno/a5xx_preempt.c:void a5xx_preempt_irq(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_preempt.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/adreno/a5xx_preempt.c:void a5xx_preempt_hw_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_preempt.c:		struct msm_ringbuffer *ring)
gpu/drm/msm/adreno/a5xx_preempt.c:	struct msm_gpu *gpu = &adreno_gpu->base;
gpu/drm/msm/adreno/a5xx_preempt.c:	ptr = msm_gem_kernel_new(gpu->dev,
gpu/drm/msm/adreno/a5xx_preempt.c:void a5xx_preempt_fini(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a5xx_preempt.c:		msm_gem_put_vaddr(a5xx_gpu->preempt_bo[i]);
gpu/drm/msm/adreno/a5xx_preempt.c:			msm_gem_put_iova(a5xx_gpu->preempt_bo[i], gpu->aspace);
gpu/drm/msm/adreno/a5xx_preempt.c:void a5xx_preempt_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gmu.c:	struct msm_gpu *gpu = &adreno_gpu->base;
gpu/drm/msm/adreno/a6xx_gmu.c:	struct msm_gpu *gpu = &adreno_gpu->base;
gpu/drm/msm/adreno/a6xx_gmu.c:	int ret = msm_clk_bulk_get(gmu->dev, &gmu->clocks);
gpu/drm/msm/adreno/a6xx_gmu.c:	gmu->core_clk = msm_clk_bulk_get_clock(gmu->clocks,
gpu/drm/msm/adreno/a6xx_gmu.h:#include "msm_drv.h"
gpu/drm/msm/adreno/a6xx_gmu.h:	return msm_readl(gmu->mmio + (offset << 2));
gpu/drm/msm/adreno/a6xx_gmu.h:	return msm_writel(value, gmu->mmio + (offset << 2));
gpu/drm/msm/adreno/a6xx_gmu.h:	return msm_writel(value, gmu->pdc_mmio + (offset << 2));
gpu/drm/msm/adreno/a6xx_gpu.c:#include "msm_gem.h"
gpu/drm/msm/adreno/a6xx_gpu.c:#include "msm_mmu.h"
gpu/drm/msm/adreno/a6xx_gpu.c:static inline bool _a6xx_check_idle(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gpu.c:bool a6xx_idle(struct msm_gpu *gpu, struct msm_ringbuffer *ring)
gpu/drm/msm/adreno/a6xx_gpu.c:static void a6xx_flush(struct msm_gpu *gpu, struct msm_ringbuffer *ring)
gpu/drm/msm/adreno/a6xx_gpu.c:static void a6xx_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit,
gpu/drm/msm/adreno/a6xx_gpu.c:	struct msm_file_private *ctx)
gpu/drm/msm/adreno/a6xx_gpu.c:	struct msm_drm_private *priv = gpu->dev->dev_private;
gpu/drm/msm/adreno/a6xx_gpu.c:	struct msm_ringbuffer *ring = submit->ring;
gpu/drm/msm/adreno/a6xx_gpu.c:static void a6xx_set_hwcg(struct msm_gpu *gpu, bool state)
gpu/drm/msm/adreno/a6xx_gpu.c:static int a6xx_cp_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gpu.c:	struct msm_ringbuffer *ring = gpu->rb[0];
gpu/drm/msm/adreno/a6xx_gpu.c:static int a6xx_ucode_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gpu.c:static int a6xx_hw_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gpu.c:static void a6xx_dump(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gpu.c:static void a6xx_recover(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gpu.c:	msm_gpu_hw_init(gpu);
gpu/drm/msm/adreno/a6xx_gpu.c:	struct msm_gpu *gpu = arg;
gpu/drm/msm/adreno/a6xx_gpu.c:static void a6xx_cp_hw_err_irq(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gpu.c:static void a6xx_fault_detect_irq(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gpu.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/adreno/a6xx_gpu.c:	struct msm_ringbuffer *ring = gpu->funcs->active_ring(gpu);
gpu/drm/msm/adreno/a6xx_gpu.c:static irqreturn_t a6xx_irq(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gpu.c:		msm_gpu_retire(gpu);
gpu/drm/msm/adreno/a6xx_gpu.c:static int a6xx_pm_resume(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gpu.c:static int a6xx_pm_suspend(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gpu.c:static int a6xx_get_timestamp(struct msm_gpu *gpu, uint64_t *value)
gpu/drm/msm/adreno/a6xx_gpu.c:static void a6xx_show(struct msm_gpu *gpu, struct msm_gpu_state *state,
gpu/drm/msm/adreno/a6xx_gpu.c:static struct msm_ringbuffer *a6xx_active_ring(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gpu.c:static void a6xx_destroy(struct msm_gpu *gpu)
gpu/drm/msm/adreno/a6xx_gpu.c:			msm_gem_put_iova(a6xx_gpu->sqe_bo, gpu->aspace);
gpu/drm/msm/adreno/a6xx_gpu.c:struct msm_gpu *a6xx_gpu_init(struct drm_device *dev)
gpu/drm/msm/adreno/a6xx_gpu.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/adreno/a6xx_gpu.c:	struct msm_gpu *gpu;
gpu/drm/msm/adreno/a6xx_gpu.c:		msm_mmu_set_fault_handler(gpu->aspace->mmu, gpu,
gpu/drm/msm/adreno/a6xx_gpu.h:	struct msm_ringbuffer *cur_ring;
gpu/drm/msm/adreno/adreno_device.c:struct msm_gpu *adreno_load_gpu(struct drm_device *dev)
gpu/drm/msm/adreno/adreno_device.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/adreno/adreno_device.c:	struct msm_gpu *gpu = NULL;
gpu/drm/msm/adreno/adreno_device.c:	ret = msm_gpu_hw_init(gpu);
gpu/drm/msm/adreno/adreno_device.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/adreno/adreno_device.c:	struct msm_gpu *gpu;
gpu/drm/msm/adreno/adreno_device.c:	struct msm_gpu *gpu = dev_get_drvdata(dev);
gpu/drm/msm/adreno/adreno_device.c:	struct msm_gpu *gpu = platform_get_drvdata(pdev);
gpu/drm/msm/adreno/adreno_device.c:	struct msm_gpu *gpu = platform_get_drvdata(pdev);
gpu/drm/msm/adreno/adreno_gpu.c:#include "msm_gem.h"
gpu/drm/msm/adreno/adreno_gpu.c:#include "msm_mmu.h"
gpu/drm/msm/adreno/adreno_gpu.c:int adreno_get_param(struct msm_gpu *gpu, uint32_t param, uint64_t *value)
gpu/drm/msm/adreno/adreno_gpu.c:struct drm_gem_object *adreno_fw_create_bo(struct msm_gpu *gpu,
gpu/drm/msm/adreno/adreno_gpu.c:	ptr = msm_gem_kernel_new_locked(gpu->dev, fw->size - 4,
gpu/drm/msm/adreno/adreno_gpu.c:	msm_gem_put_vaddr(bo);
gpu/drm/msm/adreno/adreno_gpu.c:int adreno_hw_init(struct msm_gpu *gpu)
gpu/drm/msm/adreno/adreno_gpu.c:		struct msm_ringbuffer *ring = gpu->rb[i];
gpu/drm/msm/adreno/adreno_gpu.c:		ret = msm_gem_get_iova(ring->bo, gpu->aspace, &ring->iova);
gpu/drm/msm/adreno/adreno_gpu.c:	 * for the ringbuffer size and block size is moved to msm_gpu.h for the
gpu/drm/msm/adreno/adreno_gpu.c:		struct msm_ringbuffer *ring)
gpu/drm/msm/adreno/adreno_gpu.c:struct msm_ringbuffer *adreno_active_ring(struct msm_gpu *gpu)
gpu/drm/msm/adreno/adreno_gpu.c:void adreno_recover(struct msm_gpu *gpu)
gpu/drm/msm/adreno/adreno_gpu.c:	ret = msm_gpu_hw_init(gpu);
gpu/drm/msm/adreno/adreno_gpu.c:void adreno_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit,
gpu/drm/msm/adreno/adreno_gpu.c:		struct msm_file_private *ctx)
gpu/drm/msm/adreno/adreno_gpu.c:	struct msm_drm_private *priv = gpu->dev->dev_private;
gpu/drm/msm/adreno/adreno_gpu.c:	struct msm_ringbuffer *ring = submit->ring;
gpu/drm/msm/adreno/adreno_gpu.c:void adreno_flush(struct msm_gpu *gpu, struct msm_ringbuffer *ring)
gpu/drm/msm/adreno/adreno_gpu.c:bool adreno_idle(struct msm_gpu *gpu, struct msm_ringbuffer *ring)
gpu/drm/msm/adreno/adreno_gpu.c:int adreno_gpu_state_get(struct msm_gpu *gpu, struct msm_gpu_state *state)
gpu/drm/msm/adreno/adreno_gpu.c:void adreno_gpu_state_destroy(struct msm_gpu_state *state)
gpu/drm/msm/adreno/adreno_gpu.c:	struct msm_gpu_state *state = container_of(kref,
gpu/drm/msm/adreno/adreno_gpu.c:		struct msm_gpu_state, ref);
gpu/drm/msm/adreno/adreno_gpu.c:int adreno_gpu_state_put(struct msm_gpu_state *state)
gpu/drm/msm/adreno/adreno_gpu.c:void adreno_show(struct msm_gpu *gpu, struct msm_gpu_state *state,
gpu/drm/msm/adreno/adreno_gpu.c:void adreno_dump_info(struct msm_gpu *gpu)
gpu/drm/msm/adreno/adreno_gpu.c:		struct msm_ringbuffer *ring = gpu->rb[i];
gpu/drm/msm/adreno/adreno_gpu.c:void adreno_dump(struct msm_gpu *gpu)
gpu/drm/msm/adreno/adreno_gpu.c:	/* dump these out in a form that can be parsed by demsm: */
gpu/drm/msm/adreno/adreno_gpu.c:static uint32_t ring_freewords(struct msm_ringbuffer *ring)
gpu/drm/msm/adreno/adreno_gpu.c:void adreno_wait_ring(struct msm_ringbuffer *ring, uint32_t ndwords)
gpu/drm/msm/adreno/adreno_gpu.c:		struct msm_gpu *gpu)
gpu/drm/msm/adreno/adreno_gpu.c:	struct msm_gpu_config adreno_gpu_config  = { 0 };
gpu/drm/msm/adreno/adreno_gpu.c:	struct msm_gpu *gpu = &adreno_gpu->base;
gpu/drm/msm/adreno/adreno_gpu.c:	return msm_gpu_init(drm, pdev, &adreno_gpu->base, &funcs->base,
gpu/drm/msm/adreno/adreno_gpu.c:	msm_gpu_cleanup(&adreno_gpu->base);
gpu/drm/msm/adreno/adreno_gpu.h:#include "msm_gpu.h"
gpu/drm/msm/adreno/adreno_gpu.h:	struct msm_gpu_funcs base;
gpu/drm/msm/adreno/adreno_gpu.h:	int (*get_timestamp)(struct msm_gpu *gpu, uint64_t *value);
gpu/drm/msm/adreno/adreno_gpu.h:	struct msm_gpu *(*init)(struct drm_device *dev);
gpu/drm/msm/adreno/adreno_gpu.h:	struct msm_gpu base;
gpu/drm/msm/adreno/adreno_gpu.h:int adreno_get_param(struct msm_gpu *gpu, uint32_t param, uint64_t *value);
gpu/drm/msm/adreno/adreno_gpu.h:struct drm_gem_object *adreno_fw_create_bo(struct msm_gpu *gpu,
gpu/drm/msm/adreno/adreno_gpu.h:int adreno_hw_init(struct msm_gpu *gpu);
gpu/drm/msm/adreno/adreno_gpu.h:void adreno_recover(struct msm_gpu *gpu);
gpu/drm/msm/adreno/adreno_gpu.h:void adreno_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit,
gpu/drm/msm/adreno/adreno_gpu.h:		struct msm_file_private *ctx);
gpu/drm/msm/adreno/adreno_gpu.h:void adreno_flush(struct msm_gpu *gpu, struct msm_ringbuffer *ring);
gpu/drm/msm/adreno/adreno_gpu.h:bool adreno_idle(struct msm_gpu *gpu, struct msm_ringbuffer *ring);
gpu/drm/msm/adreno/adreno_gpu.h:void adreno_show(struct msm_gpu *gpu, struct msm_gpu_state *state,
gpu/drm/msm/adreno/adreno_gpu.h:void adreno_dump_info(struct msm_gpu *gpu);
gpu/drm/msm/adreno/adreno_gpu.h:void adreno_dump(struct msm_gpu *gpu);
gpu/drm/msm/adreno/adreno_gpu.h:void adreno_wait_ring(struct msm_ringbuffer *ring, uint32_t ndwords);
gpu/drm/msm/adreno/adreno_gpu.h:struct msm_ringbuffer *adreno_active_ring(struct msm_gpu *gpu);
gpu/drm/msm/adreno/adreno_gpu.h:void adreno_gpu_state_destroy(struct msm_gpu_state *state);
gpu/drm/msm/adreno/adreno_gpu.h:int adreno_gpu_state_get(struct msm_gpu *gpu, struct msm_gpu_state *state);
gpu/drm/msm/adreno/adreno_gpu.h:int adreno_gpu_state_put(struct msm_gpu_state *state);
gpu/drm/msm/adreno/adreno_gpu.h:OUT_PKT0(struct msm_ringbuffer *ring, uint16_t regindx, uint16_t cnt)
gpu/drm/msm/adreno/adreno_gpu.h:OUT_PKT2(struct msm_ringbuffer *ring)
gpu/drm/msm/adreno/adreno_gpu.h:OUT_PKT3(struct msm_ringbuffer *ring, uint8_t opcode, uint16_t cnt)
gpu/drm/msm/adreno/adreno_gpu.h:OUT_PKT4(struct msm_ringbuffer *ring, uint16_t regindx, uint16_t cnt)
gpu/drm/msm/adreno/adreno_gpu.h:OUT_PKT7(struct msm_ringbuffer *ring, uint8_t opcode, uint16_t cnt)
gpu/drm/msm/adreno/adreno_gpu.h:struct msm_gpu *a3xx_gpu_init(struct drm_device *dev);
gpu/drm/msm/adreno/adreno_gpu.h:struct msm_gpu *a4xx_gpu_init(struct drm_device *dev);
gpu/drm/msm/adreno/adreno_gpu.h:struct msm_gpu *a5xx_gpu_init(struct drm_device *dev);
gpu/drm/msm/adreno/adreno_gpu.h:struct msm_gpu *a6xx_gpu_init(struct drm_device *dev);
gpu/drm/msm/adreno/adreno_gpu.h:static inline uint32_t get_wptr(struct msm_ringbuffer *ring)
gpu/drm/msm/disp/dpu1/dpu_core_irq.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_core_irq.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_core_perf.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_core_perf.c:	return msm_dss_clk_set_rate(core_clk, 1);
gpu/drm/msm/disp/dpu1/dpu_core_perf.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_core_perf.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_crtc.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_crtc.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_crtc.c:		format = to_dpu_format(msm_framebuffer_format(pstate->base.fb));
gpu/drm/msm/disp/dpu1/dpu_crtc.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_crtc.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_crtc.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_crtc.c:	struct msm_drm_thread *event_thread;
gpu/drm/msm/disp/dpu1/dpu_crtc.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_crtc.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_crtc.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_crtc.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_crtc.c:	struct msm_drm_private *priv = NULL;
gpu/drm/msm/disp/dpu1/dpu_crtc.h: * @property_state: Local storage for msm_prop properties
gpu/drm/msm/disp/dpu1/dpu_dbg.c:static struct vbif_debug_bus_entry vbif_dbg_bus_msm8998[] = {
gpu/drm/msm/disp/dpu1/dpu_dbg.c:		dbg->dbgbus_vbif_rt.entries = vbif_dbg_bus_msm8998;
gpu/drm/msm/disp/dpu1/dpu_dbg.c:				ARRAY_SIZE(vbif_dbg_bus_msm8998);
gpu/drm/msm/disp/dpu1/dpu_dbg.c:		dbg->dbgbus_vbif_rt.entries = vbif_dbg_bus_msm8998;
gpu/drm/msm/disp/dpu1/dpu_dbg.c:				ARRAY_SIZE(vbif_dbg_bus_msm8998);
gpu/drm/msm/disp/dpu1/dpu_encoder.c:#include "msm_drv.h"
gpu/drm/msm/disp/dpu1/dpu_encoder.c: * @disp_info:			local copy of msm_display_info struct
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_display_info disp_info;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_display_topology topology;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_display_info *disp_info;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:static struct msm_display_topology dpu_encoder_get_topology(
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_display_topology topology;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_display_topology topology;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:			struct msm_display_info *disp_info)
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_thread *disp_thread;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_display_topology topology;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_display_info *disp_info;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_thread *event_thread;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:				 struct msm_display_info *disp_info,
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:		struct msm_display_info *disp_info)
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/dpu1/dpu_encoder.c:	enum msm_event_wait event)
gpu/drm/msm/disp/dpu1/dpu_encoder.h:						enum msm_event_wait event);
gpu/drm/msm/disp/dpu1/dpu_encoder.h:		struct msm_display_info *disp_info);
gpu/drm/msm/disp/dpu1/dpu_encoder_phys_cmd.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_encoder_phys_vid.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_encoder_phys_vid.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_formats.c:#include "msm_media_info.h"
gpu/drm/msm/disp/dpu1/dpu_formats.c:		struct msm_gem_address_space *aspace,
gpu/drm/msm/disp/dpu1/dpu_formats.c:		base_addr = msm_framebuffer_iova(fb, aspace, 0);
gpu/drm/msm/disp/dpu1/dpu_formats.c:		struct msm_gem_address_space *aspace,
gpu/drm/msm/disp/dpu1/dpu_formats.c:				msm_framebuffer_iova(fb, aspace, i);
gpu/drm/msm/disp/dpu1/dpu_formats.c:		struct msm_gem_address_space *aspace,
gpu/drm/msm/disp/dpu1/dpu_formats.c:	layout->format = to_dpu_format(msm_framebuffer_format(fb));
gpu/drm/msm/disp/dpu1/dpu_formats.c:		const struct msm_kms *kms,
gpu/drm/msm/disp/dpu1/dpu_formats.c:		const struct msm_format *msm_fmt,
gpu/drm/msm/disp/dpu1/dpu_formats.c:	if (!msm_fmt || !cmd || !bos) {
gpu/drm/msm/disp/dpu1/dpu_formats.c:	fmt = to_dpu_format(msm_fmt);
gpu/drm/msm/disp/dpu1/dpu_formats.c:const struct msm_format *dpu_get_msm_format(
gpu/drm/msm/disp/dpu1/dpu_formats.c:		struct msm_kms *kms,
gpu/drm/msm/disp/dpu1/dpu_formats.h:#include "msm_gem.h"
gpu/drm/msm/disp/dpu1/dpu_formats.h: * dpu_get_msm_format - get an dpu_format by its msm_format base
gpu/drm/msm/disp/dpu1/dpu_formats.h: *                     callback function registers with the msm_kms layer
gpu/drm/msm/disp/dpu1/dpu_formats.h:const struct msm_format *dpu_get_msm_format(
gpu/drm/msm/disp/dpu1/dpu_formats.h:		struct msm_kms *kms,
gpu/drm/msm/disp/dpu1/dpu_formats.h: * @msm_fmt:         pointer to the msm_fmt base pointer of an dpu_format
gpu/drm/msm/disp/dpu1/dpu_formats.h:		const struct msm_kms *kms,
gpu/drm/msm/disp/dpu1/dpu_formats.h:		const struct msm_format *msm_fmt,
gpu/drm/msm/disp/dpu1/dpu_formats.h:		struct msm_gem_address_space *aspace,
gpu/drm/msm/disp/dpu1/dpu_hw_mdss.h:#include "msm_drv.h"
gpu/drm/msm/disp/dpu1/dpu_hw_mdss.h: * @base: base msm_format struture containing fourcc code
gpu/drm/msm/disp/dpu1/dpu_hw_mdss.h:	struct msm_format base;
gpu/drm/msm/disp/dpu1/dpu_hw_util.c:#include "msm_drv.h"
gpu/drm/msm/disp/dpu1/dpu_io_util.c:void msm_dss_put_clk(struct dss_clk *clk_arry, int num_clk)
gpu/drm/msm/disp/dpu1/dpu_io_util.c:int msm_dss_get_clk(struct device *dev, struct dss_clk *clk_arry, int num_clk)
gpu/drm/msm/disp/dpu1/dpu_io_util.c:int msm_dss_clk_set_rate(struct dss_clk *clk_arry, int num_clk)
gpu/drm/msm/disp/dpu1/dpu_io_util.c:int msm_dss_enable_clk(struct dss_clk *clk_arry, int num_clk, int enable)
gpu/drm/msm/disp/dpu1/dpu_io_util.c:				msm_dss_enable_clk(&clk_arry[i],
gpu/drm/msm/disp/dpu1/dpu_io_util.c:int msm_dss_parse_clock(struct platform_device *pdev,
gpu/drm/msm/disp/dpu1/dpu_io_util.c:	rc = msm_dss_get_clk(&pdev->dev, mp->clk_config, num_clk);
gpu/drm/msm/disp/dpu1/dpu_io_util.c:	msm_dss_put_clk(mp->clk_config, num_clk);
gpu/drm/msm/disp/dpu1/dpu_io_util.h:int msm_dss_get_clk(struct device *dev, struct dss_clk *clk_arry, int num_clk);
gpu/drm/msm/disp/dpu1/dpu_io_util.h:void msm_dss_put_clk(struct dss_clk *clk_arry, int num_clk);
gpu/drm/msm/disp/dpu1/dpu_io_util.h:int msm_dss_clk_set_rate(struct dss_clk *clk_arry, int num_clk);
gpu/drm/msm/disp/dpu1/dpu_io_util.h:int msm_dss_enable_clk(struct dss_clk *clk_arry, int num_clk, int enable);
gpu/drm/msm/disp/dpu1/dpu_io_util.h:int msm_dss_parse_clock(struct platform_device *pdev,
gpu/drm/msm/disp/dpu1/dpu_irq.c:irqreturn_t dpu_irq(struct msm_kms *kms)
gpu/drm/msm/disp/dpu1/dpu_irq.c:void dpu_irq_preinstall(struct msm_kms *kms)
gpu/drm/msm/disp/dpu1/dpu_irq.c:int dpu_irq_postinstall(struct msm_kms *kms)
gpu/drm/msm/disp/dpu1/dpu_irq.c:void dpu_irq_uninstall(struct msm_kms *kms)
gpu/drm/msm/disp/dpu1/dpu_irq.h:#include "msm_kms.h"
gpu/drm/msm/disp/dpu1/dpu_irq.h:void dpu_irq_preinstall(struct msm_kms *kms);
gpu/drm/msm/disp/dpu1/dpu_irq.h:int dpu_irq_postinstall(struct msm_kms *kms);
gpu/drm/msm/disp/dpu1/dpu_irq.h:void dpu_irq_uninstall(struct msm_kms *kms);
gpu/drm/msm/disp/dpu1/dpu_irq.h:irqreturn_t dpu_irq(struct msm_kms *kms);
gpu/drm/msm/disp/dpu1/dpu_kms.c:#include "msm_drv.h"
gpu/drm/msm/disp/dpu1/dpu_kms.c:#include "msm_mmu.h"
gpu/drm/msm/disp/dpu1/dpu_kms.c:#include "msm_gem.h"
gpu/drm/msm/disp/dpu1/dpu_kms.c:#define DPU_DEBUGFS_DIR "msm_dpu"
gpu/drm/msm/disp/dpu1/dpu_kms.c:static int dpu_kms_hw_init(struct msm_kms *kms);
gpu/drm/msm/disp/dpu1/dpu_kms.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_kms.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_kms.c:static int dpu_kms_enable_vblank(struct msm_kms *kms, struct drm_crtc *crtc)
gpu/drm/msm/disp/dpu1/dpu_kms.c:static void dpu_kms_disable_vblank(struct msm_kms *kms, struct drm_crtc *crtc)
gpu/drm/msm/disp/dpu1/dpu_kms.c:static void dpu_kms_prepare_commit(struct msm_kms *kms,
gpu/drm/msm/disp/dpu1/dpu_kms.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_kms.c:static void dpu_kms_commit(struct msm_kms *kms, struct drm_atomic_state *state)
gpu/drm/msm/disp/dpu1/dpu_kms.c:static void dpu_kms_complete_commit(struct msm_kms *kms,
gpu/drm/msm/disp/dpu1/dpu_kms.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_kms.c:static void dpu_kms_wait_for_commit_done(struct msm_kms *kms,
gpu/drm/msm/disp/dpu1/dpu_kms.c:				    struct msm_drm_private *priv,
gpu/drm/msm/disp/dpu1/dpu_kms.c:		rc = msm_dsi_modeset_init(priv->dsi[i], dev, encoder);
gpu/drm/msm/disp/dpu1/dpu_kms.c:				    struct msm_drm_private *priv,
gpu/drm/msm/disp/dpu1/dpu_kms.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_kms.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_kms.c:static int dpu_kms_debugfs_init(struct msm_kms *kms, struct drm_minor *minor)
gpu/drm/msm/disp/dpu1/dpu_kms.c:static long dpu_kms_round_pixclk(struct msm_kms *kms, unsigned long rate,
gpu/drm/msm/disp/dpu1/dpu_kms.c:static void dpu_kms_destroy(struct msm_kms *kms)
gpu/drm/msm/disp/dpu1/dpu_kms.c:	if (!ddev || !ddev_to_msm_kms(ddev))
gpu/drm/msm/disp/dpu1/dpu_kms.c:	dpu_kms = to_dpu_kms(ddev_to_msm_kms(ddev));
gpu/drm/msm/disp/dpu1/dpu_kms.c:	if (!ddev || !ddev_to_msm_kms(ddev))
gpu/drm/msm/disp/dpu1/dpu_kms.c:	dpu_kms = to_dpu_kms(ddev_to_msm_kms(ddev));
gpu/drm/msm/disp/dpu1/dpu_kms.c:static void _dpu_kms_set_encoder_mode(struct msm_kms *kms,
gpu/drm/msm/disp/dpu1/dpu_kms.c:	struct msm_display_info info;
gpu/drm/msm/disp/dpu1/dpu_kms.c:	struct msm_drm_private *priv = encoder->dev->dev_private;
gpu/drm/msm/disp/dpu1/dpu_kms.c:static const struct msm_kms_funcs kms_funcs = {
gpu/drm/msm/disp/dpu1/dpu_kms.c:	.get_format      = dpu_get_msm_format,
gpu/drm/msm/disp/dpu1/dpu_kms.c:	struct msm_mmu *mmu;
gpu/drm/msm/disp/dpu1/dpu_kms.c:	msm_gem_address_space_put(dpu_kms->base.aspace);
gpu/drm/msm/disp/dpu1/dpu_kms.c:	struct msm_gem_address_space *aspace;
gpu/drm/msm/disp/dpu1/dpu_kms.c:	aspace = msm_gem_address_space_create(dpu_kms->dev->dev,
gpu/drm/msm/disp/dpu1/dpu_kms.c:		msm_gem_address_space_put(aspace);
gpu/drm/msm/disp/dpu1/dpu_kms.c:static int dpu_kms_hw_init(struct msm_kms *kms)
gpu/drm/msm/disp/dpu1/dpu_kms.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_kms.c:	dpu_kms->mmio = msm_ioremap(dpu_kms->pdev, "mdp", "mdp");
gpu/drm/msm/disp/dpu1/dpu_kms.c:	dpu_kms->vbif[VBIF_RT] = msm_ioremap(dpu_kms->pdev, "vbif", "vbif");
gpu/drm/msm/disp/dpu1/dpu_kms.c:	dpu_kms->vbif[VBIF_NRT] = msm_ioremap(dpu_kms->pdev, "vbif_nrt", "vbif_nrt");
gpu/drm/msm/disp/dpu1/dpu_kms.c:	dpu_kms->reg_dma = msm_ioremap(dpu_kms->pdev, "regdma", "regdma");
gpu/drm/msm/disp/dpu1/dpu_kms.c:struct msm_kms *dpu_kms_init(struct drm_device *dev)
gpu/drm/msm/disp/dpu1/dpu_kms.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_kms.c:	struct msm_drm_private *priv = ddev->dev_private;
gpu/drm/msm/disp/dpu1/dpu_kms.c:	ret = msm_dss_parse_clock(pdev, mp);
gpu/drm/msm/disp/dpu1/dpu_kms.c:	msm_kms_init(&dpu_kms->base, &kms_funcs);
gpu/drm/msm/disp/dpu1/dpu_kms.c:	msm_dss_put_clk(mp->clk_config, mp->num_clk);
gpu/drm/msm/disp/dpu1/dpu_kms.c:	rc = msm_dss_enable_clk(mp->clk_config, mp->num_clk, false);
gpu/drm/msm/disp/dpu1/dpu_kms.c:	rc = msm_dss_enable_clk(mp->clk_config, mp->num_clk, true);
gpu/drm/msm/disp/dpu1/dpu_kms.c:		.name = "msm_dpu",
gpu/drm/msm/disp/dpu1/dpu_kms.c:void __init msm_dpu_register(void)
gpu/drm/msm/disp/dpu1/dpu_kms.c:void __exit msm_dpu_unregister(void)
gpu/drm/msm/disp/dpu1/dpu_kms.h:#include "msm_drv.h"
gpu/drm/msm/disp/dpu1/dpu_kms.h:#include "msm_kms.h"
gpu/drm/msm/disp/dpu1/dpu_kms.h:#include "msm_mmu.h"
gpu/drm/msm/disp/dpu1/dpu_kms.h:#include "msm_gem.h"
gpu/drm/msm/disp/dpu1/dpu_kms.h:	struct msm_kms base;
gpu/drm/msm/disp/dpu1/dpu_kms.h:/* get struct msm_kms * from drm_device * */
gpu/drm/msm/disp/dpu1/dpu_kms.h:#define ddev_to_msm_kms(D) ((D) && (D)->dev_private ? \
gpu/drm/msm/disp/dpu1/dpu_kms.h:		((struct msm_drm_private *)((D)->dev_private))->kms : NULL)
gpu/drm/msm/disp/dpu1/dpu_kms.h:	if (!ddev_to_msm_kms(dev))
gpu/drm/msm/disp/dpu1/dpu_kms.h:	return to_dpu_kms(ddev_to_msm_kms(dev))->suspend_state != NULL;
gpu/drm/msm/disp/dpu1/dpu_kms.h:	return to_dpu_kms(ddev_to_msm_kms(dev))->suspend_block;
gpu/drm/msm/disp/dpu1/dpu_kms.h:int dpu_enable_vblank(struct msm_kms *kms, struct drm_crtc *crtc);
gpu/drm/msm/disp/dpu1/dpu_kms.h:void dpu_disable_vblank(struct msm_kms *kms, struct drm_crtc *crtc);
gpu/drm/msm/disp/dpu1/dpu_mdss.c:	struct msm_mdss base;
gpu/drm/msm/disp/dpu1/dpu_mdss.c:static int dpu_mdss_enable(struct msm_mdss *mdss)
gpu/drm/msm/disp/dpu1/dpu_mdss.c:	ret = msm_dss_enable_clk(mp->clk_config, mp->num_clk, true);
gpu/drm/msm/disp/dpu1/dpu_mdss.c:static int dpu_mdss_disable(struct msm_mdss *mdss)
gpu/drm/msm/disp/dpu1/dpu_mdss.c:	ret = msm_dss_enable_clk(mp->clk_config, mp->num_clk, false);
gpu/drm/msm/disp/dpu1/dpu_mdss.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/dpu1/dpu_mdss.c:	msm_dss_put_clk(mp->clk_config, mp->num_clk);
gpu/drm/msm/disp/dpu1/dpu_mdss.c:static const struct msm_mdss_funcs mdss_funcs = {
gpu/drm/msm/disp/dpu1/dpu_mdss.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/dpu1/dpu_mdss.c:	dpu_mdss->mmio = msm_ioremap(pdev, "mdss", "mdss");
gpu/drm/msm/disp/dpu1/dpu_mdss.c:	ret = msm_dss_parse_clock(pdev, mp);
gpu/drm/msm/disp/dpu1/dpu_mdss.c:	msm_dss_put_clk(mp->clk_config, mp->num_clk);
gpu/drm/msm/disp/dpu1/dpu_plane.c:#include "msm_drv.h"
gpu/drm/msm/disp/dpu1/dpu_plane.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_plane.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_plane.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_plane.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_plane.c:		struct msm_gem_address_space **aspace)
gpu/drm/msm/disp/dpu1/dpu_plane.c:	struct msm_gem_address_space *aspace = NULL;
gpu/drm/msm/disp/dpu1/dpu_plane.c:		const struct msm_format *msm_fmt;
gpu/drm/msm/disp/dpu1/dpu_plane.c:		msm_fmt = msm_framebuffer_format(drm_state[i]->fb);
gpu/drm/msm/disp/dpu1/dpu_plane.c:		fmt[i] = to_dpu_format(msm_fmt);
gpu/drm/msm/disp/dpu1/dpu_plane.c:	struct msm_gem_object *msm_obj;
gpu/drm/msm/disp/dpu1/dpu_plane.c:	struct msm_gem_address_space *aspace;
gpu/drm/msm/disp/dpu1/dpu_plane.c:	 * TODO: Need to sort out the msm_framebuffer_prepare() call below so
gpu/drm/msm/disp/dpu1/dpu_plane.c:	 *       we can use msm_atomic_prepare_fb() instead of doing the
gpu/drm/msm/disp/dpu1/dpu_plane.c:	obj = msm_framebuffer_bo(new_state->fb, 0);
gpu/drm/msm/disp/dpu1/dpu_plane.c:	msm_obj = to_msm_bo(obj);
gpu/drm/msm/disp/dpu1/dpu_plane.c:	fence = reservation_object_get_excl_rcu(msm_obj->resv);
gpu/drm/msm/disp/dpu1/dpu_plane.c:		ret = msm_framebuffer_prepare(new_state->fb,
gpu/drm/msm/disp/dpu1/dpu_plane.c:	msm_framebuffer_cleanup(old_state->fb, old_pstate->aspace);
gpu/drm/msm/disp/dpu1/dpu_plane.c:	fmt = to_dpu_format(msm_framebuffer_format(state->fb));
gpu/drm/msm/disp/dpu1/dpu_plane.c:	fmt = to_dpu_format(msm_framebuffer_format(fb));
gpu/drm/msm/disp/dpu1/dpu_plane.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_plane.c:	struct msm_drm_private *priv;
gpu/drm/msm/disp/dpu1/dpu_plane.h: * @property_state: Local storage for msm_prop properties
gpu/drm/msm/disp/dpu1/dpu_plane.h:	struct msm_gem_address_space *aspace;
gpu/drm/msm/disp/dpu1/dpu_rm.c:dpu_rm_get_topology_name(struct msm_display_topology topology)
gpu/drm/msm/disp/dpu1/dpu_rm.c:		struct msm_display_topology req_topology)
gpu/drm/msm/disp/dpu1/dpu_rm.c:		struct msm_display_topology topology,
gpu/drm/msm/disp/dpu1/dpu_rm.h:#include "msm_kms.h"
gpu/drm/msm/disp/dpu1/dpu_rm.h:		struct msm_display_topology topology,
gpu/drm/msm/disp/dpu1/dpu_rm.h:dpu_rm_get_topology_name(struct msm_display_topology topology);
gpu/drm/msm/disp/mdp4/mdp4.xml.h:- /home/robclark/src/envytools/rnndb/msm.xml                 (    676 bytes, from 2018-07-03 19:37:13)
gpu/drm/msm/disp/mdp4/mdp4_crtc.c:	struct msm_drm_private *priv = crtc->dev->dev_private;
gpu/drm/msm/disp/mdp4/mdp4_crtc.c:	struct msm_kms *kms = &mdp4_kms->base.base;
gpu/drm/msm/disp/mdp4/mdp4_crtc.c:	msm_gem_put_iova(val, kms->aspace);
gpu/drm/msm/disp/mdp4/mdp4_crtc.c:					to_mdp_format(msm_framebuffer_format(plane->state->fb));
gpu/drm/msm/disp/mdp4/mdp4_crtc.c:	struct msm_kms *kms = &mdp4_kms->base.base;
gpu/drm/msm/disp/mdp4/mdp4_crtc.c:			msm_gem_get_iova(next_bo, kms->aspace, &iova);
gpu/drm/msm/disp/mdp4/mdp4_crtc.c:	struct msm_kms *kms = &mdp4_kms->base.base;
gpu/drm/msm/disp/mdp4/mdp4_crtc.c:		ret = msm_gem_get_iova(cursor_bo, kms->aspace, &iova);
gpu/drm/msm/disp/mdp4/mdp4_crtc.c:	struct msm_drm_private *priv = crtc->dev->dev_private;
gpu/drm/msm/disp/mdp4/mdp4_dsi_encoder.c:	struct msm_drm_private *priv = encoder->dev->dev_private;
gpu/drm/msm/disp/mdp4/mdp4_dtv_encoder.c:	struct msm_drm_private *priv = encoder->dev->dev_private;
gpu/drm/msm/disp/mdp4/mdp4_dtv_encoder.c:		mdp4_dtv_encoder->bsc = msm_bus_scale_register_client(
gpu/drm/msm/disp/mdp4/mdp4_dtv_encoder.c:		msm_bus_scale_unregister_client(mdp4_dtv_encoder->bsc);
gpu/drm/msm/disp/mdp4/mdp4_dtv_encoder.c:		msm_bus_scale_client_update_request(mdp4_dtv_encoder->bsc, idx);
gpu/drm/msm/disp/mdp4/mdp4_irq.c:#include "msm_drv.h"
gpu/drm/msm/disp/mdp4/mdp4_irq.c:void mdp4_irq_preinstall(struct msm_kms *kms)
gpu/drm/msm/disp/mdp4/mdp4_irq.c:int mdp4_irq_postinstall(struct msm_kms *kms)
gpu/drm/msm/disp/mdp4/mdp4_irq.c:void mdp4_irq_uninstall(struct msm_kms *kms)
gpu/drm/msm/disp/mdp4/mdp4_irq.c:irqreturn_t mdp4_irq(struct msm_kms *kms)
gpu/drm/msm/disp/mdp4/mdp4_irq.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp4/mdp4_irq.c:int mdp4_enable_vblank(struct msm_kms *kms, struct drm_crtc *crtc)
gpu/drm/msm/disp/mdp4/mdp4_irq.c:void mdp4_disable_vblank(struct msm_kms *kms, struct drm_crtc *crtc)
gpu/drm/msm/disp/mdp4/mdp4_kms.c:#include "msm_drv.h"
gpu/drm/msm/disp/mdp4/mdp4_kms.c:#include "msm_gem.h"
gpu/drm/msm/disp/mdp4/mdp4_kms.c:#include "msm_mmu.h"
gpu/drm/msm/disp/mdp4/mdp4_kms.c:static int mdp4_hw_init(struct msm_kms *kms)
gpu/drm/msm/disp/mdp4/mdp4_kms.c:static void mdp4_prepare_commit(struct msm_kms *kms, struct drm_atomic_state *state)
gpu/drm/msm/disp/mdp4/mdp4_kms.c:static void mdp4_complete_commit(struct msm_kms *kms, struct drm_atomic_state *state)
gpu/drm/msm/disp/mdp4/mdp4_kms.c:static void mdp4_wait_for_crtc_commit_done(struct msm_kms *kms,
gpu/drm/msm/disp/mdp4/mdp4_kms.c:static long mdp4_round_pixclk(struct msm_kms *kms, unsigned long rate,
gpu/drm/msm/disp/mdp4/mdp4_kms.c:static void mdp4_destroy(struct msm_kms *kms)
gpu/drm/msm/disp/mdp4/mdp4_kms.c:	struct msm_gem_address_space *aspace = kms->aspace;
gpu/drm/msm/disp/mdp4/mdp4_kms.c:		msm_gem_put_iova(mdp4_kms->blank_cursor_bo, kms->aspace);
gpu/drm/msm/disp/mdp4/mdp4_kms.c:		msm_gem_address_space_put(aspace);
gpu/drm/msm/disp/mdp4/mdp4_kms.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp4/mdp4_kms.c:			ret = msm_hdmi_modeset_init(priv->hdmi, dev, encoder);
gpu/drm/msm/disp/mdp4/mdp4_kms.c:		ret = msm_dsi_modeset_init(priv->dsi[dsi_id], dev, encoder);
gpu/drm/msm/disp/mdp4/mdp4_kms.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp4/mdp4_kms.c:struct msm_kms *mdp4_kms_init(struct drm_device *dev)
gpu/drm/msm/disp/mdp4/mdp4_kms.c:	struct msm_kms *kms = NULL;
gpu/drm/msm/disp/mdp4/mdp4_kms.c:	struct msm_gem_address_space *aspace;
gpu/drm/msm/disp/mdp4/mdp4_kms.c:	mdp4_kms->mmio = msm_ioremap(pdev, NULL, "MDP4");
gpu/drm/msm/disp/mdp4/mdp4_kms.c:		aspace = msm_gem_address_space_create(&pdev->dev,
gpu/drm/msm/disp/mdp4/mdp4_kms.c:	mdp4_kms->blank_cursor_bo = msm_gem_new(dev, SZ_16K, MSM_BO_WC);
gpu/drm/msm/disp/mdp4/mdp4_kms.c:	ret = msm_gem_get_iova(mdp4_kms->blank_cursor_bo, kms->aspace,
gpu/drm/msm/disp/mdp4/mdp4_kms.h:#include "msm_drv.h"
gpu/drm/msm/disp/mdp4/mdp4_kms.h:#include "msm_kms.h"
gpu/drm/msm/disp/mdp4/mdp4_kms.h:	msm_writel(data, mdp4_kms->mmio + reg);
gpu/drm/msm/disp/mdp4/mdp4_kms.h:	return msm_readl(mdp4_kms->mmio + reg);
gpu/drm/msm/disp/mdp4/mdp4_kms.h:void mdp4_irq_preinstall(struct msm_kms *kms);
gpu/drm/msm/disp/mdp4/mdp4_kms.h:int mdp4_irq_postinstall(struct msm_kms *kms);
gpu/drm/msm/disp/mdp4/mdp4_kms.h:void mdp4_irq_uninstall(struct msm_kms *kms);
gpu/drm/msm/disp/mdp4/mdp4_kms.h:irqreturn_t mdp4_irq(struct msm_kms *kms);
gpu/drm/msm/disp/mdp4/mdp4_kms.h:int mdp4_enable_vblank(struct msm_kms *kms, struct drm_crtc *crtc);
gpu/drm/msm/disp/mdp4/mdp4_kms.h:void mdp4_disable_vblank(struct msm_kms *kms, struct drm_crtc *crtc);
gpu/drm/msm/disp/mdp4/mdp4_lcdc_encoder.c:	struct msm_drm_private *priv = encoder->dev->dev_private;
gpu/drm/msm/disp/mdp4/mdp4_lcdc_encoder.c:		mdp4_lcdc_encoder->bsc = msm_bus_scale_register_client(
gpu/drm/msm/disp/mdp4/mdp4_lcdc_encoder.c:		msm_bus_scale_unregister_client(mdp4_lcdc_encoder->bsc);
gpu/drm/msm/disp/mdp4/mdp4_lcdc_encoder.c:		msm_bus_scale_client_update_request(mdp4_lcdc_encoder->bsc, idx);
gpu/drm/msm/disp/mdp4/mdp4_lvds_pll.c:	struct msm_drm_private *priv = lvds_pll->dev->dev_private;
gpu/drm/msm/disp/mdp4/mdp4_plane.c:	struct msm_drm_private *priv = plane->dev->dev_private;
gpu/drm/msm/disp/mdp4/mdp4_plane.c:	struct msm_kms *kms = &mdp4_kms->base.base;
gpu/drm/msm/disp/mdp4/mdp4_plane.c:	msm_framebuffer_cleanup(fb, kms->aspace);
gpu/drm/msm/disp/mdp4/mdp4_plane.c:		.prepare_fb = msm_atomic_prepare_fb,
gpu/drm/msm/disp/mdp4/mdp4_plane.c:	struct msm_kms *kms = &mdp4_kms->base.base;
gpu/drm/msm/disp/mdp4/mdp4_plane.c:			msm_framebuffer_iova(fb, kms->aspace, 0));
gpu/drm/msm/disp/mdp4/mdp4_plane.c:			msm_framebuffer_iova(fb, kms->aspace, 1));
gpu/drm/msm/disp/mdp4/mdp4_plane.c:			msm_framebuffer_iova(fb, kms->aspace, 2));
gpu/drm/msm/disp/mdp4/mdp4_plane.c:			msm_framebuffer_iova(fb, kms->aspace, 3));
gpu/drm/msm/disp/mdp4/mdp4_plane.c:	format = to_mdp_format(msm_framebuffer_format(fb));
gpu/drm/msm/disp/mdp5/mdp5.xml.h:- /home/robclark/src/envytools/rnndb/msm.xml                 (    676 bytes, from 2018-07-03 19:37:13)
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:const struct mdp5_cfg_hw msm8x74v1_config = {
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:	.name = "msm8x74v1",
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:const struct mdp5_cfg_hw msm8x74v2_config = {
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:	.name = "msm8x74",
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:const struct mdp5_cfg_hw msm8x16_config = {
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:	.name = "msm8x16",
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:const struct mdp5_cfg_hw msm8x94_config = {
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:	.name = "msm8x94",
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:const struct mdp5_cfg_hw msm8x96_config = {
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:	.name = "msm8x96",
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:	{ .revision = 0, .config = { .hw = &msm8x74v1_config } },
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:	{ .revision = 2, .config = { .hw = &msm8x74v2_config } },
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:	{ .revision = 6, .config = { .hw = &msm8x16_config } },
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:	{ .revision = 9, .config = { .hw = &msm8x94_config } },
gpu/drm/msm/disp/mdp5/mdp5_cfg.c:	{ .revision = 7, .config = { .hw = &msm8x96_config } },
gpu/drm/msm/disp/mdp5/mdp5_cfg.h:#include "msm_drv.h"
gpu/drm/msm/disp/mdp5/mdp5_cmd_encoder.c:	struct msm_drm_private *priv = encoder->dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_cmd_encoder.c:#include <linux/msm-bus.h>
gpu/drm/msm/disp/mdp5/mdp5_cmd_encoder.c:#include <linux/msm-bus-board.h>
gpu/drm/msm/disp/mdp5/mdp5_cmd_encoder.c:		msm_bus_scale_client_update_request(mdp5_cmd_enc->bsc, idx);
gpu/drm/msm/disp/mdp5/mdp5_crtc.c:	struct msm_drm_private *priv = crtc->dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_crtc.c:	struct msm_kms *kms = &mdp5_kms->base.base;
gpu/drm/msm/disp/mdp5/mdp5_crtc.c:	msm_gem_put_iova(val, kms->aspace);
gpu/drm/msm/disp/mdp5/mdp5_crtc.c:		format = to_mdp_format(msm_framebuffer_format(pstates[STAGE_BASE]->base.fb));
gpu/drm/msm/disp/mdp5/mdp5_crtc.c:			msm_framebuffer_format(pstates[i]->base.fb));
gpu/drm/msm/disp/mdp5/mdp5_crtc.c:	struct msm_kms *kms = &mdp5_kms->base.base;
gpu/drm/msm/disp/mdp5/mdp5_crtc.c:	ret = msm_gem_get_iova(cursor_bo, kms->aspace,
gpu/drm/msm/disp/mdp5/mdp5_crtc.c:	struct msm_drm_private *priv = crtc->dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_ctl.c:	struct msm_drm_private *priv = ctl_mgr->dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_ctl.h:#include "msm_drv.h"
gpu/drm/msm/disp/mdp5/mdp5_encoder.c:	struct msm_drm_private *priv = encoder->dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_encoder.c:#include <mach/msm_bus.h>
gpu/drm/msm/disp/mdp5/mdp5_encoder.c:#include <mach/msm_bus_board.h>
gpu/drm/msm/disp/mdp5/mdp5_encoder.c:static struct msm_bus_vectors mdp_bus_vectors[] = {
gpu/drm/msm/disp/mdp5/mdp5_encoder.c:static struct msm_bus_paths mdp_bus_usecases[] = { {
gpu/drm/msm/disp/mdp5/mdp5_encoder.c:static struct msm_bus_scale_pdata mdp_bus_scale_table = {
gpu/drm/msm/disp/mdp5/mdp5_encoder.c:	mdp5_encoder->bsc = msm_bus_scale_register_client(
gpu/drm/msm/disp/mdp5/mdp5_encoder.c:		msm_bus_scale_unregister_client(mdp5_encoder->bsc);
gpu/drm/msm/disp/mdp5/mdp5_encoder.c:		msm_bus_scale_client_update_request(mdp5_encoder->bsc, idx);
gpu/drm/msm/disp/mdp5/mdp5_irq.c:#include "msm_drv.h"
gpu/drm/msm/disp/mdp5/mdp5_irq.c:void mdp5_irq_preinstall(struct msm_kms *kms)
gpu/drm/msm/disp/mdp5/mdp5_irq.c:int mdp5_irq_postinstall(struct msm_kms *kms)
gpu/drm/msm/disp/mdp5/mdp5_irq.c:void mdp5_irq_uninstall(struct msm_kms *kms)
gpu/drm/msm/disp/mdp5/mdp5_irq.c:irqreturn_t mdp5_irq(struct msm_kms *kms)
gpu/drm/msm/disp/mdp5/mdp5_irq.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_irq.c:int mdp5_enable_vblank(struct msm_kms *kms, struct drm_crtc *crtc)
gpu/drm/msm/disp/mdp5/mdp5_irq.c:void mdp5_disable_vblank(struct msm_kms *kms, struct drm_crtc *crtc)
gpu/drm/msm/disp/mdp5/mdp5_kms.c:#include "msm_drv.h"
gpu/drm/msm/disp/mdp5/mdp5_kms.c:#include "msm_gem.h"
gpu/drm/msm/disp/mdp5/mdp5_kms.c:#include "msm_mmu.h"
gpu/drm/msm/disp/mdp5/mdp5_kms.c:static int mdp5_hw_init(struct msm_kms *kms)
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	struct msm_drm_private *priv = s->dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_kms.c:static void mdp5_prepare_commit(struct msm_kms *kms, struct drm_atomic_state *state)
gpu/drm/msm/disp/mdp5/mdp5_kms.c:static void mdp5_complete_commit(struct msm_kms *kms, struct drm_atomic_state *state)
gpu/drm/msm/disp/mdp5/mdp5_kms.c:static void mdp5_wait_for_crtc_commit_done(struct msm_kms *kms,
gpu/drm/msm/disp/mdp5/mdp5_kms.c:static long mdp5_round_pixclk(struct msm_kms *kms, unsigned long rate,
gpu/drm/msm/disp/mdp5/mdp5_kms.c:static int mdp5_set_split_display(struct msm_kms *kms,
gpu/drm/msm/disp/mdp5/mdp5_kms.c:static void mdp5_set_encoder_mode(struct msm_kms *kms,
gpu/drm/msm/disp/mdp5/mdp5_kms.c:static void mdp5_kms_destroy(struct msm_kms *kms)
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	struct msm_gem_address_space *aspace = kms->aspace;
gpu/drm/msm/disp/mdp5/mdp5_kms.c:		msm_gem_address_space_put(aspace);
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_kms.c:static int mdp5_kms_debugfs_init(struct msm_kms *kms, struct drm_minor *minor)
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_kms.c:		ret = msm_edp_modeset_init(priv->edp, dev, encoder);
gpu/drm/msm/disp/mdp5/mdp5_kms.c:		ret = msm_hdmi_modeset_init(priv->hdmi, dev, encoder);
gpu/drm/msm/disp/mdp5/mdp5_kms.c:		ret = msm_dsi_modeset_init(priv->dsi[dsi_id], dev, encoder);
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	struct clk *clk = msm_clk_get(pdev, name);
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_kms.c:struct msm_kms *mdp5_kms_init(struct drm_device *dev)
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	struct msm_kms *kms;
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	struct msm_gem_address_space *aspace;
gpu/drm/msm/disp/mdp5/mdp5_kms.c:		aspace = msm_gem_address_space_create(&pdev->dev,
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_kms.c:	mdp5_kms->mmio = msm_ioremap(pdev, "mdp_phys", "MDP5");
gpu/drm/msm/disp/mdp5/mdp5_kms.c:		.name = "msm_mdp",
gpu/drm/msm/disp/mdp5/mdp5_kms.c:void __init msm_mdp_register(void)
gpu/drm/msm/disp/mdp5/mdp5_kms.c:void __exit msm_mdp_unregister(void)
gpu/drm/msm/disp/mdp5/mdp5_kms.h:#include "msm_drv.h"
gpu/drm/msm/disp/mdp5/mdp5_kms.h:#include "msm_kms.h"
gpu/drm/msm/disp/mdp5/mdp5_kms.h:	msm_writel(data, mdp5_kms->mmio + reg);
gpu/drm/msm/disp/mdp5/mdp5_kms.h:	return msm_readl(mdp5_kms->mmio + reg);
gpu/drm/msm/disp/mdp5/mdp5_kms.h:void mdp5_irq_preinstall(struct msm_kms *kms);
gpu/drm/msm/disp/mdp5/mdp5_kms.h:int mdp5_irq_postinstall(struct msm_kms *kms);
gpu/drm/msm/disp/mdp5/mdp5_kms.h:void mdp5_irq_uninstall(struct msm_kms *kms);
gpu/drm/msm/disp/mdp5/mdp5_kms.h:irqreturn_t mdp5_irq(struct msm_kms *kms);
gpu/drm/msm/disp/mdp5/mdp5_kms.h:int mdp5_enable_vblank(struct msm_kms *kms, struct drm_crtc *crtc);
gpu/drm/msm/disp/mdp5/mdp5_kms.h:void mdp5_disable_vblank(struct msm_kms *kms, struct drm_crtc *crtc);
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:#include "msm_drv.h"
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:	struct msm_mdss base;
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:	msm_writel(data, mdp5_mdss->mmio + reg);
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:	return msm_readl(mdp5_mdss->mmio + reg);
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:static int mdp5_mdss_enable(struct msm_mdss *mdss)
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:static int mdp5_mdss_disable(struct msm_mdss *mdss)
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:static int msm_mdss_get_clocks(struct mdp5_mdss *mdp5_mdss)
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:	mdp5_mdss->ahb_clk = msm_clk_get(pdev, "iface");
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:	mdp5_mdss->axi_clk = msm_clk_get(pdev, "bus");
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:	mdp5_mdss->vsync_clk = msm_clk_get(pdev, "vsync");
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:static const struct msm_mdss_funcs mdss_funcs = {
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:	mdp5_mdss->mmio = msm_ioremap(pdev, "mdss_phys", "MDSS");
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:	mdp5_mdss->vbif = msm_ioremap(pdev, "vbif_phys", "VBIF");
gpu/drm/msm/disp/mdp5/mdp5_mdss.c:	ret = msm_mdss_get_clocks(mdp5_mdss);
gpu/drm/msm/disp/mdp5/mdp5_mixer.c:	struct msm_drm_private *priv = s->dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_pipe.c:	struct msm_drm_private *priv = s->dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_pipe.c:	struct msm_drm_private *priv = s->dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_plane.c:	struct msm_drm_private *priv = plane->dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_plane.c:	struct msm_drm_private *dev_priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_plane.c:	struct msm_drm_private *dev_priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_plane.c:	struct msm_drm_private *dev_priv = dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_plane.c:	struct msm_kms *kms = &mdp5_kms->base.base;
gpu/drm/msm/disp/mdp5/mdp5_plane.c:	msm_framebuffer_cleanup(fb, kms->aspace);
gpu/drm/msm/disp/mdp5/mdp5_plane.c:		format = to_mdp_format(msm_framebuffer_format(state->fb));
gpu/drm/msm/disp/mdp5/mdp5_plane.c:				to_mdp_format(msm_framebuffer_format(state->fb));
gpu/drm/msm/disp/mdp5/mdp5_plane.c:		.prepare_fb = msm_atomic_prepare_fb,
gpu/drm/msm/disp/mdp5/mdp5_plane.c:	struct msm_kms *kms = &mdp5_kms->base.base;
gpu/drm/msm/disp/mdp5/mdp5_plane.c:			msm_framebuffer_iova(fb, kms->aspace, 0));
gpu/drm/msm/disp/mdp5/mdp5_plane.c:			msm_framebuffer_iova(fb, kms->aspace, 1));
gpu/drm/msm/disp/mdp5/mdp5_plane.c:			msm_framebuffer_iova(fb, kms->aspace, 2));
gpu/drm/msm/disp/mdp5/mdp5_plane.c:			msm_framebuffer_iova(fb, kms->aspace, 3));
gpu/drm/msm/disp/mdp5/mdp5_plane.c:			to_mdp_format(msm_framebuffer_format(fb));
gpu/drm/msm/disp/mdp5/mdp5_plane.c:	format = to_mdp_format(msm_framebuffer_format(fb));
gpu/drm/msm/disp/mdp5/mdp5_smp.c:	struct msm_drm_private *priv = smp->dev->dev_private;
gpu/drm/msm/disp/mdp5/mdp5_smp.h:#include "msm_drv.h"
gpu/drm/msm/disp/mdp_common.xml.h:- /home/robclark/src/envytools/rnndb/msm.xml                 (    676 bytes, from 2018-07-03 19:37:13)
gpu/drm/msm/disp/mdp_format.c:#include "msm_drv.h"
gpu/drm/msm/disp/mdp_format.c:const struct msm_format *mdp_get_format(struct msm_kms *kms, uint32_t format,
gpu/drm/msm/disp/mdp_kms.c:#include "msm_drv.h"
gpu/drm/msm/disp/mdp_kms.h:#include "msm_drv.h"
gpu/drm/msm/disp/mdp_kms.h:#include "msm_kms.h"
gpu/drm/msm/disp/mdp_kms.h:	struct msm_kms_funcs base;
gpu/drm/msm/disp/mdp_kms.h:	struct msm_kms base;
gpu/drm/msm/disp/mdp_kms.h:	msm_kms_init(&mdp_kms->base, &funcs->base);
gpu/drm/msm/disp/mdp_kms.h:	struct msm_format base;
gpu/drm/msm/disp/mdp_kms.h:const struct msm_format *mdp_get_format(struct msm_kms *kms, uint32_t format, uint64_t modifier);
gpu/drm/msm/dsi/dsi.c:struct drm_encoder *msm_dsi_get_encoder(struct msm_dsi *msm_dsi)
gpu/drm/msm/dsi/dsi.c:	if (!msm_dsi || !msm_dsi_device_connected(msm_dsi))
gpu/drm/msm/dsi/dsi.c:	return msm_dsi->encoder;
gpu/drm/msm/dsi/dsi.c:static int dsi_get_phy(struct msm_dsi *msm_dsi)
gpu/drm/msm/dsi/dsi.c:	struct platform_device *pdev = msm_dsi->pdev;
gpu/drm/msm/dsi/dsi.c:		msm_dsi->phy = platform_get_drvdata(phy_pdev);
gpu/drm/msm/dsi/dsi.c:		msm_dsi->phy_dev = &phy_pdev->dev;
gpu/drm/msm/dsi/dsi.c:	if (!phy_pdev || !msm_dsi->phy) {
gpu/drm/msm/dsi/dsi.c:static void dsi_destroy(struct msm_dsi *msm_dsi)
gpu/drm/msm/dsi/dsi.c:	if (!msm_dsi)
gpu/drm/msm/dsi/dsi.c:	msm_dsi_manager_unregister(msm_dsi);
gpu/drm/msm/dsi/dsi.c:	if (msm_dsi->phy_dev) {
gpu/drm/msm/dsi/dsi.c:		put_device(msm_dsi->phy_dev);
gpu/drm/msm/dsi/dsi.c:		msm_dsi->phy = NULL;
gpu/drm/msm/dsi/dsi.c:		msm_dsi->phy_dev = NULL;
gpu/drm/msm/dsi/dsi.c:	if (msm_dsi->host) {
gpu/drm/msm/dsi/dsi.c:		msm_dsi_host_destroy(msm_dsi->host);
gpu/drm/msm/dsi/dsi.c:		msm_dsi->host = NULL;
gpu/drm/msm/dsi/dsi.c:	platform_set_drvdata(msm_dsi->pdev, NULL);
gpu/drm/msm/dsi/dsi.c:static struct msm_dsi *dsi_init(struct platform_device *pdev)
gpu/drm/msm/dsi/dsi.c:	struct msm_dsi *msm_dsi;
gpu/drm/msm/dsi/dsi.c:	msm_dsi = devm_kzalloc(&pdev->dev, sizeof(*msm_dsi), GFP_KERNEL);
gpu/drm/msm/dsi/dsi.c:	if (!msm_dsi)
gpu/drm/msm/dsi/dsi.c:	DBG("dsi probed=%p", msm_dsi);
gpu/drm/msm/dsi/dsi.c:	msm_dsi->pdev = pdev;
gpu/drm/msm/dsi/dsi.c:	platform_set_drvdata(pdev, msm_dsi);
gpu/drm/msm/dsi/dsi.c:	ret = msm_dsi_host_init(msm_dsi);
gpu/drm/msm/dsi/dsi.c:	ret = dsi_get_phy(msm_dsi);
gpu/drm/msm/dsi/dsi.c:	ret = msm_dsi_manager_register(msm_dsi);
gpu/drm/msm/dsi/dsi.c:	return msm_dsi;
gpu/drm/msm/dsi/dsi.c:	dsi_destroy(msm_dsi);
gpu/drm/msm/dsi/dsi.c:	struct msm_drm_private *priv = drm->dev_private;
gpu/drm/msm/dsi/dsi.c:	struct msm_dsi *msm_dsi;
gpu/drm/msm/dsi/dsi.c:	msm_dsi = dsi_init(pdev);
gpu/drm/msm/dsi/dsi.c:	if (IS_ERR(msm_dsi))
gpu/drm/msm/dsi/dsi.c:		return PTR_ERR(msm_dsi);
gpu/drm/msm/dsi/dsi.c:	priv->dsi[msm_dsi->id] = msm_dsi;
gpu/drm/msm/dsi/dsi.c:	struct msm_drm_private *priv = drm->dev_private;
gpu/drm/msm/dsi/dsi.c:	struct msm_dsi *msm_dsi = dev_get_drvdata(dev);
gpu/drm/msm/dsi/dsi.c:	int id = msm_dsi->id;
gpu/drm/msm/dsi/dsi.c:		dsi_destroy(msm_dsi);
gpu/drm/msm/dsi/dsi.c:	SET_RUNTIME_PM_OPS(msm_dsi_runtime_suspend, msm_dsi_runtime_resume, NULL)
gpu/drm/msm/dsi/dsi.c:		.name = "msm_dsi",
gpu/drm/msm/dsi/dsi.c:void __init msm_dsi_register(void)
gpu/drm/msm/dsi/dsi.c:	msm_dsi_phy_driver_register();
gpu/drm/msm/dsi/dsi.c:void __exit msm_dsi_unregister(void)
gpu/drm/msm/dsi/dsi.c:	msm_dsi_phy_driver_unregister();
gpu/drm/msm/dsi/dsi.c:int msm_dsi_modeset_init(struct msm_dsi *msm_dsi, struct drm_device *dev,
gpu/drm/msm/dsi/dsi.c:	struct msm_drm_private *priv;
gpu/drm/msm/dsi/dsi.c:	if (WARN_ON(!encoder) || WARN_ON(!msm_dsi) || WARN_ON(!dev))
gpu/drm/msm/dsi/dsi.c:	msm_dsi->dev = dev;
gpu/drm/msm/dsi/dsi.c:	ret = msm_dsi_host_modeset_init(msm_dsi->host, dev);
gpu/drm/msm/dsi/dsi.c:	if (!msm_dsi_manager_validate_current_config(msm_dsi->id)) {
gpu/drm/msm/dsi/dsi.c:	msm_dsi->encoder = encoder;
gpu/drm/msm/dsi/dsi.c:	msm_dsi->bridge = msm_dsi_manager_bridge_init(msm_dsi->id);
gpu/drm/msm/dsi/dsi.c:	if (IS_ERR(msm_dsi->bridge)) {
gpu/drm/msm/dsi/dsi.c:		ret = PTR_ERR(msm_dsi->bridge);
gpu/drm/msm/dsi/dsi.c:		msm_dsi->bridge = NULL;
gpu/drm/msm/dsi/dsi.c:	ext_bridge = msm_dsi_host_get_bridge(msm_dsi->host);
gpu/drm/msm/dsi/dsi.c:		msm_dsi->connector =
gpu/drm/msm/dsi/dsi.c:			msm_dsi_manager_ext_bridge_init(msm_dsi->id);
gpu/drm/msm/dsi/dsi.c:		msm_dsi->connector =
gpu/drm/msm/dsi/dsi.c:			msm_dsi_manager_connector_init(msm_dsi->id);
gpu/drm/msm/dsi/dsi.c:	if (IS_ERR(msm_dsi->connector)) {
gpu/drm/msm/dsi/dsi.c:		ret = PTR_ERR(msm_dsi->connector);
gpu/drm/msm/dsi/dsi.c:		msm_dsi->connector = NULL;
gpu/drm/msm/dsi/dsi.c:	priv->bridges[priv->num_bridges++]       = msm_dsi->bridge;
gpu/drm/msm/dsi/dsi.c:	priv->connectors[priv->num_connectors++] = msm_dsi->connector;
gpu/drm/msm/dsi/dsi.c:	if (msm_dsi->bridge) {
gpu/drm/msm/dsi/dsi.c:		msm_dsi_manager_bridge_destroy(msm_dsi->bridge);
gpu/drm/msm/dsi/dsi.c:		msm_dsi->bridge = NULL;
gpu/drm/msm/dsi/dsi.c:	if (msm_dsi->connector && !msm_dsi->external_bridge)
gpu/drm/msm/dsi/dsi.c:		msm_dsi->connector->funcs->destroy(msm_dsi->connector);
gpu/drm/msm/dsi/dsi.c:	msm_dsi->connector = NULL;
gpu/drm/msm/dsi/dsi.h:#include "msm_drv.h"
gpu/drm/msm/dsi/dsi.h:struct msm_dsi_phy_shared_timings;
gpu/drm/msm/dsi/dsi.h:struct msm_dsi_phy_clk_request;
gpu/drm/msm/dsi/dsi.h:enum msm_dsi_phy_type {
gpu/drm/msm/dsi/dsi.h:enum msm_dsi_phy_usecase {
gpu/drm/msm/dsi/dsi.h:struct msm_dsi {
gpu/drm/msm/dsi/dsi.h:	struct msm_dsi_phy *phy;
gpu/drm/msm/dsi/dsi.h:struct drm_bridge *msm_dsi_manager_bridge_init(u8 id);
gpu/drm/msm/dsi/dsi.h:void msm_dsi_manager_bridge_destroy(struct drm_bridge *bridge);
gpu/drm/msm/dsi/dsi.h:struct drm_connector *msm_dsi_manager_connector_init(u8 id);
gpu/drm/msm/dsi/dsi.h:struct drm_connector *msm_dsi_manager_ext_bridge_init(u8 id);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_manager_cmd_xfer(int id, const struct mipi_dsi_msg *msg);
gpu/drm/msm/dsi/dsi.h:bool msm_dsi_manager_cmd_xfer_trigger(int id, u32 dma_base, u32 len);
gpu/drm/msm/dsi/dsi.h:void msm_dsi_manager_attach_dsi_device(int id, u32 device_flags);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_manager_register(struct msm_dsi *msm_dsi);
gpu/drm/msm/dsi/dsi.h:void msm_dsi_manager_unregister(struct msm_dsi *msm_dsi);
gpu/drm/msm/dsi/dsi.h:bool msm_dsi_manager_validate_current_config(u8 id);
gpu/drm/msm/dsi/dsi.h:/* msm dsi */
gpu/drm/msm/dsi/dsi.h:static inline bool msm_dsi_device_connected(struct msm_dsi *msm_dsi)
gpu/drm/msm/dsi/dsi.h:	return msm_dsi->panel || msm_dsi->external_bridge;
gpu/drm/msm/dsi/dsi.h:struct drm_encoder *msm_dsi_get_encoder(struct msm_dsi *msm_dsi);
gpu/drm/msm/dsi/dsi.h:struct msm_dsi_pll;
gpu/drm/msm/dsi/dsi.h:struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
gpu/drm/msm/dsi/dsi.h:			enum msm_dsi_phy_type type, int dsi_id);
gpu/drm/msm/dsi/dsi.h:void msm_dsi_pll_destroy(struct msm_dsi_pll *pll);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_pll_get_clk_provider(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/dsi.h:void msm_dsi_pll_save_state(struct msm_dsi_pll *pll);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_pll_restore_state(struct msm_dsi_pll *pll);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_pll_set_usecase(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/dsi.h:			    enum msm_dsi_phy_usecase uc);
gpu/drm/msm/dsi/dsi.h:static inline struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
gpu/drm/msm/dsi/dsi.h:			 enum msm_dsi_phy_type type, int id) {
gpu/drm/msm/dsi/dsi.h:static inline void msm_dsi_pll_destroy(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/dsi.h:static inline int msm_dsi_pll_get_clk_provider(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/dsi.h:static inline void msm_dsi_pll_save_state(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/dsi.h:static inline int msm_dsi_pll_restore_state(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/dsi.h:static inline int msm_dsi_pll_set_usecase(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/dsi.h:					  enum msm_dsi_phy_usecase uc)
gpu/drm/msm/dsi/dsi.h:struct msm_dsi_host;
gpu/drm/msm/dsi/dsi.h:int msm_dsi_host_xfer_prepare(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi.h:void msm_dsi_host_xfer_restore(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi.h:int msm_dsi_host_cmd_tx(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi.h:int msm_dsi_host_cmd_rx(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi.h:void msm_dsi_host_cmd_xfer_commit(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi.h:int msm_dsi_host_enable(struct mipi_dsi_host *host);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_host_disable(struct mipi_dsi_host *host);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_host_power_on(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi.h:			struct msm_dsi_phy_shared_timings *phy_shared_timings,
gpu/drm/msm/dsi/dsi.h:int msm_dsi_host_power_off(struct mipi_dsi_host *host);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_host_set_display_mode(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi.h:struct drm_panel *msm_dsi_host_get_panel(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi.h:struct drm_bridge *msm_dsi_host_get_bridge(struct mipi_dsi_host *host);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_host_register(struct mipi_dsi_host *host, bool check_defer);
gpu/drm/msm/dsi/dsi.h:void msm_dsi_host_unregister(struct mipi_dsi_host *host);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_host_set_src_pll(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi.h:			struct msm_dsi_pll *src_pll);
gpu/drm/msm/dsi/dsi.h:void msm_dsi_host_reset_phy(struct mipi_dsi_host *host);
gpu/drm/msm/dsi/dsi.h:void msm_dsi_host_get_phy_clk_req(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi.h:	struct msm_dsi_phy_clk_request *clk_req,
gpu/drm/msm/dsi/dsi.h:void msm_dsi_host_destroy(struct mipi_dsi_host *host);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_host_modeset_init(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi.h:int msm_dsi_host_init(struct msm_dsi *msm_dsi);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_runtime_suspend(struct device *dev);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_runtime_resume(struct device *dev);
gpu/drm/msm/dsi/dsi.h:int dsi_link_clk_enable_6g(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi.h:int dsi_link_clk_enable_v2(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi.h:void dsi_link_clk_disable_6g(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi.h:void dsi_link_clk_disable_v2(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi.h:int dsi_tx_buf_alloc_6g(struct msm_dsi_host *msm_host, int size);
gpu/drm/msm/dsi/dsi.h:int dsi_tx_buf_alloc_v2(struct msm_dsi_host *msm_host, int size);
gpu/drm/msm/dsi/dsi.h:void *dsi_tx_buf_get_6g(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi.h:void *dsi_tx_buf_get_v2(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi.h:void dsi_tx_buf_put_6g(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi.h:int dsi_dma_base_get_6g(struct msm_dsi_host *msm_host, uint64_t *iova);
gpu/drm/msm/dsi/dsi.h:int dsi_dma_base_get_v2(struct msm_dsi_host *msm_host, uint64_t *iova);
gpu/drm/msm/dsi/dsi.h:int dsi_clk_init_v2(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi.h:int dsi_clk_init_6g_v2(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi.h:int dsi_calc_clk_rate_v2(struct msm_dsi_host *msm_host, bool is_dual_dsi);
gpu/drm/msm/dsi/dsi.h:int dsi_calc_clk_rate_6g(struct msm_dsi_host *msm_host, bool is_dual_dsi);
gpu/drm/msm/dsi/dsi.h:struct msm_dsi_phy;
gpu/drm/msm/dsi/dsi.h:struct msm_dsi_phy_shared_timings {
gpu/drm/msm/dsi/dsi.h:struct msm_dsi_phy_clk_request {
gpu/drm/msm/dsi/dsi.h:void msm_dsi_phy_driver_register(void);
gpu/drm/msm/dsi/dsi.h:void msm_dsi_phy_driver_unregister(void);
gpu/drm/msm/dsi/dsi.h:int msm_dsi_phy_enable(struct msm_dsi_phy *phy, int src_pll_id,
gpu/drm/msm/dsi/dsi.h:			struct msm_dsi_phy_clk_request *clk_req);
gpu/drm/msm/dsi/dsi.h:void msm_dsi_phy_disable(struct msm_dsi_phy *phy);
gpu/drm/msm/dsi/dsi.h:void msm_dsi_phy_get_shared_timings(struct msm_dsi_phy *phy,
gpu/drm/msm/dsi/dsi.h:			struct msm_dsi_phy_shared_timings *shared_timing);
gpu/drm/msm/dsi/dsi.h:struct msm_dsi_pll *msm_dsi_phy_get_pll(struct msm_dsi_phy *phy);
gpu/drm/msm/dsi/dsi.h:void msm_dsi_phy_set_usecase(struct msm_dsi_phy *phy,
gpu/drm/msm/dsi/dsi.h:			     enum msm_dsi_phy_usecase uc);
gpu/drm/msm/dsi/dsi.xml.h:- /home/robclark/src/envytools/rnndb/msm.xml                 (    676 bytes, from 2018-07-03 19:37:13)
gpu/drm/msm/dsi/dsi_cfg.c:static const struct msm_dsi_config apq8064_dsi_cfg = {
gpu/drm/msm/dsi/dsi_cfg.c:static const struct msm_dsi_config msm8974_apq8084_dsi_cfg = {
gpu/drm/msm/dsi/dsi_cfg.c:static const struct msm_dsi_config msm8916_dsi_cfg = {
gpu/drm/msm/dsi/dsi_cfg.c:static const struct msm_dsi_config msm8994_dsi_cfg = {
gpu/drm/msm/dsi/dsi_cfg.c:static const struct msm_dsi_config msm8996_dsi_cfg = {
gpu/drm/msm/dsi/dsi_cfg.c:static const struct msm_dsi_config sdm845_dsi_cfg = {
gpu/drm/msm/dsi/dsi_cfg.c:const static struct msm_dsi_host_cfg_ops msm_dsi_v2_host_ops = {
gpu/drm/msm/dsi/dsi_cfg.c:const static struct msm_dsi_host_cfg_ops msm_dsi_6g_host_ops = {
gpu/drm/msm/dsi/dsi_cfg.c:const static struct msm_dsi_host_cfg_ops msm_dsi_6g_v2_host_ops = {
gpu/drm/msm/dsi/dsi_cfg.c:static const struct msm_dsi_cfg_handler dsi_cfg_handlers[] = {
gpu/drm/msm/dsi/dsi_cfg.c:		&apq8064_dsi_cfg, &msm_dsi_v2_host_ops},
gpu/drm/msm/dsi/dsi_cfg.c:		&msm8974_apq8084_dsi_cfg, &msm_dsi_6g_host_ops},
gpu/drm/msm/dsi/dsi_cfg.c:		&msm8974_apq8084_dsi_cfg, &msm_dsi_6g_host_ops},
gpu/drm/msm/dsi/dsi_cfg.c:		&msm8974_apq8084_dsi_cfg, &msm_dsi_6g_host_ops},
gpu/drm/msm/dsi/dsi_cfg.c:		&msm8974_apq8084_dsi_cfg, &msm_dsi_6g_host_ops},
gpu/drm/msm/dsi/dsi_cfg.c:		&msm8994_dsi_cfg, &msm_dsi_6g_host_ops},
gpu/drm/msm/dsi/dsi_cfg.c:		&msm8916_dsi_cfg, &msm_dsi_6g_host_ops},
gpu/drm/msm/dsi/dsi_cfg.c:		&msm8996_dsi_cfg, &msm_dsi_6g_host_ops},
gpu/drm/msm/dsi/dsi_cfg.c:		&sdm845_dsi_cfg, &msm_dsi_6g_v2_host_ops},
gpu/drm/msm/dsi/dsi_cfg.c:const struct msm_dsi_cfg_handler *msm_dsi_cfg_get(u32 major, u32 minor)
gpu/drm/msm/dsi/dsi_cfg.c:	const struct msm_dsi_cfg_handler *cfg_hnd = NULL;
gpu/drm/msm/dsi/dsi_cfg.h:struct msm_dsi_config {
gpu/drm/msm/dsi/dsi_cfg.h:struct msm_dsi_host_cfg_ops {
gpu/drm/msm/dsi/dsi_cfg.h:	int (*link_clk_enable)(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi_cfg.h:	void (*link_clk_disable)(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi_cfg.h:	int (*clk_init_ver)(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi_cfg.h:	int (*tx_buf_alloc)(struct msm_dsi_host *msm_host, int size);
gpu/drm/msm/dsi/dsi_cfg.h:	void* (*tx_buf_get)(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi_cfg.h:	void (*tx_buf_put)(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi_cfg.h:	int (*dma_base_get)(struct msm_dsi_host *msm_host, uint64_t *iova);
gpu/drm/msm/dsi/dsi_cfg.h:	int (*calc_clk_rate)(struct msm_dsi_host *msm_host, bool is_dual_dsi);
gpu/drm/msm/dsi/dsi_cfg.h:struct msm_dsi_cfg_handler {
gpu/drm/msm/dsi/dsi_cfg.h:	const struct msm_dsi_config *cfg;
gpu/drm/msm/dsi/dsi_cfg.h:	const struct msm_dsi_host_cfg_ops *ops;
gpu/drm/msm/dsi/dsi_cfg.h:const struct msm_dsi_cfg_handler *msm_dsi_cfg_get(u32 major, u32 minor);
gpu/drm/msm/dsi/dsi_host.c:#include "msm_kms.h"
gpu/drm/msm/dsi/dsi_host.c:	ver = msm_readl(base + REG_DSI_VERSION);
gpu/drm/msm/dsi/dsi_host.c:		ver = msm_readl(base + DSI_6G_REG_SHIFT + REG_DSI_VERSION);
gpu/drm/msm/dsi/dsi_host.c:			*minor = msm_readl(base + REG_DSI_6G_HW_VERSION);
gpu/drm/msm/dsi/dsi_host.c:struct msm_dsi_host {
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_cfg_handler *cfg_hnd;
gpu/drm/msm/dsi/dsi_host.c:static inline u32 dsi_read(struct msm_dsi_host *msm_host, u32 reg)
gpu/drm/msm/dsi/dsi_host.c:	return msm_readl(msm_host->ctrl_base + reg);
gpu/drm/msm/dsi/dsi_host.c:static inline void dsi_write(struct msm_dsi_host *msm_host, u32 reg, u32 data)
gpu/drm/msm/dsi/dsi_host.c:	msm_writel(data, msm_host->ctrl_base + reg);
gpu/drm/msm/dsi/dsi_host.c:static int dsi_host_regulator_enable(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi_host.c:static void dsi_host_regulator_disable(struct msm_dsi_host *msm_host);
gpu/drm/msm/dsi/dsi_host.c:static const struct msm_dsi_cfg_handler *dsi_get_config(
gpu/drm/msm/dsi/dsi_host.c:						struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_cfg_handler *cfg_hnd = NULL;
gpu/drm/msm/dsi/dsi_host.c:	struct device *dev = &msm_host->pdev->dev;
gpu/drm/msm/dsi/dsi_host.c:	ahb_clk = msm_clk_get(msm_host->pdev, "iface");
gpu/drm/msm/dsi/dsi_host.c:	ret = dsi_get_version(msm_host->ctrl_base, &major, &minor);
gpu/drm/msm/dsi/dsi_host.c:	cfg_hnd = msm_dsi_cfg_get(major, minor);
gpu/drm/msm/dsi/dsi_host.c:static inline struct msm_dsi_host *to_msm_dsi_host(struct mipi_dsi_host *host)
gpu/drm/msm/dsi/dsi_host.c:	return container_of(host, struct msm_dsi_host, base);
gpu/drm/msm/dsi/dsi_host.c:static void dsi_host_regulator_disable(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	struct regulator_bulk_data *s = msm_host->supplies;
gpu/drm/msm/dsi/dsi_host.c:	const struct dsi_reg_entry *regs = msm_host->cfg_hnd->cfg->reg_cfg.regs;
gpu/drm/msm/dsi/dsi_host.c:	int num = msm_host->cfg_hnd->cfg->reg_cfg.num;
gpu/drm/msm/dsi/dsi_host.c:static int dsi_host_regulator_enable(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	struct regulator_bulk_data *s = msm_host->supplies;
gpu/drm/msm/dsi/dsi_host.c:	const struct dsi_reg_entry *regs = msm_host->cfg_hnd->cfg->reg_cfg.regs;
gpu/drm/msm/dsi/dsi_host.c:	int num = msm_host->cfg_hnd->cfg->reg_cfg.num;
gpu/drm/msm/dsi/dsi_host.c:static int dsi_regulator_init(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	struct regulator_bulk_data *s = msm_host->supplies;
gpu/drm/msm/dsi/dsi_host.c:	const struct dsi_reg_entry *regs = msm_host->cfg_hnd->cfg->reg_cfg.regs;
gpu/drm/msm/dsi/dsi_host.c:	int num = msm_host->cfg_hnd->cfg->reg_cfg.num;
gpu/drm/msm/dsi/dsi_host.c:	ret = devm_regulator_bulk_get(&msm_host->pdev->dev, num, s);
gpu/drm/msm/dsi/dsi_host.c:int dsi_clk_init_v2(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	struct platform_device *pdev = msm_host->pdev;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->src_clk = msm_clk_get(pdev, "src");
gpu/drm/msm/dsi/dsi_host.c:	if (IS_ERR(msm_host->src_clk)) {
gpu/drm/msm/dsi/dsi_host.c:		ret = PTR_ERR(msm_host->src_clk);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->src_clk = NULL;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->esc_clk_src = clk_get_parent(msm_host->esc_clk);
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->esc_clk_src) {
gpu/drm/msm/dsi/dsi_host.c:	msm_host->dsi_clk_src = clk_get_parent(msm_host->src_clk);
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->dsi_clk_src) {
gpu/drm/msm/dsi/dsi_host.c:int dsi_clk_init_6g_v2(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	struct platform_device *pdev = msm_host->pdev;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->byte_intf_clk = msm_clk_get(pdev, "byte_intf");
gpu/drm/msm/dsi/dsi_host.c:	if (IS_ERR(msm_host->byte_intf_clk)) {
gpu/drm/msm/dsi/dsi_host.c:		ret = PTR_ERR(msm_host->byte_intf_clk);
gpu/drm/msm/dsi/dsi_host.c:static int dsi_clk_init(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	struct platform_device *pdev = msm_host->pdev;
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_config *cfg = cfg_hnd->cfg;
gpu/drm/msm/dsi/dsi_host.c:		msm_host->bus_clks[i] = msm_clk_get(pdev,
gpu/drm/msm/dsi/dsi_host.c:		if (IS_ERR(msm_host->bus_clks[i])) {
gpu/drm/msm/dsi/dsi_host.c:			ret = PTR_ERR(msm_host->bus_clks[i]);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->byte_clk = msm_clk_get(pdev, "byte");
gpu/drm/msm/dsi/dsi_host.c:	if (IS_ERR(msm_host->byte_clk)) {
gpu/drm/msm/dsi/dsi_host.c:		ret = PTR_ERR(msm_host->byte_clk);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->byte_clk = NULL;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->pixel_clk = msm_clk_get(pdev, "pixel");
gpu/drm/msm/dsi/dsi_host.c:	if (IS_ERR(msm_host->pixel_clk)) {
gpu/drm/msm/dsi/dsi_host.c:		ret = PTR_ERR(msm_host->pixel_clk);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->pixel_clk = NULL;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->esc_clk = msm_clk_get(pdev, "core");
gpu/drm/msm/dsi/dsi_host.c:	if (IS_ERR(msm_host->esc_clk)) {
gpu/drm/msm/dsi/dsi_host.c:		ret = PTR_ERR(msm_host->esc_clk);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->esc_clk = NULL;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->byte_clk_src = clk_get_parent(msm_host->byte_clk);
gpu/drm/msm/dsi/dsi_host.c:	if (IS_ERR(msm_host->byte_clk_src)) {
gpu/drm/msm/dsi/dsi_host.c:		ret = PTR_ERR(msm_host->byte_clk_src);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->pixel_clk_src = clk_get_parent(msm_host->pixel_clk);
gpu/drm/msm/dsi/dsi_host.c:	if (IS_ERR(msm_host->pixel_clk_src)) {
gpu/drm/msm/dsi/dsi_host.c:		ret = PTR_ERR(msm_host->pixel_clk_src);
gpu/drm/msm/dsi/dsi_host.c:		ret = cfg_hnd->ops->clk_init_ver(msm_host);
gpu/drm/msm/dsi/dsi_host.c:static int dsi_bus_clk_enable(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_config *cfg = msm_host->cfg_hnd->cfg;
gpu/drm/msm/dsi/dsi_host.c:	DBG("id=%d", msm_host->id);
gpu/drm/msm/dsi/dsi_host.c:		ret = clk_prepare_enable(msm_host->bus_clks[i]);
gpu/drm/msm/dsi/dsi_host.c:		clk_disable_unprepare(msm_host->bus_clks[i]);
gpu/drm/msm/dsi/dsi_host.c:static void dsi_bus_clk_disable(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_config *cfg = msm_host->cfg_hnd->cfg;
gpu/drm/msm/dsi/dsi_host.c:		clk_disable_unprepare(msm_host->bus_clks[i]);
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_runtime_suspend(struct device *dev)
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi *msm_dsi = platform_get_drvdata(pdev);
gpu/drm/msm/dsi/dsi_host.c:	struct mipi_dsi_host *host = msm_dsi->host;
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->cfg_hnd)
gpu/drm/msm/dsi/dsi_host.c:	dsi_bus_clk_disable(msm_host);
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_runtime_resume(struct device *dev)
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi *msm_dsi = platform_get_drvdata(pdev);
gpu/drm/msm/dsi/dsi_host.c:	struct mipi_dsi_host *host = msm_dsi->host;
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->cfg_hnd)
gpu/drm/msm/dsi/dsi_host.c:	return dsi_bus_clk_enable(msm_host);
gpu/drm/msm/dsi/dsi_host.c:int dsi_link_clk_enable_6g(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:		msm_host->mode->clock, msm_host->byte_clk_rate);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_set_rate(msm_host->byte_clk, msm_host->byte_clk_rate);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_set_rate(msm_host->pixel_clk, msm_host->pixel_clk_rate);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->byte_intf_clk) {
gpu/drm/msm/dsi/dsi_host.c:		ret = clk_set_rate(msm_host->byte_intf_clk,
gpu/drm/msm/dsi/dsi_host.c:				   msm_host->byte_clk_rate / 2);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_prepare_enable(msm_host->esc_clk);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_prepare_enable(msm_host->byte_clk);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_prepare_enable(msm_host->pixel_clk);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->byte_intf_clk) {
gpu/drm/msm/dsi/dsi_host.c:		ret = clk_prepare_enable(msm_host->byte_intf_clk);
gpu/drm/msm/dsi/dsi_host.c:	clk_disable_unprepare(msm_host->pixel_clk);
gpu/drm/msm/dsi/dsi_host.c:	clk_disable_unprepare(msm_host->byte_clk);
gpu/drm/msm/dsi/dsi_host.c:	clk_disable_unprepare(msm_host->esc_clk);
gpu/drm/msm/dsi/dsi_host.c:int dsi_link_clk_enable_v2(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:		msm_host->mode->clock, msm_host->byte_clk_rate,
gpu/drm/msm/dsi/dsi_host.c:		msm_host->esc_clk_rate, msm_host->src_clk_rate);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_set_rate(msm_host->byte_clk, msm_host->byte_clk_rate);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_set_rate(msm_host->esc_clk, msm_host->esc_clk_rate);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_set_rate(msm_host->src_clk, msm_host->src_clk_rate);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_set_rate(msm_host->pixel_clk, msm_host->pixel_clk_rate);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_prepare_enable(msm_host->byte_clk);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_prepare_enable(msm_host->esc_clk);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_prepare_enable(msm_host->src_clk);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_prepare_enable(msm_host->pixel_clk);
gpu/drm/msm/dsi/dsi_host.c:	clk_disable_unprepare(msm_host->src_clk);
gpu/drm/msm/dsi/dsi_host.c:	clk_disable_unprepare(msm_host->esc_clk);
gpu/drm/msm/dsi/dsi_host.c:	clk_disable_unprepare(msm_host->byte_clk);
gpu/drm/msm/dsi/dsi_host.c:void dsi_link_clk_disable_6g(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	clk_disable_unprepare(msm_host->esc_clk);
gpu/drm/msm/dsi/dsi_host.c:	clk_disable_unprepare(msm_host->pixel_clk);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->byte_intf_clk)
gpu/drm/msm/dsi/dsi_host.c:		clk_disable_unprepare(msm_host->byte_intf_clk);
gpu/drm/msm/dsi/dsi_host.c:	clk_disable_unprepare(msm_host->byte_clk);
gpu/drm/msm/dsi/dsi_host.c:void dsi_link_clk_disable_v2(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	clk_disable_unprepare(msm_host->pixel_clk);
gpu/drm/msm/dsi/dsi_host.c:	clk_disable_unprepare(msm_host->src_clk);
gpu/drm/msm/dsi/dsi_host.c:	clk_disable_unprepare(msm_host->esc_clk);
gpu/drm/msm/dsi/dsi_host.c:	clk_disable_unprepare(msm_host->byte_clk);
gpu/drm/msm/dsi/dsi_host.c:static u32 dsi_get_pclk_rate(struct msm_dsi_host *msm_host, bool is_dual_dsi)
gpu/drm/msm/dsi/dsi_host.c:	struct drm_display_mode *mode = msm_host->mode;
gpu/drm/msm/dsi/dsi_host.c:static void dsi_calc_pclk(struct msm_dsi_host *msm_host, bool is_dual_dsi)
gpu/drm/msm/dsi/dsi_host.c:	u8 lanes = msm_host->lanes;
gpu/drm/msm/dsi/dsi_host.c:	u32 bpp = dsi_get_bpp(msm_host->format);
gpu/drm/msm/dsi/dsi_host.c:	u32 pclk_rate = dsi_get_pclk_rate(msm_host, is_dual_dsi);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->pixel_clk_rate = pclk_rate;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->byte_clk_rate = pclk_bpp;
gpu/drm/msm/dsi/dsi_host.c:	DBG("pclk=%d, bclk=%d", msm_host->pixel_clk_rate,
gpu/drm/msm/dsi/dsi_host.c:				msm_host->byte_clk_rate);
gpu/drm/msm/dsi/dsi_host.c:int dsi_calc_clk_rate_6g(struct msm_dsi_host *msm_host, bool is_dual_dsi)
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->mode) {
gpu/drm/msm/dsi/dsi_host.c:	dsi_calc_pclk(msm_host, is_dual_dsi);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->esc_clk_rate = clk_get_rate(msm_host->esc_clk);
gpu/drm/msm/dsi/dsi_host.c:int dsi_calc_clk_rate_v2(struct msm_dsi_host *msm_host, bool is_dual_dsi)
gpu/drm/msm/dsi/dsi_host.c:	u32 bpp = dsi_get_bpp(msm_host->format);
gpu/drm/msm/dsi/dsi_host.c:	dsi_calc_pclk(msm_host, is_dual_dsi);
gpu/drm/msm/dsi/dsi_host.c:	pclk_bpp = (u64)dsi_get_pclk_rate(msm_host, is_dual_dsi) * bpp;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->src_clk_rate = pclk_bpp;
gpu/drm/msm/dsi/dsi_host.c:	byte_mhz = msm_host->byte_clk_rate / 1000000;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->esc_clk_rate = msm_host->byte_clk_rate / esc_div;
gpu/drm/msm/dsi/dsi_host.c:	DBG("esc=%d, src=%d", msm_host->esc_clk_rate,
gpu/drm/msm/dsi/dsi_host.c:		msm_host->src_clk_rate);
gpu/drm/msm/dsi/dsi_host.c:static void dsi_intr_ctrl(struct msm_dsi_host *msm_host, u32 mask, int enable)
gpu/drm/msm/dsi/dsi_host.c:	spin_lock_irqsave(&msm_host->intr_lock, flags);
gpu/drm/msm/dsi/dsi_host.c:	intr = dsi_read(msm_host, REG_DSI_INTR_CTRL);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_INTR_CTRL, intr);
gpu/drm/msm/dsi/dsi_host.c:	spin_unlock_irqrestore(&msm_host->intr_lock, flags);
gpu/drm/msm/dsi/dsi_host.c:static void dsi_ctrl_config(struct msm_dsi_host *msm_host, bool enable,
gpu/drm/msm/dsi/dsi_host.c:			struct msm_dsi_phy_shared_timings *phy_shared_timings)
gpu/drm/msm/dsi/dsi_host.c:	u32 flags = msm_host->mode_flags;
gpu/drm/msm/dsi/dsi_host.c:	enum mipi_dsi_pixel_format mipi_fmt = msm_host->format;
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_CTRL, 0);
gpu/drm/msm/dsi/dsi_host.c:		data |= DSI_VID_CFG0_VIRT_CHANNEL(msm_host->channel);
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_VID_CFG0, data);
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_VID_CFG1, 0);
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_CMD_CFG0, data);
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_CMD_CFG1, data);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_CMD_DMA_CTRL,
gpu/drm/msm/dsi/dsi_host.c:	data |= DSI_TRIG_CTRL_STREAM(msm_host->channel);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_TRIG_CTRL, data);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_CLKOUT_TIMING_CTRL, data);
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_T_CLK_PRE_EXTEND,
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_EOT_PACKET_CTRL, data);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_ERR_INT_MASK0, 0x13ff3fe0);
gpu/drm/msm/dsi/dsi_host.c:	dsi_intr_ctrl(msm_host, DSI_IRQ_MASK_ERROR, 1);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_CLK_CTRL, DSI_CLK_CTRL_ENABLE_CLKS);
gpu/drm/msm/dsi/dsi_host.c:	DBG("lane number=%d", msm_host->lanes);
gpu/drm/msm/dsi/dsi_host.c:	data |= ((DSI_CTRL_LANE0 << msm_host->lanes) - DSI_CTRL_LANE0);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_LANE_SWAP_CTRL,
gpu/drm/msm/dsi/dsi_host.c:		  DSI_LANE_SWAP_CTRL_DLN_SWAP_SEL(msm_host->dlane_swap));
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_LANE_CTRL,
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_CTRL, data);
gpu/drm/msm/dsi/dsi_host.c:static void dsi_timing_setup(struct msm_dsi_host *msm_host, bool is_dual_dsi)
gpu/drm/msm/dsi/dsi_host.c:	struct drm_display_mode *mode = msm_host->mode;
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->mode_flags & MIPI_DSI_MODE_VIDEO) {
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_ACTIVE_H,
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_ACTIVE_V,
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_TOTAL,
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_ACTIVE_HSYNC,
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_ACTIVE_VSYNC_HPOS, 0);
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_ACTIVE_VSYNC_VPOS,
gpu/drm/msm/dsi/dsi_host.c:		wc = hdisplay * dsi_get_bpp(msm_host->format) / 8 + 1;
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_CMD_MDP_STREAM_CTRL,
gpu/drm/msm/dsi/dsi_host.c:					msm_host->channel) |
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_CMD_MDP_STREAM_TOTAL,
gpu/drm/msm/dsi/dsi_host.c:static void dsi_sw_reset(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_CLK_CTRL, DSI_CLK_CTRL_ENABLE_CLKS);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_RESET, 1);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_RESET, 0);
gpu/drm/msm/dsi/dsi_host.c:static void dsi_op_mode_config(struct msm_dsi_host *msm_host,
gpu/drm/msm/dsi/dsi_host.c:	dsi_ctrl = dsi_read(msm_host, REG_DSI_CTRL);
gpu/drm/msm/dsi/dsi_host.c:		dsi_intr_ctrl(msm_host, DSI_IRQ_MASK_CMD_MDP_DONE |
gpu/drm/msm/dsi/dsi_host.c:			dsi_intr_ctrl(msm_host, DSI_IRQ_MASK_CMD_MDP_DONE, 1);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_CTRL, dsi_ctrl);
gpu/drm/msm/dsi/dsi_host.c:static void dsi_set_tx_power_mode(int mode, struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	data = dsi_read(msm_host, REG_DSI_CMD_DMA_CTRL);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_CMD_DMA_CTRL, data);
gpu/drm/msm/dsi/dsi_host.c:static void dsi_wait4video_done(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	struct device *dev = &msm_host->pdev->dev;
gpu/drm/msm/dsi/dsi_host.c:	dsi_intr_ctrl(msm_host, DSI_IRQ_MASK_VIDEO_DONE, 1);
gpu/drm/msm/dsi/dsi_host.c:	reinit_completion(&msm_host->video_comp);
gpu/drm/msm/dsi/dsi_host.c:	ret = wait_for_completion_timeout(&msm_host->video_comp,
gpu/drm/msm/dsi/dsi_host.c:	dsi_intr_ctrl(msm_host, DSI_IRQ_MASK_VIDEO_DONE, 0);
gpu/drm/msm/dsi/dsi_host.c:static void dsi_wait4video_eng_busy(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	if (!(msm_host->mode_flags & MIPI_DSI_MODE_VIDEO))
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->power_on && msm_host->enabled) {
gpu/drm/msm/dsi/dsi_host.c:		dsi_wait4video_done(msm_host);
gpu/drm/msm/dsi/dsi_host.c:int dsi_tx_buf_alloc_6g(struct msm_dsi_host *msm_host, int size)
gpu/drm/msm/dsi/dsi_host.c:	struct drm_device *dev = msm_host->dev;
gpu/drm/msm/dsi/dsi_host.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/dsi/dsi_host.c:	data = msm_gem_kernel_new(dev, size, MSM_BO_UNCACHED,
gpu/drm/msm/dsi/dsi_host.c:					&msm_host->tx_gem_obj, &iova);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->tx_gem_obj = NULL;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->tx_size = msm_host->tx_gem_obj->size;
gpu/drm/msm/dsi/dsi_host.c:int dsi_tx_buf_alloc_v2(struct msm_dsi_host *msm_host, int size)
gpu/drm/msm/dsi/dsi_host.c:	struct drm_device *dev = msm_host->dev;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->tx_buf = dma_alloc_coherent(dev->dev, size,
gpu/drm/msm/dsi/dsi_host.c:					&msm_host->tx_buf_paddr, GFP_KERNEL);
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->tx_buf)
gpu/drm/msm/dsi/dsi_host.c:	msm_host->tx_size = size;
gpu/drm/msm/dsi/dsi_host.c:static void dsi_tx_buf_free(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	struct drm_device *dev = msm_host->dev;
gpu/drm/msm/dsi/dsi_host.c:	struct msm_drm_private *priv;
gpu/drm/msm/dsi/dsi_host.c:	 * in which case we'll hit msm_dsi_host_destroy() without having run
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->tx_gem_obj) {
gpu/drm/msm/dsi/dsi_host.c:		msm_gem_put_iova(msm_host->tx_gem_obj, priv->kms->aspace);
gpu/drm/msm/dsi/dsi_host.c:		drm_gem_object_put_unlocked(msm_host->tx_gem_obj);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->tx_gem_obj = NULL;
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->tx_buf)
gpu/drm/msm/dsi/dsi_host.c:		dma_free_coherent(dev->dev, msm_host->tx_size, msm_host->tx_buf,
gpu/drm/msm/dsi/dsi_host.c:			msm_host->tx_buf_paddr);
gpu/drm/msm/dsi/dsi_host.c:void *dsi_tx_buf_get_6g(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	return msm_gem_get_vaddr(msm_host->tx_gem_obj);
gpu/drm/msm/dsi/dsi_host.c:void *dsi_tx_buf_get_v2(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	return msm_host->tx_buf;
gpu/drm/msm/dsi/dsi_host.c:void dsi_tx_buf_put_6g(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	msm_gem_put_vaddr(msm_host->tx_gem_obj);
gpu/drm/msm/dsi/dsi_host.c:static int dsi_cmd_dma_add(struct msm_dsi_host *msm_host,
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;
gpu/drm/msm/dsi/dsi_host.c:	if (len > msm_host->tx_size) {
gpu/drm/msm/dsi/dsi_host.c:	data = cfg_hnd->ops->tx_buf_get(msm_host);
gpu/drm/msm/dsi/dsi_host.c:		cfg_hnd->ops->tx_buf_put(msm_host);
gpu/drm/msm/dsi/dsi_host.c:int dsi_dma_base_get_6g(struct msm_dsi_host *msm_host, uint64_t *dma_base)
gpu/drm/msm/dsi/dsi_host.c:	struct drm_device *dev = msm_host->dev;
gpu/drm/msm/dsi/dsi_host.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/dsi/dsi_host.c:	return msm_gem_get_iova(msm_host->tx_gem_obj,
gpu/drm/msm/dsi/dsi_host.c:int dsi_dma_base_get_v2(struct msm_dsi_host *msm_host, uint64_t *dma_base)
gpu/drm/msm/dsi/dsi_host.c:	*dma_base = msm_host->tx_buf_paddr;
gpu/drm/msm/dsi/dsi_host.c:static int dsi_cmd_dma_tx(struct msm_dsi_host *msm_host, int len)
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;
gpu/drm/msm/dsi/dsi_host.c:	ret = cfg_hnd->ops->dma_base_get(msm_host, &dma_base);
gpu/drm/msm/dsi/dsi_host.c:	reinit_completion(&msm_host->dma_comp);
gpu/drm/msm/dsi/dsi_host.c:	dsi_wait4video_eng_busy(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	triggered = msm_dsi_manager_cmd_xfer_trigger(
gpu/drm/msm/dsi/dsi_host.c:						msm_host->id, dma_base, len);
gpu/drm/msm/dsi/dsi_host.c:		ret = wait_for_completion_timeout(&msm_host->dma_comp,
gpu/drm/msm/dsi/dsi_host.c:static int dsi_cmd_dma_rx(struct msm_dsi_host *msm_host,
gpu/drm/msm/dsi/dsi_host.c:	int buf_offset = buf - msm_host->rx_buf;
gpu/drm/msm/dsi/dsi_host.c:		data = dsi_read(msm_host, REG_DSI_RDBK_DATA(i));
gpu/drm/msm/dsi/dsi_host.c:static int dsi_cmds2buf_tx(struct msm_dsi_host *msm_host,
gpu/drm/msm/dsi/dsi_host.c:	int bllp_len = msm_host->mode->hdisplay *
gpu/drm/msm/dsi/dsi_host.c:			dsi_get_bpp(msm_host->format) / 8;
gpu/drm/msm/dsi/dsi_host.c:	len = dsi_cmd_dma_add(msm_host, msg);
gpu/drm/msm/dsi/dsi_host.c:	if ((msm_host->mode_flags & MIPI_DSI_MODE_VIDEO) && (len > bllp_len)) {
gpu/drm/msm/dsi/dsi_host.c:	ret = dsi_cmd_dma_tx(msm_host, len);
gpu/drm/msm/dsi/dsi_host.c:static void dsi_sw_reset_restore(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	data0 = dsi_read(msm_host, REG_DSI_CTRL);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_CTRL, data1);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_CLK_CTRL, DSI_CLK_CTRL_ENABLE_CLKS);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_RESET, 1);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_RESET, 0);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_CTRL, data0);
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host =
gpu/drm/msm/dsi/dsi_host.c:		container_of(work, struct msm_dsi_host, hpd_work);
gpu/drm/msm/dsi/dsi_host.c:	drm_helper_hpd_irq_event(msm_host->dev);
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host =
gpu/drm/msm/dsi/dsi_host.c:		container_of(work, struct msm_dsi_host, err_work);
gpu/drm/msm/dsi/dsi_host.c:	u32 status = msm_host->err_work_state;
gpu/drm/msm/dsi/dsi_host.c:		dsi_sw_reset_restore(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->err_work_state = 0;
gpu/drm/msm/dsi/dsi_host.c:	dsi_intr_ctrl(msm_host, DSI_IRQ_MASK_ERROR, 1);
gpu/drm/msm/dsi/dsi_host.c:static void dsi_ack_err_status(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	status = dsi_read(msm_host, REG_DSI_ACK_ERR_STATUS);
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_ACK_ERR_STATUS, status);
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_ACK_ERR_STATUS, 0);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->err_work_state |= DSI_ERR_STATE_ACK;
gpu/drm/msm/dsi/dsi_host.c:static void dsi_timeout_status(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	status = dsi_read(msm_host, REG_DSI_TIMEOUT_STATUS);
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_TIMEOUT_STATUS, status);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->err_work_state |= DSI_ERR_STATE_TIMEOUT;
gpu/drm/msm/dsi/dsi_host.c:static void dsi_dln0_phy_err(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	status = dsi_read(msm_host, REG_DSI_DLN0_PHY_ERR);
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_DLN0_PHY_ERR, status);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->err_work_state |= DSI_ERR_STATE_DLN0_PHY;
gpu/drm/msm/dsi/dsi_host.c:static void dsi_fifo_status(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	status = dsi_read(msm_host, REG_DSI_FIFO_STATUS);
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_FIFO_STATUS, status);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->err_work_state |= DSI_ERR_STATE_FIFO;
gpu/drm/msm/dsi/dsi_host.c:			msm_host->err_work_state |=
gpu/drm/msm/dsi/dsi_host.c:static void dsi_status(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	status = dsi_read(msm_host, REG_DSI_STATUS0);
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_STATUS0, status);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->err_work_state |=
gpu/drm/msm/dsi/dsi_host.c:static void dsi_clk_status(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	status = dsi_read(msm_host, REG_DSI_CLK_STATUS);
gpu/drm/msm/dsi/dsi_host.c:		dsi_write(msm_host, REG_DSI_CLK_STATUS, status);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->err_work_state |= DSI_ERR_STATE_PLL_UNLOCKED;
gpu/drm/msm/dsi/dsi_host.c:static void dsi_error(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	dsi_intr_ctrl(msm_host, DSI_IRQ_MASK_ERROR, 0);
gpu/drm/msm/dsi/dsi_host.c:	dsi_clk_status(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	dsi_fifo_status(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	dsi_ack_err_status(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	dsi_timeout_status(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	dsi_status(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	dsi_dln0_phy_err(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	queue_work(msm_host->workqueue, &msm_host->err_work);
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = ptr;
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->ctrl_base)
gpu/drm/msm/dsi/dsi_host.c:	spin_lock_irqsave(&msm_host->intr_lock, flags);
gpu/drm/msm/dsi/dsi_host.c:	isr = dsi_read(msm_host, REG_DSI_INTR_CTRL);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_INTR_CTRL, isr);
gpu/drm/msm/dsi/dsi_host.c:	spin_unlock_irqrestore(&msm_host->intr_lock, flags);
gpu/drm/msm/dsi/dsi_host.c:	DBG("isr=0x%x, id=%d", isr, msm_host->id);
gpu/drm/msm/dsi/dsi_host.c:		dsi_error(msm_host);
gpu/drm/msm/dsi/dsi_host.c:		complete(&msm_host->video_comp);
gpu/drm/msm/dsi/dsi_host.c:		complete(&msm_host->dma_comp);
gpu/drm/msm/dsi/dsi_host.c:static int dsi_host_init_panel_gpios(struct msm_dsi_host *msm_host,
gpu/drm/msm/dsi/dsi_host.c:	msm_host->disp_en_gpio = devm_gpiod_get_optional(panel_device,
gpu/drm/msm/dsi/dsi_host.c:	if (IS_ERR(msm_host->disp_en_gpio)) {
gpu/drm/msm/dsi/dsi_host.c:				PTR_ERR(msm_host->disp_en_gpio));
gpu/drm/msm/dsi/dsi_host.c:		return PTR_ERR(msm_host->disp_en_gpio);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->te_gpio = devm_gpiod_get_optional(panel_device, "disp-te",
gpu/drm/msm/dsi/dsi_host.c:	if (IS_ERR(msm_host->te_gpio)) {
gpu/drm/msm/dsi/dsi_host.c:		DBG("cannot get disp-te-gpios %ld", PTR_ERR(msm_host->te_gpio));
gpu/drm/msm/dsi/dsi_host.c:		return PTR_ERR(msm_host->te_gpio);
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	if (dsi->lanes > msm_host->num_data_lanes)
gpu/drm/msm/dsi/dsi_host.c:	msm_host->channel = dsi->channel;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->lanes = dsi->lanes;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->format = dsi->format;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->mode_flags = dsi->mode_flags;
gpu/drm/msm/dsi/dsi_host.c:	msm_dsi_manager_attach_dsi_device(msm_host->id, dsi->mode_flags);
gpu/drm/msm/dsi/dsi_host.c:	ret = dsi_host_init_panel_gpios(msm_host, &dsi->dev);
gpu/drm/msm/dsi/dsi_host.c:	DBG("id=%d", msm_host->id);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->dev)
gpu/drm/msm/dsi/dsi_host.c:		queue_work(msm_host->workqueue, &msm_host->hpd_work);
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->device_node = NULL;
gpu/drm/msm/dsi/dsi_host.c:	DBG("id=%d", msm_host->id);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->dev)
gpu/drm/msm/dsi/dsi_host.c:		queue_work(msm_host->workqueue, &msm_host->hpd_work);
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	if (!msg || !msm_host->power_on)
gpu/drm/msm/dsi/dsi_host.c:	mutex_lock(&msm_host->cmd_mutex);
gpu/drm/msm/dsi/dsi_host.c:	ret = msm_dsi_manager_cmd_xfer(msm_host->id, msg);
gpu/drm/msm/dsi/dsi_host.c:	mutex_unlock(&msm_host->cmd_mutex);
gpu/drm/msm/dsi/dsi_host.c:static int dsi_host_parse_lane_data(struct msm_dsi_host *msm_host,
gpu/drm/msm/dsi/dsi_host.c:	struct device *dev = &msm_host->pdev->dev;
gpu/drm/msm/dsi/dsi_host.c:		msm_host->num_data_lanes = 4;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->num_data_lanes = num_lanes;
gpu/drm/msm/dsi/dsi_host.c:			msm_host->dlane_swap = i;
gpu/drm/msm/dsi/dsi_host.c:static int dsi_host_parse_dt(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	struct device *dev = &msm_host->pdev->dev;
gpu/drm/msm/dsi/dsi_host.c:	ret = dsi_host_parse_lane_data(msm_host, endpoint);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->device_node = device_node;
gpu/drm/msm/dsi/dsi_host.c:		msm_host->sfpb = syscon_regmap_lookup_by_phandle(np,
gpu/drm/msm/dsi/dsi_host.c:		if (IS_ERR(msm_host->sfpb)) {
gpu/drm/msm/dsi/dsi_host.c:			ret = PTR_ERR(msm_host->sfpb);
gpu/drm/msm/dsi/dsi_host.c:static int dsi_host_get_id(struct msm_dsi_host *msm_host)
gpu/drm/msm/dsi/dsi_host.c:	struct platform_device *pdev = msm_host->pdev;
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_config *cfg = msm_host->cfg_hnd->cfg;
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_host_init(struct msm_dsi *msm_dsi)
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = NULL;
gpu/drm/msm/dsi/dsi_host.c:	struct platform_device *pdev = msm_dsi->pdev;
gpu/drm/msm/dsi/dsi_host.c:	msm_host = devm_kzalloc(&pdev->dev, sizeof(*msm_host), GFP_KERNEL);
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host) {
gpu/drm/msm/dsi/dsi_host.c:	msm_host->pdev = pdev;
gpu/drm/msm/dsi/dsi_host.c:	msm_dsi->host = &msm_host->base;
gpu/drm/msm/dsi/dsi_host.c:	ret = dsi_host_parse_dt(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->ctrl_base = msm_ioremap(pdev, "dsi_ctrl", "DSI CTRL");
gpu/drm/msm/dsi/dsi_host.c:	if (IS_ERR(msm_host->ctrl_base)) {
gpu/drm/msm/dsi/dsi_host.c:		ret = PTR_ERR(msm_host->ctrl_base);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->cfg_hnd = dsi_get_config(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->cfg_hnd) {
gpu/drm/msm/dsi/dsi_host.c:	msm_host->id = dsi_host_get_id(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->id < 0) {
gpu/drm/msm/dsi/dsi_host.c:		ret = msm_host->id;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->ctrl_base += msm_host->cfg_hnd->cfg->io_offset;
gpu/drm/msm/dsi/dsi_host.c:	ret = dsi_regulator_init(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	ret = dsi_clk_init(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->rx_buf = devm_kzalloc(&pdev->dev, SZ_4K, GFP_KERNEL);
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->rx_buf) {
gpu/drm/msm/dsi/dsi_host.c:	init_completion(&msm_host->dma_comp);
gpu/drm/msm/dsi/dsi_host.c:	init_completion(&msm_host->video_comp);
gpu/drm/msm/dsi/dsi_host.c:	mutex_init(&msm_host->dev_mutex);
gpu/drm/msm/dsi/dsi_host.c:	mutex_init(&msm_host->cmd_mutex);
gpu/drm/msm/dsi/dsi_host.c:	spin_lock_init(&msm_host->intr_lock);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->workqueue = alloc_ordered_workqueue("dsi_drm_work", 0);
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->workqueue)
gpu/drm/msm/dsi/dsi_host.c:	INIT_WORK(&msm_host->err_work, dsi_err_worker);
gpu/drm/msm/dsi/dsi_host.c:	INIT_WORK(&msm_host->hpd_work, dsi_hpd_worker);
gpu/drm/msm/dsi/dsi_host.c:	msm_dsi->id = msm_host->id;
gpu/drm/msm/dsi/dsi_host.c:	DBG("Dsi Host %d initialized", msm_host->id);
gpu/drm/msm/dsi/dsi_host.c:void msm_dsi_host_destroy(struct mipi_dsi_host *host)
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	dsi_tx_buf_free(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->workqueue) {
gpu/drm/msm/dsi/dsi_host.c:		flush_workqueue(msm_host->workqueue);
gpu/drm/msm/dsi/dsi_host.c:		destroy_workqueue(msm_host->workqueue);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->workqueue = NULL;
gpu/drm/msm/dsi/dsi_host.c:	mutex_destroy(&msm_host->cmd_mutex);
gpu/drm/msm/dsi/dsi_host.c:	mutex_destroy(&msm_host->dev_mutex);
gpu/drm/msm/dsi/dsi_host.c:	pm_runtime_disable(&msm_host->pdev->dev);
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_host_modeset_init(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;
gpu/drm/msm/dsi/dsi_host.c:	struct platform_device *pdev = msm_host->pdev;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->irq < 0) {
gpu/drm/msm/dsi/dsi_host.c:		ret = msm_host->irq;
gpu/drm/msm/dsi/dsi_host.c:	ret = devm_request_irq(&pdev->dev, msm_host->irq,
gpu/drm/msm/dsi/dsi_host.c:			"dsi_isr", msm_host);
gpu/drm/msm/dsi/dsi_host.c:				msm_host->irq, ret);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->dev = dev;
gpu/drm/msm/dsi/dsi_host.c:	ret = cfg_hnd->ops->tx_buf_alloc(msm_host, SZ_4K);
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_host_register(struct mipi_dsi_host *host, bool check_defer)
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->registered) {
gpu/drm/msm/dsi/dsi_host.c:		host->dev = &msm_host->pdev->dev;
gpu/drm/msm/dsi/dsi_host.c:		msm_host->registered = true;
gpu/drm/msm/dsi/dsi_host.c:		if (check_defer && msm_host->device_node) {
gpu/drm/msm/dsi/dsi_host.c:			if (IS_ERR(of_drm_find_panel(msm_host->device_node)))
gpu/drm/msm/dsi/dsi_host.c:				if (!of_drm_find_bridge(msm_host->device_node))
gpu/drm/msm/dsi/dsi_host.c:void msm_dsi_host_unregister(struct mipi_dsi_host *host)
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->registered) {
gpu/drm/msm/dsi/dsi_host.c:		msm_host->registered = false;
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_host_xfer_prepare(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;
gpu/drm/msm/dsi/dsi_host.c:	pm_runtime_get_sync(&msm_host->pdev->dev);
gpu/drm/msm/dsi/dsi_host.c:	cfg_hnd->ops->link_clk_enable(msm_host);
gpu/drm/msm/dsi/dsi_host.c:		dsi_set_tx_power_mode(0, msm_host);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->dma_cmd_ctrl_restore = dsi_read(msm_host, REG_DSI_CTRL);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_CTRL,
gpu/drm/msm/dsi/dsi_host.c:		msm_host->dma_cmd_ctrl_restore |
gpu/drm/msm/dsi/dsi_host.c:	dsi_intr_ctrl(msm_host, DSI_IRQ_MASK_CMD_DMA_DONE, 1);
gpu/drm/msm/dsi/dsi_host.c:void msm_dsi_host_xfer_restore(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;
gpu/drm/msm/dsi/dsi_host.c:	dsi_intr_ctrl(msm_host, DSI_IRQ_MASK_CMD_DMA_DONE, 0);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_CTRL, msm_host->dma_cmd_ctrl_restore);
gpu/drm/msm/dsi/dsi_host.c:		dsi_set_tx_power_mode(1, msm_host);
gpu/drm/msm/dsi/dsi_host.c:	cfg_hnd->ops->link_clk_disable(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	pm_runtime_put_autosuspend(&msm_host->pdev->dev);
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_host_cmd_tx(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	return dsi_cmds2buf_tx(msm_host, msg);
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_host_cmd_rx(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;
gpu/drm/msm/dsi/dsi_host.c:	buf = msm_host->rx_buf;
gpu/drm/msm/dsi/dsi_host.c:		ret = dsi_cmds2buf_tx(msm_host, &max_pkt_size_msg);
gpu/drm/msm/dsi/dsi_host.c:			dsi_write(msm_host, REG_DSI_RDBK_DATA_CTRL,
gpu/drm/msm/dsi/dsi_host.c:			dsi_write(msm_host, REG_DSI_RDBK_DATA_CTRL, 0);
gpu/drm/msm/dsi/dsi_host.c:		ret = dsi_cmds2buf_tx(msm_host, msg);
gpu/drm/msm/dsi/dsi_host.c:		dlen = dsi_cmd_dma_rx(msm_host, buf, rx_byte, pkt_size);
gpu/drm/msm/dsi/dsi_host.c:		buf = msm_host->rx_buf + (10 - rlen);
gpu/drm/msm/dsi/dsi_host.c:		buf = msm_host->rx_buf;
gpu/drm/msm/dsi/dsi_host.c:void msm_dsi_host_cmd_xfer_commit(struct mipi_dsi_host *host, u32 dma_base,
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_DMA_BASE, dma_base);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_DMA_LEN, len);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_TRIG_DMA, 1);
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_host_set_src_pll(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_pll *src_pll)
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	ret = msm_dsi_pll_get_clk_provider(src_pll,
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_set_parent(msm_host->byte_clk_src, byte_clk_provider);
gpu/drm/msm/dsi/dsi_host.c:	ret = clk_set_parent(msm_host->pixel_clk_src, pixel_clk_provider);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->dsi_clk_src) {
gpu/drm/msm/dsi/dsi_host.c:		ret = clk_set_parent(msm_host->dsi_clk_src, pixel_clk_provider);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->esc_clk_src) {
gpu/drm/msm/dsi/dsi_host.c:		ret = clk_set_parent(msm_host->esc_clk_src, byte_clk_provider);
gpu/drm/msm/dsi/dsi_host.c:void msm_dsi_host_reset_phy(struct mipi_dsi_host *host)
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_PHY_RESET, DSI_PHY_RESET_RESET);
gpu/drm/msm/dsi/dsi_host.c:	dsi_write(msm_host, REG_DSI_PHY_RESET, 0);
gpu/drm/msm/dsi/dsi_host.c:void msm_dsi_host_get_phy_clk_req(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi_host.c:			struct msm_dsi_phy_clk_request *clk_req,
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;
gpu/drm/msm/dsi/dsi_host.c:	ret = cfg_hnd->ops->calc_clk_rate(msm_host, is_dual_dsi);
gpu/drm/msm/dsi/dsi_host.c:	clk_req->bitclk_rate = msm_host->byte_clk_rate * 8;
gpu/drm/msm/dsi/dsi_host.c:	clk_req->escclk_rate = msm_host->esc_clk_rate;
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_host_enable(struct mipi_dsi_host *host)
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	dsi_op_mode_config(msm_host,
gpu/drm/msm/dsi/dsi_host.c:		!!(msm_host->mode_flags & MIPI_DSI_MODE_VIDEO), true);
gpu/drm/msm/dsi/dsi_host.c:	/* if (msm_panel->mode == MSM_DSI_CMD_MODE) {
gpu/drm/msm/dsi/dsi_host.c:	 *	dsi_link_clk_disable(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	 *	pm_runtime_put_autosuspend(&msm_host->pdev->dev);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->enabled = true;
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_host_disable(struct mipi_dsi_host *host)
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->enabled = false;
gpu/drm/msm/dsi/dsi_host.c:	dsi_op_mode_config(msm_host,
gpu/drm/msm/dsi/dsi_host.c:		!!(msm_host->mode_flags & MIPI_DSI_MODE_VIDEO), false);
gpu/drm/msm/dsi/dsi_host.c:	dsi_sw_reset(msm_host);
gpu/drm/msm/dsi/dsi_host.c:static void msm_dsi_sfpb_config(struct msm_dsi_host *msm_host, bool enable)
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->sfpb)
gpu/drm/msm/dsi/dsi_host.c:	regmap_update_bits(msm_host->sfpb, REG_SFPB_GPREG,
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_host_power_on(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi_host.c:			struct msm_dsi_phy_shared_timings *phy_shared_timings,
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;
gpu/drm/msm/dsi/dsi_host.c:	mutex_lock(&msm_host->dev_mutex);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->power_on) {
gpu/drm/msm/dsi/dsi_host.c:	msm_dsi_sfpb_config(msm_host, true);
gpu/drm/msm/dsi/dsi_host.c:	ret = dsi_host_regulator_enable(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	pm_runtime_get_sync(&msm_host->pdev->dev);
gpu/drm/msm/dsi/dsi_host.c:	ret = cfg_hnd->ops->link_clk_enable(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	ret = pinctrl_pm_select_default_state(&msm_host->pdev->dev);
gpu/drm/msm/dsi/dsi_host.c:	dsi_timing_setup(msm_host, is_dual_dsi);
gpu/drm/msm/dsi/dsi_host.c:	dsi_sw_reset(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	dsi_ctrl_config(msm_host, true, phy_shared_timings);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->disp_en_gpio)
gpu/drm/msm/dsi/dsi_host.c:		gpiod_set_value(msm_host->disp_en_gpio, 1);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->power_on = true;
gpu/drm/msm/dsi/dsi_host.c:	mutex_unlock(&msm_host->dev_mutex);
gpu/drm/msm/dsi/dsi_host.c:	cfg_hnd->ops->link_clk_disable(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	pm_runtime_put_autosuspend(&msm_host->pdev->dev);
gpu/drm/msm/dsi/dsi_host.c:	dsi_host_regulator_disable(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	mutex_unlock(&msm_host->dev_mutex);
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_host_power_off(struct mipi_dsi_host *host)
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	const struct msm_dsi_cfg_handler *cfg_hnd = msm_host->cfg_hnd;
gpu/drm/msm/dsi/dsi_host.c:	mutex_lock(&msm_host->dev_mutex);
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->power_on) {
gpu/drm/msm/dsi/dsi_host.c:	dsi_ctrl_config(msm_host, false, NULL);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->disp_en_gpio)
gpu/drm/msm/dsi/dsi_host.c:		gpiod_set_value(msm_host->disp_en_gpio, 0);
gpu/drm/msm/dsi/dsi_host.c:	pinctrl_pm_select_sleep_state(&msm_host->pdev->dev);
gpu/drm/msm/dsi/dsi_host.c:	cfg_hnd->ops->link_clk_disable(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	pm_runtime_put_autosuspend(&msm_host->pdev->dev);
gpu/drm/msm/dsi/dsi_host.c:	dsi_host_regulator_disable(msm_host);
gpu/drm/msm/dsi/dsi_host.c:	msm_dsi_sfpb_config(msm_host, false);
gpu/drm/msm/dsi/dsi_host.c:	msm_host->power_on = false;
gpu/drm/msm/dsi/dsi_host.c:	mutex_unlock(&msm_host->dev_mutex);
gpu/drm/msm/dsi/dsi_host.c:int msm_dsi_host_set_display_mode(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	if (msm_host->mode) {
gpu/drm/msm/dsi/dsi_host.c:		drm_mode_destroy(msm_host->dev, msm_host->mode);
gpu/drm/msm/dsi/dsi_host.c:		msm_host->mode = NULL;
gpu/drm/msm/dsi/dsi_host.c:	msm_host->mode = drm_mode_duplicate(msm_host->dev, mode);
gpu/drm/msm/dsi/dsi_host.c:	if (!msm_host->mode) {
gpu/drm/msm/dsi/dsi_host.c:struct drm_panel *msm_dsi_host_get_panel(struct mipi_dsi_host *host,
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	panel = of_drm_find_panel(msm_host->device_node);
gpu/drm/msm/dsi/dsi_host.c:			*panel_flags = msm_host->mode_flags;
gpu/drm/msm/dsi/dsi_host.c:struct drm_bridge *msm_dsi_host_get_bridge(struct mipi_dsi_host *host)
gpu/drm/msm/dsi/dsi_host.c:	struct msm_dsi_host *msm_host = to_msm_dsi_host(host);
gpu/drm/msm/dsi/dsi_host.c:	return of_drm_find_bridge(msm_host->device_node);
gpu/drm/msm/dsi/dsi_manager.c:#include "msm_kms.h"
gpu/drm/msm/dsi/dsi_manager.c:struct msm_dsi_manager {
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *dsi[DSI_MAX];
gpu/drm/msm/dsi/dsi_manager.c:static struct msm_dsi_manager msm_dsim_glb;
gpu/drm/msm/dsi/dsi_manager.c:#define IS_DUAL_DSI()		(msm_dsim_glb.is_dual_dsi)
gpu/drm/msm/dsi/dsi_manager.c:#define IS_SYNC_NEEDED()	(msm_dsim_glb.is_sync_needed)
gpu/drm/msm/dsi/dsi_manager.c:#define IS_MASTER_DSI_LINK(id)	(msm_dsim_glb.master_dsi_link_id == id)
gpu/drm/msm/dsi/dsi_manager.c:static inline struct msm_dsi *dsi_mgr_get_dsi(int id)
gpu/drm/msm/dsi/dsi_manager.c:	return msm_dsim_glb.dsi[id];
gpu/drm/msm/dsi/dsi_manager.c:static inline struct msm_dsi *dsi_mgr_get_other_dsi(int id)
gpu/drm/msm/dsi/dsi_manager.c:	return msm_dsim_glb.dsi[(id + 1) % DSI_MAX];
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi_manager *msm_dsim = &msm_dsim_glb;
gpu/drm/msm/dsi/dsi_manager.c:	if (!msm_dsim->is_dual_dsi)
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsim->is_dual_dsi = of_property_read_bool(
gpu/drm/msm/dsi/dsi_manager.c:	if (msm_dsim->is_dual_dsi) {
gpu/drm/msm/dsi/dsi_manager.c:			msm_dsim->master_dsi_link_id = id;
gpu/drm/msm/dsi/dsi_manager.c:		if (!msm_dsim->is_sync_needed)
gpu/drm/msm/dsi/dsi_manager.c:			msm_dsim->is_sync_needed = of_property_read_bool(
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *other_dsi = dsi_mgr_get_other_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *clk_master_dsi = dsi_mgr_get_dsi(DSI_CLOCK_MASTER);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *clk_slave_dsi = dsi_mgr_get_dsi(DSI_CLOCK_SLAVE);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi_pll *src_pll;
gpu/drm/msm/dsi/dsi_manager.c:		ret = msm_dsi_host_register(msm_dsi->host, true);
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsi_phy_set_usecase(msm_dsi->phy, MSM_DSI_PHY_STANDALONE);
gpu/drm/msm/dsi/dsi_manager.c:		src_pll = msm_dsi_phy_get_pll(msm_dsi->phy);
gpu/drm/msm/dsi/dsi_manager.c:		ret = msm_dsi_host_set_src_pll(msm_dsi->host, src_pll);
gpu/drm/msm/dsi/dsi_manager.c:		struct msm_dsi *master_link_dsi = IS_MASTER_DSI_LINK(id) ?
gpu/drm/msm/dsi/dsi_manager.c:							msm_dsi : other_dsi;
gpu/drm/msm/dsi/dsi_manager.c:		struct msm_dsi *slave_link_dsi = IS_MASTER_DSI_LINK(id) ?
gpu/drm/msm/dsi/dsi_manager.c:							other_dsi : msm_dsi;
gpu/drm/msm/dsi/dsi_manager.c:		ret = msm_dsi_host_register(slave_link_dsi->host, false);
gpu/drm/msm/dsi/dsi_manager.c:		ret = msm_dsi_host_register(master_link_dsi->host, true);
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsi_phy_set_usecase(clk_master_dsi->phy,
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsi_phy_set_usecase(clk_slave_dsi->phy,
gpu/drm/msm/dsi/dsi_manager.c:		src_pll = msm_dsi_phy_get_pll(clk_master_dsi->phy);
gpu/drm/msm/dsi/dsi_manager.c:		ret = msm_dsi_host_set_src_pll(msm_dsi->host, src_pll);
gpu/drm/msm/dsi/dsi_manager.c:		ret = msm_dsi_host_set_src_pll(other_dsi->host, src_pll);
gpu/drm/msm/dsi/dsi_manager.c:static int enable_phy(struct msm_dsi *msm_dsi, int src_pll_id,
gpu/drm/msm/dsi/dsi_manager.c:		      struct msm_dsi_phy_shared_timings *shared_timings)
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi_phy_clk_request clk_req;
gpu/drm/msm/dsi/dsi_manager.c:	msm_dsi_host_get_phy_clk_req(msm_dsi->host, &clk_req, is_dual_dsi);
gpu/drm/msm/dsi/dsi_manager.c:	ret = msm_dsi_phy_enable(msm_dsi->phy, src_pll_id, &clk_req);
gpu/drm/msm/dsi/dsi_manager.c:	msm_dsi_phy_get_shared_timings(msm_dsi->phy, shared_timings);
gpu/drm/msm/dsi/dsi_manager.c:		   struct msm_dsi_phy_shared_timings shared_timings[DSI_MAX])
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *mdsi = dsi_mgr_get_dsi(DSI_CLOCK_MASTER);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *sdsi = dsi_mgr_get_dsi(DSI_CLOCK_SLAVE);
gpu/drm/msm/dsi/dsi_manager.c:			msm_dsi_host_reset_phy(mdsi->host);
gpu/drm/msm/dsi/dsi_manager.c:			msm_dsi_host_reset_phy(sdsi->host);
gpu/drm/msm/dsi/dsi_manager.c:				msm_dsi_phy_disable(mdsi->phy);
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsi_host_reset_phy(msm_dsi->host);
gpu/drm/msm/dsi/dsi_manager.c:		ret = enable_phy(msm_dsi, src_pll_id, &shared_timings[id]);
gpu/drm/msm/dsi/dsi_manager.c:	msm_dsi->phy_enabled = true;
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *mdsi = dsi_mgr_get_dsi(DSI_CLOCK_MASTER);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *sdsi = dsi_mgr_get_dsi(DSI_CLOCK_SLAVE);
gpu/drm/msm/dsi/dsi_manager.c:	msm_dsi->phy_enabled = false;
gpu/drm/msm/dsi/dsi_manager.c:			msm_dsi_phy_disable(sdsi->phy);
gpu/drm/msm/dsi/dsi_manager.c:			msm_dsi_phy_disable(mdsi->phy);
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsi_phy_disable(msm_dsi->phy);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *other_dsi = dsi_mgr_get_other_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_drm_private *priv = connector->dev->dev_private;
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/dsi/dsi_manager.c:	if (!msm_dsi->panel) {
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsi->panel = msm_dsi_host_get_panel(msm_dsi->host,
gpu/drm/msm/dsi/dsi_manager.c:						&msm_dsi->device_flags);
gpu/drm/msm/dsi/dsi_manager.c:		if (!msm_dsi->panel && IS_DUAL_DSI() &&
gpu/drm/msm/dsi/dsi_manager.c:			msm_dsi->panel = msm_dsi_host_get_panel(
gpu/drm/msm/dsi/dsi_manager.c:		if (msm_dsi->panel && kms->funcs->set_encoder_mode) {
gpu/drm/msm/dsi/dsi_manager.c:			bool cmd_mode = !(msm_dsi->device_flags &
gpu/drm/msm/dsi/dsi_manager.c:					msm_dsi_get_encoder(msm_dsi);
gpu/drm/msm/dsi/dsi_manager.c:		if (msm_dsi->panel && IS_DUAL_DSI())
gpu/drm/msm/dsi/dsi_manager.c:		if (msm_dsi->panel && IS_DUAL_DSI() &&
gpu/drm/msm/dsi/dsi_manager.c:			bool cmd_mode = !(msm_dsi->device_flags &
gpu/drm/msm/dsi/dsi_manager.c:			struct drm_encoder *encoder = msm_dsi_get_encoder(
gpu/drm/msm/dsi/dsi_manager.c:			struct drm_encoder *slave_enc = msm_dsi_get_encoder(
gpu/drm/msm/dsi/dsi_manager.c:	return msm_dsi->panel ? connector_status_connected :
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct drm_panel *panel = msm_dsi->panel;
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct drm_encoder *encoder = msm_dsi_get_encoder(msm_dsi);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_drm_private *priv = connector->dev->dev_private;
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	return msm_dsi_get_encoder(msm_dsi);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi1 = dsi_mgr_get_dsi(DSI_1);
gpu/drm/msm/dsi/dsi_manager.c:	struct mipi_dsi_host *host = msm_dsi->host;
gpu/drm/msm/dsi/dsi_manager.c:	struct drm_panel *panel = msm_dsi->panel;
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi_phy_shared_timings phy_shared_timings[DSI_MAX];
gpu/drm/msm/dsi/dsi_manager.c:	if (!msm_dsi_device_connected(msm_dsi))
gpu/drm/msm/dsi/dsi_manager.c:	ret = msm_dsi_host_power_on(host, &phy_shared_timings[id], is_dual_dsi);
gpu/drm/msm/dsi/dsi_manager.c:	if (is_dual_dsi && msm_dsi1) {
gpu/drm/msm/dsi/dsi_manager.c:		ret = msm_dsi_host_power_on(msm_dsi1->host,
gpu/drm/msm/dsi/dsi_manager.c:	ret = msm_dsi_host_enable(host);
gpu/drm/msm/dsi/dsi_manager.c:	if (is_dual_dsi && msm_dsi1) {
gpu/drm/msm/dsi/dsi_manager.c:		ret = msm_dsi_host_enable(msm_dsi1->host);
gpu/drm/msm/dsi/dsi_manager.c:	if (is_dual_dsi && msm_dsi1)
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsi_host_disable(msm_dsi1->host);
gpu/drm/msm/dsi/dsi_manager.c:	msm_dsi_host_disable(host);
gpu/drm/msm/dsi/dsi_manager.c:	if (is_dual_dsi && msm_dsi1)
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsi_host_power_off(msm_dsi1->host);
gpu/drm/msm/dsi/dsi_manager.c:	msm_dsi_host_power_off(host);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi1 = dsi_mgr_get_dsi(DSI_1);
gpu/drm/msm/dsi/dsi_manager.c:	struct mipi_dsi_host *host = msm_dsi->host;
gpu/drm/msm/dsi/dsi_manager.c:	struct drm_panel *panel = msm_dsi->panel;
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi_pll *src_pll;
gpu/drm/msm/dsi/dsi_manager.c:	if (!msm_dsi_device_connected(msm_dsi))
gpu/drm/msm/dsi/dsi_manager.c:	ret = msm_dsi_host_disable(host);
gpu/drm/msm/dsi/dsi_manager.c:	if (is_dual_dsi && msm_dsi1) {
gpu/drm/msm/dsi/dsi_manager.c:		ret = msm_dsi_host_disable(msm_dsi1->host);
gpu/drm/msm/dsi/dsi_manager.c:	src_pll = msm_dsi_phy_get_pll(msm_dsi->phy);
gpu/drm/msm/dsi/dsi_manager.c:	msm_dsi_pll_save_state(src_pll);
gpu/drm/msm/dsi/dsi_manager.c:	ret = msm_dsi_host_power_off(host);
gpu/drm/msm/dsi/dsi_manager.c:	if (is_dual_dsi && msm_dsi1) {
gpu/drm/msm/dsi/dsi_manager.c:		ret = msm_dsi_host_power_off(msm_dsi1->host);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *other_dsi = dsi_mgr_get_other_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct mipi_dsi_host *host = msm_dsi->host;
gpu/drm/msm/dsi/dsi_manager.c:	msm_dsi_host_set_display_mode(host, adjusted_mode);
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsi_host_set_display_mode(other_dsi->host, adjusted_mode);
gpu/drm/msm/dsi/dsi_manager.c:struct drm_connector *msm_dsi_manager_connector_init(u8 id)
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	ret = drm_connector_init(msm_dsi->dev, connector,
gpu/drm/msm/dsi/dsi_manager.c:	drm_connector_attach_encoder(connector, msm_dsi->encoder);
gpu/drm/msm/dsi/dsi_manager.c:bool msm_dsi_manager_validate_current_config(u8 id)
gpu/drm/msm/dsi/dsi_manager.c:struct drm_bridge *msm_dsi_manager_bridge_init(u8 id)
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	dsi_bridge = devm_kzalloc(msm_dsi->dev->dev,
gpu/drm/msm/dsi/dsi_manager.c:	encoder = msm_dsi->encoder;
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsi_manager_bridge_destroy(bridge);
gpu/drm/msm/dsi/dsi_manager.c:struct drm_connector *msm_dsi_manager_ext_bridge_init(u8 id)
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct drm_device *dev = msm_dsi->dev;
gpu/drm/msm/dsi/dsi_manager.c:	int_bridge = msm_dsi->bridge;
gpu/drm/msm/dsi/dsi_manager.c:	ext_bridge = msm_dsi->external_bridge =
gpu/drm/msm/dsi/dsi_manager.c:			msm_dsi_host_get_bridge(msm_dsi->host);
gpu/drm/msm/dsi/dsi_manager.c:	encoder = msm_dsi->encoder;
gpu/drm/msm/dsi/dsi_manager.c:	 * priv->connector[] list, mainly for msm_fbdev_init()
gpu/drm/msm/dsi/dsi_manager.c:void msm_dsi_manager_bridge_destroy(struct drm_bridge *bridge)
gpu/drm/msm/dsi/dsi_manager.c:int msm_dsi_manager_cmd_xfer(int id, const struct mipi_dsi_msg *msg)
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi0 = dsi_mgr_get_dsi(DSI_0);
gpu/drm/msm/dsi/dsi_manager.c:	struct mipi_dsi_host *host = msm_dsi->host;
gpu/drm/msm/dsi/dsi_manager.c:	if (need_sync && msm_dsi0) {
gpu/drm/msm/dsi/dsi_manager.c:		ret = msm_dsi_host_xfer_prepare(msm_dsi0->host, msg);
gpu/drm/msm/dsi/dsi_manager.c:	ret = msm_dsi_host_xfer_prepare(host, msg);
gpu/drm/msm/dsi/dsi_manager.c:	ret = is_read ? msm_dsi_host_cmd_rx(host, msg) :
gpu/drm/msm/dsi/dsi_manager.c:			msm_dsi_host_cmd_tx(host, msg);
gpu/drm/msm/dsi/dsi_manager.c:	msm_dsi_host_xfer_restore(host, msg);
gpu/drm/msm/dsi/dsi_manager.c:	if (need_sync && msm_dsi0)
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsi_host_xfer_restore(msm_dsi0->host, msg);
gpu/drm/msm/dsi/dsi_manager.c:bool msm_dsi_manager_cmd_xfer_trigger(int id, u32 dma_base, u32 len)
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi0 = dsi_mgr_get_dsi(DSI_0);
gpu/drm/msm/dsi/dsi_manager.c:	struct mipi_dsi_host *host = msm_dsi->host;
gpu/drm/msm/dsi/dsi_manager.c:	if (IS_SYNC_NEEDED() && msm_dsi0)
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsi_host_cmd_xfer_commit(msm_dsi0->host, dma_base, len);
gpu/drm/msm/dsi/dsi_manager.c:	msm_dsi_host_cmd_xfer_commit(host, dma_base, len);
gpu/drm/msm/dsi/dsi_manager.c:void msm_dsi_manager_attach_dsi_device(int id, u32 device_flags)
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi *msm_dsi = dsi_mgr_get_dsi(id);
gpu/drm/msm/dsi/dsi_manager.c:	struct drm_device *dev = msm_dsi->dev;
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_drm_private *priv;
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_kms *kms;
gpu/drm/msm/dsi/dsi_manager.c:	 * drm_device pointer is assigned to msm_dsi only in the modeset_init
gpu/drm/msm/dsi/dsi_manager.c:	encoder = msm_dsi_get_encoder(msm_dsi);
gpu/drm/msm/dsi/dsi_manager.c:int msm_dsi_manager_register(struct msm_dsi *msm_dsi)
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi_manager *msm_dsim = &msm_dsim_glb;
gpu/drm/msm/dsi/dsi_manager.c:	int id = msm_dsi->id;
gpu/drm/msm/dsi/dsi_manager.c:	if (msm_dsim->dsi[id]) {
gpu/drm/msm/dsi/dsi_manager.c:	msm_dsim->dsi[id] = msm_dsi;
gpu/drm/msm/dsi/dsi_manager.c:	ret = dsi_mgr_parse_dual_dsi(msm_dsi->pdev->dev.of_node, id);
gpu/drm/msm/dsi/dsi_manager.c:	msm_dsim->dsi[id] = NULL;
gpu/drm/msm/dsi/dsi_manager.c:void msm_dsi_manager_unregister(struct msm_dsi *msm_dsi)
gpu/drm/msm/dsi/dsi_manager.c:	struct msm_dsi_manager *msm_dsim = &msm_dsim_glb;
gpu/drm/msm/dsi/dsi_manager.c:	if (msm_dsi->host)
gpu/drm/msm/dsi/dsi_manager.c:		msm_dsi_host_unregister(msm_dsi->host);
gpu/drm/msm/dsi/dsi_manager.c:	msm_dsim->dsi[msm_dsi->id] = NULL;
gpu/drm/msm/dsi/mmss_cc.xml.h:- /home/robclark/src/envytools/rnndb/msm.xml                 (    676 bytes, from 2018-07-03 19:37:13)
gpu/drm/msm/dsi/phy/dsi_phy.c:static void dsi_dphy_timing_calc_clk_zero(struct msm_dsi_dphy_timing *timing,
gpu/drm/msm/dsi/phy/dsi_phy.c:int msm_dsi_dphy_timing_calc(struct msm_dsi_dphy_timing *timing,
gpu/drm/msm/dsi/phy/dsi_phy.c:			     struct msm_dsi_phy_clk_request *clk_req)
gpu/drm/msm/dsi/phy/dsi_phy.c:int msm_dsi_dphy_timing_calc_v2(struct msm_dsi_dphy_timing *timing,
gpu/drm/msm/dsi/phy/dsi_phy.c:				struct msm_dsi_phy_clk_request *clk_req)
gpu/drm/msm/dsi/phy/dsi_phy.c:int msm_dsi_dphy_timing_calc_v3(struct msm_dsi_dphy_timing *timing,
gpu/drm/msm/dsi/phy/dsi_phy.c:	struct msm_dsi_phy_clk_request *clk_req)
gpu/drm/msm/dsi/phy/dsi_phy.c:void msm_dsi_phy_set_src_pll(struct msm_dsi_phy *phy, int pll_id, u32 reg,
gpu/drm/msm/dsi/phy/dsi_phy.c:static int dsi_phy_regulator_init(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy.c:static void dsi_phy_regulator_disable(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy.c:static int dsi_phy_regulator_enable(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy.c:static int dsi_phy_enable_resource(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy.c:static void dsi_phy_disable_resource(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy.c:static int dsi_phy_get_id(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy.c:	const struct msm_dsi_phy_cfg *cfg = phy->cfg;
gpu/drm/msm/dsi/phy/dsi_phy.c:int msm_dsi_phy_init_common(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy.c:	phy->reg_base = msm_ioremap(pdev, "dsi_phy_regulator",
gpu/drm/msm/dsi/phy/dsi_phy.c:	struct msm_dsi_phy *phy;
gpu/drm/msm/dsi/phy/dsi_phy.c:	phy->base = msm_ioremap(pdev, "dsi_phy", "DSI_PHY");
gpu/drm/msm/dsi/phy/dsi_phy.c:	phy->ahb_clk = msm_clk_get(pdev, "iface");
gpu/drm/msm/dsi/phy/dsi_phy.c:	phy->pll = msm_dsi_pll_init(pdev, phy->cfg->type, phy->id);
gpu/drm/msm/dsi/phy/dsi_phy.c:	struct msm_dsi_phy *phy = platform_get_drvdata(pdev);
gpu/drm/msm/dsi/phy/dsi_phy.c:		msm_dsi_pll_destroy(phy->pll);
gpu/drm/msm/dsi/phy/dsi_phy.c:		.name   = "msm_dsi_phy",
gpu/drm/msm/dsi/phy/dsi_phy.c:void __init msm_dsi_phy_driver_register(void)
gpu/drm/msm/dsi/phy/dsi_phy.c:void __exit msm_dsi_phy_driver_unregister(void)
gpu/drm/msm/dsi/phy/dsi_phy.c:int msm_dsi_phy_enable(struct msm_dsi_phy *phy, int src_pll_id,
gpu/drm/msm/dsi/phy/dsi_phy.c:			struct msm_dsi_phy_clk_request *clk_req)
gpu/drm/msm/dsi/phy/dsi_phy.c:		ret = msm_dsi_pll_restore_state(phy->pll);
gpu/drm/msm/dsi/phy/dsi_phy.c:void msm_dsi_phy_disable(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy.c:void msm_dsi_phy_get_shared_timings(struct msm_dsi_phy *phy,
gpu/drm/msm/dsi/phy/dsi_phy.c:			struct msm_dsi_phy_shared_timings *shared_timings)
gpu/drm/msm/dsi/phy/dsi_phy.c:struct msm_dsi_pll *msm_dsi_phy_get_pll(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy.c:void msm_dsi_phy_set_usecase(struct msm_dsi_phy *phy,
gpu/drm/msm/dsi/phy/dsi_phy.c:			     enum msm_dsi_phy_usecase uc)
gpu/drm/msm/dsi/phy/dsi_phy.h:#define dsi_phy_read(offset) msm_readl((offset))
gpu/drm/msm/dsi/phy/dsi_phy.h:#define dsi_phy_write(offset, data) msm_writel((data), (offset))
gpu/drm/msm/dsi/phy/dsi_phy.h:struct msm_dsi_phy_ops {
gpu/drm/msm/dsi/phy/dsi_phy.h:	int (*init) (struct msm_dsi_phy *phy);
gpu/drm/msm/dsi/phy/dsi_phy.h:	int (*enable)(struct msm_dsi_phy *phy, int src_pll_id,
gpu/drm/msm/dsi/phy/dsi_phy.h:			struct msm_dsi_phy_clk_request *clk_req);
gpu/drm/msm/dsi/phy/dsi_phy.h:	void (*disable)(struct msm_dsi_phy *phy);
gpu/drm/msm/dsi/phy/dsi_phy.h:struct msm_dsi_phy_cfg {
gpu/drm/msm/dsi/phy/dsi_phy.h:	enum msm_dsi_phy_type type;
gpu/drm/msm/dsi/phy/dsi_phy.h:	struct msm_dsi_phy_ops ops;
gpu/drm/msm/dsi/phy/dsi_phy.h:extern const struct msm_dsi_phy_cfg dsi_phy_28nm_hpm_cfgs;
gpu/drm/msm/dsi/phy/dsi_phy.h:extern const struct msm_dsi_phy_cfg dsi_phy_28nm_lp_cfgs;
gpu/drm/msm/dsi/phy/dsi_phy.h:extern const struct msm_dsi_phy_cfg dsi_phy_20nm_cfgs;
gpu/drm/msm/dsi/phy/dsi_phy.h:extern const struct msm_dsi_phy_cfg dsi_phy_28nm_8960_cfgs;
gpu/drm/msm/dsi/phy/dsi_phy.h:extern const struct msm_dsi_phy_cfg dsi_phy_14nm_cfgs;
gpu/drm/msm/dsi/phy/dsi_phy.h:extern const struct msm_dsi_phy_cfg dsi_phy_10nm_cfgs;
gpu/drm/msm/dsi/phy/dsi_phy.h:struct msm_dsi_dphy_timing {
gpu/drm/msm/dsi/phy/dsi_phy.h:	struct msm_dsi_phy_shared_timings shared_timings;
gpu/drm/msm/dsi/phy/dsi_phy.h:struct msm_dsi_phy {
gpu/drm/msm/dsi/phy/dsi_phy.h:	struct msm_dsi_dphy_timing timing;
gpu/drm/msm/dsi/phy/dsi_phy.h:	const struct msm_dsi_phy_cfg *cfg;
gpu/drm/msm/dsi/phy/dsi_phy.h:	enum msm_dsi_phy_usecase usecase;
gpu/drm/msm/dsi/phy/dsi_phy.h:	struct msm_dsi_pll *pll;
gpu/drm/msm/dsi/phy/dsi_phy.h:int msm_dsi_dphy_timing_calc(struct msm_dsi_dphy_timing *timing,
gpu/drm/msm/dsi/phy/dsi_phy.h:			     struct msm_dsi_phy_clk_request *clk_req);
gpu/drm/msm/dsi/phy/dsi_phy.h:int msm_dsi_dphy_timing_calc_v2(struct msm_dsi_dphy_timing *timing,
gpu/drm/msm/dsi/phy/dsi_phy.h:				struct msm_dsi_phy_clk_request *clk_req);
gpu/drm/msm/dsi/phy/dsi_phy.h:int msm_dsi_dphy_timing_calc_v3(struct msm_dsi_dphy_timing *timing,
gpu/drm/msm/dsi/phy/dsi_phy.h:				struct msm_dsi_phy_clk_request *clk_req);
gpu/drm/msm/dsi/phy/dsi_phy.h:void msm_dsi_phy_set_src_pll(struct msm_dsi_phy *phy, int pll_id, u32 reg,
gpu/drm/msm/dsi/phy/dsi_phy.h:int msm_dsi_phy_init_common(struct msm_dsi_phy *phy);
gpu/drm/msm/dsi/phy/dsi_phy_10nm.c:static int dsi_phy_hw_v3_0_is_pll_on(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy_10nm.c:static void dsi_phy_hw_v3_0_config_lpcdrx(struct msm_dsi_phy *phy, bool enable)
gpu/drm/msm/dsi/phy/dsi_phy_10nm.c:static void dsi_phy_hw_v3_0_lane_settings(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy_10nm.c:static int dsi_10nm_phy_enable(struct msm_dsi_phy *phy, int src_pll_id,
gpu/drm/msm/dsi/phy/dsi_phy_10nm.c:			       struct msm_dsi_phy_clk_request *clk_req)
gpu/drm/msm/dsi/phy/dsi_phy_10nm.c:	struct msm_dsi_dphy_timing *timing = &phy->timing;
gpu/drm/msm/dsi/phy/dsi_phy_10nm.c:	if (msm_dsi_dphy_timing_calc_v3(timing, clk_req)) {
gpu/drm/msm/dsi/phy/dsi_phy_10nm.c:	ret = msm_dsi_pll_set_usecase(phy->pll, phy->usecase);
gpu/drm/msm/dsi/phy/dsi_phy_10nm.c:static void dsi_10nm_phy_disable(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy_10nm.c:static int dsi_10nm_phy_init(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy_10nm.c:	phy->lane_base = msm_ioremap(pdev, "dsi_phy_lane",
gpu/drm/msm/dsi/phy/dsi_phy_10nm.c:const struct msm_dsi_phy_cfg dsi_phy_10nm_cfgs = {
gpu/drm/msm/dsi/phy/dsi_phy_14nm.c:static void dsi_14nm_dphy_set_timing(struct msm_dsi_phy *phy,
gpu/drm/msm/dsi/phy/dsi_phy_14nm.c:				     struct msm_dsi_dphy_timing *timing,
gpu/drm/msm/dsi/phy/dsi_phy_14nm.c:static int dsi_14nm_phy_enable(struct msm_dsi_phy *phy, int src_pll_id,
gpu/drm/msm/dsi/phy/dsi_phy_14nm.c:			       struct msm_dsi_phy_clk_request *clk_req)
gpu/drm/msm/dsi/phy/dsi_phy_14nm.c:	struct msm_dsi_dphy_timing *timing = &phy->timing;
gpu/drm/msm/dsi/phy/dsi_phy_14nm.c:	if (msm_dsi_dphy_timing_calc_v2(timing, clk_req)) {
gpu/drm/msm/dsi/phy/dsi_phy_14nm.c:	msm_dsi_phy_set_src_pll(phy, src_pll_id,
gpu/drm/msm/dsi/phy/dsi_phy_14nm.c:	ret = msm_dsi_pll_set_usecase(phy->pll, phy->usecase);
gpu/drm/msm/dsi/phy/dsi_phy_14nm.c:static void dsi_14nm_phy_disable(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy_14nm.c:static int dsi_14nm_phy_init(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy_14nm.c:	phy->lane_base = msm_ioremap(pdev, "dsi_phy_lane",
gpu/drm/msm/dsi/phy/dsi_phy_14nm.c:const struct msm_dsi_phy_cfg dsi_phy_14nm_cfgs = {
gpu/drm/msm/dsi/phy/dsi_phy_20nm.c:static void dsi_20nm_dphy_set_timing(struct msm_dsi_phy *phy,
gpu/drm/msm/dsi/phy/dsi_phy_20nm.c:		struct msm_dsi_dphy_timing *timing)
gpu/drm/msm/dsi/phy/dsi_phy_20nm.c:static void dsi_20nm_phy_regulator_ctrl(struct msm_dsi_phy *phy, bool enable)
gpu/drm/msm/dsi/phy/dsi_phy_20nm.c:static int dsi_20nm_phy_enable(struct msm_dsi_phy *phy, int src_pll_id,
gpu/drm/msm/dsi/phy/dsi_phy_20nm.c:				struct msm_dsi_phy_clk_request *clk_req)
gpu/drm/msm/dsi/phy/dsi_phy_20nm.c:	struct msm_dsi_dphy_timing *timing = &phy->timing;
gpu/drm/msm/dsi/phy/dsi_phy_20nm.c:	if (msm_dsi_dphy_timing_calc(timing, clk_req)) {
gpu/drm/msm/dsi/phy/dsi_phy_20nm.c:	msm_dsi_phy_set_src_pll(phy, src_pll_id,
gpu/drm/msm/dsi/phy/dsi_phy_20nm.c:static void dsi_20nm_phy_disable(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy_20nm.c:const struct msm_dsi_phy_cfg dsi_phy_20nm_cfgs = {
gpu/drm/msm/dsi/phy/dsi_phy_20nm.c:		.init = msm_dsi_phy_init_common,
gpu/drm/msm/dsi/phy/dsi_phy_28nm.c:static void dsi_28nm_dphy_set_timing(struct msm_dsi_phy *phy,
gpu/drm/msm/dsi/phy/dsi_phy_28nm.c:		struct msm_dsi_dphy_timing *timing)
gpu/drm/msm/dsi/phy/dsi_phy_28nm.c:static void dsi_28nm_phy_regulator_ctrl(struct msm_dsi_phy *phy, bool enable)
gpu/drm/msm/dsi/phy/dsi_phy_28nm.c:static int dsi_28nm_phy_enable(struct msm_dsi_phy *phy, int src_pll_id,
gpu/drm/msm/dsi/phy/dsi_phy_28nm.c:				struct msm_dsi_phy_clk_request *clk_req)
gpu/drm/msm/dsi/phy/dsi_phy_28nm.c:	struct msm_dsi_dphy_timing *timing = &phy->timing;
gpu/drm/msm/dsi/phy/dsi_phy_28nm.c:	if (msm_dsi_dphy_timing_calc(timing, clk_req)) {
gpu/drm/msm/dsi/phy/dsi_phy_28nm.c:	msm_dsi_phy_set_src_pll(phy, src_pll_id,
gpu/drm/msm/dsi/phy/dsi_phy_28nm.c:static void dsi_28nm_phy_disable(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy_28nm.c:const struct msm_dsi_phy_cfg dsi_phy_28nm_hpm_cfgs = {
gpu/drm/msm/dsi/phy/dsi_phy_28nm.c:		.init = msm_dsi_phy_init_common,
gpu/drm/msm/dsi/phy/dsi_phy_28nm.c:const struct msm_dsi_phy_cfg dsi_phy_28nm_lp_cfgs = {
gpu/drm/msm/dsi/phy/dsi_phy_28nm.c:		.init = msm_dsi_phy_init_common,
gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c:static void dsi_28nm_dphy_set_timing(struct msm_dsi_phy *phy,
gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c:		struct msm_dsi_dphy_timing *timing)
gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c:static void dsi_28nm_phy_regulator_init(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c:static void dsi_28nm_phy_regulator_ctrl(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c:static void dsi_28nm_phy_calibration(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c:static void dsi_28nm_phy_lane_config(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c:static int dsi_28nm_phy_enable(struct msm_dsi_phy *phy, int src_pll_id,
gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c:				struct msm_dsi_phy_clk_request *clk_req)
gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c:	struct msm_dsi_dphy_timing *timing = &phy->timing;
gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c:	if (msm_dsi_dphy_timing_calc(timing, clk_req)) {
gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c:static void dsi_28nm_phy_disable(struct msm_dsi_phy *phy)
gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c:const struct msm_dsi_phy_cfg dsi_phy_28nm_8960_cfgs = {
gpu/drm/msm/dsi/phy/dsi_phy_28nm_8960.c:		.init = msm_dsi_phy_init_common,
gpu/drm/msm/dsi/pll/dsi_pll.c:static int dsi_pll_enable(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll.c:static void dsi_pll_disable(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll.c:long msm_dsi_pll_helper_clk_round_rate(struct clk_hw *hw,
gpu/drm/msm/dsi/pll/dsi_pll.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll.c:int msm_dsi_pll_helper_clk_prepare(struct clk_hw *hw)
gpu/drm/msm/dsi/pll/dsi_pll.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll.c:void msm_dsi_pll_helper_clk_unprepare(struct clk_hw *hw)
gpu/drm/msm/dsi/pll/dsi_pll.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll.c:void msm_dsi_pll_helper_unregister_clks(struct platform_device *pdev,
gpu/drm/msm/dsi/pll/dsi_pll.c:int msm_dsi_pll_get_clk_provider(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/pll/dsi_pll.c:void msm_dsi_pll_destroy(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll.c:void msm_dsi_pll_save_state(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll.c:int msm_dsi_pll_restore_state(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll.c:int msm_dsi_pll_set_usecase(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/pll/dsi_pll.c:			    enum msm_dsi_phy_usecase uc)
gpu/drm/msm/dsi/pll/dsi_pll.c:struct msm_dsi_pll *msm_dsi_pll_init(struct platform_device *pdev,
gpu/drm/msm/dsi/pll/dsi_pll.c:			enum msm_dsi_phy_type type, int id)
gpu/drm/msm/dsi/pll/dsi_pll.c:	struct msm_dsi_pll *pll;
gpu/drm/msm/dsi/pll/dsi_pll.c:		pll = msm_dsi_pll_28nm_init(pdev, type, id);
gpu/drm/msm/dsi/pll/dsi_pll.c:		pll = msm_dsi_pll_28nm_8960_init(pdev, id);
gpu/drm/msm/dsi/pll/dsi_pll.c:		pll = msm_dsi_pll_14nm_init(pdev, id);
gpu/drm/msm/dsi/pll/dsi_pll.c:		pll = msm_dsi_pll_10nm_init(pdev, id);
gpu/drm/msm/dsi/pll/dsi_pll.h:struct msm_dsi_pll {
gpu/drm/msm/dsi/pll/dsi_pll.h:	enum msm_dsi_phy_type type;
gpu/drm/msm/dsi/pll/dsi_pll.h:	int (*enable_seqs[MAX_DSI_PLL_EN_SEQS])(struct msm_dsi_pll *pll);
gpu/drm/msm/dsi/pll/dsi_pll.h:	void (*disable_seq)(struct msm_dsi_pll *pll);
gpu/drm/msm/dsi/pll/dsi_pll.h:	int (*get_provider)(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/pll/dsi_pll.h:	void (*destroy)(struct msm_dsi_pll *pll);
gpu/drm/msm/dsi/pll/dsi_pll.h:	void (*save_state)(struct msm_dsi_pll *pll);
gpu/drm/msm/dsi/pll/dsi_pll.h:	int (*restore_state)(struct msm_dsi_pll *pll);
gpu/drm/msm/dsi/pll/dsi_pll.h:	int (*set_usecase)(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/pll/dsi_pll.h:			   enum msm_dsi_phy_usecase uc);
gpu/drm/msm/dsi/pll/dsi_pll.h:#define hw_clk_to_pll(x) container_of(x, struct msm_dsi_pll, clk_hw)
gpu/drm/msm/dsi/pll/dsi_pll.h:	msm_writel(data, reg);
gpu/drm/msm/dsi/pll/dsi_pll.h:	return msm_readl(reg);
gpu/drm/msm/dsi/pll/dsi_pll.h:long msm_dsi_pll_helper_clk_round_rate(struct clk_hw *hw,
gpu/drm/msm/dsi/pll/dsi_pll.h:int msm_dsi_pll_helper_clk_prepare(struct clk_hw *hw);
gpu/drm/msm/dsi/pll/dsi_pll.h:void msm_dsi_pll_helper_clk_unprepare(struct clk_hw *hw);
gpu/drm/msm/dsi/pll/dsi_pll.h:void msm_dsi_pll_helper_unregister_clks(struct platform_device *pdev,
gpu/drm/msm/dsi/pll/dsi_pll.h:struct msm_dsi_pll *msm_dsi_pll_28nm_init(struct platform_device *pdev,
gpu/drm/msm/dsi/pll/dsi_pll.h:					enum msm_dsi_phy_type type, int id);
gpu/drm/msm/dsi/pll/dsi_pll.h:static inline struct msm_dsi_pll *msm_dsi_pll_28nm_init(
gpu/drm/msm/dsi/pll/dsi_pll.h:	struct platform_device *pdev, enum msm_dsi_phy_type type, int id)
gpu/drm/msm/dsi/pll/dsi_pll.h:struct msm_dsi_pll *msm_dsi_pll_28nm_8960_init(struct platform_device *pdev,
gpu/drm/msm/dsi/pll/dsi_pll.h:static inline struct msm_dsi_pll *msm_dsi_pll_28nm_8960_init(
gpu/drm/msm/dsi/pll/dsi_pll.h:struct msm_dsi_pll *msm_dsi_pll_14nm_init(struct platform_device *pdev, int id);
gpu/drm/msm/dsi/pll/dsi_pll.h:static inline struct msm_dsi_pll *
gpu/drm/msm/dsi/pll/dsi_pll.h:msm_dsi_pll_14nm_init(struct platform_device *pdev, int id)
gpu/drm/msm/dsi/pll/dsi_pll.h:struct msm_dsi_pll *msm_dsi_pll_10nm_init(struct platform_device *pdev, int id);
gpu/drm/msm/dsi/pll/dsi_pll.h:static inline struct msm_dsi_pll *
gpu/drm/msm/dsi/pll/dsi_pll.h:msm_dsi_pll_10nm_init(struct platform_device *pdev, int id)
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:	struct msm_dsi_pll base;
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:	enum msm_dsi_phy_usecase uc;
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:	.round_rate = msm_dsi_pll_helper_clk_round_rate,
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:static void dsi_pll_10nm_save_state(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:static int dsi_pll_10nm_restore_state(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:static int dsi_pll_10nm_set_usecase(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:				    enum msm_dsi_phy_usecase uc)
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:static int dsi_pll_10nm_get_provider(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:static void dsi_pll_10nm_destroy(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:struct msm_dsi_pll *msm_dsi_pll_10nm_init(struct platform_device *pdev, int id)
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:	struct msm_dsi_pll *pll;
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:	pll_10nm->phy_cmn_mmio = msm_ioremap(pdev, "dsi_phy", "DSI_PHY");
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:	pll_10nm->mmio = msm_ioremap(pdev, "dsi_pll", "DSI_PLL");
gpu/drm/msm/dsi/pll/dsi_pll_10nm.c:	msm_dsi_pll_save_state(pll);
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:	struct msm_dsi_pll base;
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:	enum msm_dsi_phy_usecase uc;
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:	.round_rate = msm_dsi_pll_helper_clk_round_rate,
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:	.prepare = msm_dsi_pll_helper_clk_prepare,
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:	.unprepare = msm_dsi_pll_helper_clk_unprepare,
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:static int dsi_pll_14nm_enable_seq(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:static void dsi_pll_14nm_disable_seq(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:static void dsi_pll_14nm_save_state(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:static int dsi_pll_14nm_restore_state(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:static int dsi_pll_14nm_set_usecase(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:				    enum msm_dsi_phy_usecase uc)
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:static int dsi_pll_14nm_get_provider(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:static void dsi_pll_14nm_destroy(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:struct msm_dsi_pll *msm_dsi_pll_14nm_init(struct platform_device *pdev, int id)
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:	struct msm_dsi_pll *pll;
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:	pll_14nm->phy_cmn_mmio = msm_ioremap(pdev, "dsi_phy", "DSI_PHY");
gpu/drm/msm/dsi/pll/dsi_pll_14nm.c:	pll_14nm->mmio = msm_ioremap(pdev, "dsi_pll", "DSI_PLL");
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:	struct msm_dsi_pll base;
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:	.round_rate = msm_dsi_pll_helper_clk_round_rate,
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:	.prepare = msm_dsi_pll_helper_clk_prepare,
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:	.unprepare = msm_dsi_pll_helper_clk_unprepare,
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:static int dsi_pll_28nm_enable_seq_hpm(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:static int dsi_pll_28nm_enable_seq_lp(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:static void dsi_pll_28nm_disable_seq(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:static void dsi_pll_28nm_save_state(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:static int dsi_pll_28nm_restore_state(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:static int dsi_pll_28nm_get_provider(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:static void dsi_pll_28nm_destroy(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:	msm_dsi_pll_helper_unregister_clks(pll_28nm->pdev,
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:struct msm_dsi_pll *msm_dsi_pll_28nm_init(struct platform_device *pdev,
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:					enum msm_dsi_phy_type type, int id)
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:	struct msm_dsi_pll *pll;
gpu/drm/msm/dsi/pll/dsi_pll_28nm.c:	pll_28nm->mmio = msm_ioremap(pdev, "dsi_pll", "DSI_PLL");
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:	struct msm_dsi_pll base;
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:	struct msm_dsi_pll *pll = hw_clk_to_pll(hw);
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:	.round_rate = msm_dsi_pll_helper_clk_round_rate,
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:	.prepare = msm_dsi_pll_helper_clk_prepare,
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:	.unprepare = msm_dsi_pll_helper_clk_unprepare,
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:static int dsi_pll_28nm_enable_seq(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:static void dsi_pll_28nm_disable_seq(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:static void dsi_pll_28nm_save_state(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:static int dsi_pll_28nm_restore_state(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:static int dsi_pll_28nm_get_provider(struct msm_dsi_pll *pll,
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:static void dsi_pll_28nm_destroy(struct msm_dsi_pll *pll)
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:	msm_dsi_pll_helper_unregister_clks(pll_28nm->pdev,
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:struct msm_dsi_pll *msm_dsi_pll_28nm_8960_init(struct platform_device *pdev,
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:	struct msm_dsi_pll *pll;
gpu/drm/msm/dsi/pll/dsi_pll_28nm_8960.c:	pll_28nm->mmio = msm_ioremap(pdev, "dsi_pll", "DSI_PLL");
gpu/drm/msm/dsi/sfpb.xml.h:- /home/robclark/src/envytools/rnndb/msm.xml                 (    676 bytes, from 2018-07-03 19:37:13)
gpu/drm/msm/edp/edp.c:	struct msm_edp *edp = dev_id;
gpu/drm/msm/edp/edp.c:	return msm_edp_ctrl_irq(edp->ctrl);
gpu/drm/msm/edp/edp.c:	struct msm_edp *edp = platform_get_drvdata(pdev);
gpu/drm/msm/edp/edp.c:		msm_edp_ctrl_destroy(edp->ctrl);
gpu/drm/msm/edp/edp.c:static struct msm_edp *edp_init(struct platform_device *pdev)
gpu/drm/msm/edp/edp.c:	struct msm_edp *edp = NULL;
gpu/drm/msm/edp/edp.c:	ret = msm_edp_ctrl_init(edp);
gpu/drm/msm/edp/edp.c:	struct msm_drm_private *priv = drm->dev_private;
gpu/drm/msm/edp/edp.c:	struct msm_edp *edp;
gpu/drm/msm/edp/edp.c:	struct msm_drm_private *priv = drm->dev_private;
gpu/drm/msm/edp/edp.c:		.name = "msm_edp",
gpu/drm/msm/edp/edp.c:void __init msm_edp_register(void)
gpu/drm/msm/edp/edp.c:void __exit msm_edp_unregister(void)
gpu/drm/msm/edp/edp.c:int msm_edp_modeset_init(struct msm_edp *edp, struct drm_device *dev,
gpu/drm/msm/edp/edp.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/edp/edp.c:	edp->bridge = msm_edp_bridge_init(edp);
gpu/drm/msm/edp/edp.c:	edp->connector = msm_edp_connector_init(edp);
gpu/drm/msm/edp/edp.h:#include "msm_drv.h"
gpu/drm/msm/edp/edp.h:#define edp_read(offset) msm_readl((offset))
gpu/drm/msm/edp/edp.h:#define edp_write(offset, data) msm_writel((data), (offset))
gpu/drm/msm/edp/edp.h:struct msm_edp {
gpu/drm/msm/edp/edp.h:struct drm_bridge *msm_edp_bridge_init(struct msm_edp *edp);
gpu/drm/msm/edp/edp.h:struct drm_connector *msm_edp_connector_init(struct msm_edp *edp);
gpu/drm/msm/edp/edp.h:void *msm_edp_aux_init(struct device *dev, void __iomem *regbase,
gpu/drm/msm/edp/edp.h:void msm_edp_aux_destroy(struct device *dev, struct edp_aux *aux);
gpu/drm/msm/edp/edp.h:irqreturn_t msm_edp_aux_irq(struct edp_aux *aux, u32 isr);
gpu/drm/msm/edp/edp.h:void msm_edp_aux_ctrl(struct edp_aux *aux, int enable);
gpu/drm/msm/edp/edp.h:bool msm_edp_phy_ready(struct edp_phy *phy);
gpu/drm/msm/edp/edp.h:void msm_edp_phy_ctrl(struct edp_phy *phy, int enable);
gpu/drm/msm/edp/edp.h:void msm_edp_phy_vm_pe_init(struct edp_phy *phy);
gpu/drm/msm/edp/edp.h:void msm_edp_phy_vm_pe_cfg(struct edp_phy *phy, u32 v0, u32 v1);
gpu/drm/msm/edp/edp.h:void msm_edp_phy_lane_power_ctrl(struct edp_phy *phy, bool up, u32 max_lane);
gpu/drm/msm/edp/edp.h:void *msm_edp_phy_init(struct device *dev, void __iomem *regbase);
gpu/drm/msm/edp/edp.h:irqreturn_t msm_edp_ctrl_irq(struct edp_ctrl *ctrl);
gpu/drm/msm/edp/edp.h:void msm_edp_ctrl_power(struct edp_ctrl *ctrl, bool on);
gpu/drm/msm/edp/edp.h:int msm_edp_ctrl_init(struct msm_edp *edp);
gpu/drm/msm/edp/edp.h:void msm_edp_ctrl_destroy(struct edp_ctrl *ctrl);
gpu/drm/msm/edp/edp.h:bool msm_edp_ctrl_panel_connected(struct edp_ctrl *ctrl);
gpu/drm/msm/edp/edp.h:int msm_edp_ctrl_get_panel_info(struct edp_ctrl *ctrl,
gpu/drm/msm/edp/edp.h:int msm_edp_ctrl_timing_cfg(struct edp_ctrl *ctrl,
gpu/drm/msm/edp/edp.h:bool msm_edp_ctrl_pixel_clock_valid(struct edp_ctrl *ctrl,
gpu/drm/msm/edp/edp.xml.h:- /home/robclark/src/envytools/rnndb/msm.xml                 (    676 bytes, from 2018-07-03 19:37:13)
gpu/drm/msm/edp/edp_aux.c: * It will call msm_edp_aux_ctrl() function to reset the AUX channel,
gpu/drm/msm/edp/edp_aux.c: * msm_edp_aux_ctrl() running concurrently in other threads, i.e.
gpu/drm/msm/edp/edp_aux.c:		msm_edp_aux_ctrl(aux, 1);
gpu/drm/msm/edp/edp_aux.c:void *msm_edp_aux_init(struct device *dev, void __iomem *regbase,
gpu/drm/msm/edp/edp_aux.c:	aux->drm_aux.name = "msm_edp_aux";
gpu/drm/msm/edp/edp_aux.c:void msm_edp_aux_destroy(struct device *dev, struct edp_aux *aux)
gpu/drm/msm/edp/edp_aux.c:irqreturn_t msm_edp_aux_irq(struct edp_aux *aux, u32 isr)
gpu/drm/msm/edp/edp_aux.c:void msm_edp_aux_ctrl(struct edp_aux *aux, int enable)
gpu/drm/msm/edp/edp_bridge.c:	struct msm_edp *edp;
gpu/drm/msm/edp/edp_bridge.c:	struct msm_edp *edp = edp_bridge->edp;
gpu/drm/msm/edp/edp_bridge.c:	msm_edp_ctrl_power(edp->ctrl, true);
gpu/drm/msm/edp/edp_bridge.c:	struct msm_edp *edp = edp_bridge->edp;
gpu/drm/msm/edp/edp_bridge.c:	msm_edp_ctrl_power(edp->ctrl, false);
gpu/drm/msm/edp/edp_bridge.c:	struct msm_edp *edp = edp_bridge->edp;
gpu/drm/msm/edp/edp_bridge.c:			msm_edp_ctrl_timing_cfg(edp->ctrl,
gpu/drm/msm/edp/edp_bridge.c:struct drm_bridge *msm_edp_bridge_init(struct msm_edp *edp)
gpu/drm/msm/edp/edp_connector.c:#include "msm_kms.h"
gpu/drm/msm/edp/edp_connector.c:	struct msm_edp *edp;
gpu/drm/msm/edp/edp_connector.c:	struct msm_edp *edp = edp_connector->edp;
gpu/drm/msm/edp/edp_connector.c:	return msm_edp_ctrl_panel_connected(edp->ctrl) ?
gpu/drm/msm/edp/edp_connector.c:	struct msm_edp *edp = edp_connector->edp;
gpu/drm/msm/edp/edp_connector.c:	ret = msm_edp_ctrl_get_panel_info(edp->ctrl, connector, &drm_edid);
gpu/drm/msm/edp/edp_connector.c:	struct msm_edp *edp = edp_connector->edp;
gpu/drm/msm/edp/edp_connector.c:	struct msm_drm_private *priv = connector->dev->dev_private;
gpu/drm/msm/edp/edp_connector.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/edp/edp_connector.c:	if (!msm_edp_ctrl_pixel_clock_valid(
gpu/drm/msm/edp/edp_connector.c:struct drm_connector *msm_edp_connector_init(struct msm_edp *edp)
gpu/drm/msm/edp/edp_ctrl.c:	ctrl->aux_clk = msm_clk_get(pdev, "core");
gpu/drm/msm/edp/edp_ctrl.c:	ctrl->pixel_clk = msm_clk_get(pdev, "pixel");
gpu/drm/msm/edp/edp_ctrl.c:	ctrl->ahb_clk = msm_clk_get(pdev, "iface");
gpu/drm/msm/edp/edp_ctrl.c:	ctrl->link_clk = msm_clk_get(pdev, "link");
gpu/drm/msm/edp/edp_ctrl.c:	ctrl->mdp_core_clk = msm_clk_get(pdev, "mdp_core");
gpu/drm/msm/edp/edp_ctrl.c:		msm_edp_phy_vm_pe_cfg(ctrl->phy, value0, value1);
gpu/drm/msm/edp/edp_ctrl.c:		msm_edp_phy_ctrl(ctrl->phy, 1);
gpu/drm/msm/edp/edp_ctrl.c:		msm_edp_aux_ctrl(ctrl->aux, 1);
gpu/drm/msm/edp/edp_ctrl.c:		msm_edp_aux_ctrl(ctrl->aux, 0);
gpu/drm/msm/edp/edp_ctrl.c:		msm_edp_phy_ctrl(ctrl->phy, 0);
gpu/drm/msm/edp/edp_ctrl.c:		msm_edp_phy_lane_power_ctrl(ctrl->phy, true, ctrl->lane_cnt);
gpu/drm/msm/edp/edp_ctrl.c:		msm_edp_phy_vm_pe_init(ctrl->phy);
gpu/drm/msm/edp/edp_ctrl.c:		msm_edp_phy_ready(ctrl->phy);
gpu/drm/msm/edp/edp_ctrl.c:		msm_edp_ctrl_pixel_clock_valid(ctrl, ctrl->pixel_rate, &m, &n);
gpu/drm/msm/edp/edp_ctrl.c:		msm_edp_phy_lane_power_ctrl(ctrl->phy, false, 0);
gpu/drm/msm/edp/edp_ctrl.c:		msm_edp_phy_ctrl(ctrl->phy, 0);
gpu/drm/msm/edp/edp_ctrl.c:		msm_edp_phy_ctrl(ctrl->phy, 1);
gpu/drm/msm/edp/edp_ctrl.c:irqreturn_t msm_edp_ctrl_irq(struct edp_ctrl *ctrl)
gpu/drm/msm/edp/edp_ctrl.c:	msm_edp_aux_irq(ctrl->aux, isr1);
gpu/drm/msm/edp/edp_ctrl.c:void msm_edp_ctrl_power(struct edp_ctrl *ctrl, bool on)
gpu/drm/msm/edp/edp_ctrl.c:int msm_edp_ctrl_init(struct msm_edp *edp)
gpu/drm/msm/edp/edp_ctrl.c:	ctrl->base = msm_ioremap(ctrl->pdev, "edp", "eDP");
gpu/drm/msm/edp/edp_ctrl.c:	ctrl->aux = msm_edp_aux_init(dev, ctrl->base, &ctrl->drm_aux);
gpu/drm/msm/edp/edp_ctrl.c:	ctrl->phy = msm_edp_phy_init(dev, ctrl->base);
gpu/drm/msm/edp/edp_ctrl.c:	msm_edp_aux_destroy(dev, ctrl->aux);
gpu/drm/msm/edp/edp_ctrl.c:void msm_edp_ctrl_destroy(struct edp_ctrl *ctrl)
gpu/drm/msm/edp/edp_ctrl.c:		msm_edp_aux_destroy(&ctrl->pdev->dev, ctrl->aux);
gpu/drm/msm/edp/edp_ctrl.c:bool msm_edp_ctrl_panel_connected(struct edp_ctrl *ctrl)
gpu/drm/msm/edp/edp_ctrl.c:int msm_edp_ctrl_get_panel_info(struct edp_ctrl *ctrl,
gpu/drm/msm/edp/edp_ctrl.c:int msm_edp_ctrl_timing_cfg(struct edp_ctrl *ctrl,
gpu/drm/msm/edp/edp_ctrl.c:bool msm_edp_ctrl_pixel_clock_valid(struct edp_ctrl *ctrl,
gpu/drm/msm/edp/edp_phy.c:bool msm_edp_phy_ready(struct edp_phy *phy)
gpu/drm/msm/edp/edp_phy.c:void msm_edp_phy_ctrl(struct edp_phy *phy, int enable)
gpu/drm/msm/edp/edp_phy.c:void msm_edp_phy_vm_pe_init(struct edp_phy *phy)
gpu/drm/msm/edp/edp_phy.c:void msm_edp_phy_vm_pe_cfg(struct edp_phy *phy, u32 v0, u32 v1)
gpu/drm/msm/edp/edp_phy.c:void msm_edp_phy_lane_power_ctrl(struct edp_phy *phy, bool up, u32 max_lane)
gpu/drm/msm/edp/edp_phy.c:void *msm_edp_phy_init(struct device *dev, void __iomem *regbase)
gpu/drm/msm/hdmi/hdmi.c:void msm_hdmi_set_mode(struct hdmi *hdmi, bool power_on)
gpu/drm/msm/hdmi/hdmi.c:static irqreturn_t msm_hdmi_irq(int irq, void *dev_id)
gpu/drm/msm/hdmi/hdmi.c:	msm_hdmi_connector_irq(hdmi->connector);
gpu/drm/msm/hdmi/hdmi.c:	msm_hdmi_i2c_irq(hdmi->i2c);
gpu/drm/msm/hdmi/hdmi.c:		msm_hdmi_hdcp_irq(hdmi->hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi.c:static void msm_hdmi_destroy(struct hdmi *hdmi)
gpu/drm/msm/hdmi/hdmi.c:	msm_hdmi_hdcp_destroy(hdmi);
gpu/drm/msm/hdmi/hdmi.c:		msm_hdmi_i2c_destroy(hdmi->i2c);
gpu/drm/msm/hdmi/hdmi.c:static int msm_hdmi_get_phy(struct hdmi *hdmi)
gpu/drm/msm/hdmi/hdmi.c:static struct hdmi *msm_hdmi_init(struct platform_device *pdev)
gpu/drm/msm/hdmi/hdmi.c:	hdmi->mmio = msm_ioremap(pdev, config->mmio_name, "HDMI");
gpu/drm/msm/hdmi/hdmi.c:	hdmi->qfprom_mmio = msm_ioremap(pdev,
gpu/drm/msm/hdmi/hdmi.c:		clk = msm_clk_get(pdev, config->hpd_clk_names[i]);
gpu/drm/msm/hdmi/hdmi.c:		clk = msm_clk_get(pdev, config->pwr_clk_names[i]);
gpu/drm/msm/hdmi/hdmi.c:	hdmi->workq = alloc_ordered_workqueue("msm_hdmi", 0);
gpu/drm/msm/hdmi/hdmi.c:	hdmi->i2c = msm_hdmi_i2c_init(hdmi);
gpu/drm/msm/hdmi/hdmi.c:	ret = msm_hdmi_get_phy(hdmi);
gpu/drm/msm/hdmi/hdmi.c:	hdmi->hdcp_ctrl = msm_hdmi_hdcp_init(hdmi);
gpu/drm/msm/hdmi/hdmi.c:		msm_hdmi_destroy(hdmi);
gpu/drm/msm/hdmi/hdmi.c: * should be handled in msm_hdmi_init() so that failure happens from
gpu/drm/msm/hdmi/hdmi.c:int msm_hdmi_modeset_init(struct hdmi *hdmi,
gpu/drm/msm/hdmi/hdmi.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/hdmi/hdmi.c:	hdmi->bridge = msm_hdmi_bridge_init(hdmi);
gpu/drm/msm/hdmi/hdmi.c:	hdmi->connector = msm_hdmi_connector_init(hdmi);
gpu/drm/msm/hdmi/hdmi.c:			msm_hdmi_irq, IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
gpu/drm/msm/hdmi/hdmi.c:	ret = msm_hdmi_hpd_enable(hdmi->connector);
gpu/drm/msm/hdmi/hdmi.c:		msm_hdmi_bridge_destroy(hdmi->bridge);
gpu/drm/msm/hdmi/hdmi.c:} msm_hdmi_gpio_pdata[] = {
gpu/drm/msm/hdmi/hdmi.c:static int msm_hdmi_get_gpio(struct device_node *of_node, const char *name)
gpu/drm/msm/hdmi/hdmi.c:static int msm_hdmi_audio_hw_params(struct device *dev, void *data,
gpu/drm/msm/hdmi/hdmi.c:	msm_hdmi_audio_set_sample_rate(hdmi, rate);
gpu/drm/msm/hdmi/hdmi.c:	msm_hdmi_audio_info_setup(hdmi, 1, chan, channel_allocation,
gpu/drm/msm/hdmi/hdmi.c:static void msm_hdmi_audio_shutdown(struct device *dev, void *data)
gpu/drm/msm/hdmi/hdmi.c:	msm_hdmi_audio_info_setup(hdmi, 0, 0, 0, 0, 0);
gpu/drm/msm/hdmi/hdmi.c:static const struct hdmi_codec_ops msm_hdmi_audio_codec_ops = {
gpu/drm/msm/hdmi/hdmi.c:	.hw_params = msm_hdmi_audio_hw_params,
gpu/drm/msm/hdmi/hdmi.c:	.audio_shutdown = msm_hdmi_audio_shutdown,
gpu/drm/msm/hdmi/hdmi.c:	.ops = &msm_hdmi_audio_codec_ops,
gpu/drm/msm/hdmi/hdmi.c:static int msm_hdmi_register_audio_driver(struct hdmi *hdmi, struct device *dev)
gpu/drm/msm/hdmi/hdmi.c:static int msm_hdmi_bind(struct device *dev, struct device *master, void *data)
gpu/drm/msm/hdmi/hdmi.c:	struct msm_drm_private *priv = drm->dev_private;
gpu/drm/msm/hdmi/hdmi.c:		hdmi_cfg->gpios[i].num = msm_hdmi_get_gpio(of_node,
gpu/drm/msm/hdmi/hdmi.c:						msm_hdmi_gpio_pdata[i].name);
gpu/drm/msm/hdmi/hdmi.c:		hdmi_cfg->gpios[i].output = msm_hdmi_gpio_pdata[i].output;
gpu/drm/msm/hdmi/hdmi.c:		hdmi_cfg->gpios[i].value = msm_hdmi_gpio_pdata[i].value;
gpu/drm/msm/hdmi/hdmi.c:		hdmi_cfg->gpios[i].label = msm_hdmi_gpio_pdata[i].label;
gpu/drm/msm/hdmi/hdmi.c:	hdmi = msm_hdmi_init(to_platform_device(dev));
gpu/drm/msm/hdmi/hdmi.c:	err = msm_hdmi_register_audio_driver(hdmi, dev);
gpu/drm/msm/hdmi/hdmi.c:static void msm_hdmi_unbind(struct device *dev, struct device *master,
gpu/drm/msm/hdmi/hdmi.c:	struct msm_drm_private *priv = drm->dev_private;
gpu/drm/msm/hdmi/hdmi.c:		msm_hdmi_destroy(priv->hdmi);
gpu/drm/msm/hdmi/hdmi.c:static const struct component_ops msm_hdmi_ops = {
gpu/drm/msm/hdmi/hdmi.c:		.bind   = msm_hdmi_bind,
gpu/drm/msm/hdmi/hdmi.c:		.unbind = msm_hdmi_unbind,
gpu/drm/msm/hdmi/hdmi.c:static int msm_hdmi_dev_probe(struct platform_device *pdev)
gpu/drm/msm/hdmi/hdmi.c:	return component_add(&pdev->dev, &msm_hdmi_ops);
gpu/drm/msm/hdmi/hdmi.c:static int msm_hdmi_dev_remove(struct platform_device *pdev)
gpu/drm/msm/hdmi/hdmi.c:	component_del(&pdev->dev, &msm_hdmi_ops);
gpu/drm/msm/hdmi/hdmi.c:static const struct of_device_id msm_hdmi_dt_match[] = {
gpu/drm/msm/hdmi/hdmi.c:static struct platform_driver msm_hdmi_driver = {
gpu/drm/msm/hdmi/hdmi.c:	.probe = msm_hdmi_dev_probe,
gpu/drm/msm/hdmi/hdmi.c:	.remove = msm_hdmi_dev_remove,
gpu/drm/msm/hdmi/hdmi.c:		.name = "hdmi_msm",
gpu/drm/msm/hdmi/hdmi.c:		.of_match_table = msm_hdmi_dt_match,
gpu/drm/msm/hdmi/hdmi.c:void __init msm_hdmi_register(void)
gpu/drm/msm/hdmi/hdmi.c:	msm_hdmi_phy_driver_register();
gpu/drm/msm/hdmi/hdmi.c:	platform_driver_register(&msm_hdmi_driver);
gpu/drm/msm/hdmi/hdmi.c:void __exit msm_hdmi_unregister(void)
gpu/drm/msm/hdmi/hdmi.c:	platform_driver_unregister(&msm_hdmi_driver);
gpu/drm/msm/hdmi/hdmi.c:	msm_hdmi_phy_driver_unregister();
gpu/drm/msm/hdmi/hdmi.h:#include "msm_drv.h"
gpu/drm/msm/hdmi/hdmi.h:void msm_hdmi_set_mode(struct hdmi *hdmi, bool power_on);
gpu/drm/msm/hdmi/hdmi.h:	msm_writel(data, hdmi->mmio + reg);
gpu/drm/msm/hdmi/hdmi.h:	return msm_readl(hdmi->mmio + reg);
gpu/drm/msm/hdmi/hdmi.h:	return msm_readl(hdmi->qfprom_mmio + reg);
gpu/drm/msm/hdmi/hdmi.h:extern const struct hdmi_phy_cfg msm_hdmi_phy_8x60_cfg;
gpu/drm/msm/hdmi/hdmi.h:extern const struct hdmi_phy_cfg msm_hdmi_phy_8960_cfg;
gpu/drm/msm/hdmi/hdmi.h:extern const struct hdmi_phy_cfg msm_hdmi_phy_8x74_cfg;
gpu/drm/msm/hdmi/hdmi.h:extern const struct hdmi_phy_cfg msm_hdmi_phy_8996_cfg;
gpu/drm/msm/hdmi/hdmi.h:	msm_writel(data, phy->mmio + reg);
gpu/drm/msm/hdmi/hdmi.h:	return msm_readl(phy->mmio + reg);
gpu/drm/msm/hdmi/hdmi.h:int msm_hdmi_phy_resource_enable(struct hdmi_phy *phy);
gpu/drm/msm/hdmi/hdmi.h:void msm_hdmi_phy_resource_disable(struct hdmi_phy *phy);
gpu/drm/msm/hdmi/hdmi.h:void msm_hdmi_phy_powerup(struct hdmi_phy *phy, unsigned long int pixclock);
gpu/drm/msm/hdmi/hdmi.h:void msm_hdmi_phy_powerdown(struct hdmi_phy *phy);
gpu/drm/msm/hdmi/hdmi.h:void __init msm_hdmi_phy_driver_register(void);
gpu/drm/msm/hdmi/hdmi.h:void __exit msm_hdmi_phy_driver_unregister(void);
gpu/drm/msm/hdmi/hdmi.h:int msm_hdmi_pll_8960_init(struct platform_device *pdev);
gpu/drm/msm/hdmi/hdmi.h:int msm_hdmi_pll_8996_init(struct platform_device *pdev);
gpu/drm/msm/hdmi/hdmi.h:static inline int msm_hdmi_pll_8960_init(struct platform_device *pdev)
gpu/drm/msm/hdmi/hdmi.h:static inline int msm_hdmi_pll_8996_init(struct platform_device *pdev)
gpu/drm/msm/hdmi/hdmi.h:int msm_hdmi_audio_update(struct hdmi *hdmi);
gpu/drm/msm/hdmi/hdmi.h:int msm_hdmi_audio_info_setup(struct hdmi *hdmi, bool enabled,
gpu/drm/msm/hdmi/hdmi.h:void msm_hdmi_audio_set_sample_rate(struct hdmi *hdmi, int rate);
gpu/drm/msm/hdmi/hdmi.h:struct drm_bridge *msm_hdmi_bridge_init(struct hdmi *hdmi);
gpu/drm/msm/hdmi/hdmi.h:void msm_hdmi_bridge_destroy(struct drm_bridge *bridge);
gpu/drm/msm/hdmi/hdmi.h:void msm_hdmi_connector_irq(struct drm_connector *connector);
gpu/drm/msm/hdmi/hdmi.h:struct drm_connector *msm_hdmi_connector_init(struct hdmi *hdmi);
gpu/drm/msm/hdmi/hdmi.h:int msm_hdmi_hpd_enable(struct drm_connector *connector);
gpu/drm/msm/hdmi/hdmi.h:void msm_hdmi_i2c_irq(struct i2c_adapter *i2c);
gpu/drm/msm/hdmi/hdmi.h:void msm_hdmi_i2c_destroy(struct i2c_adapter *i2c);
gpu/drm/msm/hdmi/hdmi.h:struct i2c_adapter *msm_hdmi_i2c_init(struct hdmi *hdmi);
gpu/drm/msm/hdmi/hdmi.h:struct hdmi_hdcp_ctrl *msm_hdmi_hdcp_init(struct hdmi *hdmi);
gpu/drm/msm/hdmi/hdmi.h:void msm_hdmi_hdcp_destroy(struct hdmi *hdmi);
gpu/drm/msm/hdmi/hdmi.h:void msm_hdmi_hdcp_on(struct hdmi_hdcp_ctrl *hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi.h:void msm_hdmi_hdcp_off(struct hdmi_hdcp_ctrl *hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi.h:void msm_hdmi_hdcp_irq(struct hdmi_hdcp_ctrl *hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi.h:static inline struct hdmi_hdcp_ctrl *msm_hdmi_hdcp_init(struct hdmi *hdmi)
gpu/drm/msm/hdmi/hdmi.h:static inline void msm_hdmi_hdcp_destroy(struct hdmi *hdmi) {}
gpu/drm/msm/hdmi/hdmi.h:static inline void msm_hdmi_hdcp_on(struct hdmi_hdcp_ctrl *hdcp_ctrl) {}
gpu/drm/msm/hdmi/hdmi.h:static inline void msm_hdmi_hdcp_off(struct hdmi_hdcp_ctrl *hdcp_ctrl) {}
gpu/drm/msm/hdmi/hdmi.h:static inline void msm_hdmi_hdcp_irq(struct hdmi_hdcp_ctrl *hdcp_ctrl) {}
gpu/drm/msm/hdmi/hdmi.xml.h:- /home/robclark/src/envytools/rnndb/msm.xml                 (    676 bytes, from 2018-07-03 19:37:13)
gpu/drm/msm/hdmi/hdmi_audio.c:struct hdmi_msm_audio_acr {
gpu/drm/msm/hdmi/hdmi_audio.c:struct hdmi_msm_audio_arcs {
gpu/drm/msm/hdmi/hdmi_audio.c:	struct hdmi_msm_audio_acr lut[MSM_HDMI_SAMPLE_RATE_MAX];
gpu/drm/msm/hdmi/hdmi_audio.c:/* Audio constants lookup table for hdmi_msm_audio_acr_setup */
gpu/drm/msm/hdmi/hdmi_audio.c:static const struct hdmi_msm_audio_arcs acr_lut[] = {
gpu/drm/msm/hdmi/hdmi_audio.c:static const struct hdmi_msm_audio_arcs *get_arcs(unsigned long int pixclock)
gpu/drm/msm/hdmi/hdmi_audio.c:		const struct hdmi_msm_audio_arcs *arcs = &acr_lut[i];
gpu/drm/msm/hdmi/hdmi_audio.c:int msm_hdmi_audio_update(struct hdmi *hdmi)
gpu/drm/msm/hdmi/hdmi_audio.c:	const struct hdmi_msm_audio_arcs *arcs = NULL;
gpu/drm/msm/hdmi/hdmi_audio.c:int msm_hdmi_audio_info_setup(struct hdmi *hdmi, bool enabled,
gpu/drm/msm/hdmi/hdmi_audio.c:	return msm_hdmi_audio_update(hdmi);
gpu/drm/msm/hdmi/hdmi_audio.c:void msm_hdmi_audio_set_sample_rate(struct hdmi *hdmi, int rate)
gpu/drm/msm/hdmi/hdmi_audio.c:	msm_hdmi_audio_update(hdmi);
gpu/drm/msm/hdmi/hdmi_bridge.c:void msm_hdmi_bridge_destroy(struct drm_bridge *bridge)
gpu/drm/msm/hdmi/hdmi_bridge.c:static void msm_hdmi_power_on(struct drm_bridge *bridge)
gpu/drm/msm/hdmi/hdmi_bridge.c:static void msm_hdmi_config_avi_infoframe(struct hdmi *hdmi)
gpu/drm/msm/hdmi/hdmi_bridge.c:static void msm_hdmi_bridge_pre_enable(struct drm_bridge *bridge)
gpu/drm/msm/hdmi/hdmi_bridge.c:		msm_hdmi_phy_resource_enable(phy);
gpu/drm/msm/hdmi/hdmi_bridge.c:		msm_hdmi_power_on(bridge);
gpu/drm/msm/hdmi/hdmi_bridge.c:			msm_hdmi_config_avi_infoframe(hdmi);
gpu/drm/msm/hdmi/hdmi_bridge.c:			msm_hdmi_audio_update(hdmi);
gpu/drm/msm/hdmi/hdmi_bridge.c:	msm_hdmi_phy_powerup(phy, hdmi->pixclock);
gpu/drm/msm/hdmi/hdmi_bridge.c:	msm_hdmi_set_mode(hdmi, true);
gpu/drm/msm/hdmi/hdmi_bridge.c:		msm_hdmi_hdcp_on(hdmi->hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_bridge.c:static void msm_hdmi_bridge_enable(struct drm_bridge *bridge)
gpu/drm/msm/hdmi/hdmi_bridge.c:static void msm_hdmi_bridge_disable(struct drm_bridge *bridge)
gpu/drm/msm/hdmi/hdmi_bridge.c:static void msm_hdmi_bridge_post_disable(struct drm_bridge *bridge)
gpu/drm/msm/hdmi/hdmi_bridge.c:		msm_hdmi_hdcp_off(hdmi->hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_bridge.c:	msm_hdmi_set_mode(hdmi, false);
gpu/drm/msm/hdmi/hdmi_bridge.c:	msm_hdmi_phy_powerdown(phy);
gpu/drm/msm/hdmi/hdmi_bridge.c:			msm_hdmi_audio_update(hdmi);
gpu/drm/msm/hdmi/hdmi_bridge.c:		msm_hdmi_phy_resource_disable(phy);
gpu/drm/msm/hdmi/hdmi_bridge.c:static void msm_hdmi_bridge_mode_set(struct drm_bridge *bridge,
gpu/drm/msm/hdmi/hdmi_bridge.c:		msm_hdmi_audio_update(hdmi);
gpu/drm/msm/hdmi/hdmi_bridge.c:static const struct drm_bridge_funcs msm_hdmi_bridge_funcs = {
gpu/drm/msm/hdmi/hdmi_bridge.c:		.pre_enable = msm_hdmi_bridge_pre_enable,
gpu/drm/msm/hdmi/hdmi_bridge.c:		.enable = msm_hdmi_bridge_enable,
gpu/drm/msm/hdmi/hdmi_bridge.c:		.disable = msm_hdmi_bridge_disable,
gpu/drm/msm/hdmi/hdmi_bridge.c:		.post_disable = msm_hdmi_bridge_post_disable,
gpu/drm/msm/hdmi/hdmi_bridge.c:		.mode_set = msm_hdmi_bridge_mode_set,
gpu/drm/msm/hdmi/hdmi_bridge.c:struct drm_bridge *msm_hdmi_bridge_init(struct hdmi *hdmi)
gpu/drm/msm/hdmi/hdmi_bridge.c:	bridge->funcs = &msm_hdmi_bridge_funcs;
gpu/drm/msm/hdmi/hdmi_bridge.c:		msm_hdmi_bridge_destroy(bridge);
gpu/drm/msm/hdmi/hdmi_connector.c:#include "msm_kms.h"
gpu/drm/msm/hdmi/hdmi_connector.c:static void msm_hdmi_phy_reset(struct hdmi *hdmi)
gpu/drm/msm/hdmi/hdmi_connector.c:int msm_hdmi_hpd_enable(struct drm_connector *connector)
gpu/drm/msm/hdmi/hdmi_connector.c:	msm_hdmi_set_mode(hdmi, false);
gpu/drm/msm/hdmi/hdmi_connector.c:	msm_hdmi_phy_reset(hdmi);
gpu/drm/msm/hdmi/hdmi_connector.c:	msm_hdmi_set_mode(hdmi, true);
gpu/drm/msm/hdmi/hdmi_connector.c:	msm_hdmi_set_mode(hdmi, false);
gpu/drm/msm/hdmi/hdmi_connector.c:msm_hdmi_hotplug_work(struct work_struct *work)
gpu/drm/msm/hdmi/hdmi_connector.c:void msm_hdmi_connector_irq(struct drm_connector *connector)
gpu/drm/msm/hdmi/hdmi_connector.c:static int msm_hdmi_connector_get_modes(struct drm_connector *connector)
gpu/drm/msm/hdmi/hdmi_connector.c:static int msm_hdmi_connector_mode_valid(struct drm_connector *connector,
gpu/drm/msm/hdmi/hdmi_connector.c:	struct msm_drm_private *priv = connector->dev->dev_private;
gpu/drm/msm/hdmi/hdmi_connector.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/hdmi/hdmi_connector.c:static const struct drm_connector_helper_funcs msm_hdmi_connector_helper_funcs = {
gpu/drm/msm/hdmi/hdmi_connector.c:	.get_modes = msm_hdmi_connector_get_modes,
gpu/drm/msm/hdmi/hdmi_connector.c:	.mode_valid = msm_hdmi_connector_mode_valid,
gpu/drm/msm/hdmi/hdmi_connector.c:struct drm_connector *msm_hdmi_connector_init(struct hdmi *hdmi)
gpu/drm/msm/hdmi/hdmi_connector.c:	INIT_WORK(&hdmi_connector->hpd_work, msm_hdmi_hotplug_work);
gpu/drm/msm/hdmi/hdmi_connector.c:	drm_connector_helper_add(connector, &msm_hdmi_connector_helper_funcs);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_ddc_read(struct hdmi *hdmi, u16 addr, u8 offset,
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_ddc_write(struct hdmi *hdmi, u16 addr, u8 offset,
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_scm_wr(struct hdmi_hdcp_ctrl *hdcp_ctrl, u32 *preg,
gpu/drm/msm/hdmi/hdmi_hdcp.c:void msm_hdmi_hdcp_irq(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_msleep(struct hdmi_hdcp_ctrl *hdcp_ctrl, u32 ms, u32 ev)
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_read_validate_aksv(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_reset_hdcp_ddc_failures(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);
gpu/drm/msm/hdmi/hdmi_hdcp.c:			rc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_hw_ddc_clean(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static void msm_hdmi_hdcp_reauth_work(struct work_struct *work)
gpu/drm/msm/hdmi/hdmi_hdcp.c:	if (msm_hdmi_hdcp_hw_ddc_clean(hdcp_ctrl)) {
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_auth_prepare(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_hdcp_read_validate_aksv(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_reset_hdcp_ddc_failures(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static void msm_hdmi_hdcp_auth_fail(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:static void msm_hdmi_hdcp_auth_done(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_wait_key_an_ready(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_send_aksv_an(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_ddc_write(hdmi, HDCP_PORT_ADDR, 0x18, (u8 *)link0_an,
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_ddc_write(hdmi, HDCP_PORT_ADDR, 0x10, aksv, 5);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_recv_bksv(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x00, bksv, 5);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, reg, data, 2);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_recv_bcaps(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x40, &bcaps, 1);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, &reg, &data, 1);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_auth_part1_key_exchange(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_wait_key_an_ready(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_recv_bcaps(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_send_aksv_an(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_recv_bksv(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_auth_part1_recv_r0(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 125, AUTH_ABORT_EV);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x08, buf, 2);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_auth_part1_verify_r0(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 10000, AUTH_RESULT_RDY_EV);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_recv_check_bstatus(struct hdmi_hdcp_ctrl *hdcp_ctrl,
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x41, buf, 2);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_auth_part2_wait_ksv_fifo_ready(
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x40, &bcaps, 1);
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_recv_check_bstatus(hdcp_ctrl, &bstatus);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, &reg, &data, 1);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_transfer_v_h(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR,
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, reg, data, size);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_recv_ksv_fifo(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x43,
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_reset_sha_engine(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, reg, data, 2);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_auth_part2_recv_ksv_fifo(
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_hdcp_recv_ksv_fifo(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 25, AUTH_ABORT_EV);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_transfer_v_h(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_reset_sha_engine(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_write_ksv_fifo(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, &reg, &data, 1);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_auth_part2_write_ksv_fifo(
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_hdcp_write_ksv_fifo(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static int msm_hdmi_hdcp_auth_part2_check_v_match(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:		rc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);
gpu/drm/msm/hdmi/hdmi_hdcp.c:static void msm_hdmi_hdcp_auth_work(struct work_struct *work)
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_auth_prepare(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_auth_part1_key_exchange(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_auth_part1_recv_r0(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_auth_part1_verify_r0(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_auth_part2_wait_ksv_fifo_ready(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_auth_part2_recv_ksv_fifo(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_auth_part2_write_ksv_fifo(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	rc = msm_hdmi_hdcp_auth_part2_check_v_match(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:		msm_hdmi_hdcp_auth_fail(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:		msm_hdmi_hdcp_auth_done(hdcp_ctrl);
gpu/drm/msm/hdmi/hdmi_hdcp.c:void msm_hdmi_hdcp_on(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:void msm_hdmi_hdcp_off(struct hdmi_hdcp_ctrl *hdcp_ctrl)
gpu/drm/msm/hdmi/hdmi_hdcp.c:struct hdmi_hdcp_ctrl *msm_hdmi_hdcp_init(struct hdmi *hdmi)
gpu/drm/msm/hdmi/hdmi_hdcp.c:	INIT_WORK(&hdcp_ctrl->hdcp_auth_work, msm_hdmi_hdcp_auth_work);
gpu/drm/msm/hdmi/hdmi_hdcp.c:	INIT_WORK(&hdcp_ctrl->hdcp_reauth_work, msm_hdmi_hdcp_reauth_work);
gpu/drm/msm/hdmi/hdmi_hdcp.c:void msm_hdmi_hdcp_destroy(struct hdmi *hdmi)
gpu/drm/msm/hdmi/hdmi_i2c.c:static int msm_hdmi_i2c_xfer(struct i2c_adapter *i2c,
gpu/drm/msm/hdmi/hdmi_i2c.c:static u32 msm_hdmi_i2c_func(struct i2c_adapter *adapter)
gpu/drm/msm/hdmi/hdmi_i2c.c:static const struct i2c_algorithm msm_hdmi_i2c_algorithm = {
gpu/drm/msm/hdmi/hdmi_i2c.c:	.master_xfer	= msm_hdmi_i2c_xfer,
gpu/drm/msm/hdmi/hdmi_i2c.c:	.functionality	= msm_hdmi_i2c_func,
gpu/drm/msm/hdmi/hdmi_i2c.c:void msm_hdmi_i2c_irq(struct i2c_adapter *i2c)
gpu/drm/msm/hdmi/hdmi_i2c.c:void msm_hdmi_i2c_destroy(struct i2c_adapter *i2c)
gpu/drm/msm/hdmi/hdmi_i2c.c:struct i2c_adapter *msm_hdmi_i2c_init(struct hdmi *hdmi)
gpu/drm/msm/hdmi/hdmi_i2c.c:	snprintf(i2c->name, sizeof(i2c->name), "msm hdmi i2c");
gpu/drm/msm/hdmi/hdmi_i2c.c:	i2c->algo = &msm_hdmi_i2c_algorithm;
gpu/drm/msm/hdmi/hdmi_i2c.c:		msm_hdmi_i2c_destroy(i2c);
gpu/drm/msm/hdmi/hdmi_phy.c:static int msm_hdmi_phy_resource_init(struct hdmi_phy *phy)
gpu/drm/msm/hdmi/hdmi_phy.c:		clk = msm_clk_get(phy->pdev, cfg->clk_names[i]);
gpu/drm/msm/hdmi/hdmi_phy.c:int msm_hdmi_phy_resource_enable(struct hdmi_phy *phy)
gpu/drm/msm/hdmi/hdmi_phy.c:void msm_hdmi_phy_resource_disable(struct hdmi_phy *phy)
gpu/drm/msm/hdmi/hdmi_phy.c:void msm_hdmi_phy_powerup(struct hdmi_phy *phy, unsigned long int pixclock)
gpu/drm/msm/hdmi/hdmi_phy.c:void msm_hdmi_phy_powerdown(struct hdmi_phy *phy)
gpu/drm/msm/hdmi/hdmi_phy.c:static int msm_hdmi_phy_pll_init(struct platform_device *pdev,
gpu/drm/msm/hdmi/hdmi_phy.c:		ret = msm_hdmi_pll_8960_init(pdev);
gpu/drm/msm/hdmi/hdmi_phy.c:		ret = msm_hdmi_pll_8996_init(pdev);
gpu/drm/msm/hdmi/hdmi_phy.c:static int msm_hdmi_phy_probe(struct platform_device *pdev)
gpu/drm/msm/hdmi/hdmi_phy.c:	phy->mmio = msm_ioremap(pdev, "hdmi_phy", "HDMI_PHY");
gpu/drm/msm/hdmi/hdmi_phy.c:	ret = msm_hdmi_phy_resource_init(phy);
gpu/drm/msm/hdmi/hdmi_phy.c:	ret = msm_hdmi_phy_resource_enable(phy);
gpu/drm/msm/hdmi/hdmi_phy.c:	ret = msm_hdmi_phy_pll_init(pdev, phy->cfg->type);
gpu/drm/msm/hdmi/hdmi_phy.c:		msm_hdmi_phy_resource_disable(phy);
gpu/drm/msm/hdmi/hdmi_phy.c:	msm_hdmi_phy_resource_disable(phy);
gpu/drm/msm/hdmi/hdmi_phy.c:static int msm_hdmi_phy_remove(struct platform_device *pdev)
gpu/drm/msm/hdmi/hdmi_phy.c:static const struct of_device_id msm_hdmi_phy_dt_match[] = {
gpu/drm/msm/hdmi/hdmi_phy.c:	  .data = &msm_hdmi_phy_8x60_cfg },
gpu/drm/msm/hdmi/hdmi_phy.c:	  .data = &msm_hdmi_phy_8960_cfg },
gpu/drm/msm/hdmi/hdmi_phy.c:	  .data = &msm_hdmi_phy_8x74_cfg },
gpu/drm/msm/hdmi/hdmi_phy.c:	  .data = &msm_hdmi_phy_8x74_cfg },
gpu/drm/msm/hdmi/hdmi_phy.c:	  .data = &msm_hdmi_phy_8996_cfg },
gpu/drm/msm/hdmi/hdmi_phy.c:static struct platform_driver msm_hdmi_phy_platform_driver = {
gpu/drm/msm/hdmi/hdmi_phy.c:	.probe      = msm_hdmi_phy_probe,
gpu/drm/msm/hdmi/hdmi_phy.c:	.remove     = msm_hdmi_phy_remove,
gpu/drm/msm/hdmi/hdmi_phy.c:		.name   = "msm_hdmi_phy",
gpu/drm/msm/hdmi/hdmi_phy.c:		.of_match_table = msm_hdmi_phy_dt_match,
gpu/drm/msm/hdmi/hdmi_phy.c:void __init msm_hdmi_phy_driver_register(void)
gpu/drm/msm/hdmi/hdmi_phy.c:	platform_driver_register(&msm_hdmi_phy_platform_driver);
gpu/drm/msm/hdmi/hdmi_phy.c:void __exit msm_hdmi_phy_driver_unregister(void)
gpu/drm/msm/hdmi/hdmi_phy.c:	platform_driver_unregister(&msm_hdmi_phy_platform_driver);
gpu/drm/msm/hdmi/hdmi_phy_8960.c:const struct hdmi_phy_cfg msm_hdmi_phy_8960_cfg = {
gpu/drm/msm/hdmi/hdmi_phy_8996.c:	msm_writel(data, pll->mmio_qserdes_com + offset);
gpu/drm/msm/hdmi/hdmi_phy_8996.c:	return msm_readl(pll->mmio_qserdes_com + offset);
gpu/drm/msm/hdmi/hdmi_phy_8996.c:	 msm_writel(data, pll->mmio_qserdes_tx[channel] + offset);
gpu/drm/msm/hdmi/hdmi_phy_8996.c:int msm_hdmi_pll_8996_init(struct platform_device *pdev)
gpu/drm/msm/hdmi/hdmi_phy_8996.c:	pll->mmio_qserdes_com = msm_ioremap(pdev, "hdmi_pll", "HDMI_PLL");
gpu/drm/msm/hdmi/hdmi_phy_8996.c:		pll->mmio_qserdes_tx[i] = msm_ioremap(pdev, name, label);
gpu/drm/msm/hdmi/hdmi_phy_8996.c:const struct hdmi_phy_cfg msm_hdmi_phy_8996_cfg = {
gpu/drm/msm/hdmi/hdmi_phy_8x60.c:const struct hdmi_phy_cfg msm_hdmi_phy_8x60_cfg = {
gpu/drm/msm/hdmi/hdmi_phy_8x74.c:const struct hdmi_phy_cfg msm_hdmi_phy_8x74_cfg = {
gpu/drm/msm/hdmi/hdmi_pll_8960.c:	msm_writel(data, pll->mmio + reg);
gpu/drm/msm/hdmi/hdmi_pll_8960.c:	return msm_readl(pll->mmio + reg);
gpu/drm/msm/hdmi/hdmi_pll_8960.c:int msm_hdmi_pll_8960_init(struct platform_device *pdev)
gpu/drm/msm/hdmi/hdmi_pll_8960.c:	pll->mmio = msm_ioremap(pdev, "hdmi_pll", "HDMI_PLL");
gpu/drm/msm/hdmi/qfprom.xml.h:- /home/robclark/src/envytools/rnndb/msm.xml                 (    676 bytes, from 2018-07-03 19:37:13)
gpu/drm/msm/msm_atomic.c:#include "msm_drv.h"
gpu/drm/msm/msm_atomic.c:#include "msm_gem.h"
gpu/drm/msm/msm_atomic.c:#include "msm_kms.h"
gpu/drm/msm/msm_atomic.c:static void msm_atomic_wait_for_commit_done(struct drm_device *dev,
gpu/drm/msm/msm_atomic.c:	struct msm_drm_private *priv = old_state->dev->dev_private;
gpu/drm/msm/msm_atomic.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_atomic.c:int msm_atomic_prepare_fb(struct drm_plane *plane,
gpu/drm/msm/msm_atomic.c:	struct msm_drm_private *priv = plane->dev->dev_private;
gpu/drm/msm/msm_atomic.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_atomic.c:	struct msm_gem_object *msm_obj;
gpu/drm/msm/msm_atomic.c:	obj = msm_framebuffer_bo(new_state->fb, 0);
gpu/drm/msm/msm_atomic.c:	msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_atomic.c:	fence = reservation_object_get_excl_rcu(msm_obj->resv);
gpu/drm/msm/msm_atomic.c:	return msm_framebuffer_prepare(new_state->fb, kms->aspace);
gpu/drm/msm/msm_atomic.c:void msm_atomic_commit_tail(struct drm_atomic_state *state)
gpu/drm/msm/msm_atomic.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_atomic.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_atomic.c:	msm_atomic_wait_for_commit_done(dev, state);
gpu/drm/msm/msm_atomic.c:int msm_drm_register_client(struct notifier_block *nb)
gpu/drm/msm/msm_atomic.c:EXPORT_SYMBOL(msm_drm_register_client);
gpu/drm/msm/msm_atomic.c:int msm_drm_unregister_client(struct notifier_block *nb)
gpu/drm/msm/msm_atomic.c:EXPORT_SYMBOL(msm_drm_unregister_client);
gpu/drm/msm/msm_debugfs.c:#include "msm_drv.h"
gpu/drm/msm/msm_debugfs.c:#include "msm_gpu.h"
gpu/drm/msm/msm_debugfs.c:#include "msm_kms.h"
gpu/drm/msm/msm_debugfs.c:#include "msm_debugfs.h"
gpu/drm/msm/msm_debugfs.c:struct msm_gpu_show_priv {
gpu/drm/msm/msm_debugfs.c:	struct msm_gpu_state *state;
gpu/drm/msm/msm_debugfs.c:static int msm_gpu_show(struct seq_file *m, void *arg)
gpu/drm/msm/msm_debugfs.c:	struct msm_gpu_show_priv *show_priv = m->private;
gpu/drm/msm/msm_debugfs.c:	struct msm_drm_private *priv = show_priv->dev->dev_private;
gpu/drm/msm/msm_debugfs.c:	struct msm_gpu *gpu = priv->gpu;
gpu/drm/msm/msm_debugfs.c:static int msm_gpu_release(struct inode *inode, struct file *file)
gpu/drm/msm/msm_debugfs.c:	struct msm_gpu_show_priv *show_priv = m->private;
gpu/drm/msm/msm_debugfs.c:	struct msm_drm_private *priv = show_priv->dev->dev_private;
gpu/drm/msm/msm_debugfs.c:	struct msm_gpu *gpu = priv->gpu;
gpu/drm/msm/msm_debugfs.c:static int msm_gpu_open(struct inode *inode, struct file *file)
gpu/drm/msm/msm_debugfs.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_debugfs.c:	struct msm_gpu *gpu = priv->gpu;
gpu/drm/msm/msm_debugfs.c:	struct msm_gpu_show_priv *show_priv;
gpu/drm/msm/msm_debugfs.c:	msm_gpu_hw_init(gpu);
gpu/drm/msm/msm_debugfs.c:	ret = single_open(file, msm_gpu_show, show_priv);
gpu/drm/msm/msm_debugfs.c:static const struct file_operations msm_gpu_fops = {
gpu/drm/msm/msm_debugfs.c:	.open = msm_gpu_open,
gpu/drm/msm/msm_debugfs.c:	.release = msm_gpu_release,
gpu/drm/msm/msm_debugfs.c:static int msm_gem_show(struct drm_device *dev, struct seq_file *m)
gpu/drm/msm/msm_debugfs.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_debugfs.c:	struct msm_gpu *gpu = priv->gpu;
gpu/drm/msm/msm_debugfs.c:		msm_gem_describe_objects(&gpu->active_list, m);
gpu/drm/msm/msm_debugfs.c:	msm_gem_describe_objects(&priv->inactive_list, m);
gpu/drm/msm/msm_debugfs.c:static int msm_mm_show(struct drm_device *dev, struct seq_file *m)
gpu/drm/msm/msm_debugfs.c:static int msm_fb_show(struct drm_device *dev, struct seq_file *m)
gpu/drm/msm/msm_debugfs.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_debugfs.c:		msm_framebuffer_describe(fbdev_fb, m);
gpu/drm/msm/msm_debugfs.c:		msm_framebuffer_describe(fb, m);
gpu/drm/msm/msm_debugfs.c:static struct drm_info_list msm_debugfs_list[] = {
gpu/drm/msm/msm_debugfs.c:		{"gem", show_locked, 0, msm_gem_show},
gpu/drm/msm/msm_debugfs.c:		{ "mm", show_locked, 0, msm_mm_show },
gpu/drm/msm/msm_debugfs.c:		{ "fb", show_locked, 0, msm_fb_show },
gpu/drm/msm/msm_debugfs.c:	ret = msm_rd_debugfs_init(minor);
gpu/drm/msm/msm_debugfs.c:	ret = msm_perf_debugfs_init(minor);
gpu/drm/msm/msm_debugfs.c:int msm_debugfs_late_init(struct drm_device *dev)
gpu/drm/msm/msm_debugfs.c:int msm_debugfs_init(struct drm_minor *minor)
gpu/drm/msm/msm_debugfs.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_debugfs.c:	ret = drm_debugfs_create_files(msm_debugfs_list,
gpu/drm/msm/msm_debugfs.c:			ARRAY_SIZE(msm_debugfs_list),
gpu/drm/msm/msm_debugfs.c:		dev_err(dev->dev, "could not install msm_debugfs_list\n");
gpu/drm/msm/msm_debugfs.c:		dev, &msm_gpu_fops);
gpu/drm/msm/msm_debugfs.h:int msm_debugfs_init(struct drm_minor *minor);
gpu/drm/msm/msm_drv.c:#include "msm_drv.h"
gpu/drm/msm/msm_drv.c:#include "msm_debugfs.h"
gpu/drm/msm/msm_drv.c:#include "msm_fence.h"
gpu/drm/msm/msm_drv.c:#include "msm_gpu.h"
gpu/drm/msm/msm_drv.c:#include "msm_kms.h"
gpu/drm/msm/msm_drv.c:	.fb_create = msm_framebuffer_create,
gpu/drm/msm/msm_drv.c:	.atomic_commit_tail = msm_atomic_commit_tail,
gpu/drm/msm/msm_drv.c:int msm_clk_bulk_get(struct device *dev, struct clk_bulk_data **bulk)
gpu/drm/msm/msm_drv.c:struct clk *msm_clk_bulk_get_clock(struct clk_bulk_data *bulk, int count,
gpu/drm/msm/msm_drv.c:struct clk *msm_clk_get(struct platform_device *pdev, const char *name)
gpu/drm/msm/msm_drv.c:void __iomem *msm_ioremap(struct platform_device *pdev, const char *name,
gpu/drm/msm/msm_drv.c:void msm_writel(u32 data, void __iomem *addr)
gpu/drm/msm/msm_drv.c:u32 msm_readl(const void __iomem *addr)
gpu/drm/msm/msm_drv.c:	struct msm_vblank_ctrl *vbl_ctrl = container_of(work,
gpu/drm/msm/msm_drv.c:						struct msm_vblank_ctrl, work);
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = container_of(vbl_ctrl,
gpu/drm/msm/msm_drv.c:					struct msm_drm_private, vblank_ctrl);
gpu/drm/msm/msm_drv.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_drv.c:static int vblank_ctrl_queue_work(struct msm_drm_private *priv,
gpu/drm/msm/msm_drv.c:	struct msm_vblank_ctrl *vbl_ctrl = &priv->vblank_ctrl;
gpu/drm/msm/msm_drv.c:static int msm_drm_uninit(struct device *dev)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = ddev->dev_private;
gpu/drm/msm/msm_drv.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_drv.c:	struct msm_mdss *mdss = priv->mdss;
gpu/drm/msm/msm_drv.c:	struct msm_vblank_ctrl *vbl_ctrl = &priv->vblank_ctrl;
gpu/drm/msm/msm_drv.c:	msm_gem_shrinker_cleanup(ddev);
gpu/drm/msm/msm_drv.c:	msm_perf_debugfs_cleanup(priv);
gpu/drm/msm/msm_drv.c:	msm_rd_debugfs_cleanup(priv);
gpu/drm/msm/msm_drv.c:		msm_fbdev_free(ddev);
gpu/drm/msm/msm_drv.c:static int msm_init_vram(struct drm_device *dev)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_drv.c:		 * mach-msm:
gpu/drm/msm/msm_drv.c:static int msm_drm_init(struct device *dev, struct drm_driver *drv)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv;
gpu/drm/msm/msm_drv.c:	struct msm_kms *kms;
gpu/drm/msm/msm_drv.c:	struct msm_mdss *mdss;
gpu/drm/msm/msm_drv.c:	priv->wq = alloc_ordered_workqueue("msm", 0);
gpu/drm/msm/msm_drv.c:	ret = msm_init_vram(ddev);
gpu/drm/msm/msm_drv.c:			goto err_msm_uninit;
gpu/drm/msm/msm_drv.c:	msm_gem_shrinker_init(ddev);
gpu/drm/msm/msm_drv.c:		goto err_msm_uninit;
gpu/drm/msm/msm_drv.c:			goto err_msm_uninit;
gpu/drm/msm/msm_drv.c:			goto err_msm_uninit;
gpu/drm/msm/msm_drv.c:		goto err_msm_uninit;
gpu/drm/msm/msm_drv.c:			goto err_msm_uninit;
gpu/drm/msm/msm_drv.c:		goto err_msm_uninit;
gpu/drm/msm/msm_drv.c:		priv->fbdev = msm_fbdev_init(ddev);
gpu/drm/msm/msm_drv.c:	ret = msm_debugfs_late_init(ddev);
gpu/drm/msm/msm_drv.c:		goto err_msm_uninit;
gpu/drm/msm/msm_drv.c:err_msm_uninit:
gpu/drm/msm/msm_drv.c:	msm_drm_uninit(dev);
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_drv.c:	struct msm_file_private *ctx;
gpu/drm/msm/msm_drv.c:	msm_submitqueue_init(dev, ctx);
gpu/drm/msm/msm_drv.c:static int msm_open(struct drm_device *dev, struct drm_file *file)
gpu/drm/msm/msm_drv.c:static void context_close(struct msm_file_private *ctx)
gpu/drm/msm/msm_drv.c:	msm_submitqueue_close(ctx);
gpu/drm/msm/msm_drv.c:static void msm_postclose(struct drm_device *dev, struct drm_file *file)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_drv.c:	struct msm_file_private *ctx = file->driver_priv;
gpu/drm/msm/msm_drv.c:static irqreturn_t msm_irq(int irq, void *arg)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_drv.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_drv.c:static void msm_irq_preinstall(struct drm_device *dev)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_drv.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_drv.c:static int msm_irq_postinstall(struct drm_device *dev)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_drv.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_drv.c:static void msm_irq_uninstall(struct drm_device *dev)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_drv.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_drv.c:static int msm_enable_vblank(struct drm_device *dev, unsigned int pipe)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_drv.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_drv.c:static void msm_disable_vblank(struct drm_device *dev, unsigned int pipe)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_drv.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_drv.c:static int msm_ioctl_get_param(struct drm_device *dev, void *data,
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_drv.c:	struct drm_msm_param *args = data;
gpu/drm/msm/msm_drv.c:	struct msm_gpu *gpu;
gpu/drm/msm/msm_drv.c:static int msm_ioctl_gem_new(struct drm_device *dev, void *data,
gpu/drm/msm/msm_drv.c:	struct drm_msm_gem_new *args = data;
gpu/drm/msm/msm_drv.c:	return msm_gem_new_handle(dev, file, args->size,
gpu/drm/msm/msm_drv.c:static inline ktime_t to_ktime(struct drm_msm_timespec timeout)
gpu/drm/msm/msm_drv.c:static int msm_ioctl_gem_cpu_prep(struct drm_device *dev, void *data,
gpu/drm/msm/msm_drv.c:	struct drm_msm_gem_cpu_prep *args = data;
gpu/drm/msm/msm_drv.c:	ret = msm_gem_cpu_prep(obj, args->op, &timeout);
gpu/drm/msm/msm_drv.c:static int msm_ioctl_gem_cpu_fini(struct drm_device *dev, void *data,
gpu/drm/msm/msm_drv.c:	struct drm_msm_gem_cpu_fini *args = data;
gpu/drm/msm/msm_drv.c:	ret = msm_gem_cpu_fini(obj);
gpu/drm/msm/msm_drv.c:static int msm_ioctl_gem_info_iova(struct drm_device *dev,
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_drv.c:	return msm_gem_get_iova(obj, priv->gpu->aspace, iova);
gpu/drm/msm/msm_drv.c:static int msm_ioctl_gem_info(struct drm_device *dev, void *data,
gpu/drm/msm/msm_drv.c:	struct drm_msm_gem_info *args = data;
gpu/drm/msm/msm_drv.c:		ret = msm_ioctl_gem_info_iova(dev, obj, &iova);
gpu/drm/msm/msm_drv.c:		args->offset = msm_gem_mmap_offset(obj);
gpu/drm/msm/msm_drv.c:static int msm_ioctl_wait_fence(struct drm_device *dev, void *data,
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_drv.c:	struct drm_msm_wait_fence *args = data;
gpu/drm/msm/msm_drv.c:	struct msm_gpu_submitqueue *queue;
gpu/drm/msm/msm_drv.c:	struct msm_gpu *gpu = priv->gpu;
gpu/drm/msm/msm_drv.c:	queue = msm_submitqueue_get(file->driver_priv, args->queueid);
gpu/drm/msm/msm_drv.c:	ret = msm_wait_fence(gpu->rb[queue->prio]->fctx, args->fence, &timeout,
gpu/drm/msm/msm_drv.c:	msm_submitqueue_put(queue);
gpu/drm/msm/msm_drv.c:static int msm_ioctl_gem_madvise(struct drm_device *dev, void *data,
gpu/drm/msm/msm_drv.c:	struct drm_msm_gem_madvise *args = data;
gpu/drm/msm/msm_drv.c:	ret = msm_gem_madvise(obj, args->madv);
gpu/drm/msm/msm_drv.c:static int msm_ioctl_submitqueue_new(struct drm_device *dev, void *data,
gpu/drm/msm/msm_drv.c:	struct drm_msm_submitqueue *args = data;
gpu/drm/msm/msm_drv.c:	return msm_submitqueue_create(dev, file->driver_priv, args->prio,
gpu/drm/msm/msm_drv.c:static int msm_ioctl_submitqueue_close(struct drm_device *dev, void *data,
gpu/drm/msm/msm_drv.c:	return msm_submitqueue_remove(file->driver_priv, id);
gpu/drm/msm/msm_drv.c:static const struct drm_ioctl_desc msm_ioctls[] = {
gpu/drm/msm/msm_drv.c:	DRM_IOCTL_DEF_DRV(MSM_GET_PARAM,    msm_ioctl_get_param,    DRM_AUTH|DRM_RENDER_ALLOW),
gpu/drm/msm/msm_drv.c:	DRM_IOCTL_DEF_DRV(MSM_GEM_NEW,      msm_ioctl_gem_new,      DRM_AUTH|DRM_RENDER_ALLOW),
gpu/drm/msm/msm_drv.c:	DRM_IOCTL_DEF_DRV(MSM_GEM_INFO,     msm_ioctl_gem_info,     DRM_AUTH|DRM_RENDER_ALLOW),
gpu/drm/msm/msm_drv.c:	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_PREP, msm_ioctl_gem_cpu_prep, DRM_AUTH|DRM_RENDER_ALLOW),
gpu/drm/msm/msm_drv.c:	DRM_IOCTL_DEF_DRV(MSM_GEM_CPU_FINI, msm_ioctl_gem_cpu_fini, DRM_AUTH|DRM_RENDER_ALLOW),
gpu/drm/msm/msm_drv.c:	DRM_IOCTL_DEF_DRV(MSM_GEM_SUBMIT,   msm_ioctl_gem_submit,   DRM_AUTH|DRM_RENDER_ALLOW),
gpu/drm/msm/msm_drv.c:	DRM_IOCTL_DEF_DRV(MSM_WAIT_FENCE,   msm_ioctl_wait_fence,   DRM_AUTH|DRM_RENDER_ALLOW),
gpu/drm/msm/msm_drv.c:	DRM_IOCTL_DEF_DRV(MSM_GEM_MADVISE,  msm_ioctl_gem_madvise,  DRM_AUTH|DRM_RENDER_ALLOW),
gpu/drm/msm/msm_drv.c:	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_NEW,   msm_ioctl_submitqueue_new,   DRM_AUTH|DRM_RENDER_ALLOW),
gpu/drm/msm/msm_drv.c:	DRM_IOCTL_DEF_DRV(MSM_SUBMITQUEUE_CLOSE, msm_ioctl_submitqueue_close, DRM_AUTH|DRM_RENDER_ALLOW),
gpu/drm/msm/msm_drv.c:	.fault = msm_gem_fault,
gpu/drm/msm/msm_drv.c:	.mmap               = msm_gem_mmap,
gpu/drm/msm/msm_drv.c:static struct drm_driver msm_driver = {
gpu/drm/msm/msm_drv.c:	.open               = msm_open,
gpu/drm/msm/msm_drv.c:	.postclose           = msm_postclose,
gpu/drm/msm/msm_drv.c:	.irq_handler        = msm_irq,
gpu/drm/msm/msm_drv.c:	.irq_preinstall     = msm_irq_preinstall,
gpu/drm/msm/msm_drv.c:	.irq_postinstall    = msm_irq_postinstall,
gpu/drm/msm/msm_drv.c:	.irq_uninstall      = msm_irq_uninstall,
gpu/drm/msm/msm_drv.c:	.enable_vblank      = msm_enable_vblank,
gpu/drm/msm/msm_drv.c:	.disable_vblank     = msm_disable_vblank,
gpu/drm/msm/msm_drv.c:	.gem_free_object    = msm_gem_free_object,
gpu/drm/msm/msm_drv.c:	.dumb_create        = msm_gem_dumb_create,
gpu/drm/msm/msm_drv.c:	.dumb_map_offset    = msm_gem_dumb_map_offset,
gpu/drm/msm/msm_drv.c:	.gem_prime_res_obj  = msm_gem_prime_res_obj,
gpu/drm/msm/msm_drv.c:	.gem_prime_pin      = msm_gem_prime_pin,
gpu/drm/msm/msm_drv.c:	.gem_prime_unpin    = msm_gem_prime_unpin,
gpu/drm/msm/msm_drv.c:	.gem_prime_get_sg_table = msm_gem_prime_get_sg_table,
gpu/drm/msm/msm_drv.c:	.gem_prime_import_sg_table = msm_gem_prime_import_sg_table,
gpu/drm/msm/msm_drv.c:	.gem_prime_vmap     = msm_gem_prime_vmap,
gpu/drm/msm/msm_drv.c:	.gem_prime_vunmap   = msm_gem_prime_vunmap,
gpu/drm/msm/msm_drv.c:	.gem_prime_mmap     = msm_gem_prime_mmap,
gpu/drm/msm/msm_drv.c:	.debugfs_init       = msm_debugfs_init,
gpu/drm/msm/msm_drv.c:	.ioctls             = msm_ioctls,
gpu/drm/msm/msm_drv.c:	.num_ioctls         = ARRAY_SIZE(msm_ioctls),
gpu/drm/msm/msm_drv.c:	.name               = "msm",
gpu/drm/msm/msm_drv.c:static int msm_pm_suspend(struct device *dev)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = ddev->dev_private;
gpu/drm/msm/msm_drv.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_drv.c:static int msm_pm_resume(struct device *dev)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = ddev->dev_private;
gpu/drm/msm/msm_drv.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_drv.c:static int msm_runtime_suspend(struct device *dev)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = ddev->dev_private;
gpu/drm/msm/msm_drv.c:	struct msm_mdss *mdss = priv->mdss;
gpu/drm/msm/msm_drv.c:static int msm_runtime_resume(struct device *dev)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = ddev->dev_private;
gpu/drm/msm/msm_drv.c:	struct msm_mdss *mdss = priv->mdss;
gpu/drm/msm/msm_drv.c:static const struct dev_pm_ops msm_pm_ops = {
gpu/drm/msm/msm_drv.c:	SET_SYSTEM_SLEEP_PM_OPS(msm_pm_suspend, msm_pm_resume)
gpu/drm/msm/msm_drv.c:	SET_RUNTIME_PM_OPS(msm_runtime_suspend, msm_runtime_resume, NULL)
gpu/drm/msm/msm_drv.c:static const struct of_device_id msm_gpu_match[] = {
gpu/drm/msm/msm_drv.c:	np = of_find_matching_node(NULL, msm_gpu_match);
gpu/drm/msm/msm_drv.c:static int msm_drm_bind(struct device *dev)
gpu/drm/msm/msm_drv.c:	return msm_drm_init(dev, &msm_driver);
gpu/drm/msm/msm_drv.c:static void msm_drm_unbind(struct device *dev)
gpu/drm/msm/msm_drv.c:	msm_drm_uninit(dev);
gpu/drm/msm/msm_drv.c:static const struct component_master_ops msm_drm_ops = {
gpu/drm/msm/msm_drv.c:	.bind = msm_drm_bind,
gpu/drm/msm/msm_drv.c:	.unbind = msm_drm_unbind,
gpu/drm/msm/msm_drv.c:static int msm_pdev_probe(struct platform_device *pdev)
gpu/drm/msm/msm_drv.c:	ret = component_master_add_with_match(&pdev->dev, &msm_drm_ops, match);
gpu/drm/msm/msm_drv.c:static int msm_pdev_remove(struct platform_device *pdev)
gpu/drm/msm/msm_drv.c:	component_master_del(&pdev->dev, &msm_drm_ops);
gpu/drm/msm/msm_drv.c:static void msm_pdev_shutdown(struct platform_device *pdev)
gpu/drm/msm/msm_drv.c:	struct msm_drm_private *priv = drm ? drm->dev_private : NULL;
gpu/drm/msm/msm_drv.c:static struct platform_driver msm_platform_driver = {
gpu/drm/msm/msm_drv.c:	.probe      = msm_pdev_probe,
gpu/drm/msm/msm_drv.c:	.remove     = msm_pdev_remove,
gpu/drm/msm/msm_drv.c:	.shutdown   = msm_pdev_shutdown,
gpu/drm/msm/msm_drv.c:		.name   = "msm",
gpu/drm/msm/msm_drv.c:		.pm     = &msm_pm_ops,
gpu/drm/msm/msm_drv.c:static int __init msm_drm_register(void)
gpu/drm/msm/msm_drv.c:	msm_mdp_register();
gpu/drm/msm/msm_drv.c:	msm_dpu_register();
gpu/drm/msm/msm_drv.c:	msm_dsi_register();
gpu/drm/msm/msm_drv.c:	msm_edp_register();
gpu/drm/msm/msm_drv.c:	msm_hdmi_register();
gpu/drm/msm/msm_drv.c:	return platform_driver_register(&msm_platform_driver);
gpu/drm/msm/msm_drv.c:static void __exit msm_drm_unregister(void)
gpu/drm/msm/msm_drv.c:	platform_driver_unregister(&msm_platform_driver);
gpu/drm/msm/msm_drv.c:	msm_hdmi_unregister();
gpu/drm/msm/msm_drv.c:	msm_edp_unregister();
gpu/drm/msm/msm_drv.c:	msm_dsi_unregister();
gpu/drm/msm/msm_drv.c:	msm_mdp_unregister();
gpu/drm/msm/msm_drv.c:	msm_dpu_unregister();
gpu/drm/msm/msm_drv.c:module_init(msm_drm_register);
gpu/drm/msm/msm_drv.c:module_exit(msm_drm_unregister);
gpu/drm/msm/msm_drv.h:#include <drm/msm_drm.h>
gpu/drm/msm/msm_drv.h:struct msm_kms;
gpu/drm/msm/msm_drv.h:struct msm_gpu;
gpu/drm/msm/msm_drv.h:struct msm_mmu;
gpu/drm/msm/msm_drv.h:struct msm_mdss;
gpu/drm/msm/msm_drv.h:struct msm_rd_state;
gpu/drm/msm/msm_drv.h:struct msm_perf_state;
gpu/drm/msm/msm_drv.h:struct msm_gem_submit;
gpu/drm/msm/msm_drv.h:struct msm_fence_context;
gpu/drm/msm/msm_drv.h:struct msm_gem_address_space;
gpu/drm/msm/msm_drv.h:struct msm_gem_vma;
gpu/drm/msm/msm_drv.h:struct msm_file_private {
gpu/drm/msm/msm_drv.h:enum msm_mdp_plane_property {
gpu/drm/msm/msm_drv.h:struct msm_vblank_ctrl {
gpu/drm/msm/msm_drv.h: * enum msm_display_caps - features/capabilities supported by displays
gpu/drm/msm/msm_drv.h:enum msm_display_caps {
gpu/drm/msm/msm_drv.h: * enum msm_event_wait - type of HW events to wait for
gpu/drm/msm/msm_drv.h:enum msm_event_wait {
gpu/drm/msm/msm_drv.h: * struct msm_display_topology - defines a display topology pipeline
gpu/drm/msm/msm_drv.h:struct msm_display_topology {
gpu/drm/msm/msm_drv.h: * struct msm_display_info - defines display properties
gpu/drm/msm/msm_drv.h:struct msm_display_info {
gpu/drm/msm/msm_drv.h:struct msm_drm_thread {
gpu/drm/msm/msm_drv.h:struct msm_drm_private {
gpu/drm/msm/msm_drv.h:	struct msm_kms *kms;
gpu/drm/msm/msm_drv.h:	struct msm_mdss *mdss;
gpu/drm/msm/msm_drv.h:	struct msm_edp *edp;
gpu/drm/msm/msm_drv.h:	struct msm_dsi *dsi[2];
gpu/drm/msm/msm_drv.h:	/* when we have more than one 'msm_gpu' these need to be an array: */
gpu/drm/msm/msm_drv.h:	struct msm_gpu *gpu;
gpu/drm/msm/msm_drv.h:	struct msm_file_private *lastctx;
gpu/drm/msm/msm_drv.h:	struct msm_rd_state *rd;       /* debugfs to dump all submits */
gpu/drm/msm/msm_drv.h:	struct msm_rd_state *hangrd;   /* debugfs to dump hanging submits */
gpu/drm/msm/msm_drv.h:	struct msm_perf_state *perf;
gpu/drm/msm/msm_drv.h:	struct msm_drm_thread disp_thread[MAX_CRTCS];
gpu/drm/msm/msm_drv.h:	struct msm_drm_thread event_thread[MAX_CRTCS];
gpu/drm/msm/msm_drv.h:	struct msm_vblank_ctrl vblank_ctrl;
gpu/drm/msm/msm_drv.h:struct msm_format {
gpu/drm/msm/msm_drv.h:int msm_atomic_prepare_fb(struct drm_plane *plane,
gpu/drm/msm/msm_drv.h:void msm_atomic_commit_tail(struct drm_atomic_state *state);
gpu/drm/msm/msm_drv.h:struct drm_atomic_state *msm_atomic_state_alloc(struct drm_device *dev);
gpu/drm/msm/msm_drv.h:void msm_atomic_state_clear(struct drm_atomic_state *state);
gpu/drm/msm/msm_drv.h:void msm_atomic_state_free(struct drm_atomic_state *state);
gpu/drm/msm/msm_drv.h:void msm_gem_unmap_vma(struct msm_gem_address_space *aspace,
gpu/drm/msm/msm_drv.h:		struct msm_gem_vma *vma, struct sg_table *sgt);
gpu/drm/msm/msm_drv.h:int msm_gem_map_vma(struct msm_gem_address_space *aspace,
gpu/drm/msm/msm_drv.h:		struct msm_gem_vma *vma, struct sg_table *sgt, int npages);
gpu/drm/msm/msm_drv.h:void msm_gem_address_space_put(struct msm_gem_address_space *aspace);
gpu/drm/msm/msm_drv.h:struct msm_gem_address_space *
gpu/drm/msm/msm_drv.h:msm_gem_address_space_create(struct device *dev, struct iommu_domain *domain,
gpu/drm/msm/msm_drv.h:int msm_register_mmu(struct drm_device *dev, struct msm_mmu *mmu);
gpu/drm/msm/msm_drv.h:void msm_unregister_mmu(struct drm_device *dev, struct msm_mmu *mmu);
gpu/drm/msm/msm_drv.h:void msm_gem_submit_free(struct msm_gem_submit *submit);
gpu/drm/msm/msm_drv.h:int msm_ioctl_gem_submit(struct drm_device *dev, void *data,
gpu/drm/msm/msm_drv.h:void msm_gem_shrinker_init(struct drm_device *dev);
gpu/drm/msm/msm_drv.h:void msm_gem_shrinker_cleanup(struct drm_device *dev);
gpu/drm/msm/msm_drv.h:int msm_gem_mmap_obj(struct drm_gem_object *obj,
gpu/drm/msm/msm_drv.h:int msm_gem_mmap(struct file *filp, struct vm_area_struct *vma);
gpu/drm/msm/msm_drv.h:vm_fault_t msm_gem_fault(struct vm_fault *vmf);
gpu/drm/msm/msm_drv.h:uint64_t msm_gem_mmap_offset(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:int msm_gem_get_iova(struct drm_gem_object *obj,
gpu/drm/msm/msm_drv.h:		struct msm_gem_address_space *aspace, uint64_t *iova);
gpu/drm/msm/msm_drv.h:uint64_t msm_gem_iova(struct drm_gem_object *obj,
gpu/drm/msm/msm_drv.h:		struct msm_gem_address_space *aspace);
gpu/drm/msm/msm_drv.h:struct page **msm_gem_get_pages(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:void msm_gem_put_pages(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:void msm_gem_put_iova(struct drm_gem_object *obj,
gpu/drm/msm/msm_drv.h:		struct msm_gem_address_space *aspace);
gpu/drm/msm/msm_drv.h:int msm_gem_dumb_create(struct drm_file *file, struct drm_device *dev,
gpu/drm/msm/msm_drv.h:int msm_gem_dumb_map_offset(struct drm_file *file, struct drm_device *dev,
gpu/drm/msm/msm_drv.h:struct sg_table *msm_gem_prime_get_sg_table(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:void *msm_gem_prime_vmap(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:void msm_gem_prime_vunmap(struct drm_gem_object *obj, void *vaddr);
gpu/drm/msm/msm_drv.h:int msm_gem_prime_mmap(struct drm_gem_object *obj, struct vm_area_struct *vma);
gpu/drm/msm/msm_drv.h:struct reservation_object *msm_gem_prime_res_obj(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:struct drm_gem_object *msm_gem_prime_import_sg_table(struct drm_device *dev,
gpu/drm/msm/msm_drv.h:int msm_gem_prime_pin(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:void msm_gem_prime_unpin(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:void *msm_gem_get_vaddr(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:void *msm_gem_get_vaddr_active(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:void msm_gem_put_vaddr(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:int msm_gem_madvise(struct drm_gem_object *obj, unsigned madv);
gpu/drm/msm/msm_drv.h:int msm_gem_sync_object(struct drm_gem_object *obj,
gpu/drm/msm/msm_drv.h:		struct msm_fence_context *fctx, bool exclusive);
gpu/drm/msm/msm_drv.h:void msm_gem_move_to_active(struct drm_gem_object *obj,
gpu/drm/msm/msm_drv.h:		struct msm_gpu *gpu, bool exclusive, struct dma_fence *fence);
gpu/drm/msm/msm_drv.h:void msm_gem_move_to_inactive(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:int msm_gem_cpu_prep(struct drm_gem_object *obj, uint32_t op, ktime_t *timeout);
gpu/drm/msm/msm_drv.h:int msm_gem_cpu_fini(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:void msm_gem_free_object(struct drm_gem_object *obj);
gpu/drm/msm/msm_drv.h:int msm_gem_new_handle(struct drm_device *dev, struct drm_file *file,
gpu/drm/msm/msm_drv.h:struct drm_gem_object *msm_gem_new(struct drm_device *dev,
gpu/drm/msm/msm_drv.h:struct drm_gem_object *msm_gem_new_locked(struct drm_device *dev,
gpu/drm/msm/msm_drv.h:void *msm_gem_kernel_new(struct drm_device *dev, uint32_t size,
gpu/drm/msm/msm_drv.h:		uint32_t flags, struct msm_gem_address_space *aspace,
gpu/drm/msm/msm_drv.h:void *msm_gem_kernel_new_locked(struct drm_device *dev, uint32_t size,
gpu/drm/msm/msm_drv.h:		uint32_t flags, struct msm_gem_address_space *aspace,
gpu/drm/msm/msm_drv.h:struct drm_gem_object *msm_gem_import(struct drm_device *dev,
gpu/drm/msm/msm_drv.h:int msm_framebuffer_prepare(struct drm_framebuffer *fb,
gpu/drm/msm/msm_drv.h:		struct msm_gem_address_space *aspace);
gpu/drm/msm/msm_drv.h:void msm_framebuffer_cleanup(struct drm_framebuffer *fb,
gpu/drm/msm/msm_drv.h:		struct msm_gem_address_space *aspace);
gpu/drm/msm/msm_drv.h:uint32_t msm_framebuffer_iova(struct drm_framebuffer *fb,
gpu/drm/msm/msm_drv.h:		struct msm_gem_address_space *aspace, int plane);
gpu/drm/msm/msm_drv.h:struct drm_gem_object *msm_framebuffer_bo(struct drm_framebuffer *fb, int plane);
gpu/drm/msm/msm_drv.h:const struct msm_format *msm_framebuffer_format(struct drm_framebuffer *fb);
gpu/drm/msm/msm_drv.h:struct drm_framebuffer *msm_framebuffer_create(struct drm_device *dev,
gpu/drm/msm/msm_drv.h:struct drm_framebuffer * msm_alloc_stolen_fb(struct drm_device *dev,
gpu/drm/msm/msm_drv.h:struct drm_fb_helper *msm_fbdev_init(struct drm_device *dev);
gpu/drm/msm/msm_drv.h:void msm_fbdev_free(struct drm_device *dev);
gpu/drm/msm/msm_drv.h:int msm_hdmi_modeset_init(struct hdmi *hdmi, struct drm_device *dev,
gpu/drm/msm/msm_drv.h:void __init msm_hdmi_register(void);
gpu/drm/msm/msm_drv.h:void __exit msm_hdmi_unregister(void);
gpu/drm/msm/msm_drv.h:struct msm_edp;
gpu/drm/msm/msm_drv.h:void __init msm_edp_register(void);
gpu/drm/msm/msm_drv.h:void __exit msm_edp_unregister(void);
gpu/drm/msm/msm_drv.h:int msm_edp_modeset_init(struct msm_edp *edp, struct drm_device *dev,
gpu/drm/msm/msm_drv.h:struct msm_dsi;
gpu/drm/msm/msm_drv.h:void __init msm_dsi_register(void);
gpu/drm/msm/msm_drv.h:void __exit msm_dsi_unregister(void);
gpu/drm/msm/msm_drv.h:int msm_dsi_modeset_init(struct msm_dsi *msm_dsi, struct drm_device *dev,
gpu/drm/msm/msm_drv.h:static inline void __init msm_dsi_register(void)
gpu/drm/msm/msm_drv.h:static inline void __exit msm_dsi_unregister(void)
gpu/drm/msm/msm_drv.h:static inline int msm_dsi_modeset_init(struct msm_dsi *msm_dsi,
gpu/drm/msm/msm_drv.h:void __init msm_mdp_register(void);
gpu/drm/msm/msm_drv.h:void __exit msm_mdp_unregister(void);
gpu/drm/msm/msm_drv.h:void __init msm_dpu_register(void);
gpu/drm/msm/msm_drv.h:void __exit msm_dpu_unregister(void);
gpu/drm/msm/msm_drv.h:void msm_gem_describe(struct drm_gem_object *obj, struct seq_file *m);
gpu/drm/msm/msm_drv.h:void msm_gem_describe_objects(struct list_head *list, struct seq_file *m);
gpu/drm/msm/msm_drv.h:void msm_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m);
gpu/drm/msm/msm_drv.h:int msm_debugfs_late_init(struct drm_device *dev);
gpu/drm/msm/msm_drv.h:int msm_rd_debugfs_init(struct drm_minor *minor);
gpu/drm/msm/msm_drv.h:void msm_rd_debugfs_cleanup(struct msm_drm_private *priv);
gpu/drm/msm/msm_drv.h:void msm_rd_dump_submit(struct msm_rd_state *rd, struct msm_gem_submit *submit,
gpu/drm/msm/msm_drv.h:int msm_perf_debugfs_init(struct drm_minor *minor);
gpu/drm/msm/msm_drv.h:void msm_perf_debugfs_cleanup(struct msm_drm_private *priv);
gpu/drm/msm/msm_drv.h:static inline int msm_debugfs_late_init(struct drm_device *dev) { return 0; }
gpu/drm/msm/msm_drv.h:static inline void msm_rd_dump_submit(struct msm_rd_state *rd, struct msm_gem_submit *submit,
gpu/drm/msm/msm_drv.h:static inline void msm_rd_debugfs_cleanup(struct msm_drm_private *priv) {}
gpu/drm/msm/msm_drv.h:static inline void msm_perf_debugfs_cleanup(struct msm_drm_private *priv) {}
gpu/drm/msm/msm_drv.h:struct clk *msm_clk_get(struct platform_device *pdev, const char *name);
gpu/drm/msm/msm_drv.h:int msm_clk_bulk_get(struct device *dev, struct clk_bulk_data **bulk);
gpu/drm/msm/msm_drv.h:struct clk *msm_clk_bulk_get_clock(struct clk_bulk_data *bulk, int count,
gpu/drm/msm/msm_drv.h:void __iomem *msm_ioremap(struct platform_device *pdev, const char *name,
gpu/drm/msm/msm_drv.h:void msm_writel(u32 data, void __iomem *addr);
gpu/drm/msm/msm_drv.h:u32 msm_readl(const void __iomem *addr);
gpu/drm/msm/msm_drv.h:struct msm_gpu_submitqueue;
gpu/drm/msm/msm_drv.h:int msm_submitqueue_init(struct drm_device *drm, struct msm_file_private *ctx);
gpu/drm/msm/msm_drv.h:struct msm_gpu_submitqueue *msm_submitqueue_get(struct msm_file_private *ctx,
gpu/drm/msm/msm_drv.h:int msm_submitqueue_create(struct drm_device *drm, struct msm_file_private *ctx,
gpu/drm/msm/msm_drv.h:int msm_submitqueue_remove(struct msm_file_private *ctx, u32 id);
gpu/drm/msm/msm_drv.h:void msm_submitqueue_close(struct msm_file_private *ctx);
gpu/drm/msm/msm_drv.h:void msm_submitqueue_destroy(struct kref *kref);
gpu/drm/msm/msm_fb.c:#include "msm_drv.h"
gpu/drm/msm/msm_fb.c:#include "msm_kms.h"
gpu/drm/msm/msm_fb.c:#include "msm_gem.h"
gpu/drm/msm/msm_fb.c:struct msm_framebuffer {
gpu/drm/msm/msm_fb.c:	const struct msm_format *format;
gpu/drm/msm/msm_fb.c:#define to_msm_framebuffer(x) container_of(x, struct msm_framebuffer, base)
gpu/drm/msm/msm_fb.c:static struct drm_framebuffer *msm_framebuffer_init(struct drm_device *dev,
gpu/drm/msm/msm_fb.c:static const struct drm_framebuffer_funcs msm_framebuffer_funcs = {
gpu/drm/msm/msm_fb.c:void msm_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)
gpu/drm/msm/msm_fb.c:		msm_gem_describe(fb->obj[i], m);
gpu/drm/msm/msm_fb.c:int msm_framebuffer_prepare(struct drm_framebuffer *fb,
gpu/drm/msm/msm_fb.c:		struct msm_gem_address_space *aspace)
gpu/drm/msm/msm_fb.c:		ret = msm_gem_get_iova(fb->obj[i], aspace, &iova);
gpu/drm/msm/msm_fb.c:void msm_framebuffer_cleanup(struct drm_framebuffer *fb,
gpu/drm/msm/msm_fb.c:		struct msm_gem_address_space *aspace)
gpu/drm/msm/msm_fb.c:		msm_gem_put_iova(fb->obj[i], aspace);
gpu/drm/msm/msm_fb.c:uint32_t msm_framebuffer_iova(struct drm_framebuffer *fb,
gpu/drm/msm/msm_fb.c:		struct msm_gem_address_space *aspace, int plane)
gpu/drm/msm/msm_fb.c:	return msm_gem_iova(fb->obj[plane], aspace) + fb->offsets[plane];
gpu/drm/msm/msm_fb.c:struct drm_gem_object *msm_framebuffer_bo(struct drm_framebuffer *fb, int plane)
gpu/drm/msm/msm_fb.c:const struct msm_format *msm_framebuffer_format(struct drm_framebuffer *fb)
gpu/drm/msm/msm_fb.c:	struct msm_framebuffer *msm_fb = to_msm_framebuffer(fb);
gpu/drm/msm/msm_fb.c:	return msm_fb->format;
gpu/drm/msm/msm_fb.c:struct drm_framebuffer *msm_framebuffer_create(struct drm_device *dev,
gpu/drm/msm/msm_fb.c:	fb = msm_framebuffer_init(dev, mode_cmd, bos);
gpu/drm/msm/msm_fb.c:static struct drm_framebuffer *msm_framebuffer_init(struct drm_device *dev,
gpu/drm/msm/msm_fb.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_fb.c:	struct msm_kms *kms = priv->kms;
gpu/drm/msm/msm_fb.c:	struct msm_framebuffer *msm_fb = NULL;
gpu/drm/msm/msm_fb.c:	const struct msm_format *format;
gpu/drm/msm/msm_fb.c:	msm_fb = kzalloc(sizeof(*msm_fb), GFP_KERNEL);
gpu/drm/msm/msm_fb.c:	if (!msm_fb) {
gpu/drm/msm/msm_fb.c:	fb = &msm_fb->base;
gpu/drm/msm/msm_fb.c:	msm_fb->format = format;
gpu/drm/msm/msm_fb.c:		msm_fb->base.obj[i] = bos[i];
gpu/drm/msm/msm_fb.c:	ret = drm_framebuffer_init(dev, fb, &msm_framebuffer_funcs);
gpu/drm/msm/msm_fb.c:	kfree(msm_fb);
gpu/drm/msm/msm_fb.c:msm_alloc_stolen_fb(struct drm_device *dev, int w, int h,
gpu/drm/msm/msm_fb.c:	bo = msm_gem_new(dev, size, MSM_BO_SCANOUT | MSM_BO_WC | MSM_BO_STOLEN);
gpu/drm/msm/msm_fb.c:		bo = msm_gem_new(dev, size, MSM_BO_SCANOUT | MSM_BO_WC);
gpu/drm/msm/msm_fb.c:	fb = msm_framebuffer_init(dev, &mode_cmd, &bo);
gpu/drm/msm/msm_fbdev.c:#include "msm_drv.h"
gpu/drm/msm/msm_fbdev.c:#include "msm_kms.h"
gpu/drm/msm/msm_fbdev.c:extern int msm_gem_mmap_obj(struct drm_gem_object *obj,
gpu/drm/msm/msm_fbdev.c:static int msm_fbdev_mmap(struct fb_info *info, struct vm_area_struct *vma);
gpu/drm/msm/msm_fbdev.c:#define to_msm_fbdev(x) container_of(x, struct msm_fbdev, base)
gpu/drm/msm/msm_fbdev.c:struct msm_fbdev {
gpu/drm/msm/msm_fbdev.c:static struct fb_ops msm_fb_ops = {
gpu/drm/msm/msm_fbdev.c:	.fb_mmap = msm_fbdev_mmap,
gpu/drm/msm/msm_fbdev.c:static int msm_fbdev_mmap(struct fb_info *info, struct vm_area_struct *vma)
gpu/drm/msm/msm_fbdev.c:	struct msm_fbdev *fbdev = to_msm_fbdev(helper);
gpu/drm/msm/msm_fbdev.c:	struct drm_gem_object *bo = msm_framebuffer_bo(fbdev->fb, 0);
gpu/drm/msm/msm_fbdev.c:	return msm_gem_mmap_obj(bo, vma);
gpu/drm/msm/msm_fbdev.c:static int msm_fbdev_create(struct drm_fb_helper *helper,
gpu/drm/msm/msm_fbdev.c:	struct msm_fbdev *fbdev = to_msm_fbdev(helper);
gpu/drm/msm/msm_fbdev.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_fbdev.c:	fb = msm_alloc_stolen_fb(dev, sizes->surface_width,
gpu/drm/msm/msm_fbdev.c:	bo = msm_framebuffer_bo(fb, 0);
gpu/drm/msm/msm_fbdev.c:	ret = msm_gem_get_iova(bo, priv->kms->aspace, &paddr);
gpu/drm/msm/msm_fbdev.c:	fbi->fbops = &msm_fb_ops;
gpu/drm/msm/msm_fbdev.c:	strcpy(fbi->fix.id, "msm");
gpu/drm/msm/msm_fbdev.c:	fbi->screen_base = msm_gem_get_vaddr(bo);
gpu/drm/msm/msm_fbdev.c:static const struct drm_fb_helper_funcs msm_fb_helper_funcs = {
gpu/drm/msm/msm_fbdev.c:	.fb_probe = msm_fbdev_create,
gpu/drm/msm/msm_fbdev.c:struct drm_fb_helper *msm_fbdev_init(struct drm_device *dev)
gpu/drm/msm/msm_fbdev.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_fbdev.c:	struct msm_fbdev *fbdev = NULL;
gpu/drm/msm/msm_fbdev.c:	drm_fb_helper_prepare(dev, helper, &msm_fb_helper_funcs);
gpu/drm/msm/msm_fbdev.c:void msm_fbdev_free(struct drm_device *dev)
gpu/drm/msm/msm_fbdev.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_fbdev.c:	struct msm_fbdev *fbdev;
gpu/drm/msm/msm_fbdev.c:	fbdev = to_msm_fbdev(priv->fbdev);
gpu/drm/msm/msm_fbdev.c:			msm_framebuffer_bo(fbdev->fb, 0);
gpu/drm/msm/msm_fbdev.c:		msm_gem_put_vaddr(bo);
gpu/drm/msm/msm_fence.c:#include "msm_drv.h"
gpu/drm/msm/msm_fence.c:#include "msm_fence.h"
gpu/drm/msm/msm_fence.c:struct msm_fence_context *
gpu/drm/msm/msm_fence.c:msm_fence_context_alloc(struct drm_device *dev, const char *name)
gpu/drm/msm/msm_fence.c:	struct msm_fence_context *fctx;
gpu/drm/msm/msm_fence.c:void msm_fence_context_free(struct msm_fence_context *fctx)
gpu/drm/msm/msm_fence.c:static inline bool fence_completed(struct msm_fence_context *fctx, uint32_t fence)
gpu/drm/msm/msm_fence.c:int msm_wait_fence(struct msm_fence_context *fctx, uint32_t fence,
gpu/drm/msm/msm_fence.c:void msm_update_fence(struct msm_fence_context *fctx, uint32_t fence)
gpu/drm/msm/msm_fence.c:struct msm_fence {
gpu/drm/msm/msm_fence.c:	struct msm_fence_context *fctx;
gpu/drm/msm/msm_fence.c:static inline struct msm_fence *to_msm_fence(struct dma_fence *fence)
gpu/drm/msm/msm_fence.c:	return container_of(fence, struct msm_fence, base);
gpu/drm/msm/msm_fence.c:static const char *msm_fence_get_driver_name(struct dma_fence *fence)
gpu/drm/msm/msm_fence.c:	return "msm";
gpu/drm/msm/msm_fence.c:static const char *msm_fence_get_timeline_name(struct dma_fence *fence)
gpu/drm/msm/msm_fence.c:	struct msm_fence *f = to_msm_fence(fence);
gpu/drm/msm/msm_fence.c:static bool msm_fence_enable_signaling(struct dma_fence *fence)
gpu/drm/msm/msm_fence.c:static bool msm_fence_signaled(struct dma_fence *fence)
gpu/drm/msm/msm_fence.c:	struct msm_fence *f = to_msm_fence(fence);
gpu/drm/msm/msm_fence.c:static const struct dma_fence_ops msm_fence_ops = {
gpu/drm/msm/msm_fence.c:	.get_driver_name = msm_fence_get_driver_name,
gpu/drm/msm/msm_fence.c:	.get_timeline_name = msm_fence_get_timeline_name,
gpu/drm/msm/msm_fence.c:	.enable_signaling = msm_fence_enable_signaling,
gpu/drm/msm/msm_fence.c:	.signaled = msm_fence_signaled,
gpu/drm/msm/msm_fence.c:msm_fence_alloc(struct msm_fence_context *fctx)
gpu/drm/msm/msm_fence.c:	struct msm_fence *f;
gpu/drm/msm/msm_fence.c:	dma_fence_init(&f->base, &msm_fence_ops, &fctx->spinlock,
gpu/drm/msm/msm_fence.h:#include "msm_drv.h"
gpu/drm/msm/msm_fence.h:struct msm_fence_context {
gpu/drm/msm/msm_fence.h:struct msm_fence_context * msm_fence_context_alloc(struct drm_device *dev,
gpu/drm/msm/msm_fence.h:void msm_fence_context_free(struct msm_fence_context *fctx);
gpu/drm/msm/msm_fence.h:int msm_wait_fence(struct msm_fence_context *fctx, uint32_t fence,
gpu/drm/msm/msm_fence.h:void msm_update_fence(struct msm_fence_context *fctx, uint32_t fence);
gpu/drm/msm/msm_fence.h:struct dma_fence * msm_fence_alloc(struct msm_fence_context *fctx);
gpu/drm/msm/msm_gem.c:#include "msm_drv.h"
gpu/drm/msm/msm_gem.c:#include "msm_fence.h"
gpu/drm/msm/msm_gem.c:#include "msm_gem.h"
gpu/drm/msm/msm_gem.c:#include "msm_gpu.h"
gpu/drm/msm/msm_gem.c:#include "msm_mmu.h"
gpu/drm/msm/msm_gem.c:static void msm_gem_vunmap_locked(struct drm_gem_object *obj);
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	struct msm_drm_private *priv = obj->dev->dev_private;
gpu/drm/msm/msm_gem.c:	return (((dma_addr_t)msm_obj->vram_node->start) << PAGE_SHIFT) +
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	return !msm_obj->vram_node;
gpu/drm/msm/msm_gem.c:static void sync_for_device(struct msm_gem_object *msm_obj)
gpu/drm/msm/msm_gem.c:	struct device *dev = msm_obj->base.dev->dev;
gpu/drm/msm/msm_gem.c:		dma_sync_sg_for_device(dev, msm_obj->sgt->sgl,
gpu/drm/msm/msm_gem.c:			msm_obj->sgt->nents, DMA_BIDIRECTIONAL);
gpu/drm/msm/msm_gem.c:		dma_map_sg(dev, msm_obj->sgt->sgl,
gpu/drm/msm/msm_gem.c:			msm_obj->sgt->nents, DMA_BIDIRECTIONAL);
gpu/drm/msm/msm_gem.c:static void sync_for_cpu(struct msm_gem_object *msm_obj)
gpu/drm/msm/msm_gem.c:	struct device *dev = msm_obj->base.dev->dev;
gpu/drm/msm/msm_gem.c:		dma_sync_sg_for_cpu(dev, msm_obj->sgt->sgl,
gpu/drm/msm/msm_gem.c:			msm_obj->sgt->nents, DMA_BIDIRECTIONAL);
gpu/drm/msm/msm_gem.c:		dma_unmap_sg(dev, msm_obj->sgt->sgl,
gpu/drm/msm/msm_gem.c:			msm_obj->sgt->nents, DMA_BIDIRECTIONAL);
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	struct msm_drm_private *priv = obj->dev->dev_private;
gpu/drm/msm/msm_gem.c:	ret = drm_mm_insert_node(&priv->vram.mm, msm_obj->vram_node, npages);
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	if (!msm_obj->pages) {
gpu/drm/msm/msm_gem.c:		msm_obj->pages = p;
gpu/drm/msm/msm_gem.c:		msm_obj->sgt = drm_prime_pages_to_sg(p, npages);
gpu/drm/msm/msm_gem.c:		if (IS_ERR(msm_obj->sgt)) {
gpu/drm/msm/msm_gem.c:			void *ptr = ERR_CAST(msm_obj->sgt);
gpu/drm/msm/msm_gem.c:			msm_obj->sgt = NULL;
gpu/drm/msm/msm_gem.c:		if (msm_obj->flags & (MSM_BO_WC|MSM_BO_UNCACHED))
gpu/drm/msm/msm_gem.c:			sync_for_device(msm_obj);
gpu/drm/msm/msm_gem.c:	return msm_obj->pages;
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	struct msm_drm_private *priv = obj->dev->dev_private;
gpu/drm/msm/msm_gem.c:	drm_mm_remove_node(msm_obj->vram_node);
gpu/drm/msm/msm_gem.c:	kvfree(msm_obj->pages);
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	if (msm_obj->pages) {
gpu/drm/msm/msm_gem.c:		if (msm_obj->sgt) {
gpu/drm/msm/msm_gem.c:			if (msm_obj->flags & (MSM_BO_WC|MSM_BO_UNCACHED))
gpu/drm/msm/msm_gem.c:				sync_for_cpu(msm_obj);
gpu/drm/msm/msm_gem.c:			sg_free_table(msm_obj->sgt);
gpu/drm/msm/msm_gem.c:			kfree(msm_obj->sgt);
gpu/drm/msm/msm_gem.c:			drm_gem_put_pages(obj, msm_obj->pages, true, false);
gpu/drm/msm/msm_gem.c:		msm_obj->pages = NULL;
gpu/drm/msm/msm_gem.c:struct page **msm_gem_get_pages(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	mutex_lock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	if (WARN_ON(msm_obj->madv != MSM_MADV_WILLNEED)) {
gpu/drm/msm/msm_gem.c:		mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:void msm_gem_put_pages(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem.c:int msm_gem_mmap_obj(struct drm_gem_object *obj,
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	if (msm_obj->flags & MSM_BO_WC) {
gpu/drm/msm/msm_gem.c:	} else if (msm_obj->flags & MSM_BO_UNCACHED) {
gpu/drm/msm/msm_gem.c:int msm_gem_mmap(struct file *filp, struct vm_area_struct *vma)
gpu/drm/msm/msm_gem.c:	return msm_gem_mmap_obj(vma->vm_private_data, vma);
gpu/drm/msm/msm_gem.c:vm_fault_t msm_gem_fault(struct vm_fault *vmf)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	err = mutex_lock_interruptible(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	if (WARN_ON(msm_obj->madv != MSM_MADV_WILLNEED)) {
gpu/drm/msm/msm_gem.c:		mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	WARN_ON(!mutex_is_locked(&msm_obj->lock));
gpu/drm/msm/msm_gem.c:uint64_t msm_gem_mmap_offset(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	mutex_lock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:static struct msm_gem_vma *add_vma(struct drm_gem_object *obj,
gpu/drm/msm/msm_gem.c:		struct msm_gem_address_space *aspace)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	struct msm_gem_vma *vma;
gpu/drm/msm/msm_gem.c:	WARN_ON(!mutex_is_locked(&msm_obj->lock));
gpu/drm/msm/msm_gem.c:	list_add_tail(&vma->list, &msm_obj->vmas);
gpu/drm/msm/msm_gem.c:static struct msm_gem_vma *lookup_vma(struct drm_gem_object *obj,
gpu/drm/msm/msm_gem.c:		struct msm_gem_address_space *aspace)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	struct msm_gem_vma *vma;
gpu/drm/msm/msm_gem.c:	WARN_ON(!mutex_is_locked(&msm_obj->lock));
gpu/drm/msm/msm_gem.c:	list_for_each_entry(vma, &msm_obj->vmas, list) {
gpu/drm/msm/msm_gem.c:static void del_vma(struct msm_gem_vma *vma)
gpu/drm/msm/msm_gem.c:/* Called with msm_obj->lock locked */
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	struct msm_gem_vma *vma, *tmp;
gpu/drm/msm/msm_gem.c:	WARN_ON(!mutex_is_locked(&msm_obj->lock));
gpu/drm/msm/msm_gem.c:	list_for_each_entry_safe(vma, tmp, &msm_obj->vmas, list) {
gpu/drm/msm/msm_gem.c:		msm_gem_unmap_vma(vma->aspace, vma, msm_obj->sgt);
gpu/drm/msm/msm_gem.c:int msm_gem_get_iova(struct drm_gem_object *obj,
gpu/drm/msm/msm_gem.c:		struct msm_gem_address_space *aspace, uint64_t *iova)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	struct msm_gem_vma *vma;
gpu/drm/msm/msm_gem.c:	mutex_lock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	if (WARN_ON(msm_obj->madv != MSM_MADV_WILLNEED)) {
gpu/drm/msm/msm_gem.c:		mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:		ret = msm_gem_map_vma(aspace, vma, msm_obj->sgt,
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c: * already done a 'msm_gem_get_iova()'.
gpu/drm/msm/msm_gem.c:uint64_t msm_gem_iova(struct drm_gem_object *obj,
gpu/drm/msm/msm_gem.c:		struct msm_gem_address_space *aspace)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	struct msm_gem_vma *vma;
gpu/drm/msm/msm_gem.c:	mutex_lock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:void msm_gem_put_iova(struct drm_gem_object *obj,
gpu/drm/msm/msm_gem.c:		struct msm_gem_address_space *aspace)
gpu/drm/msm/msm_gem.c:int msm_gem_dumb_create(struct drm_file *file, struct drm_device *dev,
gpu/drm/msm/msm_gem.c:	return msm_gem_new_handle(dev, file, args->size,
gpu/drm/msm/msm_gem.c:int msm_gem_dumb_map_offset(struct drm_file *file, struct drm_device *dev,
gpu/drm/msm/msm_gem.c:	*offset = msm_gem_mmap_offset(obj);
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	mutex_lock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	if (WARN_ON(msm_obj->madv > madv)) {
gpu/drm/msm/msm_gem.c:			msm_obj->madv, madv);
gpu/drm/msm/msm_gem.c:		mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	 * check vmap_count (is_vunmapable()) outside of msm_obj->lock.
gpu/drm/msm/msm_gem.c:	 * This guarantees that we won't try to msm_gem_vunmap() this
gpu/drm/msm/msm_gem.c:	 * hold msm_obj->lock)
gpu/drm/msm/msm_gem.c:	msm_obj->vmap_count++;
gpu/drm/msm/msm_gem.c:	if (!msm_obj->vaddr) {
gpu/drm/msm/msm_gem.c:		msm_obj->vaddr = vmap(pages, obj->size >> PAGE_SHIFT,
gpu/drm/msm/msm_gem.c:		if (msm_obj->vaddr == NULL) {
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	return msm_obj->vaddr;
gpu/drm/msm/msm_gem.c:	msm_obj->vmap_count--;
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:void *msm_gem_get_vaddr(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem.c:void *msm_gem_get_vaddr_active(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem.c:void msm_gem_put_vaddr(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	mutex_lock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	WARN_ON(msm_obj->vmap_count < 1);
gpu/drm/msm/msm_gem.c:	msm_obj->vmap_count--;
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:int msm_gem_madvise(struct drm_gem_object *obj, unsigned madv)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	mutex_lock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	if (msm_obj->madv != __MSM_MADV_PURGED)
gpu/drm/msm/msm_gem.c:		msm_obj->madv = madv;
gpu/drm/msm/msm_gem.c:	madv = msm_obj->madv;
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:void msm_gem_purge(struct drm_gem_object *obj, enum msm_gem_lock subclass)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	WARN_ON(!is_purgeable(msm_obj));
gpu/drm/msm/msm_gem.c:	mutex_lock_nested(&msm_obj->lock, subclass);
gpu/drm/msm/msm_gem.c:	msm_gem_vunmap_locked(obj);
gpu/drm/msm/msm_gem.c:	msm_obj->madv = __MSM_MADV_PURGED;
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:static void msm_gem_vunmap_locked(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	WARN_ON(!mutex_is_locked(&msm_obj->lock));
gpu/drm/msm/msm_gem.c:	if (!msm_obj->vaddr || WARN_ON(!is_vunmapable(msm_obj)))
gpu/drm/msm/msm_gem.c:	vunmap(msm_obj->vaddr);
gpu/drm/msm/msm_gem.c:	msm_obj->vaddr = NULL;
gpu/drm/msm/msm_gem.c:void msm_gem_vunmap(struct drm_gem_object *obj, enum msm_gem_lock subclass)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	mutex_lock_nested(&msm_obj->lock, subclass);
gpu/drm/msm/msm_gem.c:	msm_gem_vunmap_locked(obj);
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:int msm_gem_sync_object(struct drm_gem_object *obj,
gpu/drm/msm/msm_gem.c:		struct msm_fence_context *fctx, bool exclusive)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	fobj = reservation_object_get_list(msm_obj->resv);
gpu/drm/msm/msm_gem.c:		fence = reservation_object_get_excl(msm_obj->resv);
gpu/drm/msm/msm_gem.c:						reservation_object_held(msm_obj->resv));
gpu/drm/msm/msm_gem.c:void msm_gem_move_to_active(struct drm_gem_object *obj,
gpu/drm/msm/msm_gem.c:		struct msm_gpu *gpu, bool exclusive, struct dma_fence *fence)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	WARN_ON(msm_obj->madv != MSM_MADV_WILLNEED);
gpu/drm/msm/msm_gem.c:	msm_obj->gpu = gpu;
gpu/drm/msm/msm_gem.c:		reservation_object_add_excl_fence(msm_obj->resv, fence);
gpu/drm/msm/msm_gem.c:		reservation_object_add_shared_fence(msm_obj->resv, fence);
gpu/drm/msm/msm_gem.c:	list_del_init(&msm_obj->mm_list);
gpu/drm/msm/msm_gem.c:	list_add_tail(&msm_obj->mm_list, &gpu->active_list);
gpu/drm/msm/msm_gem.c:void msm_gem_move_to_inactive(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	msm_obj->gpu = NULL;
gpu/drm/msm/msm_gem.c:	list_del_init(&msm_obj->mm_list);
gpu/drm/msm/msm_gem.c:	list_add_tail(&msm_obj->mm_list, &priv->inactive_list);
gpu/drm/msm/msm_gem.c:int msm_gem_cpu_prep(struct drm_gem_object *obj, uint32_t op, ktime_t *timeout)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	ret = reservation_object_wait_timeout_rcu(msm_obj->resv, write,
gpu/drm/msm/msm_gem.c:int msm_gem_cpu_fini(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem.c:void msm_gem_describe(struct drm_gem_object *obj, struct seq_file *m)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	struct reservation_object *robj = msm_obj->resv;
gpu/drm/msm/msm_gem.c:	struct msm_gem_vma *vma;
gpu/drm/msm/msm_gem.c:	mutex_lock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	switch (msm_obj->madv) {
gpu/drm/msm/msm_gem.c:			msm_obj->flags, is_active(msm_obj) ? 'A' : 'I',
gpu/drm/msm/msm_gem.c:			off, msm_obj->vaddr);
gpu/drm/msm/msm_gem.c:	list_for_each_entry(vma, &msm_obj->vmas, list)
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:void msm_gem_describe_objects(struct list_head *list, struct seq_file *m)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj;
gpu/drm/msm/msm_gem.c:	list_for_each_entry(msm_obj, list, mm_list) {
gpu/drm/msm/msm_gem.c:		struct drm_gem_object *obj = &msm_obj->base;
gpu/drm/msm/msm_gem.c:		msm_gem_describe(obj, m);
gpu/drm/msm/msm_gem.c:void msm_gem_free_object(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	WARN_ON(is_active(msm_obj));
gpu/drm/msm/msm_gem.c:	list_del(&msm_obj->mm_list);
gpu/drm/msm/msm_gem.c:	mutex_lock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:		if (msm_obj->vaddr)
gpu/drm/msm/msm_gem.c:			dma_buf_vunmap(obj->import_attach->dmabuf, msm_obj->vaddr);
gpu/drm/msm/msm_gem.c:		if (msm_obj->pages)
gpu/drm/msm/msm_gem.c:			kvfree(msm_obj->pages);
gpu/drm/msm/msm_gem.c:		drm_prime_gem_destroy(obj, msm_obj->sgt);
gpu/drm/msm/msm_gem.c:		msm_gem_vunmap_locked(obj);
gpu/drm/msm/msm_gem.c:	if (msm_obj->resv == &msm_obj->_resv)
gpu/drm/msm/msm_gem.c:		reservation_object_fini(msm_obj->resv);
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	kfree(msm_obj);
gpu/drm/msm/msm_gem.c:int msm_gem_new_handle(struct drm_device *dev, struct drm_file *file,
gpu/drm/msm/msm_gem.c:	obj = msm_gem_new(dev, size, flags);
gpu/drm/msm/msm_gem.c:static int msm_gem_new_impl(struct drm_device *dev,
gpu/drm/msm/msm_gem.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj;
gpu/drm/msm/msm_gem.c:	msm_obj = kzalloc(sizeof(*msm_obj), GFP_KERNEL);
gpu/drm/msm/msm_gem.c:	if (!msm_obj)
gpu/drm/msm/msm_gem.c:	mutex_init(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	msm_obj->flags = flags;
gpu/drm/msm/msm_gem.c:	msm_obj->madv = MSM_MADV_WILLNEED;
gpu/drm/msm/msm_gem.c:		msm_obj->resv = resv;
gpu/drm/msm/msm_gem.c:		msm_obj->resv = &msm_obj->_resv;
gpu/drm/msm/msm_gem.c:		reservation_object_init(msm_obj->resv);
gpu/drm/msm/msm_gem.c:	INIT_LIST_HEAD(&msm_obj->submit_entry);
gpu/drm/msm/msm_gem.c:	INIT_LIST_HEAD(&msm_obj->vmas);
gpu/drm/msm/msm_gem.c:		list_add_tail(&msm_obj->mm_list, &priv->inactive_list);
gpu/drm/msm/msm_gem.c:		list_add_tail(&msm_obj->mm_list, &priv->inactive_list);
gpu/drm/msm/msm_gem.c:	*obj = &msm_obj->base;
gpu/drm/msm/msm_gem.c:static struct drm_gem_object *_msm_gem_new(struct drm_device *dev,
gpu/drm/msm/msm_gem.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_gem.c:	ret = msm_gem_new_impl(dev, size, flags, NULL, &obj, struct_mutex_locked);
gpu/drm/msm/msm_gem.c:		struct msm_gem_vma *vma;
gpu/drm/msm/msm_gem.c:		struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:		mutex_lock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:		mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:		to_msm_bo(obj)->vram_node = &vma->node;
gpu/drm/msm/msm_gem.c:struct drm_gem_object *msm_gem_new_locked(struct drm_device *dev,
gpu/drm/msm/msm_gem.c:	return _msm_gem_new(dev, size, flags, true);
gpu/drm/msm/msm_gem.c:struct drm_gem_object *msm_gem_new(struct drm_device *dev,
gpu/drm/msm/msm_gem.c:	return _msm_gem_new(dev, size, flags, false);
gpu/drm/msm/msm_gem.c:struct drm_gem_object *msm_gem_import(struct drm_device *dev,
gpu/drm/msm/msm_gem.c:	struct msm_gem_object *msm_obj;
gpu/drm/msm/msm_gem.c:	ret = msm_gem_new_impl(dev, size, MSM_BO_WC, dmabuf->resv, &obj, false);
gpu/drm/msm/msm_gem.c:	msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem.c:	mutex_lock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	msm_obj->sgt = sgt;
gpu/drm/msm/msm_gem.c:	msm_obj->pages = kvmalloc_array(npages, sizeof(struct page *),
gpu/drm/msm/msm_gem.c:	if (!msm_obj->pages) {
gpu/drm/msm/msm_gem.c:		mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	ret = drm_prime_sg_to_page_addr_arrays(sgt, msm_obj->pages, NULL,
gpu/drm/msm/msm_gem.c:		mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:	mutex_unlock(&msm_obj->lock);
gpu/drm/msm/msm_gem.c:static void *_msm_gem_kernel_new(struct drm_device *dev, uint32_t size,
gpu/drm/msm/msm_gem.c:		uint32_t flags, struct msm_gem_address_space *aspace,
gpu/drm/msm/msm_gem.c:	struct drm_gem_object *obj = _msm_gem_new(dev, size, flags, locked);
gpu/drm/msm/msm_gem.c:		ret = msm_gem_get_iova(obj, aspace, iova);
gpu/drm/msm/msm_gem.c:	vaddr = msm_gem_get_vaddr(obj);
gpu/drm/msm/msm_gem.c:		msm_gem_put_iova(obj, aspace);
gpu/drm/msm/msm_gem.c:void *msm_gem_kernel_new(struct drm_device *dev, uint32_t size,
gpu/drm/msm/msm_gem.c:		uint32_t flags, struct msm_gem_address_space *aspace,
gpu/drm/msm/msm_gem.c:	return _msm_gem_kernel_new(dev, size, flags, aspace, bo, iova, false);
gpu/drm/msm/msm_gem.c:void *msm_gem_kernel_new_locked(struct drm_device *dev, uint32_t size,
gpu/drm/msm/msm_gem.c:		uint32_t flags, struct msm_gem_address_space *aspace,
gpu/drm/msm/msm_gem.c:	return _msm_gem_kernel_new(dev, size, flags, aspace, bo, iova, true);
gpu/drm/msm/msm_gem.h:#include "msm_drv.h"
gpu/drm/msm/msm_gem.h:struct msm_gem_address_space {
gpu/drm/msm/msm_gem.h:	struct msm_mmu *mmu;
gpu/drm/msm/msm_gem.h:struct msm_gem_vma {
gpu/drm/msm/msm_gem.h:	struct msm_gem_address_space *aspace;
gpu/drm/msm/msm_gem.h:	struct list_head list;    /* node in msm_gem_object::vmas */
gpu/drm/msm/msm_gem.h:struct msm_gem_object {
gpu/drm/msm/msm_gem.h:	struct msm_gpu *gpu;     /* non-null if active */
gpu/drm/msm/msm_gem.h:	struct list_head vmas;    /* list of msm_gem_vma */
gpu/drm/msm/msm_gem.h:#define to_msm_bo(x) container_of(x, struct msm_gem_object, base)
gpu/drm/msm/msm_gem.h:static inline bool is_active(struct msm_gem_object *msm_obj)
gpu/drm/msm/msm_gem.h:	return msm_obj->gpu != NULL;
gpu/drm/msm/msm_gem.h:static inline bool is_purgeable(struct msm_gem_object *msm_obj)
gpu/drm/msm/msm_gem.h:	WARN_ON(!mutex_is_locked(&msm_obj->base.dev->struct_mutex));
gpu/drm/msm/msm_gem.h:	return (msm_obj->madv == MSM_MADV_DONTNEED) && msm_obj->sgt &&
gpu/drm/msm/msm_gem.h:			!msm_obj->base.dma_buf && !msm_obj->base.import_attach;
gpu/drm/msm/msm_gem.h:static inline bool is_vunmapable(struct msm_gem_object *msm_obj)
gpu/drm/msm/msm_gem.h:	return (msm_obj->vmap_count == 0) && msm_obj->vaddr;
gpu/drm/msm/msm_gem.h: * msm_obj->madv == MSM_MADV_WILLNEED.
gpu/drm/msm/msm_gem.h:enum msm_gem_lock {
gpu/drm/msm/msm_gem.h:void msm_gem_purge(struct drm_gem_object *obj, enum msm_gem_lock subclass);
gpu/drm/msm/msm_gem.h:void msm_gem_vunmap(struct drm_gem_object *obj, enum msm_gem_lock subclass);
gpu/drm/msm/msm_gem.h:struct msm_gem_submit {
gpu/drm/msm/msm_gem.h:	struct msm_gpu *gpu;
gpu/drm/msm/msm_gem.h:	struct msm_gpu_submitqueue *queue;
gpu/drm/msm/msm_gem.h:	struct msm_ringbuffer *ring;
gpu/drm/msm/msm_gem.h:		struct msm_gem_object *obj;
gpu/drm/msm/msm_gem_prime.c:#include "msm_drv.h"
gpu/drm/msm/msm_gem_prime.c:#include "msm_gem.h"
gpu/drm/msm/msm_gem_prime.c:struct sg_table *msm_gem_prime_get_sg_table(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem_prime.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem_prime.c:	if (WARN_ON(!msm_obj->pages))  /* should have already pinned! */
gpu/drm/msm/msm_gem_prime.c:	return drm_prime_pages_to_sg(msm_obj->pages, npages);
gpu/drm/msm/msm_gem_prime.c:void *msm_gem_prime_vmap(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem_prime.c:	return msm_gem_get_vaddr(obj);
gpu/drm/msm/msm_gem_prime.c:void msm_gem_prime_vunmap(struct drm_gem_object *obj, void *vaddr)
gpu/drm/msm/msm_gem_prime.c:	msm_gem_put_vaddr(obj);
gpu/drm/msm/msm_gem_prime.c:int msm_gem_prime_mmap(struct drm_gem_object *obj, struct vm_area_struct *vma)
gpu/drm/msm/msm_gem_prime.c:	return msm_gem_mmap_obj(vma->vm_private_data, vma);
gpu/drm/msm/msm_gem_prime.c:struct drm_gem_object *msm_gem_prime_import_sg_table(struct drm_device *dev,
gpu/drm/msm/msm_gem_prime.c:	return msm_gem_import(dev, attach->dmabuf, sg);
gpu/drm/msm/msm_gem_prime.c:int msm_gem_prime_pin(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem_prime.c:		msm_gem_get_pages(obj);
gpu/drm/msm/msm_gem_prime.c:void msm_gem_prime_unpin(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem_prime.c:		msm_gem_put_pages(obj);
gpu/drm/msm/msm_gem_prime.c:struct reservation_object *msm_gem_prime_res_obj(struct drm_gem_object *obj)
gpu/drm/msm/msm_gem_prime.c:	struct msm_gem_object *msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem_prime.c:	return msm_obj->resv;
gpu/drm/msm/msm_gem_shrinker.c:#include "msm_drv.h"
gpu/drm/msm/msm_gem_shrinker.c:#include "msm_gem.h"
gpu/drm/msm/msm_gem_shrinker.c:static bool msm_gem_shrinker_lock(struct drm_device *dev, bool *unlock)
gpu/drm/msm/msm_gem_shrinker.c:	 * mutex_trylock_recursive().. the msm_gem code itself does
gpu/drm/msm/msm_gem_shrinker.c:	 * Also, msm_obj->madv is protected by struct_mutex.
gpu/drm/msm/msm_gem_shrinker.c:msm_gem_shrinker_count(struct shrinker *shrinker, struct shrink_control *sc)
gpu/drm/msm/msm_gem_shrinker.c:	struct msm_drm_private *priv =
gpu/drm/msm/msm_gem_shrinker.c:		container_of(shrinker, struct msm_drm_private, shrinker);
gpu/drm/msm/msm_gem_shrinker.c:	struct msm_gem_object *msm_obj;
gpu/drm/msm/msm_gem_shrinker.c:	if (!msm_gem_shrinker_lock(dev, &unlock))
gpu/drm/msm/msm_gem_shrinker.c:	list_for_each_entry(msm_obj, &priv->inactive_list, mm_list) {
gpu/drm/msm/msm_gem_shrinker.c:		if (is_purgeable(msm_obj))
gpu/drm/msm/msm_gem_shrinker.c:			count += msm_obj->base.size >> PAGE_SHIFT;
gpu/drm/msm/msm_gem_shrinker.c:msm_gem_shrinker_scan(struct shrinker *shrinker, struct shrink_control *sc)
gpu/drm/msm/msm_gem_shrinker.c:	struct msm_drm_private *priv =
gpu/drm/msm/msm_gem_shrinker.c:		container_of(shrinker, struct msm_drm_private, shrinker);
gpu/drm/msm/msm_gem_shrinker.c:	struct msm_gem_object *msm_obj;
gpu/drm/msm/msm_gem_shrinker.c:	if (!msm_gem_shrinker_lock(dev, &unlock))
gpu/drm/msm/msm_gem_shrinker.c:	list_for_each_entry(msm_obj, &priv->inactive_list, mm_list) {
gpu/drm/msm/msm_gem_shrinker.c:		if (is_purgeable(msm_obj)) {
gpu/drm/msm/msm_gem_shrinker.c:			msm_gem_purge(&msm_obj->base, OBJ_LOCK_SHRINKER);
gpu/drm/msm/msm_gem_shrinker.c:			freed += msm_obj->base.size >> PAGE_SHIFT;
gpu/drm/msm/msm_gem_shrinker.c:msm_gem_shrinker_vmap(struct notifier_block *nb, unsigned long event, void *ptr)
gpu/drm/msm/msm_gem_shrinker.c:	struct msm_drm_private *priv =
gpu/drm/msm/msm_gem_shrinker.c:		container_of(nb, struct msm_drm_private, vmap_notifier);
gpu/drm/msm/msm_gem_shrinker.c:	struct msm_gem_object *msm_obj;
gpu/drm/msm/msm_gem_shrinker.c:	if (!msm_gem_shrinker_lock(dev, &unlock))
gpu/drm/msm/msm_gem_shrinker.c:	list_for_each_entry(msm_obj, &priv->inactive_list, mm_list) {
gpu/drm/msm/msm_gem_shrinker.c:		if (is_vunmapable(msm_obj)) {
gpu/drm/msm/msm_gem_shrinker.c:			msm_gem_vunmap(&msm_obj->base, OBJ_LOCK_SHRINKER);
gpu/drm/msm/msm_gem_shrinker.c: * msm_gem_shrinker_init - Initialize msm shrinker
gpu/drm/msm/msm_gem_shrinker.c: * @dev_priv: msm device
gpu/drm/msm/msm_gem_shrinker.c: * This function registers and sets up the msm shrinker.
gpu/drm/msm/msm_gem_shrinker.c:void msm_gem_shrinker_init(struct drm_device *dev)
gpu/drm/msm/msm_gem_shrinker.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_gem_shrinker.c:	priv->shrinker.count_objects = msm_gem_shrinker_count;
gpu/drm/msm/msm_gem_shrinker.c:	priv->shrinker.scan_objects = msm_gem_shrinker_scan;
gpu/drm/msm/msm_gem_shrinker.c:	priv->vmap_notifier.notifier_call = msm_gem_shrinker_vmap;
gpu/drm/msm/msm_gem_shrinker.c: * msm_gem_shrinker_cleanup - Clean up msm shrinker
gpu/drm/msm/msm_gem_shrinker.c: * @dev_priv: msm device
gpu/drm/msm/msm_gem_shrinker.c: * This function unregisters the msm shrinker.
gpu/drm/msm/msm_gem_shrinker.c:void msm_gem_shrinker_cleanup(struct drm_device *dev)
gpu/drm/msm/msm_gem_shrinker.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_gem_submit.c:#include "msm_drv.h"
gpu/drm/msm/msm_gem_submit.c:#include "msm_gpu.h"
gpu/drm/msm/msm_gem_submit.c:#include "msm_gem.h"
gpu/drm/msm/msm_gem_submit.c:static struct msm_gem_submit *submit_create(struct drm_device *dev,
gpu/drm/msm/msm_gem_submit.c:		struct msm_gpu *gpu, struct msm_gpu_submitqueue *queue,
gpu/drm/msm/msm_gem_submit.c:	struct msm_gem_submit *submit;
gpu/drm/msm/msm_gem_submit.c:void msm_gem_submit_free(struct msm_gem_submit *submit)
gpu/drm/msm/msm_gem_submit.c:	msm_submitqueue_put(submit->queue);
gpu/drm/msm/msm_gem_submit.c:static int submit_lookup_objects(struct msm_gem_submit *submit,
gpu/drm/msm/msm_gem_submit.c:		struct drm_msm_gem_submit *args, struct drm_file *file)
gpu/drm/msm/msm_gem_submit.c:		struct drm_msm_gem_submit_bo submit_bo;
gpu/drm/msm/msm_gem_submit.c:		struct msm_gem_object *msm_obj;
gpu/drm/msm/msm_gem_submit.c:		msm_obj = to_msm_bo(obj);
gpu/drm/msm/msm_gem_submit.c:		if (!list_empty(&msm_obj->submit_entry)) {
gpu/drm/msm/msm_gem_submit.c:		submit->bos[i].obj = msm_obj;
gpu/drm/msm/msm_gem_submit.c:		list_add_tail(&msm_obj->submit_entry, &submit->bo_list);
gpu/drm/msm/msm_gem_submit.c:static void submit_unlock_unpin_bo(struct msm_gem_submit *submit,
gpu/drm/msm/msm_gem_submit.c:	struct msm_gem_object *msm_obj = submit->bos[i].obj;
gpu/drm/msm/msm_gem_submit.c:		msm_gem_put_iova(&msm_obj->base, submit->gpu->aspace);
gpu/drm/msm/msm_gem_submit.c:		ww_mutex_unlock(&msm_obj->resv->lock);
gpu/drm/msm/msm_gem_submit.c:static int submit_lock_objects(struct msm_gem_submit *submit)
gpu/drm/msm/msm_gem_submit.c:		struct msm_gem_object *msm_obj = submit->bos[i].obj;
gpu/drm/msm/msm_gem_submit.c:			ret = ww_mutex_lock_interruptible(&msm_obj->resv->lock,
gpu/drm/msm/msm_gem_submit.c:		struct msm_gem_object *msm_obj = submit->bos[contended].obj;
gpu/drm/msm/msm_gem_submit.c:		ret = ww_mutex_lock_slow_interruptible(&msm_obj->resv->lock,
gpu/drm/msm/msm_gem_submit.c:static int submit_fence_sync(struct msm_gem_submit *submit, bool no_implicit)
gpu/drm/msm/msm_gem_submit.c:		struct msm_gem_object *msm_obj = submit->bos[i].obj;
gpu/drm/msm/msm_gem_submit.c:			ret = reservation_object_reserve_shared(msm_obj->resv);
gpu/drm/msm/msm_gem_submit.c:		ret = msm_gem_sync_object(&msm_obj->base, submit->ring->fctx,
gpu/drm/msm/msm_gem_submit.c:static int submit_pin_objects(struct msm_gem_submit *submit)
gpu/drm/msm/msm_gem_submit.c:		struct msm_gem_object *msm_obj = submit->bos[i].obj;
gpu/drm/msm/msm_gem_submit.c:		ret = msm_gem_get_iova(&msm_obj->base,
gpu/drm/msm/msm_gem_submit.c:static int submit_bo(struct msm_gem_submit *submit, uint32_t idx,
gpu/drm/msm/msm_gem_submit.c:		struct msm_gem_object **obj, uint64_t *iova, bool *valid)
gpu/drm/msm/msm_gem_submit.c:static int submit_reloc(struct msm_gem_submit *submit, struct msm_gem_object *obj,
gpu/drm/msm/msm_gem_submit.c:	ptr = msm_gem_get_vaddr(&obj->base);
gpu/drm/msm/msm_gem_submit.c:		struct drm_msm_gem_submit_reloc submit_reloc;
gpu/drm/msm/msm_gem_submit.c:	msm_gem_put_vaddr(&obj->base);
gpu/drm/msm/msm_gem_submit.c:static void submit_cleanup(struct msm_gem_submit *submit)
gpu/drm/msm/msm_gem_submit.c:		struct msm_gem_object *msm_obj = submit->bos[i].obj;
gpu/drm/msm/msm_gem_submit.c:		list_del_init(&msm_obj->submit_entry);
gpu/drm/msm/msm_gem_submit.c:		drm_gem_object_unreference(&msm_obj->base);
gpu/drm/msm/msm_gem_submit.c:int msm_ioctl_gem_submit(struct drm_device *dev, void *data,
gpu/drm/msm/msm_gem_submit.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_gem_submit.c:	struct drm_msm_gem_submit *args = data;
gpu/drm/msm/msm_gem_submit.c:	struct msm_file_private *ctx = file->driver_priv;
gpu/drm/msm/msm_gem_submit.c:	struct msm_gem_submit *submit;
gpu/drm/msm/msm_gem_submit.c:	struct msm_gpu *gpu = priv->gpu;
gpu/drm/msm/msm_gem_submit.c:	struct msm_gpu_submitqueue *queue;
gpu/drm/msm/msm_gem_submit.c:	struct msm_ringbuffer *ring;
gpu/drm/msm/msm_gem_submit.c:	queue = msm_submitqueue_get(ctx, args->queueid);
gpu/drm/msm/msm_gem_submit.c:		struct drm_msm_gem_submit_cmd submit_cmd;
gpu/drm/msm/msm_gem_submit.c:		struct msm_gem_object *msm_obj;
gpu/drm/msm/msm_gem_submit.c:				&msm_obj, &iova, NULL);
gpu/drm/msm/msm_gem_submit.c:				msm_obj->base.size)) {
gpu/drm/msm/msm_gem_submit.c:		ret = submit_reloc(submit, msm_obj, submit_cmd.submit_offset,
gpu/drm/msm/msm_gem_submit.c:	submit->fence = msm_fence_alloc(ring->fctx);
gpu/drm/msm/msm_gem_submit.c:	msm_gpu_submit(gpu, submit, ctx);
gpu/drm/msm/msm_gem_submit.c:		msm_gem_submit_free(submit);
gpu/drm/msm/msm_gem_vma.c:#include "msm_drv.h"
gpu/drm/msm/msm_gem_vma.c:#include "msm_gem.h"
gpu/drm/msm/msm_gem_vma.c:#include "msm_mmu.h"
gpu/drm/msm/msm_gem_vma.c:msm_gem_address_space_destroy(struct kref *kref)
gpu/drm/msm/msm_gem_vma.c:	struct msm_gem_address_space *aspace = container_of(kref,
gpu/drm/msm/msm_gem_vma.c:			struct msm_gem_address_space, kref);
gpu/drm/msm/msm_gem_vma.c:void msm_gem_address_space_put(struct msm_gem_address_space *aspace)
gpu/drm/msm/msm_gem_vma.c:		kref_put(&aspace->kref, msm_gem_address_space_destroy);
gpu/drm/msm/msm_gem_vma.c:msm_gem_unmap_vma(struct msm_gem_address_space *aspace,
gpu/drm/msm/msm_gem_vma.c:		struct msm_gem_vma *vma, struct sg_table *sgt)
gpu/drm/msm/msm_gem_vma.c:	msm_gem_address_space_put(aspace);
gpu/drm/msm/msm_gem_vma.c:msm_gem_map_vma(struct msm_gem_address_space *aspace,
gpu/drm/msm/msm_gem_vma.c:		struct msm_gem_vma *vma, struct sg_table *sgt, int npages)
gpu/drm/msm/msm_gem_vma.c:struct msm_gem_address_space *
gpu/drm/msm/msm_gem_vma.c:msm_gem_address_space_create(struct device *dev, struct iommu_domain *domain,
gpu/drm/msm/msm_gem_vma.c:	struct msm_gem_address_space *aspace;
gpu/drm/msm/msm_gem_vma.c:	aspace->mmu = msm_iommu_new(dev, domain);
gpu/drm/msm/msm_gpu.c:#include "msm_gpu.h"
gpu/drm/msm/msm_gpu.c:#include "msm_gem.h"
gpu/drm/msm/msm_gpu.c:#include "msm_mmu.h"
gpu/drm/msm/msm_gpu.c:#include "msm_fence.h"
gpu/drm/msm/msm_gpu.c:static int msm_devfreq_target(struct device *dev, unsigned long *freq,
gpu/drm/msm/msm_gpu.c:	struct msm_gpu *gpu = platform_get_drvdata(to_platform_device(dev));
gpu/drm/msm/msm_gpu.c:static int msm_devfreq_get_dev_status(struct device *dev,
gpu/drm/msm/msm_gpu.c:	struct msm_gpu *gpu = platform_get_drvdata(to_platform_device(dev));
gpu/drm/msm/msm_gpu.c:static int msm_devfreq_get_cur_freq(struct device *dev, unsigned long *freq)
gpu/drm/msm/msm_gpu.c:	struct msm_gpu *gpu = platform_get_drvdata(to_platform_device(dev));
gpu/drm/msm/msm_gpu.c:static struct devfreq_dev_profile msm_devfreq_profile = {
gpu/drm/msm/msm_gpu.c:	.target = msm_devfreq_target,
gpu/drm/msm/msm_gpu.c:	.get_dev_status = msm_devfreq_get_dev_status,
gpu/drm/msm/msm_gpu.c:	.get_cur_freq = msm_devfreq_get_cur_freq,
gpu/drm/msm/msm_gpu.c:static void msm_devfreq_init(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:	msm_devfreq_profile.initial_freq = gpu->fast_rate;
gpu/drm/msm/msm_gpu.c:			&msm_devfreq_profile, "simple_ondemand", NULL);
gpu/drm/msm/msm_gpu.c:static int enable_pwrrail(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:static int disable_pwrrail(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:static int enable_clk(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:static int disable_clk(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:static int enable_axi(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:static int disable_axi(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:int msm_gpu_pm_resume(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:int msm_gpu_pm_suspend(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:int msm_gpu_hw_init(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:static ssize_t msm_gpu_devcoredump_read(char *buffer, loff_t offset,
gpu/drm/msm/msm_gpu.c:	struct msm_gpu *gpu = data;
gpu/drm/msm/msm_gpu.c:	struct msm_gpu_state *state;
gpu/drm/msm/msm_gpu.c:	state = msm_gpu_crashstate_get(gpu);
gpu/drm/msm/msm_gpu.c:	msm_gpu_crashstate_put(gpu);
gpu/drm/msm/msm_gpu.c:static void msm_gpu_devcoredump_free(void *data)
gpu/drm/msm/msm_gpu.c:	struct msm_gpu *gpu = data;
gpu/drm/msm/msm_gpu.c:	msm_gpu_crashstate_put(gpu);
gpu/drm/msm/msm_gpu.c:static void msm_gpu_crashstate_get_bo(struct msm_gpu_state *state,
gpu/drm/msm/msm_gpu.c:		struct msm_gem_object *obj, u64 iova, u32 flags)
gpu/drm/msm/msm_gpu.c:	struct msm_gpu_state_bo *state_bo = &state->bos[state->nr_bos];
gpu/drm/msm/msm_gpu.c:		ptr = msm_gem_get_vaddr_active(&obj->base);
gpu/drm/msm/msm_gpu.c:		msm_gem_put_vaddr(&obj->base);
gpu/drm/msm/msm_gpu.c:static void msm_gpu_crashstate_capture(struct msm_gpu *gpu,
gpu/drm/msm/msm_gpu.c:		struct msm_gem_submit *submit, char *comm, char *cmd)
gpu/drm/msm/msm_gpu.c:	struct msm_gpu_state *state;
gpu/drm/msm/msm_gpu.c:			sizeof(struct msm_gpu_state_bo), GFP_KERNEL);
gpu/drm/msm/msm_gpu.c:			msm_gpu_crashstate_get_bo(state, submit->bos[i].obj,
gpu/drm/msm/msm_gpu.c:		msm_gpu_devcoredump_read, msm_gpu_devcoredump_free);
gpu/drm/msm/msm_gpu.c:static void msm_gpu_crashstate_capture(struct msm_gpu *gpu,
gpu/drm/msm/msm_gpu.c:		struct msm_gem_submit *submit, char *comm, char *cmd)
gpu/drm/msm/msm_gpu.c:static void update_fences(struct msm_gpu *gpu, struct msm_ringbuffer *ring,
gpu/drm/msm/msm_gpu.c:	struct msm_gem_submit *submit;
gpu/drm/msm/msm_gpu.c:		msm_update_fence(submit->ring->fctx,
gpu/drm/msm/msm_gpu.c:static struct msm_gem_submit *
gpu/drm/msm/msm_gpu.c:find_submit(struct msm_ringbuffer *ring, uint32_t fence)
gpu/drm/msm/msm_gpu.c:	struct msm_gem_submit *submit;
gpu/drm/msm/msm_gpu.c:static void retire_submits(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.c:	struct msm_gpu *gpu = container_of(work, struct msm_gpu, recover_work);
gpu/drm/msm/msm_gpu.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_gpu.c:	struct msm_gem_submit *submit;
gpu/drm/msm/msm_gpu.c:	struct msm_ringbuffer *cur_ring = gpu->funcs->active_ring(gpu);
gpu/drm/msm/msm_gpu.c:			msm_rd_dump_submit(priv->hangrd, submit,
gpu/drm/msm/msm_gpu.c:			msm_rd_dump_submit(priv->hangrd, submit, NULL);
gpu/drm/msm/msm_gpu.c:	msm_gpu_crashstate_capture(gpu, submit, comm, cmd);
gpu/drm/msm/msm_gpu.c:	 * needs to happen after msm_rd_dump_submit() to ensure that the
gpu/drm/msm/msm_gpu.c:		struct msm_ringbuffer *ring = gpu->rb[i];
gpu/drm/msm/msm_gpu.c:	if (msm_gpu_active(gpu)) {
gpu/drm/msm/msm_gpu.c:			struct msm_ringbuffer *ring = gpu->rb[i];
gpu/drm/msm/msm_gpu.c:	msm_gpu_retire(gpu);
gpu/drm/msm/msm_gpu.c:static void hangcheck_timer_reset(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:	struct msm_gpu *gpu = from_timer(gpu, t, hangcheck_timer);
gpu/drm/msm/msm_gpu.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_gpu.c:	struct msm_ringbuffer *ring = gpu->funcs->active_ring(gpu);
gpu/drm/msm/msm_gpu.c:static int update_hw_cntrs(struct msm_gpu *gpu, uint32_t ncntrs, uint32_t *cntrs)
gpu/drm/msm/msm_gpu.c:static void update_sw_cntrs(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:	gpu->last_sample.active = msm_gpu_active(gpu);
gpu/drm/msm/msm_gpu.c:void msm_gpu_perfcntr_start(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:	gpu->last_sample.active = msm_gpu_active(gpu);
gpu/drm/msm/msm_gpu.c:void msm_gpu_perfcntr_stop(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:int msm_gpu_perfcntr_sample(struct msm_gpu *gpu, uint32_t *activetime,
gpu/drm/msm/msm_gpu.c:static void retire_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit)
gpu/drm/msm/msm_gpu.c:		struct msm_gem_object *msm_obj = submit->bos[i].obj;
gpu/drm/msm/msm_gpu.c:		msm_gem_move_to_inactive(&msm_obj->base);
gpu/drm/msm/msm_gpu.c:		msm_gem_put_iova(&msm_obj->base, gpu->aspace);
gpu/drm/msm/msm_gpu.c:		drm_gem_object_put(&msm_obj->base);
gpu/drm/msm/msm_gpu.c:	msm_gem_submit_free(submit);
gpu/drm/msm/msm_gpu.c:static void retire_submits(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:	struct msm_gem_submit *submit, *tmp;
gpu/drm/msm/msm_gpu.c:		struct msm_ringbuffer *ring = gpu->rb[i];
gpu/drm/msm/msm_gpu.c:	struct msm_gpu *gpu = container_of(work, struct msm_gpu, retire_work);
gpu/drm/msm/msm_gpu.c:void msm_gpu_retire(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:	struct msm_drm_private *priv = gpu->dev->dev_private;
gpu/drm/msm/msm_gpu.c:void msm_gpu_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit,
gpu/drm/msm/msm_gpu.c:		struct msm_file_private *ctx)
gpu/drm/msm/msm_gpu.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_gpu.c:	struct msm_ringbuffer *ring = submit->ring;
gpu/drm/msm/msm_gpu.c:	msm_gpu_hw_init(gpu);
gpu/drm/msm/msm_gpu.c:	msm_rd_dump_submit(priv->rd, submit, NULL);
gpu/drm/msm/msm_gpu.c:		struct msm_gem_object *msm_obj = submit->bos[i].obj;
gpu/drm/msm/msm_gpu.c:		WARN_ON(is_active(msm_obj) && (msm_obj->gpu != gpu));
gpu/drm/msm/msm_gpu.c:		drm_gem_object_get(&msm_obj->base);
gpu/drm/msm/msm_gpu.c:		msm_gem_get_iova(&msm_obj->base,
gpu/drm/msm/msm_gpu.c:			msm_gem_move_to_active(&msm_obj->base, gpu, true, submit->fence);
gpu/drm/msm/msm_gpu.c:			msm_gem_move_to_active(&msm_obj->base, gpu, false, submit->fence);
gpu/drm/msm/msm_gpu.c:	struct msm_gpu *gpu = data;
gpu/drm/msm/msm_gpu.c:static int get_clocks(struct platform_device *pdev, struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:	int ret = msm_clk_bulk_get(&pdev->dev, &gpu->grp_clks);
gpu/drm/msm/msm_gpu.c:	gpu->core_clk = msm_clk_bulk_get_clock(gpu->grp_clks,
gpu/drm/msm/msm_gpu.c:	gpu->rbbmtimer_clk = msm_clk_bulk_get_clock(gpu->grp_clks,
gpu/drm/msm/msm_gpu.c:static struct msm_gem_address_space *
gpu/drm/msm/msm_gpu.c:msm_gpu_create_address_space(struct msm_gpu *gpu, struct platform_device *pdev,
gpu/drm/msm/msm_gpu.c:	struct msm_gem_address_space *aspace;
gpu/drm/msm/msm_gpu.c:	aspace = msm_gem_address_space_create(&pdev->dev, iommu, "gpu");
gpu/drm/msm/msm_gpu.c:		msm_gem_address_space_put(aspace);
gpu/drm/msm/msm_gpu.c:int msm_gpu_init(struct drm_device *drm, struct platform_device *pdev,
gpu/drm/msm/msm_gpu.c:		struct msm_gpu *gpu, const struct msm_gpu_funcs *funcs,
gpu/drm/msm/msm_gpu.c:		const char *name, struct msm_gpu_config *config)
gpu/drm/msm/msm_gpu.c:	gpu->mmio = msm_ioremap(pdev, config->ioname, name);
gpu/drm/msm/msm_gpu.c:	gpu->ebi1_clk = msm_clk_get(pdev, "bus");
gpu/drm/msm/msm_gpu.c:	msm_devfreq_init(gpu);
gpu/drm/msm/msm_gpu.c:	gpu->aspace = msm_gpu_create_address_space(gpu, pdev,
gpu/drm/msm/msm_gpu.c:	memptrs = msm_gem_kernel_new(drm, sizeof(*gpu->memptrs_bo),
gpu/drm/msm/msm_gpu.c:		gpu->rb[i] = msm_ringbuffer_new(gpu, i, memptrs, memptrs_iova);
gpu/drm/msm/msm_gpu.c:		memptrs += sizeof(struct msm_rbmemptrs);
gpu/drm/msm/msm_gpu.c:		memptrs_iova += sizeof(struct msm_rbmemptrs);
gpu/drm/msm/msm_gpu.c:		msm_ringbuffer_destroy(gpu->rb[i]);
gpu/drm/msm/msm_gpu.c:		msm_gem_put_vaddr(gpu->memptrs_bo);
gpu/drm/msm/msm_gpu.c:		msm_gem_put_iova(gpu->memptrs_bo, gpu->aspace);
gpu/drm/msm/msm_gpu.c:void msm_gpu_cleanup(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.c:		msm_ringbuffer_destroy(gpu->rb[i]);
gpu/drm/msm/msm_gpu.c:		msm_gem_put_vaddr(gpu->memptrs_bo);
gpu/drm/msm/msm_gpu.c:		msm_gem_put_iova(gpu->memptrs_bo, gpu->aspace);
gpu/drm/msm/msm_gpu.c:		msm_gem_address_space_put(gpu->aspace);
gpu/drm/msm/msm_gpu.h:#include "msm_drv.h"
gpu/drm/msm/msm_gpu.h:#include "msm_fence.h"
gpu/drm/msm/msm_gpu.h:#include "msm_ringbuffer.h"
gpu/drm/msm/msm_gpu.h:struct msm_gem_submit;
gpu/drm/msm/msm_gpu.h:struct msm_gpu_perfcntr;
gpu/drm/msm/msm_gpu.h:struct msm_gpu_state;
gpu/drm/msm/msm_gpu.h:struct msm_gpu_config {
gpu/drm/msm/msm_gpu.h: *  + msm_gpu
gpu/drm/msm/msm_gpu.h:struct msm_gpu_funcs {
gpu/drm/msm/msm_gpu.h:	int (*get_param)(struct msm_gpu *gpu, uint32_t param, uint64_t *value);
gpu/drm/msm/msm_gpu.h:	int (*hw_init)(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:	int (*pm_suspend)(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:	int (*pm_resume)(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:	void (*submit)(struct msm_gpu *gpu, struct msm_gem_submit *submit,
gpu/drm/msm/msm_gpu.h:			struct msm_file_private *ctx);
gpu/drm/msm/msm_gpu.h:	void (*flush)(struct msm_gpu *gpu, struct msm_ringbuffer *ring);
gpu/drm/msm/msm_gpu.h:	irqreturn_t (*irq)(struct msm_gpu *irq);
gpu/drm/msm/msm_gpu.h:	struct msm_ringbuffer *(*active_ring)(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:	void (*recover)(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:	void (*destroy)(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:	void (*show)(struct msm_gpu *gpu, struct msm_gpu_state *state,
gpu/drm/msm/msm_gpu.h:	int (*debugfs_init)(struct msm_gpu *gpu, struct drm_minor *minor);
gpu/drm/msm/msm_gpu.h:	int (*gpu_busy)(struct msm_gpu *gpu, uint64_t *value);
gpu/drm/msm/msm_gpu.h:	struct msm_gpu_state *(*gpu_state_get)(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:	int (*gpu_state_put)(struct msm_gpu_state *state);
gpu/drm/msm/msm_gpu.h:struct msm_gpu {
gpu/drm/msm/msm_gpu.h:	const struct msm_gpu_funcs *funcs;
gpu/drm/msm/msm_gpu.h:	const struct msm_gpu_perfcntr *perfcntrs;
gpu/drm/msm/msm_gpu.h:	struct msm_ringbuffer *rb[MSM_GPU_MAX_RINGS];
gpu/drm/msm/msm_gpu.h:	struct msm_gem_address_space *aspace;
gpu/drm/msm/msm_gpu.h:	struct msm_gpu_state *crashstate;
gpu/drm/msm/msm_gpu.h:static inline bool msm_gpu_active(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.h:		struct msm_ringbuffer *ring = gpu->rb[i];
gpu/drm/msm/msm_gpu.h: * class that actually enables the perf counter..  but msm_gpu base class
gpu/drm/msm/msm_gpu.h:struct msm_gpu_perfcntr {
gpu/drm/msm/msm_gpu.h:struct msm_gpu_submitqueue {
gpu/drm/msm/msm_gpu.h:struct msm_gpu_state_bo {
gpu/drm/msm/msm_gpu.h:struct msm_gpu_state {
gpu/drm/msm/msm_gpu.h:	struct msm_gpu_state_bo *bos;
gpu/drm/msm/msm_gpu.h:static inline void gpu_write(struct msm_gpu *gpu, u32 reg, u32 data)
gpu/drm/msm/msm_gpu.h:	msm_writel(data, gpu->mmio + (reg << 2));
gpu/drm/msm/msm_gpu.h:static inline u32 gpu_read(struct msm_gpu *gpu, u32 reg)
gpu/drm/msm/msm_gpu.h:	return msm_readl(gpu->mmio + (reg << 2));
gpu/drm/msm/msm_gpu.h:static inline void gpu_rmw(struct msm_gpu *gpu, u32 reg, u32 mask, u32 or)
gpu/drm/msm/msm_gpu.h:static inline u64 gpu_read64(struct msm_gpu *gpu, u32 lo, u32 hi)
gpu/drm/msm/msm_gpu.h:	val = (u64) msm_readl(gpu->mmio + (lo << 2));
gpu/drm/msm/msm_gpu.h:	val |= ((u64) msm_readl(gpu->mmio + (hi << 2)) << 32);
gpu/drm/msm/msm_gpu.h:static inline void gpu_write64(struct msm_gpu *gpu, u32 lo, u32 hi, u64 val)
gpu/drm/msm/msm_gpu.h:	msm_writel(lower_32_bits(val), gpu->mmio + (lo << 2));
gpu/drm/msm/msm_gpu.h:	msm_writel(upper_32_bits(val), gpu->mmio + (hi << 2));
gpu/drm/msm/msm_gpu.h:int msm_gpu_pm_suspend(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:int msm_gpu_pm_resume(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:int msm_gpu_hw_init(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:void msm_gpu_perfcntr_start(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:void msm_gpu_perfcntr_stop(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:int msm_gpu_perfcntr_sample(struct msm_gpu *gpu, uint32_t *activetime,
gpu/drm/msm/msm_gpu.h:void msm_gpu_retire(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:void msm_gpu_submit(struct msm_gpu *gpu, struct msm_gem_submit *submit,
gpu/drm/msm/msm_gpu.h:		struct msm_file_private *ctx);
gpu/drm/msm/msm_gpu.h:int msm_gpu_init(struct drm_device *drm, struct platform_device *pdev,
gpu/drm/msm/msm_gpu.h:		struct msm_gpu *gpu, const struct msm_gpu_funcs *funcs,
gpu/drm/msm/msm_gpu.h:		const char *name, struct msm_gpu_config *config);
gpu/drm/msm/msm_gpu.h:void msm_gpu_cleanup(struct msm_gpu *gpu);
gpu/drm/msm/msm_gpu.h:struct msm_gpu *adreno_load_gpu(struct drm_device *dev);
gpu/drm/msm/msm_gpu.h:static inline void msm_submitqueue_put(struct msm_gpu_submitqueue *queue)
gpu/drm/msm/msm_gpu.h:		kref_put(&queue->ref, msm_submitqueue_destroy);
gpu/drm/msm/msm_gpu.h:static inline struct msm_gpu_state *msm_gpu_crashstate_get(struct msm_gpu *gpu)
gpu/drm/msm/msm_gpu.h:	struct msm_gpu_state *state = NULL;
gpu/drm/msm/msm_gpu.h:static inline void msm_gpu_crashstate_put(struct msm_gpu *gpu)
gpu/drm/msm/msm_iommu.c:#include "msm_drv.h"
gpu/drm/msm/msm_iommu.c:#include "msm_mmu.h"
gpu/drm/msm/msm_iommu.c:struct msm_iommu {
gpu/drm/msm/msm_iommu.c:	struct msm_mmu base;
gpu/drm/msm/msm_iommu.c:#define to_msm_iommu(x) container_of(x, struct msm_iommu, base)
gpu/drm/msm/msm_iommu.c:static int msm_fault_handler(struct iommu_domain *domain, struct device *dev,
gpu/drm/msm/msm_iommu.c:	struct msm_iommu *iommu = arg;
gpu/drm/msm/msm_iommu.c:static int msm_iommu_attach(struct msm_mmu *mmu, const char * const *names,
gpu/drm/msm/msm_iommu.c:	struct msm_iommu *iommu = to_msm_iommu(mmu);
gpu/drm/msm/msm_iommu.c:static void msm_iommu_detach(struct msm_mmu *mmu, const char * const *names,
gpu/drm/msm/msm_iommu.c:	struct msm_iommu *iommu = to_msm_iommu(mmu);
gpu/drm/msm/msm_iommu.c:static int msm_iommu_map(struct msm_mmu *mmu, uint64_t iova,
gpu/drm/msm/msm_iommu.c:	struct msm_iommu *iommu = to_msm_iommu(mmu);
gpu/drm/msm/msm_iommu.c:static int msm_iommu_unmap(struct msm_mmu *mmu, uint64_t iova,
gpu/drm/msm/msm_iommu.c:	struct msm_iommu *iommu = to_msm_iommu(mmu);
gpu/drm/msm/msm_iommu.c:static void msm_iommu_destroy(struct msm_mmu *mmu)
gpu/drm/msm/msm_iommu.c:	struct msm_iommu *iommu = to_msm_iommu(mmu);
gpu/drm/msm/msm_iommu.c:static const struct msm_mmu_funcs funcs = {
gpu/drm/msm/msm_iommu.c:		.attach = msm_iommu_attach,
gpu/drm/msm/msm_iommu.c:		.detach = msm_iommu_detach,
gpu/drm/msm/msm_iommu.c:		.map = msm_iommu_map,
gpu/drm/msm/msm_iommu.c:		.unmap = msm_iommu_unmap,
gpu/drm/msm/msm_iommu.c:		.destroy = msm_iommu_destroy,
gpu/drm/msm/msm_iommu.c:struct msm_mmu *msm_iommu_new(struct device *dev, struct iommu_domain *domain)
gpu/drm/msm/msm_iommu.c:	struct msm_iommu *iommu;
gpu/drm/msm/msm_iommu.c:	msm_mmu_init(&iommu->base, dev, &funcs);
gpu/drm/msm/msm_iommu.c:	iommu_set_fault_handler(domain, msm_fault_handler, iommu);
gpu/drm/msm/msm_kms.h:#include "msm_drv.h"
gpu/drm/msm/msm_kms.h:struct msm_kms_funcs {
gpu/drm/msm/msm_kms.h:	int (*hw_init)(struct msm_kms *kms);
gpu/drm/msm/msm_kms.h:	void (*irq_preinstall)(struct msm_kms *kms);
gpu/drm/msm/msm_kms.h:	int (*irq_postinstall)(struct msm_kms *kms);
gpu/drm/msm/msm_kms.h:	void (*irq_uninstall)(struct msm_kms *kms);
gpu/drm/msm/msm_kms.h:	irqreturn_t (*irq)(struct msm_kms *kms);
gpu/drm/msm/msm_kms.h:	int (*enable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);
gpu/drm/msm/msm_kms.h:	void (*disable_vblank)(struct msm_kms *kms, struct drm_crtc *crtc);
gpu/drm/msm/msm_kms.h:	void (*prepare_commit)(struct msm_kms *kms,
gpu/drm/msm/msm_kms.h:	void (*commit)(struct msm_kms *kms, struct drm_atomic_state *state);
gpu/drm/msm/msm_kms.h:	void (*complete_commit)(struct msm_kms *kms,
gpu/drm/msm/msm_kms.h:	void (*wait_for_crtc_commit_done)(struct msm_kms *kms,
gpu/drm/msm/msm_kms.h:	/* get msm_format w/ optional format modifiers from drm_mode_fb_cmd2 */
gpu/drm/msm/msm_kms.h:	const struct msm_format *(*get_format)(struct msm_kms *kms,
gpu/drm/msm/msm_kms.h:	int (*check_modified_format)(const struct msm_kms *kms,
gpu/drm/msm/msm_kms.h:			const struct msm_format *msm_fmt,
gpu/drm/msm/msm_kms.h:	long (*round_pixclk)(struct msm_kms *kms, unsigned long rate,
gpu/drm/msm/msm_kms.h:	int (*set_split_display)(struct msm_kms *kms,
gpu/drm/msm/msm_kms.h:	void (*set_encoder_mode)(struct msm_kms *kms,
gpu/drm/msm/msm_kms.h:	void (*destroy)(struct msm_kms *kms);
gpu/drm/msm/msm_kms.h:	int (*debugfs_init)(struct msm_kms *kms, struct drm_minor *minor);
gpu/drm/msm/msm_kms.h:struct msm_kms {
gpu/drm/msm/msm_kms.h:	const struct msm_kms_funcs *funcs;
gpu/drm/msm/msm_kms.h:	struct msm_gem_address_space *aspace;
gpu/drm/msm/msm_kms.h:static inline void msm_kms_init(struct msm_kms *kms,
gpu/drm/msm/msm_kms.h:		const struct msm_kms_funcs *funcs)
gpu/drm/msm/msm_kms.h:struct msm_kms *mdp4_kms_init(struct drm_device *dev);
gpu/drm/msm/msm_kms.h:struct msm_kms *mdp5_kms_init(struct drm_device *dev);
gpu/drm/msm/msm_kms.h:struct msm_kms *dpu_kms_init(struct drm_device *dev);
gpu/drm/msm/msm_kms.h:struct msm_mdss_funcs {
gpu/drm/msm/msm_kms.h:	int (*enable)(struct msm_mdss *mdss);
gpu/drm/msm/msm_kms.h:	int (*disable)(struct msm_mdss *mdss);
gpu/drm/msm/msm_kms.h:struct msm_mdss {
gpu/drm/msm/msm_kms.h:	const struct msm_mdss_funcs *funcs;
gpu/drm/msm/msm_mmu.h:struct msm_mmu_funcs {
gpu/drm/msm/msm_mmu.h:	int (*attach)(struct msm_mmu *mmu, const char * const *names, int cnt);
gpu/drm/msm/msm_mmu.h:	void (*detach)(struct msm_mmu *mmu, const char * const *names, int cnt);
gpu/drm/msm/msm_mmu.h:	int (*map)(struct msm_mmu *mmu, uint64_t iova, struct sg_table *sgt,
gpu/drm/msm/msm_mmu.h:	int (*unmap)(struct msm_mmu *mmu, uint64_t iova, struct sg_table *sgt,
gpu/drm/msm/msm_mmu.h:	void (*destroy)(struct msm_mmu *mmu);
gpu/drm/msm/msm_mmu.h:struct msm_mmu {
gpu/drm/msm/msm_mmu.h:	const struct msm_mmu_funcs *funcs;
gpu/drm/msm/msm_mmu.h:static inline void msm_mmu_init(struct msm_mmu *mmu, struct device *dev,
gpu/drm/msm/msm_mmu.h:		const struct msm_mmu_funcs *funcs)
gpu/drm/msm/msm_mmu.h:struct msm_mmu *msm_iommu_new(struct device *dev, struct iommu_domain *domain);
gpu/drm/msm/msm_mmu.h:struct msm_mmu *msm_gpummu_new(struct device *dev, struct msm_gpu *gpu);
gpu/drm/msm/msm_mmu.h:static inline void msm_mmu_set_fault_handler(struct msm_mmu *mmu, void *arg,
gpu/drm/msm/msm_perf.c:#include "msm_drv.h"
gpu/drm/msm/msm_perf.c:#include "msm_gpu.h"
gpu/drm/msm/msm_perf.c:struct msm_perf_state {
gpu/drm/msm/msm_perf.c:static int wait_sample(struct msm_perf_state *perf)
gpu/drm/msm/msm_perf.c:static int refill_buf(struct msm_perf_state *perf)
gpu/drm/msm/msm_perf.c:	struct msm_drm_private *priv = perf->dev->dev_private;
gpu/drm/msm/msm_perf.c:	struct msm_gpu *gpu = priv->gpu;
gpu/drm/msm/msm_perf.c:			const struct msm_gpu_perfcntr *perfcntr = &gpu->perfcntrs[i];
gpu/drm/msm/msm_perf.c:		ret = msm_gpu_perfcntr_sample(gpu, &activetime, &totaltime,
gpu/drm/msm/msm_perf.c:	struct msm_perf_state *perf = file->private_data;
gpu/drm/msm/msm_perf.c:	struct msm_perf_state *perf = inode->i_private;
gpu/drm/msm/msm_perf.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_perf.c:	struct msm_gpu *gpu = priv->gpu;
gpu/drm/msm/msm_perf.c:	msm_gpu_perfcntr_start(gpu);
gpu/drm/msm/msm_perf.c:	struct msm_perf_state *perf = inode->i_private;
gpu/drm/msm/msm_perf.c:	struct msm_drm_private *priv = perf->dev->dev_private;
gpu/drm/msm/msm_perf.c:	msm_gpu_perfcntr_stop(priv->gpu);
gpu/drm/msm/msm_perf.c:int msm_perf_debugfs_init(struct drm_minor *minor)
gpu/drm/msm/msm_perf.c:void msm_perf_debugfs_cleanup(struct msm_drm_private *priv)
gpu/drm/msm/msm_perf.c:	struct msm_perf_state *perf = priv->perf;
gpu/drm/msm/msm_rd.c:#include "msm_drv.h"
gpu/drm/msm/msm_rd.c:#include "msm_gpu.h"
gpu/drm/msm/msm_rd.c:#include "msm_gem.h"
gpu/drm/msm/msm_rd.c:struct msm_rd_state {
gpu/drm/msm/msm_rd.c:	struct msm_gem_submit *submit;
gpu/drm/msm/msm_rd.c:static void rd_write(struct msm_rd_state *rd, const void *buf, int sz)
gpu/drm/msm/msm_rd.c:static void rd_write_section(struct msm_rd_state *rd,
gpu/drm/msm/msm_rd.c:	struct msm_rd_state *rd = file->private_data;
gpu/drm/msm/msm_rd.c:	struct msm_rd_state *rd = inode->i_private;
gpu/drm/msm/msm_rd.c:	struct msm_drm_private *priv = dev->dev_private;
gpu/drm/msm/msm_rd.c:	struct msm_gpu *gpu = priv->gpu;
gpu/drm/msm/msm_rd.c:	struct msm_rd_state *rd = inode->i_private;
gpu/drm/msm/msm_rd.c:static void rd_cleanup(struct msm_rd_state *rd)
gpu/drm/msm/msm_rd.c:static struct msm_rd_state *rd_init(struct drm_minor *minor, const char *name)
gpu/drm/msm/msm_rd.c:	struct msm_rd_state *rd;
gpu/drm/msm/msm_rd.c:int msm_rd_debugfs_init(struct drm_minor *minor)
gpu/drm/msm/msm_rd.c:void msm_rd_debugfs_cleanup(struct msm_drm_private *priv)
gpu/drm/msm/msm_rd.c:static void snapshot_buf(struct msm_rd_state *rd,
gpu/drm/msm/msm_rd.c:		struct msm_gem_submit *submit, int idx,
gpu/drm/msm/msm_rd.c:	struct msm_gem_object *obj = submit->bos[idx].obj;
gpu/drm/msm/msm_rd.c:	buf = msm_gem_get_vaddr_active(&obj->base);
gpu/drm/msm/msm_rd.c:	msm_gem_put_vaddr(&obj->base);
gpu/drm/msm/msm_rd.c:void msm_rd_dump_submit(struct msm_rd_state *rd, struct msm_gem_submit *submit,
gpu/drm/msm/msm_ringbuffer.c:#include "msm_ringbuffer.h"
gpu/drm/msm/msm_ringbuffer.c:#include "msm_gpu.h"
gpu/drm/msm/msm_ringbuffer.c:struct msm_ringbuffer *msm_ringbuffer_new(struct msm_gpu *gpu, int id,
gpu/drm/msm/msm_ringbuffer.c:	struct msm_ringbuffer *ring;
gpu/drm/msm/msm_ringbuffer.c:	ring->start = msm_gem_kernel_new(gpu->dev, MSM_GPU_RINGBUFFER_SZ,
gpu/drm/msm/msm_ringbuffer.c:	ring->fctx = msm_fence_context_alloc(gpu->dev, name);
gpu/drm/msm/msm_ringbuffer.c:	msm_ringbuffer_destroy(ring);
gpu/drm/msm/msm_ringbuffer.c:void msm_ringbuffer_destroy(struct msm_ringbuffer *ring)
gpu/drm/msm/msm_ringbuffer.c:	msm_fence_context_free(ring->fctx);
gpu/drm/msm/msm_ringbuffer.c:		msm_gem_put_iova(ring->bo, ring->gpu->aspace);
gpu/drm/msm/msm_ringbuffer.c:		msm_gem_put_vaddr(ring->bo);
gpu/drm/msm/msm_ringbuffer.h:#include "msm_drv.h"
gpu/drm/msm/msm_ringbuffer.h:	((ring)->memptrs_iova + offsetof(struct msm_rbmemptrs, member))
gpu/drm/msm/msm_ringbuffer.h:struct msm_rbmemptrs {
gpu/drm/msm/msm_ringbuffer.h:struct msm_ringbuffer {
gpu/drm/msm/msm_ringbuffer.h:	struct msm_gpu *gpu;
gpu/drm/msm/msm_ringbuffer.h:	struct msm_rbmemptrs *memptrs;
gpu/drm/msm/msm_ringbuffer.h:	struct msm_fence_context *fctx;
gpu/drm/msm/msm_ringbuffer.h:struct msm_ringbuffer *msm_ringbuffer_new(struct msm_gpu *gpu, int id,
gpu/drm/msm/msm_ringbuffer.h:void msm_ringbuffer_destroy(struct msm_ringbuffer *ring);
gpu/drm/msm/msm_ringbuffer.h:OUT_RING(struct msm_ringbuffer *ring, uint32_t data)
gpu/drm/msm/msm_submitqueue.c:#include "msm_gpu.h"
gpu/drm/msm/msm_submitqueue.c:void msm_submitqueue_destroy(struct kref *kref)
gpu/drm/msm/msm_submitqueue.c:	struct msm_gpu_submitqueue *queue = container_of(kref,
gpu/drm/msm/msm_submitqueue.c:		struct msm_gpu_submitqueue, ref);
gpu/drm/msm/msm_submitqueue.c:struct msm_gpu_submitqueue *msm_submitqueue_get(struct msm_file_private *ctx,
gpu/drm/msm/msm_submitqueue.c:	struct msm_gpu_submitqueue *entry;
gpu/drm/msm/msm_submitqueue.c:void msm_submitqueue_close(struct msm_file_private *ctx)
gpu/drm/msm/msm_submitqueue.c:	struct msm_gpu_submitqueue *entry, *tmp;
gpu/drm/msm/msm_submitqueue.c:		msm_submitqueue_put(entry);
gpu/drm/msm/msm_submitqueue.c:int msm_submitqueue_create(struct drm_device *drm, struct msm_file_private *ctx,
gpu/drm/msm/msm_submitqueue.c:	struct msm_drm_private *priv = drm->dev_private;
gpu/drm/msm/msm_submitqueue.c:	struct msm_gpu_submitqueue *queue;
gpu/drm/msm/msm_submitqueue.c:int msm_submitqueue_init(struct drm_device *drm, struct msm_file_private *ctx)
gpu/drm/msm/msm_submitqueue.c:	struct msm_drm_private *priv = drm->dev_private;
gpu/drm/msm/msm_submitqueue.c:	return msm_submitqueue_create(drm, ctx, default_prio, 0, NULL);
gpu/drm/msm/msm_submitqueue.c:int msm_submitqueue_remove(struct msm_file_private *ctx, u32 id)
gpu/drm/msm/msm_submitqueue.c:	struct msm_gpu_submitqueue *entry;
gpu/drm/msm/msm_submitqueue.c:			msm_submitqueue_put(entry);
gpu/drm/msm/Kconfig:	  that can be parsed by envytools demsm tool.  If enabled, register
gpu/drm/msm/Kconfig:	  logging can be switched on via msm.reglog=y module param.
gpu/msm/Kconfig:	default "msm-adreno-tz" if DEVFREQ_GOV_QCOM_ADRENO_TZ
gpu/msm/Makefile:msm_kgsl_core-y = \
gpu/msm/Makefile:msm_kgsl_core-$(CONFIG_QCOM_KGSL_IOMMU) += kgsl_iommu.o
gpu/msm/Makefile:msm_kgsl_core-$(CONFIG_DEBUG_FS) += kgsl_debugfs.o
gpu/msm/Makefile:msm_kgsl_core-$(CONFIG_SYNC_FILE) += kgsl_sync.o
gpu/msm/Makefile:msm_kgsl_core-$(CONFIG_COMPAT) += kgsl_compat.o
gpu/msm/Makefile:msm_kgsl_core-$(CONFIG_QCOM_KGSL_PROCESS_RECLAIM) += kgsl_reclaim.o
gpu/msm/Makefile:	msm_kgsl_core-y += kgsl_pool.o
gpu/msm/Makefile:msm_adreno-y += \
gpu/msm/Makefile:msm_adreno-$(CONFIG_QCOM_KGSL_IOMMU) += adreno_iommu.o
gpu/msm/Makefile:msm_adreno-$(CONFIG_DEBUG_FS) += adreno_debugfs.o adreno_profile.o
gpu/msm/Makefile:msm_adreno-$(CONFIG_COMPAT) += adreno_compat.o
gpu/msm/Makefile:msm_adreno-$(CONFIG_CORESIGHT_ADRENO) += adreno_coresight.o
gpu/msm/Makefile:msm_kgsl_core-objs = $(msm_kgsl_core-y)
gpu/msm/Makefile:msm_adreno-objs = $(msm_adreno-y)
gpu/msm/Makefile:obj-$(CONFIG_QCOM_KGSL) += msm_kgsl_core.o
gpu/msm/Makefile:obj-$(CONFIG_QCOM_KGSL) += msm_adreno.o
gpu/msm/adreno_debugfs.c:#include <linux/msm_kgsl.h>
gpu/msm/adreno_snapshot.c:#include <linux/msm-bus.h>
gpu/msm/adreno_snapshot.c:		msm_bus_scale_client_update_request(device->pwrctrl.gpu_cfg,
gpu/msm/adreno_snapshot.c:		msm_bus_scale_client_update_request(device->pwrctrl.gpu_cfg,
gpu/msm/kgsl.h:#include <uapi/linux/msm_kgsl.h>
gpu/msm/kgsl_compat.h:#include <uapi/linux/msm_kgsl.h>
gpu/msm/kgsl_device.h:struct msm_bus_scale_pdata *kgsl_get_bus_scale_table(
gpu/msm/kgsl_gmu.c:#include <linux/msm-bus.h>
gpu/msm/kgsl_gmu.c:		unsigned int num_usecases, struct msm_bus_tcs_handle handle)
gpu/msm/kgsl_gmu.c:	struct msm_bus_tcs_usecase *tmp;
gpu/msm/kgsl_gmu.c:	struct msm_bus_tcs_usecase *usecases;
gpu/msm/kgsl_gmu.c:	struct msm_bus_tcs_handle hdl;
gpu/msm/kgsl_gmu.c:	ret = msm_bus_scale_query_tcs_cmd_all(&hdl, gmu->pcl);
gpu/msm/kgsl_gmu.c:	ret = msm_bus_scale_query_tcs_cmd_all(&hdl, gmu->ccl);
gpu/msm/kgsl_gmu.c:	struct msm_bus_scale_pdata *bus_scale_table =
gpu/msm/kgsl_gmu.c:	gmu->pcl = msm_bus_scale_register_client(bus_scale_table);
gpu/msm/kgsl_gmu.c:	struct msm_bus_scale_pdata *cnoc_table;
gpu/msm/kgsl_gmu.c:	cnoc_table = msm_bus_cl_get_pdata(gmu->pdev);
gpu/msm/kgsl_gmu.c:	gmu->ccl = msm_bus_scale_register_client(cnoc_table);
gpu/msm/kgsl_gmu.c:		ret = msm_bus_scale_client_update_request(gmu->pcl,
gpu/msm/kgsl_gmu.c:		msm_bus_scale_client_update_request(gmu->pcl, 0);
gpu/msm/kgsl_gmu.c:	msm_bus_scale_client_update_request(gmu->pcl, 0);
gpu/msm/kgsl_gmu.c:		msm_bus_scale_unregister_client(gmu->ccl);
gpu/msm/kgsl_gmu.c:		msm_bus_scale_unregister_client(gmu->pcl);
gpu/msm/kgsl_pwrctrl.c:#include <linux/msm-bus.h>
gpu/msm/kgsl_pwrctrl.c:#include <linux/msm-bus-board.h>
gpu/msm/kgsl_pwrctrl.c:#include <linux/msm_kgsl.h>
gpu/msm/kgsl_pwrctrl.c: * kgsl_get_bw() - Return latest msm bus IB vote
gpu/msm/kgsl_pwrctrl.c: * _ab_buslevel_update() - Return latest msm bus AB vote
gpu/msm/kgsl_pwrctrl.c:		ret = msm_bus_scale_client_update_request(pwr->pcl, buslevel);
gpu/msm/kgsl_pwrctrl.c:		msm_bus_scale_unregister_client(pwr->pcl);
gpu/msm/kgsl_pwrctrl.c:		msm_bus_scale_unregister_client(pwr->gpu_cfg);
gpu/msm/kgsl_pwrctrl.c:static bool pwrlevel_uses_ib(struct msm_bus_scale_pdata *bus_scale_table,
gpu/msm/kgsl_pwrctrl.c:				struct msm_bus_vectors *vector,
gpu/msm/kgsl_pwrctrl.c:	struct msm_bus_scale_pdata *bus_scale_table;
gpu/msm/kgsl_pwrctrl.c:	struct msm_bus_scale_pdata *gpu_cfg_table;
gpu/msm/kgsl_pwrctrl.c:			msm_bus_pdata_from_node(device->pdev, gpu_cfg_node);
gpu/msm/kgsl_pwrctrl.c:				msm_bus_scale_register_client(gpu_cfg_table);
gpu/msm/kgsl_pwrctrl.c:		pwr->pcl = msm_bus_scale_register_client(bus_scale_table);
gpu/msm/kgsl_pwrctrl.c:		struct msm_bus_paths *usecase =
gpu/msm/kgsl_pwrctrl.c:		struct msm_bus_vectors *vector = &usecase->vectors[0];
gpu/msm/kgsl_pwrscale.c:#include <linux/msm_kgsl.h>
gpu/msm/kgsl_pwrscale.c:	struct msm_adreno_extended_profile *gpu_profile;
gpu/msm/kgsl_pwrscale.c:	struct devfreq_msm_adreno_tz_data *data;
gpu/msm/kgsl_pwrscale.c:	/* initialize msm-adreno-tz governor specific data here */
gpu/msm/kgsl_pwrscale.h:#include <linux/msm_adreno_devfreq.h>
gpu/msm/kgsl_pwrscale.h:	struct msm_adreno_extended_profile gpu_profile;
gpu/msm/kgsl_pwrscale.h:	struct msm_busmon_extended_profile bus_profile;
gpu/msm/adreno.c:#include <linux/msm_kgsl.h>
gpu/msm/adreno.c:#include <linux/msm-bus.h>
gpu/msm/adreno.c:static struct devfreq_msm_adreno_tz_data adreno_tz_data = {
gpu/msm/adreno.c:		msm_bus_scale_client_update_request(device->pwrctrl.gpu_cfg,
gpu/msm/adreno.c:		msm_bus_scale_client_update_request(device->pwrctrl.gpu_cfg,
gpu/msm/adreno.c:		msm_bus_scale_client_update_request(device->pwrctrl.gpu_cfg,
gpu/msm/adreno.c:		msm_bus_scale_client_update_request(device->pwrctrl.gpu_cfg,
gpu/msm/kgsl.c:#include <linux/msm-bus.h>
gpu/msm/kgsl.c:struct msm_bus_scale_pdata *kgsl_get_bus_scale_table(struct kgsl_device *device)
gpu/msm/kgsl.c:		struct msm_bus_scale_pdata *data = msm_bus_pdata_from_node(
gpu/msm/kgsl.c:	return msm_bus_cl_get_pdata(device->pdev);
gpu/Makefile:obj-$(CONFIG_QCOM_KGSL) += msm/
hid/hid-qvr.c:#include <linux/msm_ion.h>
hwtracing/coresight/coresight-common.h:extern void msm_qdss_csr_enable_bam_to_usb(struct coresight_csr *csr);
hwtracing/coresight/coresight-common.h:extern void msm_qdss_csr_enable_flush(struct coresight_csr *csr);
hwtracing/coresight/coresight-common.h:extern void msm_qdss_csr_disable_bam_to_usb(struct coresight_csr *csr);
hwtracing/coresight/coresight-common.h:extern void msm_qdss_csr_disable_flush(struct coresight_csr *csr);
hwtracing/coresight/coresight-common.h:static inline void msm_qdss_csr_enable_bam_to_usb(struct coresight_csr *csr) {}
hwtracing/coresight/coresight-common.h:static inline void msm_qdss_csr_disable_bam_to_usb(struct coresight_csr *csr) {}
hwtracing/coresight/coresight-common.h:static inline void msm_qdss_csr_disable_flush(struct coresight_csr *csr) {}
hwtracing/coresight/coresight-csr.c:static void msm_qdss_csr_config_flush_period(struct csr_drvdata *drvdata)
hwtracing/coresight/coresight-csr.c:void msm_qdss_csr_enable_bam_to_usb(struct coresight_csr *csr)
hwtracing/coresight/coresight-csr.c:EXPORT_SYMBOL(msm_qdss_csr_enable_bam_to_usb);
hwtracing/coresight/coresight-csr.c:void msm_qdss_csr_enable_flush(struct coresight_csr *csr)
hwtracing/coresight/coresight-csr.c:	msm_qdss_csr_config_flush_period(drvdata);
hwtracing/coresight/coresight-csr.c:EXPORT_SYMBOL(msm_qdss_csr_enable_flush);
hwtracing/coresight/coresight-csr.c:void msm_qdss_csr_disable_bam_to_usb(struct coresight_csr *csr)
hwtracing/coresight/coresight-csr.c:EXPORT_SYMBOL(msm_qdss_csr_disable_bam_to_usb);
hwtracing/coresight/coresight-csr.c:void msm_qdss_csr_disable_flush(struct coresight_csr *csr)
hwtracing/coresight/coresight-csr.c:EXPORT_SYMBOL(msm_qdss_csr_disable_flush);
hwtracing/coresight/coresight-csr.c:		msm_qdss_csr_config_flush_period(drvdata);
hwtracing/coresight/coresight-tmc-etr.c:	msm_qdss_csr_enable_bam_to_usb(drvdata->csr);
hwtracing/coresight/coresight-tmc-etr.c:	msm_qdss_csr_enable_flush(drvdata->csr);
hwtracing/coresight/coresight-tmc-etr.c:	msm_qdss_csr_disable_flush(drvdata->csr);
hwtracing/coresight/coresight-tmc-etr.c:	msm_qdss_csr_disable_bam_to_usb(drvdata->csr);
hwtracing/coresight/coresight-tmc.c:	struct msm_dump_data *dump_data;
hwtracing/coresight/coresight-tmc.c:		dump_entry = get_msm_dump_ptr(MSM_DUMP_DATA_TMC_ETR_REG);
hwtracing/coresight/coresight-tmc.c:		dump_entry = get_msm_dump_ptr(MSM_DUMP_DATA_TMC_ETF_REG);
hwtracing/coresight/coresight-tmc.h:#include <linux/msm-sps.h>
i2c/busses/Kconfig:	  will be called i2c-msm-v2.
i2c/busses/Makefile:obj-$(CONFIG_I2C_MSM_V2)        += i2c-msm-v2.o
i2c/busses/i2c-qcom-geni.c:#include <linux/msm_gpi.h>
i2c/busses/i2c-qcom-geni.c:	struct msm_gpi_tre lock_t;
i2c/busses/i2c-qcom-geni.c:	struct msm_gpi_tre unlock_t;
i2c/busses/i2c-qcom-geni.c:	struct msm_gpi_tre cfg0_t;
i2c/busses/i2c-qcom-geni.c:	struct msm_gpi_tre go_t;
i2c/busses/i2c-qcom-geni.c:	struct msm_gpi_tre tx_t;
i2c/busses/i2c-qcom-geni.c:	struct msm_gpi_tre rx_t;
i2c/busses/i2c-qcom-geni.c:	struct msm_gpi_ctrl tx_ev;
i2c/busses/i2c-qcom-geni.c:	struct msm_gpi_ctrl rx_ev;
i2c/busses/i2c-qcom-geni.c:	struct msm_gpi_dma_async_tx_cb_param tx_cb;
i2c/busses/i2c-qcom-geni.c:	struct msm_gpi_dma_async_tx_cb_param rx_cb;
i2c/busses/i2c-qcom-geni.c:static void gi2c_ev_cb(struct dma_chan *ch, struct msm_gpi_cb const *cb_str,
i2c/busses/i2c-qcom-geni.c:static void gi2c_gsi_cb_err(struct msm_gpi_dma_async_tx_cb_param *cb,
i2c/busses/i2c-qcom-geni.c:	struct msm_gpi_dma_async_tx_cb_param *tx_cb = ptr;
i2c/busses/i2c-qcom-geni.c:	struct msm_gpi_dma_async_tx_cb_param *rx_cb = ptr;
i2c/busses/i2c-qcom-geni.c:		struct msm_gpi_tre *lock_t = &gi2c->lock_t;
i2c/busses/i2c-qcom-geni.c:		struct msm_gpi_tre *unlock_t = &gi2c->unlock_t;
i2c/busses/i2c-qcom-geni.c:		struct msm_gpi_tre *cfg0 = &gi2c->cfg0_t;
i2c/busses/i2c-qcom-geni.c:		struct msm_gpi_tre *go_t = &gi2c->go_t;
i2c/busses/i2c-msm-v2.c:#include <linux/msm-sps.h>
i2c/busses/i2c-msm-v2.c:#include <linux/msm-bus.h>
i2c/busses/i2c-msm-v2.c:#include <linux/msm-bus-board.h>
i2c/busses/i2c-msm-v2.c:#include <linux/i2c-msm-v2.h>
i2c/busses/i2c-msm-v2.c:static const enum msm_i2_debug_level DEFAULT_DBG_LVL = MSM_DBG;
i2c/busses/i2c-msm-v2.c:static const enum msm_i2_debug_level DEFAULT_DBG_LVL = MSM_ERR;
i2c/busses/i2c-msm-v2.c:static bool i2c_msm_xfer_next_buf(struct i2c_msm_ctrl *ctrl);
i2c/busses/i2c-msm-v2.c:static int i2c_msm_xfer_wait_for_completion(struct i2c_msm_ctrl *ctrl,
i2c/busses/i2c-msm-v2.c:static int  i2c_msm_pm_resume(struct device *dev);
i2c/busses/i2c-msm-v2.c:static void i2c_msm_pm_suspend(struct device *dev);
i2c/busses/i2c-msm-v2.c:static void i2c_msm_clk_path_init(struct i2c_msm_ctrl *ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_rsrcs_gpio_get_state(struct i2c_msm_ctrl *ctrl,
i2c/busses/i2c-msm-v2.c:static void i2c_msm_pm_pinctrl_state(struct i2c_msm_ctrl *ctrl,
i2c/busses/i2c-msm-v2.c:/* string table for enum i2c_msm_xfer_mode_id */
i2c/busses/i2c-msm-v2.c:const char * const i2c_msm_mode_str_tbl[] = {
i2c/busses/i2c-msm-v2.c:static const u32 i2c_msm_fifo_block_sz_tbl[] = {16, 16, 32, 0};
i2c/busses/i2c-msm-v2.c:/* from enum i2c_msm_xfer_mode_id to qup_io_modes register values */
i2c/busses/i2c-msm-v2.c:static const u32 i2c_msm_mode_to_reg_tbl[] = {
i2c/busses/i2c-msm-v2.c:const char *i2c_msm_err_str_table[] = {
i2c/busses/i2c-msm-v2.c:static void i2c_msm_dbg_dump_diag(struct i2c_msm_ctrl *ctrl,
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer *xfer = &ctrl->xfer;
i2c/busses/i2c-msm-v2.c:	const char *str = i2c_msm_err_str_table[xfer->err];
i2c/busses/i2c-msm-v2.c:		i2c_msm_mode_str_tbl[xfer->mode_id], xfer->msgs->addr,
i2c/busses/i2c-msm-v2.c:static u32 i2c_msm_reg_io_modes_out_blk_sz(u32 qup_io_modes)
i2c/busses/i2c-msm-v2.c:	return i2c_msm_fifo_block_sz_tbl[qup_io_modes & 0x3];
i2c/busses/i2c-msm-v2.c:static u32 i2c_msm_reg_io_modes_in_blk_sz(u32 qup_io_modes)
i2c/busses/i2c-msm-v2.c:	return i2c_msm_fifo_block_sz_tbl[BITS_AT(qup_io_modes, 5, 2)];
i2c/busses/i2c-msm-v2.c:static const u32 i2c_msm_fifo_sz_table[] = {2, 4, 8, 16};
i2c/busses/i2c-msm-v2.c:static void i2c_msm_qup_fifo_calc_size(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_fifo *fifo = &ctrl->xfer.fifo;
i2c/busses/i2c-msm-v2.c:	fifo->input_fifo_sz = i2c_msm_reg_io_modes_in_blk_sz(reg_data) *
i2c/busses/i2c-msm-v2.c:					i2c_msm_fifo_sz_table[input_fifo_size];
i2c/busses/i2c-msm-v2.c:	fifo->output_fifo_sz = i2c_msm_reg_io_modes_out_blk_sz(reg_data) *
i2c/busses/i2c-msm-v2.c:					i2c_msm_fifo_sz_table[output_fifo_size];
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_PROF, "QUP input-sz:%zu, input-sz:%zu\n",
i2c/busses/i2c-msm-v2.c: * i2c_msm_tag_byte: accessor for tag as four bytes array
i2c/busses/i2c-msm-v2.c:static u8 *i2c_msm_tag_byte(struct i2c_msm_tag *tag, int byte_n)
i2c/busses/i2c-msm-v2.c: * i2c_msm_buf_to_ptr: translates a xfer buf to a pointer into the i2c_msg data
i2c/busses/i2c-msm-v2.c:static u8 *i2c_msm_buf_to_ptr(struct i2c_msm_xfer_buf *buf)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer *xfer =
i2c/busses/i2c-msm-v2.c:				container_of(buf, struct i2c_msm_xfer, cur_buf);
i2c/busses/i2c-msm-v2.c:static const struct i2c_msm_tag tag_lookup_table[2][2][2] = {
i2c/busses/i2c-msm-v2.c: * i2c_msm_tag_create: format a qup tag ver2
i2c/busses/i2c-msm-v2.c:static struct i2c_msm_tag i2c_msm_tag_create(bool is_new_addr, bool is_last_buf,
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_tag tag;
i2c/busses/i2c-msm-v2.c:		*i2c_msm_tag_byte(&tag, 1) = slave_addr;
i2c/busses/i2c-msm-v2.c:		*i2c_msm_tag_byte(&tag, 3) = buf_len;
i2c/busses/i2c-msm-v2.c:		*i2c_msm_tag_byte(&tag, 1) = buf_len;
i2c/busses/i2c-msm-v2.c:i2c_msm_qup_state_wait_valid(struct i2c_msm_ctrl *ctrl,
i2c/busses/i2c-msm-v2.c:			enum i2c_msm_qup_state state, bool only_valid)
i2c/busses/i2c-msm-v2.c:		i2c_msm_prof_evnt_add(ctrl, MSM_DBG, I2C_MSM_VALID_END,
i2c/busses/i2c-msm-v2.c:static int i2c_msm_qup_state_set(struct i2c_msm_ctrl *ctrl,
i2c/busses/i2c-msm-v2.c:						enum i2c_msm_qup_state state)
i2c/busses/i2c-msm-v2.c:	if (i2c_msm_qup_state_wait_valid(ctrl, 0, true))
i2c/busses/i2c-msm-v2.c:	if (i2c_msm_qup_state_wait_valid(ctrl, state, false))
i2c/busses/i2c-msm-v2.c:static int i2c_msm_qup_sw_reset(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_state_wait_valid(ctrl, QUP_STATE_RESET, false);
i2c/busses/i2c-msm-v2.c: * i2c_msm_qup_xfer_init_reset_state: setup QUP registers for the next run state
i2c/busses/i2c-msm-v2.c:i2c_msm_qup_xfer_init_reset_state(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer *xfer = &ctrl->xfer;
i2c/busses/i2c-msm-v2.c:	u32  input_mode    = i2c_msm_mode_to_reg_tbl[xfer->mode_id] << 12;
i2c/busses/i2c-msm-v2.c:	u32  output_mode   = i2c_msm_mode_to_reg_tbl[xfer->mode_id] << 10;
i2c/busses/i2c-msm-v2.c: * i2c_msm_clk_div_fld:
i2c/busses/i2c-msm-v2.c:struct i2c_msm_clk_div_fld {
i2c/busses/i2c-msm-v2.c:static struct i2c_msm_clk_div_fld i2c_msm_clk_div_map[] = {
i2c/busses/i2c-msm-v2.c:static int i2c_msm_set_mstr_clk_ctl(struct i2c_msm_ctrl *ctrl, int fs_div,
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_clk_div_fld *itr = i2c_msm_clk_div_map;
i2c/busses/i2c-msm-v2.c:	for (i = 0; i < ARRAY_SIZE(i2c_msm_clk_div_map); ++i, ++itr) {
i2c/busses/i2c-msm-v2.c: * i2c_msm_qup_xfer_init_run_state: set qup regs which must be set *after* reset
i2c/busses/i2c-msm-v2.c:static void i2c_msm_qup_xfer_init_run_state(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:		i2c_msm_dbg_qup_reg_dump(ctrl);
i2c/busses/i2c-msm-v2.c:static void i2c_msm_fifo_wr_word(struct i2c_msm_ctrl *ctrl, u32 data)
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_DBG, "OUT-FIFO:0x%08x\n", data);
i2c/busses/i2c-msm-v2.c:static u32 i2c_msm_fifo_rd_word(struct i2c_msm_ctrl *ctrl, u32 *data)
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_DBG, "IN-FIFO :0x%08x\n", val);
i2c/busses/i2c-msm-v2.c: * i2c_msm_fifo_wr_buf_flush:
i2c/busses/i2c-msm-v2.c:static void i2c_msm_fifo_wr_buf_flush(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_fifo *fifo = &ctrl->xfer.fifo;
i2c/busses/i2c-msm-v2.c:	i2c_msm_fifo_wr_word(ctrl, *word);
i2c/busses/i2c-msm-v2.c: * i2c_msm_fifo_wr_buf:
i2c/busses/i2c-msm-v2.c:i2c_msm_fifo_wr_buf(struct i2c_msm_ctrl *ctrl, u8 *buf, size_t len)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_fifo *fifo = &ctrl->xfer.fifo;
i2c/busses/i2c-msm-v2.c:			i2c_msm_fifo_wr_word(ctrl, *word);
i2c/busses/i2c-msm-v2.c:static size_t i2c_msm_fifo_xfer_wr_tag(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_buf *buf = &ctrl->xfer.cur_buf;
i2c/busses/i2c-msm-v2.c:			i2c_msm_dbg_tag_to_str(&buf->out_tag, str,
i2c/busses/i2c-msm-v2.c:		len = i2c_msm_fifo_wr_buf(ctrl, (u8 *) &buf->out_tag.val,
i2c/busses/i2c-msm-v2.c:		buf->out_tag = (struct i2c_msm_tag) {0};
i2c/busses/i2c-msm-v2.c: * i2c_msm_fifo_read: reads up to fifo size into user's buf
i2c/busses/i2c-msm-v2.c:static void i2c_msm_fifo_read_xfer_buf(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_buf *buf = &ctrl->xfer.cur_buf;
i2c/busses/i2c-msm-v2.c:		i2c_msm_fifo_rd_word(ctrl, (u32 *) word);
i2c/busses/i2c-msm-v2.c:					i2c_msm_dbg_tag_to_str(&buf->in_tag,
i2c/busses/i2c-msm-v2.c: * i2c_msm_fifo_write_xfer_buf: write xfer.cur_buf (user's-buf + tag) to fifo
i2c/busses/i2c-msm-v2.c:static void i2c_msm_fifo_write_xfer_buf(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_buf *buf  = &ctrl->xfer.cur_buf;
i2c/busses/i2c-msm-v2.c:	len = i2c_msm_fifo_xfer_wr_tag(ctrl);
i2c/busses/i2c-msm-v2.c:			u8  *p      = i2c_msm_buf_to_ptr(buf);
i2c/busses/i2c-msm-v2.c:		len = i2c_msm_fifo_wr_buf(ctrl, i2c_msm_buf_to_ptr(buf),
i2c/busses/i2c-msm-v2.c: * i2c_msm_fifo_xfer_process:
i2c/busses/i2c-msm-v2.c:static int i2c_msm_fifo_xfer_process(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_buf first_buf = ctrl->xfer.cur_buf;
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_state_set(ctrl, QUP_STATE_PAUSE);
i2c/busses/i2c-msm-v2.c:	while (i2c_msm_xfer_next_buf(ctrl))
i2c/busses/i2c-msm-v2.c:		i2c_msm_fifo_write_xfer_buf(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_fifo_wr_buf_flush(ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_state_set(ctrl, QUP_STATE_RUN);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_xfer_wait_for_completion(ctrl, &ctrl->xfer.complete);
i2c/busses/i2c-msm-v2.c:	while (i2c_msm_xfer_next_buf(ctrl))
i2c/busses/i2c-msm-v2.c:		i2c_msm_fifo_read_xfer_buf(ctrl);
i2c/busses/i2c-msm-v2.c: * i2c_msm_fifo_xfer: process transfer using fifo mode
i2c/busses/i2c-msm-v2.c:static int i2c_msm_fifo_xfer(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_DBG, "Starting FIFO transfer\n");
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_state_set(ctrl, QUP_STATE_RESET);
i2c/busses/i2c-msm-v2.c:	i2c_msm_qup_xfer_init_reset_state(ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_state_set(ctrl, QUP_STATE_RUN);
i2c/busses/i2c-msm-v2.c:	i2c_msm_qup_xfer_init_run_state(ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_fifo_xfer_process(ctrl);
i2c/busses/i2c-msm-v2.c: * i2c_msm_blk_init_struct: Allocate memory and initialize blk structure
i2c/busses/i2c-msm-v2.c:static int i2c_msm_blk_init_struct(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
i2c/busses/i2c-msm-v2.c:	blk->in_blk_sz  = i2c_msm_reg_io_modes_in_blk_sz(reg_data),
i2c/busses/i2c-msm-v2.c:	blk->out_blk_sz = i2c_msm_reg_io_modes_out_blk_sz(reg_data),
i2c/busses/i2c-msm-v2.c: * i2c_msm_blk_wr_flush: flushes internal cached block to FIFO
i2c/busses/i2c-msm-v2.c:static int i2c_msm_blk_wr_flush(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_xfer_wait_for_completion(ctrl, &blk->wait_tx_blk);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_state_set(ctrl, QUP_STATE_PAUSE);
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_DBG, "OUT-BLK:%*phC\n", blk->tx_cache_idx,
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_state_set(ctrl, QUP_STATE_RUN);
i2c/busses/i2c-msm-v2.c: * i2c_msm_blk_wr_buf:
i2c/busses/i2c-msm-v2.c:i2c_msm_blk_wr_buf(struct i2c_msm_ctrl *ctrl, const u8 *buf, int len)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
i2c/busses/i2c-msm-v2.c:			ret = i2c_msm_blk_wr_flush(ctrl);
i2c/busses/i2c-msm-v2.c: * i2c_msm_blk_xfer_wr_tag: buffered writing the tag of current buf
i2c/busses/i2c-msm-v2.c:static int i2c_msm_blk_xfer_wr_tag(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_buf *buf = &ctrl->xfer.cur_buf;
i2c/busses/i2c-msm-v2.c:	len = i2c_msm_blk_wr_buf(ctrl, (u8 *) &buf->out_tag.val,
i2c/busses/i2c-msm-v2.c:	buf->out_tag = (struct i2c_msm_tag) {0};
i2c/busses/i2c-msm-v2.c: * i2c_msm_blk_wr_xfer_buf: writes ctrl->xfer.cur_buf to HW
i2c/busses/i2c-msm-v2.c:static int i2c_msm_blk_wr_xfer_buf(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_buf *buf  = &ctrl->xfer.cur_buf;
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_blk_xfer_wr_tag(ctrl);
i2c/busses/i2c-msm-v2.c:	len = i2c_msm_blk_wr_buf(ctrl, i2c_msm_buf_to_ptr(buf), buf->len);
i2c/busses/i2c-msm-v2.c: * i2c_msm_blk_rd_blk: read a block from HW FIFO to internal cache
i2c/busses/i2c-msm-v2.c:static int i2c_msm_blk_rd_blk(struct i2c_msm_ctrl *ctrl, int need_bc)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_xfer_wait_for_completion(ctrl, &blk->wait_rx_blk);
i2c/busses/i2c-msm-v2.c: * i2c_msm_blk_rd_xfer_buf: fill in ctrl->xfer.cur_buf from HW
i2c/busses/i2c-msm-v2.c:static int i2c_msm_blk_rd_xfer_buf(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_buf *buf      = &ctrl->xfer.cur_buf;
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_blk_xfer_wr_tag(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_blk_wr_flush(ctrl);
i2c/busses/i2c-msm-v2.c:		cache_avail_bc = i2c_msm_blk_rd_blk(ctrl,
i2c/busses/i2c-msm-v2.c:		i2c_msm_dbg(ctrl, MSM_DBG, "IN-BLK:%*phC\n", cache_avail_bc,
i2c/busses/i2c-msm-v2.c: * i2c_msm_blk_xfer: process transfer using block mode
i2c/busses/i2c-msm-v2.c:static int i2c_msm_blk_xfer(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_buf      *buf = &ctrl->xfer.cur_buf;
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
i2c/busses/i2c-msm-v2.c:		ret = i2c_msm_blk_init_struct(ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_state_set(ctrl, QUP_STATE_RESET);
i2c/busses/i2c-msm-v2.c:	i2c_msm_qup_xfer_init_reset_state(ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_state_set(ctrl, QUP_STATE_RUN);
i2c/busses/i2c-msm-v2.c:	i2c_msm_qup_xfer_init_run_state(ctrl);
i2c/busses/i2c-msm-v2.c:	while (i2c_msm_xfer_next_buf(ctrl)) {
i2c/busses/i2c-msm-v2.c:			ret = i2c_msm_blk_rd_xfer_buf(ctrl);
i2c/busses/i2c-msm-v2.c:				ret = i2c_msm_xfer_wait_for_completion(ctrl,
i2c/busses/i2c-msm-v2.c:			ret = i2c_msm_blk_wr_xfer_buf(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_blk_wr_flush(ctrl);
i2c/busses/i2c-msm-v2.c:	return i2c_msm_xfer_wait_for_completion(ctrl, &ctrl->xfer.complete);
i2c/busses/i2c-msm-v2.c: * i2c_msm_dma_xfer_prepare: map DMA buffers, and create tags.
i2c/busses/i2c-msm-v2.c:static int i2c_msm_dma_xfer_prepare(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_dma *dma  = &ctrl->xfer.dma;
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_buf      *buf  = &ctrl->xfer.cur_buf;
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_dma_chan      *tx = &dma->chan[I2C_MSM_DMA_TX];
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_dma_chan      *rx = &dma->chan[I2C_MSM_DMA_RX];
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_dma_buf *dma_buf;
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_dma_mem  data;
i2c/busses/i2c-msm-v2.c:	for (; i2c_msm_xfer_next_buf(ctrl) && rem_buf_cnt;
i2c/busses/i2c-msm-v2.c:		i2c_msm_dbg(ctrl, MSM_DBG,
i2c/busses/i2c-msm-v2.c:		 * by i2c_msm_xfer_next_buf()
i2c/busses/i2c-msm-v2.c:		*dma_buf = (struct i2c_msm_dma_buf) {
i2c/busses/i2c-msm-v2.c:			.tag      = (struct i2c_msm_dma_tag) {
i2c/busses/i2c-msm-v2.c: * i2c_msm_dma_xfer_unprepare: DAM unmap buffers.
i2c/busses/i2c-msm-v2.c:static void i2c_msm_dma_xfer_unprepare(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_dma_buf *buf_itr = ctrl->xfer.dma.buf_arr;
i2c/busses/i2c-msm-v2.c:static void i2c_msm_dma_callback_tx_complete(void *dma_async_param)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_ctrl *ctrl = dma_async_param;
i2c/busses/i2c-msm-v2.c:static void i2c_msm_dma_callback_rx_complete(void *dma_async_param)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_ctrl *ctrl = dma_async_param;
i2c/busses/i2c-msm-v2.c: * i2c_msm_dma_xfer_process: Queue transfers to DMA
i2c/busses/i2c-msm-v2.c: * @pre 1)QUP is in run state. 2) i2c_msm_dma_xfer_prepare() was called.
i2c/busses/i2c-msm-v2.c:static int i2c_msm_dma_xfer_process(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_dma *dma = &ctrl->xfer.dma;
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_dma_chan *tx       = &dma->chan[I2C_MSM_DMA_TX];
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_dma_chan *rx       = &dma->chan[I2C_MSM_DMA_RX];
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_dma_buf             *buf_itr;
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_DBG, "Going to enqueue %zu buffers in DMA\n",
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_state_set(ctrl, QUP_STATE_PAUSE);
i2c/busses/i2c-msm-v2.c:	dma_desc_tx->callback       = i2c_msm_dma_callback_tx_complete;
i2c/busses/i2c-msm-v2.c:	dma_desc_rx->callback       = i2c_msm_dma_callback_rx_complete;
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_state_set(ctrl, QUP_STATE_RUN);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_xfer_wait_for_completion(ctrl, &ctrl->xfer.complete);
i2c/busses/i2c-msm-v2.c:		ret = i2c_msm_xfer_wait_for_completion(ctrl,
i2c/busses/i2c-msm-v2.c:static void i2c_msm_dma_free_channels(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:		struct i2c_msm_dma_chan *chan = &ctrl->xfer.dma.chan[i];
i2c/busses/i2c-msm-v2.c:static const char * const i2c_msm_dma_chan_name[] = {"tx", "rx"};
i2c/busses/i2c-msm-v2.c:static int i2c_msm_dmaengine_dir[] = {
i2c/busses/i2c-msm-v2.c:static int i2c_msm_dma_init_channels(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:		struct i2c_msm_dma_chan *chan = &ctrl->xfer.dma.chan[i];
i2c/busses/i2c-msm-v2.c:		chan->name     = i2c_msm_dma_chan_name[i];
i2c/busses/i2c-msm-v2.c:			i2c_msm_dma_free_channels(ctrl);
i2c/busses/i2c-msm-v2.c:		chan->dir = cfg.direction = i2c_msm_dmaengine_dir[i];
i2c/busses/i2c-msm-v2.c:			i2c_msm_dma_free_channels(ctrl);
i2c/busses/i2c-msm-v2.c:static void i2c_msm_dma_teardown(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_dma *dma = &ctrl->xfer.dma;
i2c/busses/i2c-msm-v2.c:	i2c_msm_dma_free_channels(ctrl);
i2c/busses/i2c-msm-v2.c:static int i2c_msm_dma_init(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_dma *dma = &ctrl->xfer.dma;
i2c/busses/i2c-msm-v2.c:	return i2c_msm_dma_init_channels(ctrl);
i2c/busses/i2c-msm-v2.c:static int i2c_msm_dma_xfer(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_dma_init(ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_dma_xfer_prepare(ctrl);
i2c/busses/i2c-msm-v2.c:		dev_err(ctrl->dev, "error on i2c_msm_dma_xfer_prepare():%d\n",
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_state_set(ctrl, QUP_STATE_RESET);
i2c/busses/i2c-msm-v2.c:	i2c_msm_qup_xfer_init_reset_state(ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_state_set(ctrl, QUP_STATE_RUN);
i2c/busses/i2c-msm-v2.c:	i2c_msm_qup_xfer_init_run_state(ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_dma_xfer_process(ctrl);
i2c/busses/i2c-msm-v2.c:			"error i2c_msm_dma_xfer_process(n_bufs:%zu):%d\n",
i2c/busses/i2c-msm-v2.c:	i2c_msm_dma_xfer_unprepare(ctrl);
i2c/busses/i2c-msm-v2.c: * i2c_msm_qup_slv_holds_bus: true when slave hold the SDA low
i2c/busses/i2c-msm-v2.c:static bool i2c_msm_qup_slv_holds_bus(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c: * i2c_msm_qup_poll_bus_active_unset: poll until QUP_BUS_ACTIVE is unset
i2c/busses/i2c-msm-v2.c:static int i2c_msm_qup_poll_bus_active_unset(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	i2c_msm_prof_evnt_add(ctrl, MSM_DBG, I2C_MSM_ACTV_END,
i2c/busses/i2c-msm-v2.c:static void i2c_msm_clk_path_vote(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	i2c_msm_clk_path_init(ctrl);
i2c/busses/i2c-msm-v2.c:		msm_bus_scale_client_update_request(
i2c/busses/i2c-msm-v2.c:static void i2c_msm_clk_path_unvote(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:		msm_bus_scale_client_update_request(
i2c/busses/i2c-msm-v2.c:static void i2c_msm_clk_path_teardown(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:		msm_bus_scale_unregister_client(
i2c/busses/i2c-msm-v2.c: * i2c_msm_clk_path_init_structs: internal impl detail of i2c_msm_clk_path_init
i2c/busses/i2c-msm-v2.c:static int i2c_msm_clk_path_init_structs(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct msm_bus_vectors *paths    = NULL;
i2c/busses/i2c-msm-v2.c:	struct msm_bus_paths   *usecases = NULL;
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_PROF, "initializes path clock voting structs\n");
i2c/busses/i2c-msm-v2.c:	paths[I2C_MSM_CLK_PATH_SUSPEND_VEC] = (struct msm_bus_vectors) {
i2c/busses/i2c-msm-v2.c:	paths[I2C_MSM_CLK_PATH_RESUME_VEC]  = (struct msm_bus_vectors) {
i2c/busses/i2c-msm-v2.c:	usecases[I2C_MSM_CLK_PATH_SUSPEND_VEC] = (struct msm_bus_paths) {
i2c/busses/i2c-msm-v2.c:	usecases[I2C_MSM_CLK_PATH_RESUME_VEC] = (struct msm_bus_paths) {
i2c/busses/i2c-msm-v2.c:	*ctrl->rsrcs.clk_path_vote.pdata = (struct msm_bus_scale_pdata) {
i2c/busses/i2c-msm-v2.c: * i2c_msm_clk_path_postponed_register: reg with bus-scaling after it is probed
i2c/busses/i2c-msm-v2.c: * msm_bus_scale_register_client() will fail if the bus scaling driver is not
i2c/busses/i2c-msm-v2.c:static int i2c_msm_clk_path_postponed_register(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:		msm_bus_scale_register_client(ctrl->rsrcs.clk_path_vote.pdata);
i2c/busses/i2c-msm-v2.c:				"msm_bus_scale_register_client(mstr-id:%d):0x%x (ok)\n",
i2c/busses/i2c-msm-v2.c:				"msm_bus_scale_register_client(mstr-id:%d):0 (not a problem)\n",
i2c/busses/i2c-msm-v2.c:static void i2c_msm_clk_path_init(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:					i2c_msm_clk_path_init_structs(ctrl)) {
i2c/busses/i2c-msm-v2.c:	if (i2c_msm_clk_path_postponed_register(ctrl))
i2c/busses/i2c-msm-v2.c: * i2c_msm_qup_isr: QUP interrupt service routine
i2c/busses/i2c-msm-v2.c:static irqreturn_t i2c_msm_qup_isr(int irq, void *devid)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_ctrl *ctrl = devid;
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer *xfer = &ctrl->xfer;
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_blk *blk = &ctrl->xfer.blk;
i2c/busses/i2c-msm-v2.c:	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, I2C_MSM_IRQ_BGN, irq, 0, 0);
i2c/busses/i2c-msm-v2.c:		i2c_msm_dbg_qup_reg_dump(ctrl);
i2c/busses/i2c-msm-v2.c:		i2c_msm_prof_evnt_add(ctrl, MSM_PROF,
i2c/busses/i2c-msm-v2.c:static void i2x_msm_blk_free_cache(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:static void i2c_msm_qup_init(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, I2C_MSM_PROF_RESET, 0, 0, 0);
i2c/busses/i2c-msm-v2.c:	i2c_msm_qup_sw_reset(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_qup_state_set(ctrl, QUP_STATE_RESET);
i2c/busses/i2c-msm-v2.c:	i2c_msm_qup_fifo_calc_size(ctrl);
i2c/busses/i2c-msm-v2.c:static void qup_i2c_recover_bit_bang(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	bitbang = i2c_msm_rsrcs_gpio_get_state(ctrl, "i2c_bitbang");
i2c/busses/i2c-msm-v2.c:	i2c_msm_pm_pinctrl_state(ctrl, true);
i2c/busses/i2c-msm-v2.c:static int i2c_msm_qup_post_xfer(struct i2c_msm_ctrl *ctrl, int err)
i2c/busses/i2c-msm-v2.c:	if (i2c_msm_qup_poll_bus_active_unset(ctrl)) {
i2c/busses/i2c-msm-v2.c:			if (i2c_msm_qup_slv_holds_bus(ctrl))
i2c/busses/i2c-msm-v2.c:		i2c_msm_qup_state_set(ctrl, QUP_STATE_RESET);
i2c/busses/i2c-msm-v2.c:static enum i2c_msm_xfer_mode_id
i2c/busses/i2c-msm-v2.c:i2c_msm_qup_choose_mode(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_mode_fifo *fifo = &ctrl->xfer.fifo;
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer           *xfer = &ctrl->xfer;
i2c/busses/i2c-msm-v2.c: * i2c_msm_xfer_calc_timeout: calc maximum xfer time in jiffies
i2c/busses/i2c-msm-v2.c:static void i2c_msm_xfer_calc_timeout(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:static int i2c_msm_xfer_wait_for_completion(struct i2c_msm_ctrl *ctrl,
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer *xfer = &ctrl->xfer;
i2c/busses/i2c-msm-v2.c:		i2c_msm_dbg_dump_diag(ctrl, false, 0, 0);
i2c/busses/i2c-msm-v2.c:		i2c_msm_prof_evnt_add(ctrl, MSM_ERR, I2C_MSM_COMPLT_FL,
i2c/busses/i2c-msm-v2.c:			i2c_msm_dbg_dump_diag(ctrl, true,
i2c/busses/i2c-msm-v2.c:		i2c_msm_prof_evnt_add(ctrl, MSM_DBG, I2C_MSM_COMPLT_OK,
i2c/busses/i2c-msm-v2.c:static u16 i2c_msm_slv_rd_wr_addr(u16 slv_addr, bool is_rx)
i2c/busses/i2c-msm-v2.c:static bool i2c_msm_xfer_msg_is_last(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:static bool i2c_msm_xfer_buf_is_last(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_buf *cur_buf = &ctrl->xfer.cur_buf;
i2c/busses/i2c-msm-v2.c:	return i2c_msm_xfer_msg_is_last(ctrl) &&
i2c/busses/i2c-msm-v2.c:static void i2c_msm_xfer_create_cur_tag(struct i2c_msm_ctrl *ctrl,
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_buf *cur_buf = &ctrl->xfer.cur_buf;
i2c/busses/i2c-msm-v2.c:	cur_buf->out_tag = i2c_msm_tag_create(start_req, cur_buf->is_last,
i2c/busses/i2c-msm-v2.c: * i2c_msm_xfer_next_buf: support cases when msg.len > 256 bytes
i2c/busses/i2c-msm-v2.c:static bool i2c_msm_xfer_next_buf(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_buf *cur_buf = &ctrl->xfer.cur_buf;
i2c/busses/i2c-msm-v2.c:		cur_buf->is_last   = i2c_msm_xfer_buf_is_last(ctrl);
i2c/busses/i2c-msm-v2.c:		i2c_msm_xfer_create_cur_tag(ctrl, false);
i2c/busses/i2c-msm-v2.c:			if (i2c_msm_xfer_msg_is_last(ctrl))
i2c/busses/i2c-msm-v2.c:		cur_buf->is_last   = i2c_msm_xfer_buf_is_last(ctrl);
i2c/busses/i2c-msm-v2.c:		cur_buf->slv_addr  = i2c_msm_slv_rd_wr_addr(cur_msg->addr,
i2c/busses/i2c-msm-v2.c:		i2c_msm_xfer_create_cur_tag(ctrl, true);
i2c/busses/i2c-msm-v2.c:	i2c_msm_prof_evnt_add(ctrl, MSM_DBG, I2C_MSM_NEXT_BUF, cur_buf->msg_idx,
i2c/busses/i2c-msm-v2.c:static void i2c_msm_pm_clk_unprepare(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:static int i2c_msm_pm_clk_prepare(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:static void i2c_msm_pm_clk_disable(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:static int i2c_msm_pm_clk_enable(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:		i2c_msm_pm_clk_unprepare(ctrl);
i2c/busses/i2c-msm-v2.c:		i2c_msm_pm_clk_unprepare(ctrl);
i2c/busses/i2c-msm-v2.c:static int i2c_msm_pm_xfer_start(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	i2c_msm_pm_pinctrl_state(ctrl, true);
i2c/busses/i2c-msm-v2.c:		i2c_msm_pm_resume(ctrl->dev);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_pm_clk_enable(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_qup_init(ctrl);
i2c/busses/i2c-msm-v2.c:static void i2c_msm_pm_xfer_end(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:		i2c_msm_dma_free_channels(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_pm_clk_disable(ctrl);
i2c/busses/i2c-msm-v2.c:		i2c_msm_pm_suspend(ctrl->dev);
i2c/busses/i2c-msm-v2.c:	i2c_msm_pm_pinctrl_state(ctrl, false);
i2c/busses/i2c-msm-v2.c: * i2c_msm_xfer_scan: initial input scan
i2c/busses/i2c-msm-v2.c:static void i2c_msm_xfer_scan(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer     *xfer      = &ctrl->xfer;
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer_buf *cur_buf   = &xfer->cur_buf;
i2c/busses/i2c-msm-v2.c:	while (i2c_msm_xfer_next_buf(ctrl)) {
i2c/busses/i2c-msm-v2.c:		if (i2c_msm_xfer_msg_is_last(ctrl))
i2c/busses/i2c-msm-v2.c:	xfer->cur_buf = (struct i2c_msm_xfer_buf){0};
i2c/busses/i2c-msm-v2.c:i2c_msm_frmwrk_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_ctrl      *ctrl = i2c_get_adapdata(adap);
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_xfer      *xfer = &ctrl->xfer;
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_pm_xfer_start(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, I2C_MSM_XFER_BEG, num,
i2c/busses/i2c-msm-v2.c:	i2c_msm_xfer_scan(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_xfer_calc_timeout(ctrl);
i2c/busses/i2c-msm-v2.c:	xfer->mode_id = i2c_msm_qup_choose_mode(ctrl);
i2c/busses/i2c-msm-v2.c:		ret = i2c_msm_fifo_xfer(ctrl);
i2c/busses/i2c-msm-v2.c:		ret = i2c_msm_blk_xfer(ctrl);
i2c/busses/i2c-msm-v2.c:		ret = i2c_msm_dma_xfer(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, I2C_MSM_SCAN_SUM,
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_post_xfer(ctrl, ret);
i2c/busses/i2c-msm-v2.c:	i2c_msm_prof_evnt_add(ctrl, MSM_PROF, I2C_MSM_XFER_END, ret, xfer->err,
i2c/busses/i2c-msm-v2.c:		i2c_msm_prof_evnt_dump(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_pm_xfer_end(ctrl);
i2c/busses/i2c-msm-v2.c:enum i2c_msm_dt_entry_status {
i2c/busses/i2c-msm-v2.c:enum i2c_msm_dt_entry_type {
i2c/busses/i2c-msm-v2.c:struct i2c_msm_dt_to_pdata_map {
i2c/busses/i2c-msm-v2.c:	enum i2c_msm_dt_entry_status status;
i2c/busses/i2c-msm-v2.c:	enum i2c_msm_dt_entry_type   type;
i2c/busses/i2c-msm-v2.c:static int i2c_msm_dt_to_pdata_populate(struct i2c_msm_ctrl *ctrl,
i2c/busses/i2c-msm-v2.c:					struct i2c_msm_dt_to_pdata_map *itr)
i2c/busses/i2c-msm-v2.c:		i2c_msm_dbg(ctrl, MSM_PROF, "DT entry ret:%d name:%s val:%d\n",
i2c/busses/i2c-msm-v2.c: * i2c_msm_rsrcs_process_dt: copy data from DT to platform data
i2c/busses/i2c-msm-v2.c:static int i2c_msm_rsrcs_process_dt(struct i2c_msm_ctrl *ctrl,
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_dt_to_pdata_map map[] = {
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_dt_to_pdata_populate(ctrl, pdev, map);
i2c/busses/i2c-msm-v2.c:	return i2c_msm_set_mstr_clk_ctl(ctrl, fs_clk_div, ht_clk_div,
i2c/busses/i2c-msm-v2.c: * i2c_msm_rsrcs_mem_init: reads pdata request region and ioremap it
i2c/busses/i2c-msm-v2.c:static int i2c_msm_rsrcs_mem_init(struct platform_device *pdev,
i2c/busses/i2c-msm-v2.c:						struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:static void i2c_msm_rsrcs_mem_teardown(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c: * i2c_msm_rsrcs_irq_init: finds irq num in pdata and requests it
i2c/busses/i2c-msm-v2.c:static int i2c_msm_rsrcs_irq_init(struct platform_device *pdev,
i2c/busses/i2c-msm-v2.c:						struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	ret = request_irq(irq, i2c_msm_qup_isr, IRQF_TRIGGER_HIGH,
i2c/busses/i2c-msm-v2.c:						"i2c-msm-v2-irq", ctrl);
i2c/busses/i2c-msm-v2.c:static void i2c_msm_rsrcs_irq_teardown(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:i2c_msm_rsrcs_gpio_get_state(struct i2c_msm_ctrl *ctrl, const char *name)
i2c/busses/i2c-msm-v2.c: * i2c_msm_rsrcs_gpio_pinctrl_init: initializes the pinctrl for i2c gpios
i2c/busses/i2c-msm-v2.c:static int i2c_msm_rsrcs_gpio_pinctrl_init(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:		i2c_msm_rsrcs_gpio_get_state(ctrl, I2C_MSM_PINCTRL_ACTIVE);
i2c/busses/i2c-msm-v2.c:		i2c_msm_rsrcs_gpio_get_state(ctrl, I2C_MSM_PINCTRL_SUSPEND);
i2c/busses/i2c-msm-v2.c:static void i2c_msm_pm_pinctrl_state(struct i2c_msm_ctrl *ctrl,
i2c/busses/i2c-msm-v2.c: * i2c_msm_rsrcs_clk_init: get clocks and set rate
i2c/busses/i2c-msm-v2.c:static int i2c_msm_rsrcs_clk_init(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:static void i2c_msm_rsrcs_clk_teardown(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	i2c_msm_clk_path_teardown(ctrl);
i2c/busses/i2c-msm-v2.c:static void i2c_msm_pm_suspend(struct device *dev)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_ctrl *ctrl = dev_get_drvdata(dev);
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_DBG, "suspending...\n");
i2c/busses/i2c-msm-v2.c:	i2c_msm_pm_clk_unprepare(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_clk_path_unvote(ctrl);
i2c/busses/i2c-msm-v2.c:static int i2c_msm_pm_resume(struct device *dev)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_ctrl *ctrl = dev_get_drvdata(dev);
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_DBG, "resuming...\n");
i2c/busses/i2c-msm-v2.c:	i2c_msm_clk_path_vote(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_pm_clk_prepare(ctrl);
i2c/busses/i2c-msm-v2.c: * i2c_msm_pm_sys_suspend_noirq: system power management callback
i2c/busses/i2c-msm-v2.c:static int i2c_msm_pm_sys_suspend_noirq(struct device *dev)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_ctrl *ctrl = dev_get_drvdata(dev);
i2c/busses/i2c-msm-v2.c:	enum i2c_msm_power_state prev_state = ctrl->pwr_state;
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_DBG, "pm_sys_noirq: suspending...\n");
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_DBG, "pm_sys_noirq: suspending...\n");
i2c/busses/i2c-msm-v2.c:		i2c_msm_pm_suspend(dev);
i2c/busses/i2c-msm-v2.c: * i2c_msm_pm_sys_resume: system power management callback
i2c/busses/i2c-msm-v2.c:static int i2c_msm_pm_sys_resume_noirq(struct device *dev)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_ctrl *ctrl = dev_get_drvdata(dev);
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_DBG, "pm_sys_noirq: resuming...\n");
i2c/busses/i2c-msm-v2.c:static void i2c_msm_pm_rt_init(struct device *dev)
i2c/busses/i2c-msm-v2.c: * i2c_msm_pm_rt_suspend: runtime power management callback
i2c/busses/i2c-msm-v2.c:static int i2c_msm_pm_rt_suspend(struct device *dev)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_ctrl *ctrl = dev_get_drvdata(dev);
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_DBG, "pm_runtime: suspending...\n");
i2c/busses/i2c-msm-v2.c:	i2c_msm_pm_suspend(dev);
i2c/busses/i2c-msm-v2.c: * i2c_msm_pm_rt_resume: runtime power management callback
i2c/busses/i2c-msm-v2.c:static int i2c_msm_pm_rt_resume(struct device *dev)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_ctrl *ctrl = dev_get_drvdata(dev);
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_DBG, "pm_runtime: resuming...\n");
i2c/busses/i2c-msm-v2.c:	return  i2c_msm_pm_resume(dev);
i2c/busses/i2c-msm-v2.c:static void i2c_msm_pm_rt_init(struct device *dev) {}
i2c/busses/i2c-msm-v2.c:#define i2c_msm_pm_rt_suspend NULL
i2c/busses/i2c-msm-v2.c:#define i2c_msm_pm_rt_resume NULL
i2c/busses/i2c-msm-v2.c:static const struct dev_pm_ops i2c_msm_pm_ops = {
i2c/busses/i2c-msm-v2.c:	.suspend_noirq		= i2c_msm_pm_sys_suspend_noirq,
i2c/busses/i2c-msm-v2.c:	.resume_noirq		= i2c_msm_pm_sys_resume_noirq,
i2c/busses/i2c-msm-v2.c:	SET_RUNTIME_PM_OPS(i2c_msm_pm_rt_suspend,
i2c/busses/i2c-msm-v2.c:			   i2c_msm_pm_rt_resume,
i2c/busses/i2c-msm-v2.c:static u32 i2c_msm_frmwrk_func(struct i2c_adapter *adap)
i2c/busses/i2c-msm-v2.c:static const struct i2c_algorithm i2c_msm_frmwrk_algrtm = {
i2c/busses/i2c-msm-v2.c:	.master_xfer	= i2c_msm_frmwrk_xfer,
i2c/busses/i2c-msm-v2.c:	.functionality	= i2c_msm_frmwrk_func,
i2c/busses/i2c-msm-v2.c:static const char * const i2c_msm_adapter_name = "MSM-I2C-v2-adapter";
i2c/busses/i2c-msm-v2.c:static int i2c_msm_frmwrk_reg(struct platform_device *pdev,
i2c/busses/i2c-msm-v2.c:						struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:	ctrl->adapter.algo = &i2c_msm_frmwrk_algrtm;
i2c/busses/i2c-msm-v2.c:	strlcpy(ctrl->adapter.name, i2c_msm_adapter_name,
i2c/busses/i2c-msm-v2.c:static void i2c_msm_frmwrk_unreg(struct i2c_msm_ctrl *ctrl)
i2c/busses/i2c-msm-v2.c:static int i2c_msm_probe(struct platform_device *pdev)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_ctrl *ctrl;
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_rsrcs_process_dt(ctrl, pdev);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_rsrcs_mem_init(pdev, ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_rsrcs_clk_init(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_clk_path_vote(ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_pm_clk_prepare(ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_pm_clk_enable(ctrl);
i2c/busses/i2c-msm-v2.c:		i2c_msm_pm_clk_unprepare(ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_qup_sw_reset(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_pm_clk_disable(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_pm_clk_unprepare(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_clk_path_unvote(ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_rsrcs_gpio_pinctrl_init(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_pm_rt_init(ctrl->dev);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_rsrcs_irq_init(pdev, ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbgfs_init(ctrl);
i2c/busses/i2c-msm-v2.c:	ret = i2c_msm_frmwrk_reg(pdev, ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbg(ctrl, MSM_PROF, "probe() completed with success\n");
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbgfs_teardown(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_rsrcs_irq_teardown(ctrl);
i2c/busses/i2c-msm-v2.c:	i2x_msm_blk_free_cache(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_rsrcs_clk_teardown(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_rsrcs_mem_teardown(ctrl);
i2c/busses/i2c-msm-v2.c:static int i2c_msm_remove(struct platform_device *pdev)
i2c/busses/i2c-msm-v2.c:	struct i2c_msm_ctrl *ctrl = platform_get_drvdata(pdev);
i2c/busses/i2c-msm-v2.c:	i2c_msm_frmwrk_unreg(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_dma_teardown(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_dbgfs_teardown(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_rsrcs_irq_teardown(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_rsrcs_clk_teardown(ctrl);
i2c/busses/i2c-msm-v2.c:	i2c_msm_rsrcs_mem_teardown(ctrl);
i2c/busses/i2c-msm-v2.c:	i2x_msm_blk_free_cache(ctrl);
i2c/busses/i2c-msm-v2.c:static const struct of_device_id i2c_msm_dt_match[] = {
i2c/busses/i2c-msm-v2.c:		.compatible = "qcom,i2c-msm-v2",
i2c/busses/i2c-msm-v2.c:static struct platform_driver i2c_msm_driver = {
i2c/busses/i2c-msm-v2.c:	.probe  = i2c_msm_probe,
i2c/busses/i2c-msm-v2.c:	.remove = i2c_msm_remove,
i2c/busses/i2c-msm-v2.c:		.name           = "i2c-msm-v2",
i2c/busses/i2c-msm-v2.c:		.pm             = &i2c_msm_pm_ops,
i2c/busses/i2c-msm-v2.c:		.of_match_table = i2c_msm_dt_match,
i2c/busses/i2c-msm-v2.c:static int i2c_msm_init(void)
i2c/busses/i2c-msm-v2.c:	return platform_driver_register(&i2c_msm_driver);
i2c/busses/i2c-msm-v2.c:subsys_initcall(i2c_msm_init);
i2c/busses/i2c-msm-v2.c:static void i2c_msm_exit(void)
i2c/busses/i2c-msm-v2.c:	platform_driver_unregister(&i2c_msm_driver);
i2c/busses/i2c-msm-v2.c:module_exit(i2c_msm_exit);
i2c/busses/i2c-msm-v2.c:MODULE_ALIAS("platform:i2c-msm-v2");
i3c/master/i3c-master-qcom-geni.c:	msm_qup_write(gi3c->ibi.ctrl_id, TLMM_I3C_MODE);
iio/adc/qcom-pm8xxx-xoadc.c: * Taken from arch/arm/mach-msm/board-9615.c in the vendor tree:
iio/adc/qcom-pm8xxx-xoadc.c: * Taken from arch/arm/mach-msm/board-8930-pmic.c in the vendor tree:
iio/adc/qcom-pm8xxx-xoadc.c: * arch/arm/mach-msm/board-msm8x60.c msm_adc_channels_data[]
input/fingerprint/fpc_tee/fpc1020_tee_old.c:	if (msm_gpio_mpm_wake_set(121, true)) {
iommu/Makefile:obj-$(CONFIG_QCOM_LAZY_MAPPING) += msm_dma_iommu_mapping.o
iommu/Makefile:obj-$(CONFIG_MSM_TZ_SMMU) += io-pgtable-msm-secure.o
iommu/Makefile:obj-$(CONFIG_MSM_IOMMU) += msm_iommu.o
iommu/arm-smmu.c:#include <linux/msm-bus.h>
iommu/arm-smmu.c:#include <dt-bindings/msm/msm-bus-ids.h>
iommu/arm-smmu.c:#include <soc/qcom/msm_tz_smmu.h>
iommu/arm-smmu.c:	struct msm_bus_scale_pdata	*bus_dt_data;
iommu/arm-smmu.c:static int msm_secure_smmu_map(struct iommu_domain *domain, unsigned long iova,
iommu/arm-smmu.c:static size_t msm_secure_smmu_unmap(struct iommu_domain *domain,
iommu/arm-smmu.c:static size_t msm_secure_smmu_map_sg(struct iommu_domain *domain,
iommu/arm-smmu.c:	return msm_bus_scale_client_update_request(pwr->bus_client, 1);
iommu/arm-smmu.c:	WARN_ON(msm_bus_scale_client_update_request(pwr->bus_client, 0));
iommu/arm-smmu.c:static void msm_smmu_tlb_inv_context(void *cookie)
iommu/arm-smmu.c:static void msm_smmu_tlb_inv_range_nosync(unsigned long iova, size_t size,
iommu/arm-smmu.c:static void msm_smmu_tlb_sync(void *cookie)
iommu/arm-smmu.c:static struct iommu_gather_ops msm_smmu_gather_ops = {
iommu/arm-smmu.c:	.tlb_flush_all	= msm_smmu_tlb_inv_context,
iommu/arm-smmu.c:	.tlb_add_flush	= msm_smmu_tlb_inv_range_nosync,
iommu/arm-smmu.c:	.tlb_sync	= msm_smmu_tlb_sync,
iommu/arm-smmu.c:		ret = msm_tz_set_cb_format(smmu->sec_id, cfg->cbndx);
iommu/arm-smmu.c:		smmu_domain->tlb_ops = &msm_smmu_gather_ops;
iommu/arm-smmu.c:			.arm_msm_secure_cfg = {
iommu/arm-smmu.c:		return msm_secure_smmu_map(domain, iova, paddr, size, prot);
iommu/arm-smmu.c:		return msm_secure_smmu_unmap(domain, iova, size);
iommu/arm-smmu.c:		return msm_secure_smmu_map_sg(domain, iova, sg, nents, prot);
iommu/arm-smmu.c:static int msm_secure_smmu_map(struct iommu_domain *domain, unsigned long iova,
iommu/arm-smmu.c:static size_t msm_secure_smmu_unmap(struct iommu_domain *domain,
iommu/arm-smmu.c:static size_t msm_secure_smmu_map_sg(struct iommu_domain *domain,
iommu/arm-smmu.c:		msm_secure_smmu_unmap(domain, iova, size);
iommu/arm-smmu.c:	if (!of_find_property(dev->of_node, "qcom,msm-bus,name", NULL)) {
iommu/arm-smmu.c:	pwr->bus_dt_data = msm_bus_cl_get_pdata(pwr->pdev);
iommu/arm-smmu.c:	pwr->bus_client = msm_bus_scale_register_client(pwr->bus_dt_data);
iommu/arm-smmu.c:	msm_bus_scale_unregister_client(pwr->bus_client);
iommu/arm-smmu.c:	return msm_iommu_sec_pgtbl_init();
iommu/arm-smmu.c:	smmu->sec_id = msm_dev_to_device_id(dev);
iommu/io-pgtable-msm-secure.c:#define pr_fmt(fmt)	"io-pgtable-msm-secure: " fmt
iommu/io-pgtable-msm-secure.c:	container_of((x), struct msm_secure_io_pgtable, iop)
iommu/io-pgtable-msm-secure.c:struct msm_secure_io_pgtable {
iommu/io-pgtable-msm-secure.c:int msm_iommu_sec_pgtbl_init(void)
iommu/io-pgtable-msm-secure.c:EXPORT_SYMBOL(msm_iommu_sec_pgtbl_init);
iommu/io-pgtable-msm-secure.c:static int msm_secure_map(struct io_pgtable_ops *ops, unsigned long iova,
iommu/io-pgtable-msm-secure.c:	struct msm_secure_io_pgtable *data = io_pgtable_ops_to_data(ops);
iommu/io-pgtable-msm-secure.c:	desc.args[3] = cfg->arm_msm_secure_cfg.sec_id;
iommu/io-pgtable-msm-secure.c:	desc.args[4] = cfg->arm_msm_secure_cfg.cbndx;
iommu/io-pgtable-msm-secure.c:static dma_addr_t msm_secure_get_phys_addr(struct scatterlist *sg)
iommu/io-pgtable-msm-secure.c:static int msm_secure_map_sg(struct io_pgtable_ops *ops, unsigned long iova,
iommu/io-pgtable-msm-secure.c:	struct msm_secure_io_pgtable *data = io_pgtable_ops_to_data(ops);
iommu/io-pgtable-msm-secure.c:		pa = msm_secure_get_phys_addr(sg);
iommu/io-pgtable-msm-secure.c:		pa = msm_secure_get_phys_addr(sgiter);
iommu/io-pgtable-msm-secure.c:				pa = msm_secure_get_phys_addr(sgiter);
iommu/io-pgtable-msm-secure.c:	desc.args[3] = cfg->arm_msm_secure_cfg.sec_id;
iommu/io-pgtable-msm-secure.c:	desc.args[4] = cfg->arm_msm_secure_cfg.cbndx;
iommu/io-pgtable-msm-secure.c:static size_t msm_secure_unmap(struct io_pgtable_ops *ops, unsigned long iova,
iommu/io-pgtable-msm-secure.c:	struct msm_secure_io_pgtable *data = io_pgtable_ops_to_data(ops);
iommu/io-pgtable-msm-secure.c:	desc.args[0] = cfg->arm_msm_secure_cfg.sec_id;
iommu/io-pgtable-msm-secure.c:	desc.args[1] = cfg->arm_msm_secure_cfg.cbndx;
iommu/io-pgtable-msm-secure.c:static phys_addr_t msm_secure_iova_to_phys(struct io_pgtable_ops *ops,
iommu/io-pgtable-msm-secure.c:static struct msm_secure_io_pgtable *
iommu/io-pgtable-msm-secure.c:msm_secure_alloc_pgtable_data(struct io_pgtable_cfg *cfg)
iommu/io-pgtable-msm-secure.c:	struct msm_secure_io_pgtable *data;
iommu/io-pgtable-msm-secure.c:		.map		= msm_secure_map,
iommu/io-pgtable-msm-secure.c:		.map_sg		= msm_secure_map_sg,
iommu/io-pgtable-msm-secure.c:		.unmap		= msm_secure_unmap,
iommu/io-pgtable-msm-secure.c:		.iova_to_phys	= msm_secure_iova_to_phys,
iommu/io-pgtable-msm-secure.c:msm_secure_alloc_pgtable(struct io_pgtable_cfg *cfg, void *cookie)
iommu/io-pgtable-msm-secure.c:	struct msm_secure_io_pgtable *data =
iommu/io-pgtable-msm-secure.c:		msm_secure_alloc_pgtable_data(cfg);
iommu/io-pgtable-msm-secure.c:static void msm_secure_free_pgtable(struct io_pgtable *iop)
iommu/io-pgtable-msm-secure.c:	struct msm_secure_io_pgtable *data = io_pgtable_to_data(iop);
iommu/io-pgtable-msm-secure.c:struct io_pgtable_init_fns io_pgtable_arm_msm_secure_init_fns = {
iommu/io-pgtable-msm-secure.c:	.alloc	= msm_secure_alloc_pgtable,
iommu/io-pgtable-msm-secure.c:	.free	= msm_secure_free_pgtable,
iommu/io-pgtable.c:	[ARM_MSM_SECURE] = &io_pgtable_arm_msm_secure_init_fns,
iommu/iommu.c:#include <soc/qcom/msm_tz_smmu.h>
iommu/msm_dma_iommu_mapping.c:#include <linux/msm_dma_iommu_mapping.h>
iommu/msm_dma_iommu_mapping.c:struct msm_iommu_map {
iommu/msm_dma_iommu_mapping.c:	struct msm_iommu_data *data;
iommu/msm_dma_iommu_mapping.c:static struct msm_iommu_map *msm_iommu_map_lookup(struct msm_iommu_data *data,
iommu/msm_dma_iommu_mapping.c:	struct msm_iommu_map *map;
iommu/msm_dma_iommu_mapping.c:static void msm_iommu_map_free(struct msm_iommu_map *map)
iommu/msm_dma_iommu_mapping.c:int msm_dma_map_sg_attrs(struct device *dev, struct scatterlist *sgl, int nents,
iommu/msm_dma_iommu_mapping.c:	struct msm_iommu_data *data = dmabuf->priv;
iommu/msm_dma_iommu_mapping.c:	struct msm_iommu_map *map;
iommu/msm_dma_iommu_mapping.c:	map = msm_iommu_map_lookup(data, dev);
iommu/msm_dma_iommu_mapping.c:void msm_dma_unmap_sg_attrs(struct device *dev, struct scatterlist *sgl,
iommu/msm_dma_iommu_mapping.c:	struct msm_iommu_data *data = dmabuf->priv;
iommu/msm_dma_iommu_mapping.c:	struct msm_iommu_map *map;
iommu/msm_dma_iommu_mapping.c:	map = msm_iommu_map_lookup(data, dev);
iommu/msm_dma_iommu_mapping.c:		msm_iommu_map_free(map);
iommu/msm_dma_iommu_mapping.c:void msm_dma_unmap_all_for_dev(struct device *dev)
iommu/msm_dma_iommu_mapping.c:	struct msm_iommu_map *map, *tmp;
iommu/msm_dma_iommu_mapping.c:		struct msm_iommu_data *data = map->data;
iommu/msm_dma_iommu_mapping.c:		msm_iommu_map_free(map);
iommu/msm_dma_iommu_mapping.c:void msm_dma_buf_freed(struct msm_iommu_data *data)
iommu/msm_dma_iommu_mapping.c:	struct msm_iommu_map *map, *tmp;
iommu/msm_dma_iommu_mapping.c:			msm_iommu_map_free(map);
iommu/msm_iommu.c:#include "msm_iommu_hw-8xxx.h"
iommu/msm_iommu.c:#include "msm_iommu.h"
iommu/msm_iommu.c:DEFINE_SPINLOCK(msm_iommu_lock);
iommu/msm_iommu.c:static struct iommu_ops msm_iommu_ops;
iommu/msm_iommu.c:struct msm_priv {
iommu/msm_iommu.c:static struct msm_priv *to_msm_priv(struct iommu_domain *dom)
iommu/msm_iommu.c:	return container_of(dom, struct msm_priv, domain);
iommu/msm_iommu.c:static int __enable_clocks(struct msm_iommu_dev *iommu)
iommu/msm_iommu.c:static void __disable_clocks(struct msm_iommu_dev *iommu)
iommu/msm_iommu.c:static void msm_iommu_reset(void __iomem *base, int ncb)
iommu/msm_iommu.c:	struct msm_priv *priv = cookie;
iommu/msm_iommu.c:	struct msm_iommu_dev *iommu = NULL;
iommu/msm_iommu.c:	struct msm_iommu_ctx_dev *master;
iommu/msm_iommu.c:	struct msm_priv *priv = cookie;
iommu/msm_iommu.c:	struct msm_iommu_dev *iommu = NULL;
iommu/msm_iommu.c:	struct msm_iommu_ctx_dev *master;
iommu/msm_iommu.c:static const struct iommu_gather_ops msm_iommu_gather_ops = {
iommu/msm_iommu.c:static int msm_iommu_alloc_ctx(unsigned long *map, int start, int end)
iommu/msm_iommu.c:static void msm_iommu_free_ctx(unsigned long *map, int idx)
iommu/msm_iommu.c:static void config_mids(struct msm_iommu_dev *iommu,
iommu/msm_iommu.c:			struct msm_iommu_ctx_dev *master)
iommu/msm_iommu.c:			      struct msm_priv *priv)
iommu/msm_iommu.c:static struct iommu_domain *msm_iommu_domain_alloc(unsigned type)
iommu/msm_iommu.c:	struct msm_priv *priv;
iommu/msm_iommu.c:static void msm_iommu_domain_free(struct iommu_domain *domain)
iommu/msm_iommu.c:	struct msm_priv *priv;
iommu/msm_iommu.c:	spin_lock_irqsave(&msm_iommu_lock, flags);
iommu/msm_iommu.c:	priv = to_msm_priv(domain);
iommu/msm_iommu.c:	spin_unlock_irqrestore(&msm_iommu_lock, flags);
iommu/msm_iommu.c:static int msm_iommu_domain_config(struct msm_priv *priv)
iommu/msm_iommu.c:		.pgsize_bitmap = msm_iommu_ops.pgsize_bitmap,
iommu/msm_iommu.c:		.tlb = &msm_iommu_gather_ops,
iommu/msm_iommu.c:	msm_iommu_ops.pgsize_bitmap = priv->cfg.pgsize_bitmap;
iommu/msm_iommu.c:/* Must be called under msm_iommu_lock */
iommu/msm_iommu.c:static struct msm_iommu_dev *find_iommu_for_dev(struct device *dev)
iommu/msm_iommu.c:	struct msm_iommu_dev *iommu, *ret = NULL;
iommu/msm_iommu.c:	struct msm_iommu_ctx_dev *master;
iommu/msm_iommu.c:					  struct msm_iommu_ctx_dev,
iommu/msm_iommu.c:static int msm_iommu_add_device(struct device *dev)
iommu/msm_iommu.c:	struct msm_iommu_dev *iommu;
iommu/msm_iommu.c:	spin_lock_irqsave(&msm_iommu_lock, flags);
iommu/msm_iommu.c:	spin_unlock_irqrestore(&msm_iommu_lock, flags);
iommu/msm_iommu.c:static void msm_iommu_remove_device(struct device *dev)
iommu/msm_iommu.c:	struct msm_iommu_dev *iommu;
iommu/msm_iommu.c:	spin_lock_irqsave(&msm_iommu_lock, flags);
iommu/msm_iommu.c:	spin_unlock_irqrestore(&msm_iommu_lock, flags);
iommu/msm_iommu.c:static int msm_iommu_attach_dev(struct iommu_domain *domain, struct device *dev)
iommu/msm_iommu.c:	struct msm_iommu_dev *iommu;
iommu/msm_iommu.c:	struct msm_priv *priv = to_msm_priv(domain);
iommu/msm_iommu.c:	struct msm_iommu_ctx_dev *master;
iommu/msm_iommu.c:	msm_iommu_domain_config(priv);
iommu/msm_iommu.c:	spin_lock_irqsave(&msm_iommu_lock, flags);
iommu/msm_iommu.c:					  struct msm_iommu_ctx_dev,
iommu/msm_iommu.c:					msm_iommu_alloc_ctx(iommu->context_map,
iommu/msm_iommu.c:	spin_unlock_irqrestore(&msm_iommu_lock, flags);
iommu/msm_iommu.c:static void msm_iommu_detach_dev(struct iommu_domain *domain,
iommu/msm_iommu.c:	struct msm_priv *priv = to_msm_priv(domain);
iommu/msm_iommu.c:	struct msm_iommu_dev *iommu;
iommu/msm_iommu.c:	struct msm_iommu_ctx_dev *master;
iommu/msm_iommu.c:	spin_lock_irqsave(&msm_iommu_lock, flags);
iommu/msm_iommu.c:			msm_iommu_free_ctx(iommu->context_map, master->num);
iommu/msm_iommu.c:	spin_unlock_irqrestore(&msm_iommu_lock, flags);
iommu/msm_iommu.c:static int msm_iommu_map(struct iommu_domain *domain, unsigned long iova,
iommu/msm_iommu.c:	struct msm_priv *priv = to_msm_priv(domain);
iommu/msm_iommu.c:static size_t msm_iommu_unmap(struct iommu_domain *domain, unsigned long iova,
iommu/msm_iommu.c:	struct msm_priv *priv = to_msm_priv(domain);
iommu/msm_iommu.c:static phys_addr_t msm_iommu_iova_to_phys(struct iommu_domain *domain,
iommu/msm_iommu.c:	struct msm_priv *priv;
iommu/msm_iommu.c:	struct msm_iommu_dev *iommu;
iommu/msm_iommu.c:	struct msm_iommu_ctx_dev *master;
iommu/msm_iommu.c:	spin_lock_irqsave(&msm_iommu_lock, flags);
iommu/msm_iommu.c:	priv = to_msm_priv(domain);
iommu/msm_iommu.c:				 struct msm_iommu_dev, dom_node);
iommu/msm_iommu.c:				  struct msm_iommu_ctx_dev, list);
iommu/msm_iommu.c:	spin_unlock_irqrestore(&msm_iommu_lock, flags);
iommu/msm_iommu.c:static bool msm_iommu_capable(enum iommu_cap cap)
iommu/msm_iommu.c:				struct msm_iommu_dev **iommu,
iommu/msm_iommu.c:	struct msm_iommu_ctx_dev *master = dev->archdata.iommu;
iommu/msm_iommu.c:	struct msm_iommu_dev *iommu = NULL, *iter;
iommu/msm_iommu.c:	spin_lock_irqsave(&msm_iommu_lock, flags);
iommu/msm_iommu.c:	spin_unlock_irqrestore(&msm_iommu_lock, flags);
iommu/msm_iommu.c:irqreturn_t msm_iommu_fault_handler(int irq, void *dev_id)
iommu/msm_iommu.c:	struct msm_iommu_dev *iommu = dev_id;
iommu/msm_iommu.c:	spin_lock(&msm_iommu_lock);
iommu/msm_iommu.c:	spin_unlock(&msm_iommu_lock);
iommu/msm_iommu.c:static struct iommu_ops msm_iommu_ops = {
iommu/msm_iommu.c:	.capable = msm_iommu_capable,
iommu/msm_iommu.c:	.domain_alloc = msm_iommu_domain_alloc,
iommu/msm_iommu.c:	.domain_free = msm_iommu_domain_free,
iommu/msm_iommu.c:	.attach_dev = msm_iommu_attach_dev,
iommu/msm_iommu.c:	.detach_dev = msm_iommu_detach_dev,
iommu/msm_iommu.c:	.map = msm_iommu_map,
iommu/msm_iommu.c:	.unmap = msm_iommu_unmap,
iommu/msm_iommu.c:	.iova_to_phys = msm_iommu_iova_to_phys,
iommu/msm_iommu.c:	.add_device = msm_iommu_add_device,
iommu/msm_iommu.c:	.remove_device = msm_iommu_remove_device,
iommu/msm_iommu.c:static int msm_iommu_probe(struct platform_device *pdev)
iommu/msm_iommu.c:	struct msm_iommu_dev *iommu;
iommu/msm_iommu.c:	msm_iommu_reset(iommu->base, iommu->ncb);
iommu/msm_iommu.c:					msm_iommu_fault_handler,
iommu/msm_iommu.c:					"msm_iommu_secure_irpt_handler",
iommu/msm_iommu.c:				     "msm-smmu.%pa", &ioaddr);
iommu/msm_iommu.c:		pr_err("Could not add msm-smmu at %pa to sysfs\n", &ioaddr);
iommu/msm_iommu.c:	iommu_device_set_ops(&iommu->iommu, &msm_iommu_ops);
iommu/msm_iommu.c:		pr_err("Could not register msm-smmu at %pa\n", &ioaddr);
iommu/msm_iommu.c:	bus_set_iommu(&platform_bus_type, &msm_iommu_ops);
iommu/msm_iommu.c:static const struct of_device_id msm_iommu_dt_match[] = {
iommu/msm_iommu.c:static int msm_iommu_remove(struct platform_device *pdev)
iommu/msm_iommu.c:	struct msm_iommu_dev *iommu = platform_get_drvdata(pdev);
iommu/msm_iommu.c:static struct platform_driver msm_iommu_driver = {
iommu/msm_iommu.c:		.name	= "msm_iommu",
iommu/msm_iommu.c:		.of_match_table = msm_iommu_dt_match,
iommu/msm_iommu.c:	.probe		= msm_iommu_probe,
iommu/msm_iommu.c:	.remove		= msm_iommu_remove,
iommu/msm_iommu.c:static int __init msm_iommu_driver_init(void)
iommu/msm_iommu.c:	ret = platform_driver_register(&msm_iommu_driver);
iommu/msm_iommu.c:static void __exit msm_iommu_driver_exit(void)
iommu/msm_iommu.c:	platform_driver_unregister(&msm_iommu_driver);
iommu/msm_iommu.c:subsys_initcall(msm_iommu_driver_init);
iommu/msm_iommu.c:module_exit(msm_iommu_driver_exit);
iommu/msm_iommu.h: * struct msm_iommu_dev - a single IOMMU hardware instance
iommu/msm_iommu.h: * ctx_list:	list of 'struct msm_iommu_ctx_dev'
iommu/msm_iommu.h:struct msm_iommu_dev {
iommu/msm_iommu.h: * struct msm_iommu_ctx_dev - an IOMMU context bank instance
iommu/msm_iommu.h:struct msm_iommu_ctx_dev {
iommu/msm_iommu.h:irqreturn_t msm_iommu_fault_handler(int irq, void *dev_id);
iommu/qcom_iommu.c:	{ .compatible = "qcom,msm-iommu-v1-ns" },
iommu/qcom_iommu.c:	{ .compatible = "qcom,msm-iommu-v1-sec" },
iommu/qcom_iommu.c:		if (of_device_is_compatible(child, "qcom,msm-iommu-v1-sec")) {
iommu/qcom_iommu.c:	{ .compatible = "qcom,msm-iommu-v1" },
irqchip/Makefile:obj-$(CONFIG_QCOM_SHOW_RESUME_IRQ)      += msm_show_resume_irq.o
irqchip/Makefile:obj-$(CONFIG_QCOM_MPM)			+= qcom-mpm.o qcom-mpm-bengal.o qcom-mpm-scuba.o qcom-mpm-sdm660.o qcom-mpm-msm8937.o qcom-mpm-msm8953.o qcom-mpm-khaje.o
irqchip/irq-gic-common.h:extern int msm_show_resume_irq_mask;
irqchip/irq-gic-common.h:#define msm_show_resume_irq_mask 0
irqchip/irq-gic-v3.c:#include <linux/msm_rtb.h>
irqchip/irq-gic-v3.c:		if (msm_show_resume_irq_mask)
irqchip/irq-gic.c:IRQCHIP_DECLARE(msm_8660_qgic, "qcom,msm-8660-qgic", gic_of_init);
irqchip/irq-gic.c:IRQCHIP_DECLARE(msm_qgic2, "qcom,msm-qgic2", gic_of_init);
irqchip/msm_show_resume_irq.c:int msm_show_resume_irq_mask;
irqchip/msm_show_resume_irq.c:	debug_mask, msm_show_resume_irq_mask, int, 0664);
irqchip/qcom-mpm-msm8937.c:const struct mpm_pin mpm_msm8937_gic_chip_data[] = {
irqchip/qcom-mpm-msm8953.c:const struct mpm_pin mpm_msm8953_gic_chip_data[] = {
irqchip/qcom-mpm.c:struct msm_mpm_device_data {
irqchip/qcom-mpm.c:static int msm_pm_sleep_time_override;
irqchip/qcom-mpm.c:	msm_pm_sleep_time_override, int, 0664);
irqchip/qcom-mpm.c:static struct msm_mpm_device_data msm_mpm_dev_data;
irqchip/qcom-mpm.c:static void msm_get_mpm_pin(struct irq_data *d, int *mpm_pin, bool is_mpmgic)
irqchip/qcom-mpm.c:static inline uint32_t msm_mpm_read(unsigned int reg, unsigned int subreg_index)
irqchip/qcom-mpm.c:	return readl_relaxed(msm_mpm_dev_data.mpm_request_reg_base + offset);
irqchip/qcom-mpm.c:static inline void msm_mpm_write(unsigned int reg,
irqchip/qcom-mpm.c:	void __iomem *mpm_reg_base = msm_mpm_dev_data.mpm_request_reg_base;
irqchip/qcom-mpm.c:static inline void msm_mpm_enable_irq(struct irq_data *d, bool on,
irqchip/qcom-mpm.c:	msm_get_mpm_pin(d, mpm_pin, is_mpmgic);
irqchip/qcom-mpm.c:		enable = msm_mpm_read(reg, index);
irqchip/qcom-mpm.c:		msm_mpm_write(reg, index, enable);
irqchip/qcom-mpm.c:static void msm_mpm_program_set_type(bool set, unsigned int reg,
irqchip/qcom-mpm.c:	type = msm_mpm_read(reg, index);
irqchip/qcom-mpm.c:	msm_mpm_write(reg, index, type);
irqchip/qcom-mpm.c:static void msm_mpm_set_type(struct irq_data *d,
irqchip/qcom-mpm.c:	msm_get_mpm_pin(d, mpm_pin, is_mpmgic);
irqchip/qcom-mpm.c:			msm_mpm_program_set_type(1, reg, index, mask);
irqchip/qcom-mpm.c:			msm_mpm_program_set_type(0, reg, index, mask);
irqchip/qcom-mpm.c:			msm_mpm_program_set_type(1, reg, index, mask);
irqchip/qcom-mpm.c:			msm_mpm_program_set_type(0, reg, index, mask);
irqchip/qcom-mpm.c:			msm_mpm_program_set_type(1, reg, index, mask);
irqchip/qcom-mpm.c:			msm_mpm_program_set_type(0, reg, index, mask);
irqchip/qcom-mpm.c:static void msm_mpm_gpio_chip_mask(struct irq_data *d)
irqchip/qcom-mpm.c:	msm_mpm_enable_irq(d, false, MPM_GPIO);
irqchip/qcom-mpm.c:static void msm_mpm_gpio_chip_unmask(struct irq_data *d)
irqchip/qcom-mpm.c:	msm_mpm_enable_irq(d, true, MPM_GPIO);
irqchip/qcom-mpm.c:static int msm_mpm_gpio_chip_set_type(struct irq_data *d, unsigned int type)
irqchip/qcom-mpm.c:	msm_mpm_set_type(d, type, MPM_GPIO);
irqchip/qcom-mpm.c:static void msm_mpm_gic_chip_mask(struct irq_data *d)
irqchip/qcom-mpm.c:	msm_mpm_enable_irq(d, false, MPM_GIC);
irqchip/qcom-mpm.c:static void msm_mpm_gic_chip_unmask(struct irq_data *d)
irqchip/qcom-mpm.c:	msm_mpm_enable_irq(d, true, MPM_GIC);
irqchip/qcom-mpm.c:static int msm_mpm_gic_chip_set_type(struct irq_data *d, unsigned int type)
irqchip/qcom-mpm.c:	msm_mpm_set_type(d, type, MPM_GIC);
irqchip/qcom-mpm.c:static struct irq_chip msm_mpm_gic_chip = {
irqchip/qcom-mpm.c:	.irq_mask	= msm_mpm_gic_chip_mask,
irqchip/qcom-mpm.c:	.irq_disable	= msm_mpm_gic_chip_mask,
irqchip/qcom-mpm.c:	.irq_unmask	= msm_mpm_gic_chip_unmask,
irqchip/qcom-mpm.c:	.irq_set_type	= msm_mpm_gic_chip_set_type,
irqchip/qcom-mpm.c:static struct irq_chip msm_mpm_gpio_chip = {
irqchip/qcom-mpm.c:	.irq_mask	= msm_mpm_gpio_chip_mask,
irqchip/qcom-mpm.c:	.irq_disable	= msm_mpm_gpio_chip_mask,
irqchip/qcom-mpm.c:	.irq_unmask	= msm_mpm_gpio_chip_unmask,
irqchip/qcom-mpm.c:	.irq_set_type	= msm_mpm_gpio_chip_set_type,
irqchip/qcom-mpm.c:static int msm_mpm_gpio_chip_translate(struct irq_domain *d,
irqchip/qcom-mpm.c:static int msm_mpm_gpio_chip_alloc(struct irq_domain *domain,
irqchip/qcom-mpm.c:	ret = msm_mpm_gpio_chip_translate(domain, fwspec, &hwirq, &type);
irqchip/qcom-mpm.c:				&msm_mpm_gpio_chip, NULL);
irqchip/qcom-mpm.c:static const struct irq_domain_ops msm_mpm_gpio_chip_domain_ops = {
irqchip/qcom-mpm.c:	.translate	= msm_mpm_gpio_chip_translate,
irqchip/qcom-mpm.c:	.alloc		= msm_mpm_gpio_chip_alloc,
irqchip/qcom-mpm.c:static int msm_mpm_gic_chip_translate(struct irq_domain *d,
irqchip/qcom-mpm.c:static int msm_mpm_gic_chip_alloc(struct irq_domain *domain,
irqchip/qcom-mpm.c:	ret = msm_mpm_gic_chip_translate(domain, fwspec, &hwirq, &type);
irqchip/qcom-mpm.c:						&msm_mpm_gic_chip, NULL);
irqchip/qcom-mpm.c:static const struct irq_domain_ops msm_mpm_gic_chip_domain_ops = {
irqchip/qcom-mpm.c:	.translate	= msm_mpm_gic_chip_translate,
irqchip/qcom-mpm.c:	.alloc		= msm_mpm_gic_chip_alloc,
irqchip/qcom-mpm.c:static inline void msm_mpm_send_interrupt(void)
irqchip/qcom-mpm.c:	writel_relaxed(2, msm_mpm_dev_data.mpm_ipc_reg);
irqchip/qcom-mpm.c:static inline void msm_mpm_timer_write(uint32_t *expiry)
irqchip/qcom-mpm.c:	writel_relaxed(expiry[0], msm_mpm_dev_data.mpm_request_reg_base);
irqchip/qcom-mpm.c:	writel_relaxed(expiry[1], msm_mpm_dev_data.mpm_request_reg_base + 0x4);
irqchip/qcom-mpm.c:static void msm_mpm_enter_sleep(struct cpumask *cpumask)
irqchip/qcom-mpm.c:	msm_mpm_send_interrupt();
irqchip/qcom-mpm.c:	irq_set_affinity(msm_mpm_dev_data.ipc_irq, cpumask);
irqchip/qcom-mpm.c:	msm_rpm_exit_sleep();
irqchip/qcom-mpm.c:	if (unlikely(!from_idle && msm_pm_sleep_time_override)) {
irqchip/qcom-mpm.c:		wake_time = msm_pm_sleep_time_override * USEC_PER_SEC;
irqchip/qcom-mpm.c:	msm_mpm_timer_write((uint32_t *)&wakeup);
irqchip/qcom-mpm.c:	ret = msm_rpm_enter_sleep(0, mask);
irqchip/qcom-mpm.c:		msm_mpm_write(MPM_REG_STATUS, i, 0);
irqchip/qcom-mpm.c:	msm_mpm_enter_sleep(mask);
irqchip/qcom-mpm.c:	return !msm_rpm_waiting_for_ack();
irqchip/qcom-mpm.c:static irqreturn_t msm_mpm_irq(int irq, void *dev_id)
irqchip/qcom-mpm.c:		value[i] = msm_mpm_read(reg, i);
irqchip/qcom-mpm.c:		pending = msm_mpm_read(MPM_REG_STATUS, i);
irqchip/qcom-mpm.c:static int msm_mpm_init(struct device_node *node)
irqchip/qcom-mpm.c:	struct msm_mpm_device_data *dev = &msm_mpm_dev_data;
irqchip/qcom-mpm.c:	ret = request_irq(dev->ipc_irq, msm_mpm_irq,
irqchip/qcom-mpm.c:		msm_mpm_irq);
irqchip/qcom-mpm.c:	free_irq(dev->ipc_irq, msm_mpm_irq);
irqchip/qcom-mpm.c:		.compatible = "qcom,mpm-gic-msm8937",
irqchip/qcom-mpm.c:		.data = mpm_msm8937_gic_chip_data,
irqchip/qcom-mpm.c:		.compatible = "qcom,mpm-gic-msm8953",
irqchip/qcom-mpm.c:		.data = mpm_msm8953_gic_chip_data,
irqchip/qcom-mpm.c:	msm_mpm_dev_data.gic_chip_domain = irq_domain_add_hierarchy(
irqchip/qcom-mpm.c:			&msm_mpm_gic_chip_domain_ops, (void *)id->data);
irqchip/qcom-mpm.c:	if (!msm_mpm_dev_data.gic_chip_domain) {
irqchip/qcom-mpm.c:	msm_mpm_dev_data.gic_chip_domain->name = "qcom,mpm-gic";
irqchip/qcom-mpm.c:	ret = msm_mpm_init(node);
irqchip/qcom-mpm.c:	irq_domain_remove(msm_mpm_dev_data.gic_chip_domain);
irqchip/qcom-mpm.c:	msm_mpm_dev_data.gpio_chip_domain = irq_domain_create_linear(
irqchip/qcom-mpm.c:			&msm_mpm_gpio_chip_domain_ops, NULL);
irqchip/qcom-mpm.c:	if (!msm_mpm_dev_data.gpio_chip_domain)
irqchip/qcom-mpm.c:	irq_domain_update_bus_token(msm_mpm_dev_data.gpio_chip_domain,
irqchip/qcom-mpm.c:	msm_mpm_dev_data.gpio_chip_domain->name = "qcom,mpm-gpio";
mailbox/Makefile:obj-$(CONFIG_MSM_QMP)   += msm_qmp.o
mailbox/qcom-apcs-ipc-mailbox.c:		{ .compatible = "qcom,msm8916-apcs-kpss-global", },
mailbox/qcom-apcs-ipc-mailbox.c:							  "qcom-apcs-msm8916-clk",
mailbox/qcom-apcs-ipc-mailbox.c:	{ .compatible = "qcom,msm8916-apcs-kpss-global", .data = (void *)8 },
mailbox/qcom-apcs-ipc-mailbox.c:	{ .compatible = "qcom,msm8996-apcs-hmss-global", .data = (void *)16 },
mailbox/qcom-apcs-ipc-mailbox.c:	{ .compatible = "qcom,msm8998-apcs-hmss-global", .data = (void *)8 },
media/common/siano/Makefile:smsmdtv-objs := smscoreapi.o sms-cards.o smsendian.o
media/common/siano/Makefile:obj-$(CONFIG_SMS_SIANO_MDTV) += smsmdtv.o smsdvb.o
media/common/siano/Makefile:  smsmdtv-objs += smsir.o
media/common/siano/smsir.c:#define MODULE_NAME "smsmdtv"
media/i2c/ov5645.c: * - the OV5645 driver from QC msm-3.10 kernel on codeaurora.org:
media/i2c/ov5645.c: *   https://us.codeaurora.org/cgit/quic/la/kernel/msm-3.10/tree/drivers/
media/i2c/ov5645.c: *       media/platform/msm/camera_v2/sensor/ov5645.c?h=LA.BR.1.2.4_rb1.41
media/pci/saa7134/saa7134-cards.c:		/* Michael Smith <msmith@cbnco.com> */
media/platform/Kconfig:source "drivers/media/platform/msm/Kconfig"
media/platform/Kconfig:source "drivers/media/platform/msm/Kconfig"
media/platform/Kconfig:source "drivers/media/platform/msm/Kconfig"
media/platform/Makefile:obj-y                                   += msm/
media/platform/Makefile:obj-y					+= msm/
media/platform/msm/Kconfig:source "drivers/media/platform/msm/vidc_3x/Kconfig"
media/platform/msm/Kconfig:       QTI msm camera and video capture drivers. enabling this
media/platform/msm/Kconfig:       QTI msm camera and video capture drivers. enabling this
media/platform/msm/Kconfig:       Enable printk() debug for msm camera.
media/platform/msm/Kconfig:       QTI msm camera and video capture 2.0, enabling this
media/platform/msm/Kconfig:       QTI msm camera and video capture 2.0, enabling this
media/platform/msm/Kconfig:       Enable printk() debug for msm camera 2.0.
media/platform/msm/Kconfig:       source "drivers/media/platform/msm/camera_v2/Kconfig"
media/platform/msm/Kconfig:source "drivers/media/platform/msm/cvp/Kconfig"
media/platform/msm/Kconfig:source "drivers/media/platform/msm/npu/Kconfig"
media/platform/msm/Kconfig:source "drivers/media/platform/msm/synx/Kconfig"
media/platform/msm/Kconfig:source "drivers/media/platform/msm/dvb/Kconfig"
media/platform/msm/Kconfig:source "drivers/media/platform/msm/broadcast/Kconfig"
media/platform/msm/Kconfig:source "drivers/media/platform/msm/sde/Kconfig"
media/platform/msm/broadcast/tspp.c:#include <linux/msm-sps.h>       /* BAM stuff */
media/platform/msm/broadcast/tspp.c:#include <linux/msm-bus.h>
media/platform/msm/broadcast/tspp.c:		rc = msm_bus_scale_client_update_request(
media/platform/msm/broadcast/tspp.c:				msm_bus_scale_client_update_request(
media/platform/msm/broadcast/tspp.c:			msm_bus_scale_client_update_request(
media/platform/msm/broadcast/tspp.c:			msm_bus_scale_client_update_request(
media/platform/msm/broadcast/tspp.c:		rc = msm_bus_scale_client_update_request(
media/platform/msm/broadcast/tspp.c:static int msm_tspp_req_irqs(struct tspp_device *device)
media/platform/msm/broadcast/tspp.c:static inline void msm_tspp_free_irqs(struct tspp_device *device)
media/platform/msm/broadcast/tspp.c:		rc = msm_tspp_req_irqs(pdev);
media/platform/msm/broadcast/tspp.c:		msm_tspp_free_irqs(pdev);
media/platform/msm/broadcast/tspp.c:		msm_tspp_free_irqs(pdev);
media/platform/msm/broadcast/tspp.c:static int msm_tspp_map_irqs(struct platform_device *pdev,
media/platform/msm/broadcast/tspp.c:static int msm_tspp_probe(struct platform_device *pdev)
media/platform/msm/broadcast/tspp.c:	struct msm_bus_scale_pdata *tspp_bus_pdata = NULL;
media/platform/msm/broadcast/tspp.c:		tspp_bus_pdata = msm_bus_cl_get_pdata(pdev);
media/platform/msm/broadcast/tspp.c:			msm_bus_scale_register_client(tspp_bus_pdata);
media/platform/msm/broadcast/tspp.c:	if (msm_tspp_map_irqs(pdev, device))
media/platform/msm/broadcast/tspp.c:		msm_bus_scale_unregister_client(device->tsif_bus_client);
media/platform/msm/broadcast/tspp.c:static int msm_tspp_remove(struct platform_device *pdev)
media/platform/msm/broadcast/tspp.c:		msm_bus_scale_unregister_client(device->tsif_bus_client);
media/platform/msm/broadcast/tspp.c:		msm_tspp_free_irqs(device);
media/platform/msm/broadcast/tspp.c:static const struct of_device_id msm_match_table[] = {
media/platform/msm/broadcast/tspp.c:	{.compatible = "qcom,msm_tspp"},
media/platform/msm/broadcast/tspp.c:static struct platform_driver msm_tspp_driver = {
media/platform/msm/broadcast/tspp.c:	.probe          = msm_tspp_probe,
media/platform/msm/broadcast/tspp.c:	.remove         = msm_tspp_remove,
media/platform/msm/broadcast/tspp.c:		.name   = "msm_tspp",
media/platform/msm/broadcast/tspp.c:		.of_match_table = msm_match_table,
media/platform/msm/broadcast/tspp.c:	rc = platform_driver_register(&msm_tspp_driver);
media/platform/msm/broadcast/tspp.c:	platform_driver_unregister(&msm_tspp_driver);
media/platform/msm/camera_v2/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor
media/platform/msm/camera_v2/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/codecs
media/platform/msm/camera_v2/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/isp
media/platform/msm/camera_v2/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/pproc
media/platform/msm/camera_v2/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/msm_vb2
media/platform/msm/camera_v2/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/camera
media/platform/msm/camera_v2/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/jpeg_10
media/platform/msm/camera_v2/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/jpeg_dma
media/platform/msm/camera_v2/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/fd
media/platform/msm/camera_v2/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm.o
media/platform/msm/camera_v2/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_vb2/
media/platform/msm/camera_v2/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_buf_mgr/
media/platform/msm/camera_v2/camera/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/camera/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/msm_vb2
media/platform/msm/camera_v2/camera/camera.c:#include <linux/msm_ion.h>
media/platform/msm/camera_v2/camera/camera.c:#include "msm.h"
media/platform/msm/camera_v2/camera/camera.c:#include "msm_vb2.h"
media/platform/msm/camera_v2/camera/camera.c:	struct msm_v4l2_event_data *event_data =
media/platform/msm/camera_v2/camera/camera.c:		(struct msm_v4l2_event_data *)&event->u.data[0];
media/platform/msm/camera_v2/camera/camera.c:	struct msm_video_device *pvdev = video_drvdata(filep);
media/platform/msm/camera_v2/camera/camera.c:	struct msm_v4l2_event_data *event_data =
media/platform/msm/camera_v2/camera/camera.c:		(struct msm_v4l2_event_data *)&event->u.data[0];
media/platform/msm/camera_v2/camera/camera.c:	if (!msm_is_daemon_present())
media/platform/msm/camera_v2/camera/camera.c:	rc = msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:	if (!msm_is_daemon_present())
media/platform/msm/camera_v2/camera/camera.c:		rc = msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:	if (!msm_is_daemon_present())
media/platform/msm/camera_v2/camera/camera.c:		rc = msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:	if (!msm_is_daemon_present())
media/platform/msm/camera_v2/camera/camera.c:		rc = msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:	struct msm_video_device *pvdev = video_drvdata(filep);
media/platform/msm/camera_v2/camera/camera.c:			rc = msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:	struct msm_v4l2_event_data *event_data;
media/platform/msm/camera_v2/camera/camera.c:		rc = msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:		event_data = (struct msm_v4l2_event_data *)event.u.data;
media/platform/msm/camera_v2/camera/camera.c:	struct msm_session *session;
media/platform/msm/camera_v2/camera/camera.c:	struct msm_video_device *pvdev = video_drvdata(filep);
media/platform/msm/camera_v2/camera/camera.c:	session = msm_session_find(session_id);
media/platform/msm/camera_v2/camera/camera.c:	struct msm_session *session;
media/platform/msm/camera_v2/camera/camera.c:		struct msm_video_device *pvdev = video_drvdata(filep);
media/platform/msm/camera_v2/camera/camera.c:	session = msm_session_find(session_id);
media/platform/msm/camera_v2/camera/camera.c:	struct msm_session *session;
media/platform/msm/camera_v2/camera/camera.c:		struct msm_video_device *pvdev = video_drvdata(filep);
media/platform/msm/camera_v2/camera/camera.c:	session = msm_session_find(session_id);
media/platform/msm/camera_v2/camera/camera.c:	if (!msm_is_daemon_present())
media/platform/msm/camera_v2/camera/camera.c:	rc = msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:	if (msm_is_daemon_present()) {
media/platform/msm/camera_v2/camera/camera.c:		rc = msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:	if (!msm_is_daemon_present())
media/platform/msm/camera_v2/camera/camera.c:		rc = msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:	struct msm_v4l2_format_data *user_fmt;
media/platform/msm/camera_v2/camera/camera.c:			sizeof(struct msm_v4l2_format_data));
media/platform/msm/camera_v2/camera/camera.c:		user_fmt = (struct msm_v4l2_format_data *)sp->vb2_q.drv_priv;
media/platform/msm/camera_v2/camera/camera.c:		if (msm_is_daemon_present()) {
media/platform/msm/camera_v2/camera/camera.c:			rc = msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:	struct msm_v4l2_event_data *event_data =
media/platform/msm/camera_v2/camera/camera.c:		(struct msm_v4l2_event_data *)&event.u.data[0];
media/platform/msm/camera_v2/camera/camera.c:	rc = msm_create_stream(event_data->session_id,
media/platform/msm/camera_v2/camera/camera.c:	if (msm_is_daemon_present()) {
media/platform/msm/camera_v2/camera/camera.c:		rc = msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:	msm_delete_stream(event_data->session_id,
media/platform/msm/camera_v2/camera/camera.c:	struct msm_video_device *pvdev = video_drvdata(filep);
media/platform/msm/camera_v2/camera/camera.c:	struct msm_camera_private_ioctl_arg *k_ioctl = arg;
media/platform/msm/camera_v2/camera/camera.c:		struct msm_camera_return_buf ptr;
media/platform/msm/camera_v2/camera/camera.c:		struct msm_camera_return_buf __user *tmp = NULL;
media/platform/msm/camera_v2/camera/camera.c:			sizeof(struct msm_camera_return_buf))) {
media/platform/msm/camera_v2/camera/camera.c:		rc = msm_vb2_return_buf_by_idx(pvdev->vdev->num, sp->stream_id,
media/platform/msm/camera_v2/camera/camera.c:	struct msm_video_device *pvdev = video_drvdata(filep);
media/platform/msm/camera_v2/camera/camera.c:		kzalloc(sizeof(struct msm_v4l2_format_data), GFP_KERNEL);
media/platform/msm/camera_v2/camera/camera.c:	q->mem_ops = msm_vb2_get_q_mem_ops();
media/platform/msm/camera_v2/camera/camera.c:	q->ops = msm_vb2_get_q_ops();
media/platform/msm/camera_v2/camera/camera.c:	q->buf_struct_size = sizeof(struct msm_vb2_buffer);
media/platform/msm/camera_v2/camera/camera.c:	struct msm_video_device *pvdev = video_drvdata(filep);
media/platform/msm/camera_v2/camera/camera.c:		msm_pm_qos_update_request(CAMERA_DISABLE_PC_LATENCY);
media/platform/msm/camera_v2/camera/camera.c:		rc = msm_create_session(pvdev->vdev->num, pvdev->vdev);
media/platform/msm/camera_v2/camera/camera.c:		rc = msm_create_command_ack_q(pvdev->vdev->num,
media/platform/msm/camera_v2/camera/camera.c:		if (msm_is_daemon_present()) {
media/platform/msm/camera_v2/camera/camera.c:			rc = msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:		rc = msm_create_command_ack_q(pvdev->vdev->num,
media/platform/msm/camera_v2/camera/camera.c:	msm_delete_command_ack_q(pvdev->vdev->num, 0);
media/platform/msm/camera_v2/camera/camera.c:	msm_destroy_session(pvdev->vdev->num);
media/platform/msm/camera_v2/camera/camera.c:	msm_pm_qos_update_request(CAMERA_ENABLE_PC_LATENCY);
media/platform/msm/camera_v2/camera/camera.c:	struct msm_video_device *pvdev = video_drvdata(filep);
media/platform/msm/camera_v2/camera/camera.c:	struct msm_session *session;
media/platform/msm/camera_v2/camera/camera.c:	session = msm_session_find(pvdev->vdev->num);
media/platform/msm/camera_v2/camera/camera.c:	if (msm_is_daemon_present() && sp->stream_created) {
media/platform/msm/camera_v2/camera/camera.c:		msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:		if (msm_is_daemon_present()) {
media/platform/msm/camera_v2/camera/camera.c:			msm_post_event(&event, MSM_POST_EVT_TIMEOUT);
media/platform/msm/camera_v2/camera/camera.c:		msm_delete_command_ack_q(pvdev->vdev->num, 0);
media/platform/msm/camera_v2/camera/camera.c:		msm_delete_stream(pvdev->vdev->num, sp->stream_id);
media/platform/msm/camera_v2/camera/camera.c:		msm_destroy_session(pvdev->vdev->num);
media/platform/msm/camera_v2/camera/camera.c:		msm_pm_qos_update_request(CAMERA_ENABLE_PC_LATENCY);
media/platform/msm/camera_v2/camera/camera.c:		msm_delete_command_ack_q(pvdev->vdev->num,
media/platform/msm/camera_v2/camera/camera.c:		msm_delete_stream(pvdev->vdev->num, sp->stream_id);
media/platform/msm/camera_v2/camera/camera.c:	struct msm_camera_private_ioctl_arg k_ioctl;
media/platform/msm/camera_v2/camera/camera.c:	rc = msm_copy_camera_private_ioctl_args(arg,
media/platform/msm/camera_v2/camera/camera.c:		if (k_ioctl.size != sizeof(struct msm_camera_return_buf)) {
media/platform/msm/camera_v2/camera/camera.c:	struct msm_video_device *pvdev;
media/platform/msm/camera_v2/camera/camera.c:	pvdev = kzalloc(sizeof(struct msm_video_device),
media/platform/msm/camera_v2/camera/camera.c:	strlcpy(pvdev->vdev->name, "msm-sensor", sizeof(pvdev->vdev->name));
media/platform/msm/camera_v2/common/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/
media/platform/msm/camera_v2/common/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_camera_io_util.o cam_smmu_api.o cam_hw_ops.o cam_soc_api.o msm_camera_tz_util.o msm_cam_cx_ipeak.o
media/platform/msm/camera_v2/common/cam_hw_ops.c:#include <linux/msm-bus.h>
media/platform/msm/camera_v2/common/cam_hw_ops.c:#include <linux/msm-bus-board.h>
media/platform/msm/camera_v2/common/cam_hw_ops.c:	struct msm_bus_scale_pdata *pbus_data;
media/platform/msm/camera_v2/common/cam_hw_ops.c:	struct msm_bus_vectors *paths;
media/platform/msm/camera_v2/common/cam_hw_ops.c:	struct msm_bus_paths *usecases;
media/platform/msm/camera_v2/common/cam_hw_ops.c:		sizeof(struct msm_bus_vectors) * cnt,
media/platform/msm/camera_v2/common/cam_hw_ops.c:		sizeof(struct msm_bus_paths) * cnt,
media/platform/msm/camera_v2/common/cam_hw_ops.c:		sizeof(struct msm_bus_scale_pdata),
media/platform/msm/camera_v2/common/cam_hw_ops.c:		data.paths[i] = (struct msm_bus_vectors) {
media/platform/msm/camera_v2/common/cam_hw_ops.c:		data.usecases[i] = (struct msm_bus_paths) {
media/platform/msm/camera_v2/common/cam_hw_ops.c:	*data.pbus_data = (struct msm_bus_scale_pdata) {
media/platform/msm/camera_v2/common/cam_hw_ops.c:		.name = "msm_camera_ahb",
media/platform/msm/camera_v2/common/cam_hw_ops.c:		msm_bus_scale_register_client(data.pbus_data);
media/platform/msm/camera_v2/common/cam_hw_ops.c:	msm_bus_scale_client_update_request(data.ahb_client,
media/platform/msm/camera_v2/common/cam_hw_ops.c:	msm_bus_scale_unregister_client(data.ahb_client);
media/platform/msm/camera_v2/common/cam_hw_ops.c:		msm_bus_scale_client_update_request(data.ahb_client,
media/platform/msm/camera_v2/common/cam_smmu_api.c:#include <linux/msm_dma_iommu_mapping.h>
media/platform/msm/camera_v2/common/cam_smmu_api.c:#include <msm_camera_tz_util.h>
media/platform/msm/camera_v2/common/cam_smmu_api.c:static const struct of_device_id msm_cam_smmu_dt_match[] = {
media/platform/msm/camera_v2/common/cam_smmu_api.c:	{ .compatible = "qcom,msm-cam-smmu", },
media/platform/msm/camera_v2/common/cam_smmu_api.c:	{ .compatible = "qcom,msm-cam-smmu-cb", },
media/platform/msm/camera_v2/common/cam_smmu_api.c:	rc = msm_camera_tz_set_mode(MSM_CAMERA_TZ_MODE_SECURE,
media/platform/msm/camera_v2/common/cam_smmu_api.c:	rc = msm_camera_tz_set_mode(MSM_CAMERA_TZ_MODE_NON_SECURE,
media/platform/msm/camera_v2/common/cam_smmu_api.c:		rc = msm_camera_tz_set_mode(MSM_CAMERA_TZ_MODE_SECURE,
media/platform/msm/camera_v2/common/cam_smmu_api.c:		rc = msm_camera_tz_set_mode(MSM_CAMERA_TZ_MODE_NON_SECURE,
media/platform/msm/camera_v2/common/cam_smmu_api.c:			"qcom,msm-cam-smmu-cb"))
media/platform/msm/camera_v2/common/cam_smmu_api.c:	if (of_device_is_compatible(dev->of_node, "qcom,msm-cam-smmu")) {
media/platform/msm/camera_v2/common/cam_smmu_api.c:	if (of_device_is_compatible(dev->of_node, "qcom,msm-cam-smmu-cb")) {
media/platform/msm/camera_v2/common/cam_smmu_api.c:	rc = of_platform_populate(pdev->dev.of_node, msm_cam_smmu_dt_match,
media/platform/msm/camera_v2/common/cam_smmu_api.c:	if (of_device_is_compatible(pdev->dev.of_node, "qcom,msm-cam-smmu"))
media/platform/msm/camera_v2/common/cam_smmu_api.c:		.name = "msm_cam_smmu",
media/platform/msm/camera_v2/common/cam_smmu_api.c:		.of_match_table = msm_cam_smmu_dt_match,
media/platform/msm/camera_v2/common/cam_smmu_api.h:#include <linux/msm_ion.h>
media/platform/msm/camera_v2/common/cam_soc_api.c:#include <linux/msm-bus.h>
media/platform/msm/camera_v2/common/cam_soc_api.c:struct msm_cam_bus_pscale_data {
media/platform/msm/camera_v2/common/cam_soc_api.c:	struct msm_bus_scale_pdata *pdata;
media/platform/msm/camera_v2/common/cam_soc_api.c:static struct msm_cam_bus_pscale_data g_cv[CAM_BUS_CLIENT_MAX];
media/platform/msm/camera_v2/common/cam_soc_api.c:static int msm_camera_get_clk_info_internal(struct device *dev,
media/platform/msm/camera_v2/common/cam_soc_api.c:			struct msm_cam_clk_info **clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.c:				sizeof(struct msm_cam_clk_info), GFP_KERNEL);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_i2c_dev_get_clk_info(struct device *dev,
media/platform/msm/camera_v2/common/cam_soc_api.c:			struct msm_cam_clk_info **clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.c:	rc = msm_camera_get_clk_info_internal(dev, clk_info, clk_ptr, num_clk);
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_i2c_dev_get_clk_info);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_get_clk_info(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:			struct msm_cam_clk_info **clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.c:	rc = msm_camera_get_clk_info_internal(&pdev->dev,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_get_clk_info);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_get_clk_info_and_rates(
media/platform/msm/camera_v2/common/cam_soc_api.c:			struct msm_cam_clk_info **pclk_info,
media/platform/msm/camera_v2/common/cam_soc_api.c:	struct msm_cam_clk_info *clk_info;
media/platform/msm/camera_v2/common/cam_soc_api.c:				sizeof(struct msm_cam_clk_info), GFP_KERNEL);
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_get_clk_info_and_rates);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_clk_enable(struct device *dev,
media/platform/msm/camera_v2/common/cam_soc_api.c:		struct msm_cam_clk_info *clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_clk_enable);
media/platform/msm/camera_v2/common/cam_soc_api.c:long msm_camera_clk_set_rate(struct device *dev,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_clk_set_rate);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_set_clk_flags(struct clk *clk, unsigned long flags)
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_set_clk_flags);
media/platform/msm/camera_v2/common/cam_soc_api.c:static int msm_camera_put_clk_info_internal(struct device *dev,
media/platform/msm/camera_v2/common/cam_soc_api.c:				struct msm_cam_clk_info **clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_i2c_dev_put_clk_info(struct device *dev,
media/platform/msm/camera_v2/common/cam_soc_api.c:				struct msm_cam_clk_info **clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.c:	rc = msm_camera_put_clk_info_internal(dev, clk_info, clk_ptr, cnt);
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_i2c_dev_put_clk_info);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_put_clk_info(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:				struct msm_cam_clk_info **clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.c:	rc = msm_camera_put_clk_info_internal(&pdev->dev,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_put_clk_info);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_put_clk_info_and_rates(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:		struct msm_cam_clk_info **clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_put_clk_info_and_rates);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_get_reset_info(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_get_reset_info);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_get_regulator_info(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:				struct msm_cam_regulator **vdd_info,
media/platform/msm/camera_v2/common/cam_soc_api.c:	struct msm_cam_regulator *tmp_reg;
media/platform/msm/camera_v2/common/cam_soc_api.c:				sizeof(struct msm_cam_regulator), GFP_KERNEL);
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_get_regulator_info);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_regulator_enable(struct msm_cam_regulator *vdd_info,
media/platform/msm/camera_v2/common/cam_soc_api.c:	struct msm_cam_regulator *tmp = vdd_info;
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_regulator_enable);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_regulator_disable(struct msm_cam_regulator *vdd_info,
media/platform/msm/camera_v2/common/cam_soc_api.c:	struct msm_cam_regulator *tmp = vdd_info;
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_regulator_disable);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_regulator_set_mode(struct msm_cam_regulator *vdd_info,
media/platform/msm/camera_v2/common/cam_soc_api.c:	struct msm_cam_regulator *tmp = vdd_info;
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_regulator_set_mode);
media/platform/msm/camera_v2/common/cam_soc_api.c:void msm_camera_put_regulators(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:	struct msm_cam_regulator **vdd_info, int cnt)
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_put_regulators);
media/platform/msm/camera_v2/common/cam_soc_api.c:struct resource *msm_camera_get_irq(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_get_irq);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_register_irq(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_register_irq);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_register_threaded_irq(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_register_threaded_irq);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_enable_irq(struct resource *irq, int enable)
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_enable_irq);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_unregister_irq(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_unregister_irq);
media/platform/msm/camera_v2/common/cam_soc_api.c:void __iomem *msm_camera_get_reg_base(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_get_reg_base);
media/platform/msm/camera_v2/common/cam_soc_api.c:uint32_t msm_camera_get_res_size(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_get_res_size);
media/platform/msm/camera_v2/common/cam_soc_api.c:int msm_camera_put_reg_base(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_put_reg_base);
media/platform/msm/camera_v2/common/cam_soc_api.c:uint32_t msm_camera_register_bus_client(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.c:	struct msm_bus_scale_pdata *pdata;
media/platform/msm/camera_v2/common/cam_soc_api.c:		rc = of_property_read_u32(of_node, "qcom,msm-bus,num-cases",
media/platform/msm/camera_v2/common/cam_soc_api.c:		rc = of_property_read_u32(of_node, "qcom,msm-bus,num-paths",
media/platform/msm/camera_v2/common/cam_soc_api.c:				"qcom,msm-bus-vector-dyn-vote")) {
media/platform/msm/camera_v2/common/cam_soc_api.c:		pdata = msm_bus_cl_get_pdata(pdev);
media/platform/msm/camera_v2/common/cam_soc_api.c:		bus_client = msm_bus_scale_register_client(pdata);
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_register_bus_client);
media/platform/msm/camera_v2/common/cam_soc_api.c:uint32_t msm_camera_update_bus_bw(int id, uint64_t ab, uint64_t ib)
media/platform/msm/camera_v2/common/cam_soc_api.c:	struct msm_bus_paths *path;
media/platform/msm/camera_v2/common/cam_soc_api.c:	struct msm_bus_scale_pdata *pdata;
media/platform/msm/camera_v2/common/cam_soc_api.c:	msm_bus_scale_client_update_request(g_cv[id].bus_client, idx);
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_update_bus_bw);
media/platform/msm/camera_v2/common/cam_soc_api.c:uint32_t msm_camera_update_bus_vector(enum cam_bus_client id,
media/platform/msm/camera_v2/common/cam_soc_api.c:	msm_bus_scale_client_update_request(g_cv[id].bus_client,
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_update_bus_vector);
media/platform/msm/camera_v2/common/cam_soc_api.c:uint32_t msm_camera_unregister_bus_client(enum cam_bus_client id)
media/platform/msm/camera_v2/common/cam_soc_api.c:	msm_bus_scale_unregister_client(g_cv[id].bus_client);
media/platform/msm/camera_v2/common/cam_soc_api.c:EXPORT_SYMBOL(msm_camera_unregister_bus_client);
media/platform/msm/camera_v2/common/cam_soc_api.h:struct msm_cam_regulator {
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_get_clk_info(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.h:			struct msm_cam_clk_info **clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_i2c_dev_get_clk_info(struct device *dev,
media/platform/msm/camera_v2/common/cam_soc_api.h:			struct msm_cam_clk_info **clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_get_clk_info_and_rates(
media/platform/msm/camera_v2/common/cam_soc_api.h:			struct msm_cam_clk_info **clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_put_clk_info(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.h:				struct msm_cam_clk_info **clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_i2c_dev_put_clk_info(struct device *dev,
media/platform/msm/camera_v2/common/cam_soc_api.h:			struct msm_cam_clk_info **clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_put_clk_info_and_rates(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.h:		struct msm_cam_clk_info **clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_clk_enable(struct device *dev,
media/platform/msm/camera_v2/common/cam_soc_api.h:		struct msm_cam_clk_info *clk_info,
media/platform/msm/camera_v2/common/cam_soc_api.h:long msm_camera_clk_set_rate(struct device *dev,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_get_reset_info(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_set_clk_flags(struct clk *clk, unsigned long flags);
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_get_regulator_info(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.h:		struct msm_cam_regulator **vdd_info, int *num_reg);
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_regulator_enable(struct msm_cam_regulator *vdd_info,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_regulator_disable(struct msm_cam_regulator *vdd_info,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_regulator_set_mode(struct msm_cam_regulator *vdd_info,
media/platform/msm/camera_v2/common/cam_soc_api.h:void msm_camera_put_regulators(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.h:	struct msm_cam_regulator **vdd_info, int cnt);
media/platform/msm/camera_v2/common/cam_soc_api.h:struct resource *msm_camera_get_irq(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_register_irq(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_register_threaded_irq(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_enable_irq(struct resource *irq, int flag);
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_unregister_irq(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.h:void __iomem *msm_camera_get_reg_base(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.h:int msm_camera_put_reg_base(struct platform_device *pdev, void __iomem *base,
media/platform/msm/camera_v2/common/cam_soc_api.h:uint32_t msm_camera_register_bus_client(struct platform_device *pdev,
media/platform/msm/camera_v2/common/cam_soc_api.h:uint32_t msm_camera_update_bus_vector(enum cam_bus_client id,
media/platform/msm/camera_v2/common/cam_soc_api.h:uint32_t msm_camera_update_bus_bw(int id, uint64_t ab, uint64_t ib);
media/platform/msm/camera_v2/common/cam_soc_api.h:uint32_t msm_camera_unregister_bus_client(enum cam_bus_client id);
media/platform/msm/camera_v2/common/cam_soc_api.h:uint32_t msm_camera_get_res_size(struct platform_device *pdev,
media/platform/msm/camera_v2/common/msm_cam_cx_ipeak.c:#include "msm_cam_cx_ipeak.h"
media/platform/msm/camera_v2/common/msm_camera_io_util.c:#include <linux/msm-bus.h>
media/platform/msm/camera_v2/common/msm_camera_io_util.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/common/msm_camera_io_util.c:void msm_camera_io_w(u32 data, void __iomem *addr)
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int32_t msm_camera_io_w_block(const u32 *addr, void __iomem *base,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int32_t msm_camera_io_w_reg_block(const u32 *addr, void __iomem *base,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:void msm_camera_io_w_mb(u32 data, void __iomem *addr)
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int32_t msm_camera_io_w_mb_block(const u32 *addr, void __iomem *base, u32 len)
media/platform/msm/camera_v2/common/msm_camera_io_util.c:u32 msm_camera_io_r(void __iomem *addr)
media/platform/msm/camera_v2/common/msm_camera_io_util.c:u32 msm_camera_io_r_mb(void __iomem *addr)
media/platform/msm/camera_v2/common/msm_camera_io_util.c:static void msm_camera_io_memcpy_toio(void __iomem *dest_addr,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int32_t msm_camera_io_poll_value(void __iomem *addr, u32 wait_data, u32 retry,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:	tmp = msm_camera_io_r(addr);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		tmp = msm_camera_io_r(addr);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int32_t msm_camera_io_poll_value_wmask(void __iomem *addr, u32 wait_data,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:	tmp = msm_camera_io_r(addr);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		tmp = msm_camera_io_r(addr);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:void msm_camera_io_dump(void __iomem *addr, int size, int enable)
media/platform/msm/camera_v2/common/msm_camera_io_util.c:void msm_camera_io_dump_wstring_base(void __iomem *addr,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:	struct msm_cam_dump_string_info *dump_data,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:	int i, u = sizeof(struct msm_cam_dump_string_info);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:void msm_camera_io_memcpy(void __iomem *dest_addr,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:	msm_camera_io_memcpy_toio(dest_addr, src_addr, len / 4);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:void msm_camera_io_memcpy_mb(void __iomem *dest_addr,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		msm_camera_io_w(*s++, d++);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int msm_cam_clk_sel_src(struct device *dev, struct msm_cam_clk_info *clk_info,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		struct msm_cam_clk_info *clk_src_info, int num_clk)
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int msm_cam_clk_enable(struct device *dev, struct msm_cam_clk_info *clk_info,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int msm_camera_config_vreg(struct device *dev, struct camera_vreg_t *cam_vreg,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		int num_vreg, enum msm_camera_vreg_name_t *vreg_seq,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int msm_camera_enable_vreg(struct device *dev, struct camera_vreg_t *cam_vreg,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		int num_vreg, enum msm_camera_vreg_name_t *vreg_seq,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:void msm_camera_bus_scale_cfg(uint32_t bus_perf_client,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		enum msm_bus_perf_setting perf_setting)
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		rc = msm_bus_scale_client_update_request(bus_perf_client, 1);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		msm_bus_scale_unregister_client(bus_perf_client);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		rc = msm_bus_scale_client_update_request(bus_perf_client, 1);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		rc = msm_bus_scale_client_update_request(bus_perf_client, 2);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		rc = msm_bus_scale_client_update_request(bus_perf_client, 3);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		rc = msm_bus_scale_client_update_request(bus_perf_client, 4);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:		rc = msm_bus_scale_client_update_request(bus_perf_client, 5);
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int msm_camera_set_gpio_table(struct msm_gpio_set_tbl *gpio_tbl,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int msm_camera_config_single_vreg(struct device *dev,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int msm_camera_request_gpio_table(struct gpio *gpio_tbl, uint8_t size,
media/platform/msm/camera_v2/common/msm_camera_io_util.c: * msm_camera_get_dt_reg_settings - Get dt reg settings from device-tree.
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int msm_camera_get_dt_reg_settings(struct device_node *of_node,
media/platform/msm/camera_v2/common/msm_camera_io_util.c: * msm_camera_get_dt_reg_settings - Free dt reg settings memory.
media/platform/msm/camera_v2/common/msm_camera_io_util.c:void msm_camera_put_dt_reg_settings(uint32_t **reg_s,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:int msm_camera_hw_write_dt_reg_settings(void __iomem *base,
media/platform/msm/camera_v2/common/msm_camera_io_util.c:	rc = msm_camera_io_w_reg_block((const u32 *) reg_s,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:#include <media/msm_cam_sensor.h>
media/platform/msm/camera_v2/common/msm_camera_io_util.h:struct msm_gpio_set_tbl {
media/platform/msm/camera_v2/common/msm_camera_io_util.h:struct msm_cam_dump_string_info {
media/platform/msm/camera_v2/common/msm_camera_io_util.h:void msm_camera_io_w(u32 data, void __iomem *addr);
media/platform/msm/camera_v2/common/msm_camera_io_util.h:void msm_camera_io_w_mb(u32 data, void __iomem *addr);
media/platform/msm/camera_v2/common/msm_camera_io_util.h:u32 msm_camera_io_r(void __iomem *addr);
media/platform/msm/camera_v2/common/msm_camera_io_util.h:u32 msm_camera_io_r_mb(void __iomem *addr);
media/platform/msm/camera_v2/common/msm_camera_io_util.h:void msm_camera_io_dump(void __iomem *addr, int size, int enable);
media/platform/msm/camera_v2/common/msm_camera_io_util.h:void msm_camera_io_memcpy(void __iomem *dest_addr,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:void msm_camera_io_memcpy_mb(void __iomem *dest_addr,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int msm_cam_clk_sel_src(struct device *dev, struct msm_cam_clk_info *clk_info,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:		struct msm_cam_clk_info *clk_src_info, int num_clk);
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int msm_cam_clk_enable(struct device *dev, struct msm_cam_clk_info *clk_info,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int msm_camera_config_vreg(struct device *dev, struct camera_vreg_t *cam_vreg,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:		int num_vreg, enum msm_camera_vreg_name_t *vreg_seq,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int msm_camera_enable_vreg(struct device *dev, struct camera_vreg_t *cam_vreg,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:		int num_vreg, enum msm_camera_vreg_name_t *vreg_seq,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:void msm_camera_bus_scale_cfg(uint32_t bus_perf_client,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:		enum msm_bus_perf_setting perf_setting);
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int msm_camera_set_gpio_table(struct msm_gpio_set_tbl *gpio_tbl,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:void msm_camera_config_single_gpio(uint16_t gpio, unsigned long flags,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int msm_camera_config_single_vreg(struct device *dev,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int msm_camera_request_gpio_table(struct gpio *gpio_tbl, uint8_t size,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:void msm_camera_io_dump_wstring_base(void __iomem *addr,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:	struct msm_cam_dump_string_info *dump_data,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int32_t msm_camera_io_poll_value_wmask(void __iomem *addr, u32 wait_data,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int32_t msm_camera_io_poll_value(void __iomem *addr, u32 wait_data, u32 retry,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int32_t msm_camera_io_w_block(const u32 *addr, void __iomem *base, u32 len);
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int32_t msm_camera_io_w_reg_block(const u32 *addr, void __iomem *base, u32 len);
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int32_t msm_camera_io_w_mb_block(const u32 *addr, void __iomem *base, u32 len);
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int msm_camera_get_dt_reg_settings(struct device_node *of_node,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:void msm_camera_put_dt_reg_settings(uint32_t **reg_s,
media/platform/msm/camera_v2/common/msm_camera_io_util.h:int msm_camera_hw_write_dt_reg_settings(void __iomem *base,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:#include "msm_camera_tz_util.h"
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:#pragma pack(push, msm_camera_tz_util, 1)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:#define msm_camera_tz_get_if_version_req_t msm_camera_tz_generic_req_t
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:struct msm_camera_tz_get_if_version_rsp_t {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_status_t rc;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:#define msm_camera_tz_set_mode_rsp_t msm_camera_tz_generic_rsp_t
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:struct msm_camera_tz_set_mode_req_t {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_cmd_id_t cmd_id;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:#pragma pack(pop, msm_camera_tz_util)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:struct msm_camera_tz_ctrl_t {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static struct msm_camera_tz_ctrl_t msm_camera_tz_ctrl = {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:struct msm_camera_tz_register_t {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:struct msm_camera_tz_reg_ctrl_t {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t deferred_region;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	struct msm_camera_tz_register_t
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static struct msm_camera_tz_reg_ctrl_t msm_camera_tz_reg_ctrl = {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static DEFINE_MUTEX(msm_camera_tz_util_lock);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static int32_t msm_camera_tz_tzbsp_reg_write(uint32_t data, uint32_t offset,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static const char *msm_camera_tz_scm_call_name(uint32_t call_id)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static const char *msm_camera_tz_region_name(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:uint32_t msm_camera_tz_region_to_hw_block(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static uint32_t msm_camera_tz_get_tzbsp_status(uint32_t status_mask)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if (msm_camera_tz_ctrl.tzbsp_status == 0) {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:				msm_camera_tz_scm_call_name(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_ctrl.tzbsp_status = 0xFFFFFFFF;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_ctrl.tzbsp_status = desc.ret[0];
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_ctrl.tzbsp_status,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if ((msm_camera_tz_ctrl.tzbsp_status != 0xFFFFFFFF) &&
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		(msm_camera_tz_ctrl.tzbsp_status & status_mask))
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:void msm_camera_tz_clear_tzbsp_status(void)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	msm_camera_tz_ctrl.tzbsp_status = 0;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:uint32_t msm_camera_tz_is_secured(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if (msm_camera_tz_get_tzbsp_status(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if (msm_camera_tz_get_tzbsp_status(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		(msm_camera_tz_region_to_hw_block(region) <<
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:struct qseecom_handle *msm_camera_tz_get_ta_handle(void)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	return msm_camera_tz_ctrl.ta_qseecom_handle;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:void msm_camera_tz_lock(void)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	mutex_lock(&msm_camera_tz_util_lock);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:void msm_camera_tz_unlock(void)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	mutex_unlock(&msm_camera_tz_util_lock);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static int32_t msm_camera_tz_ta_get_if_version(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	struct msm_camera_tz_get_if_version_req_t *cmd;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	struct msm_camera_tz_get_if_version_rsp_t *rsp;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	cmd_len = sizeof(struct msm_camera_tz_get_if_version_req_t);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	rsp_len = sizeof(struct msm_camera_tz_get_if_version_rsp_t);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:int32_t msm_camera_tz_load_ta(void)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_ctrl.ta_enabled > 0) {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_ctrl.ta_name,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_ctrl.ta_enabled);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_ctrl.ta_name,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_ctrl.ta_enabled);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	msm_camera_tz_lock();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if (msm_camera_tz_ctrl.ta_enabled == 0) {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		if ((msm_camera_tz_ctrl.ta_qseecom_handle == NULL) &&
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			(msm_camera_tz_ctrl.ta_name != NULL) &&
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			('\0' != msm_camera_tz_ctrl.ta_name[0])) {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:				&msm_camera_tz_ctrl.ta_qseecom_handle,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:				(char *)msm_camera_tz_ctrl.ta_name,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:				rc = msm_camera_tz_ta_get_if_version(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:					msm_camera_tz_ctrl.ta_qseecom_handle,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:					&msm_camera_tz_ctrl.ta_qseecom_handle);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:				msm_camera_tz_ctrl.ta_qseecom_handle
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:					msm_camera_tz_ctrl.ta_enabled = 1;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_ctrl.ta_name,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			(msm_camera_tz_ctrl.ta_enabled)?"Ok" :
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_ctrl.ta_enabled++;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_ctrl.ta_name,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_ctrl.ta_enabled);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	msm_camera_tz_unlock();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:int32_t msm_camera_tz_unload_ta(void)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_ctrl.ta_name,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_ctrl.ta_enabled);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_ctrl.ta_name,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_ctrl.ta_enabled);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	msm_camera_tz_lock();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if (msm_camera_tz_ctrl.ta_enabled == 1) {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			&msm_camera_tz_ctrl.ta_qseecom_handle);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_ctrl.ta_qseecom_handle
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_ctrl.ta_enabled = 0;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_ctrl.ta_name,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_ctrl.ta_enabled--;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_ctrl.ta_name,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_ctrl.ta_enabled);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	msm_camera_tz_unlock();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static int32_t msm_camera_tz_ta_set_mode(uint32_t mode,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	struct msm_camera_tz_set_mode_req_t *cmd;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	struct msm_camera_tz_set_mode_rsp_t *rsp;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_get_ta_handle();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	cmd_len = sizeof(struct msm_camera_tz_set_mode_req_t);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	rsp_len = sizeof(struct msm_camera_tz_set_mode_rsp_t);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	msm_camera_tz_lock();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_unlock();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	msm_camera_tz_unlock();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:uint32_t msm_camera_tz_set_mode(uint32_t mode,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		rc = msm_camera_tz_load_ta();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			rc = msm_camera_tz_ta_set_mode(mode, hw_block);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:				msm_camera_tz_ctrl.secure_hw_blocks |= hw_block;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_ta_set_mode(mode, hw_block);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_ctrl.secure_hw_blocks &= ~hw_block;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		rc = msm_camera_tz_unload_ta();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static int32_t msm_camera_tz_tzbsp_reg_write_bulk(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if (msm_camera_tz_reg_ctrl.num_of_deffered_registers == 0 ||
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.num_of_deffered_registers >
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.num_of_deffered_registers;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		index < msm_camera_tz_reg_ctrl.num_of_deffered_registers;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_reg_ctrl.deferred_registers[index].offset;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_reg_ctrl.deferred_registers[index].data;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	desc.args[1] = msm_camera_tz_reg_ctrl.num_of_deffered_registers;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.num_of_deffered_registers);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.num_of_deffered_registers);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_scm_call_name(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_region_name(region),
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.num_of_deffered_registers,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static void msm_camera_tz_flush_deferred(void)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if (msm_camera_tz_reg_ctrl.num_of_deffered_registers) {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		uint32_t region = msm_camera_tz_reg_ctrl.deferred_region;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_reg_ctrl.num_of_deffered_registers,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_region_name(region));
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		if (msm_camera_tz_is_secured(region) &&
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_get_tzbsp_status((1 <<
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			rc = msm_camera_tz_tzbsp_reg_write_bulk(region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		if (rc && msm_camera_tz_is_secured(region) &&
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_get_tzbsp_status(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_reg_ctrl.num_of_deffered_registers;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:				rc = msm_camera_tz_tzbsp_reg_write(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:				msm_camera_tz_reg_ctrl.deferred_registers[
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:				msm_camera_tz_reg_ctrl.deferred_registers[
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:				msm_camera_tz_reg_ctrl.deferred_registers[
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.num_of_deffered_registers = 0;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.deferred_region =
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.deferred_base_addr = NULL;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static int32_t msm_camera_tz_tzbsp_reg_read(uint32_t offset, uint32_t *data,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_scm_call_name(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		rc, msm_camera_tz_region_name(region),
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:uint32_t msm_camera_tz_r(void __iomem *base_addr, uint32_t offset,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if (msm_camera_tz_is_secured(region)) {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_flush_deferred();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		if (msm_camera_tz_is_secured(region) &&
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_get_tzbsp_status(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			rc = msm_camera_tz_tzbsp_reg_read(offset, &data,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	data = msm_camera_io_r(base_addr + offset);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static int32_t msm_camera_tz_tzbsp_reg_write(uint32_t data, uint32_t offset,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_scm_call_name(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		rc, msm_camera_tz_region_name(region),
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static void msm_camera_tz_write(uint32_t data,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if (msm_camera_tz_reg_ctrl.num_of_deffered_registers > 0 &&
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.num_of_deffered_registers <
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.deferred_region == region &&
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.deferred_region !=
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_w_deferred(data, base_addr, offset, region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_flush_deferred();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_flush_deferred();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		if (msm_camera_tz_is_secured(region) &&
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_get_tzbsp_status((1 <<
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			rc = msm_camera_tz_tzbsp_reg_write(data, offset,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:void msm_camera_tz_w_mb(uint32_t data,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if (msm_camera_tz_is_secured(region)) {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_region_name(region),
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_is_secured(region),
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_write(data, base_addr, offset, region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_io_w_mb(data, base_addr + offset);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:void msm_camera_tz_w(uint32_t data,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if (msm_camera_tz_is_secured(region)) {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_region_name(region),
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_is_secured(region),
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_write(data, base_addr, offset, region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_io_w(data, base_addr + offset);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:void msm_camera_tz_w_deferred(uint32_t data,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if (msm_camera_tz_is_secured(region)) {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_region_name(region),
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_is_secured(region),
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		if ((msm_camera_tz_reg_ctrl.deferred_region != region &&
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:				msm_camera_tz_reg_ctrl.deferred_region !=
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			 msm_camera_tz_reg_ctrl.num_of_deffered_registers >=
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_flush_deferred();
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		if (msm_camera_tz_reg_ctrl.num_of_deffered_registers == 0) {
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_reg_ctrl.deferred_region = region;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_reg_ctrl.deferred_base_addr = base_addr;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.deferred_registers[
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.num_of_deffered_registers].offset =
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.deferred_registers[
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.num_of_deffered_registers].data =
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_reg_ctrl.num_of_deffered_registers++;
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	msm_camera_io_w(data, base_addr + offset);
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:static int32_t msm_camera_tz_tzbsp_reset_hw_block(uint32_t mask,
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:			msm_camera_tz_scm_call_name(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		msm_camera_tz_region_name(region),
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:int32_t msm_camera_tz_reset_hw_block(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	enum msm_camera_tz_io_region_t region)
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	CDBG("%s\n", msm_camera_tz_region_name(region));
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:	if (msm_camera_tz_is_secured(region) && msm_camera_tz_get_tzbsp_status(
media/platform/msm/camera_v2/common/msm_camera_tz_util.c:		rc = msm_camera_tz_tzbsp_reset_hw_block(mask, region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:enum msm_camera_tz_io_region_t {
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:enum msm_camera_tz_cmd_id_t {
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:enum msm_camera_tz_status_t {
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:#pragma pack(push, msm_camera_tz, 1)
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:struct msm_camera_tz_generic_req_t {
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:	enum msm_camera_tz_cmd_id_t  cmd_id;
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:struct msm_camera_tz_generic_rsp_t {
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:	enum msm_camera_tz_status_t  rc;
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:#pragma pack(pop, msm_camera_tz)
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:uint32_t msm_camera_tz_is_secured(
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:	enum msm_camera_tz_io_region_t region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:uint32_t msm_camera_tz_secure(uint32_t is_secure);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:uint32_t msm_camera_tz_region_to_hw_block(
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:	enum msm_camera_tz_io_region_t region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:int32_t msm_camera_tz_reset_hw_block(
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:	enum msm_camera_tz_io_region_t region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:uint32_t msm_camera_tz_r(void __iomem *base_addr, uint32_t offset,
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:	enum msm_camera_tz_io_region_t region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:void msm_camera_tz_w_mb(uint32_t data,
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:	enum msm_camera_tz_io_region_t region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:void msm_camera_tz_w(uint32_t data,
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:	enum msm_camera_tz_io_region_t region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:void msm_camera_tz_w_deferred(uint32_t data,
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:	enum msm_camera_tz_io_region_t region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:void msm_camera_tz_clear_tzbsp_status(void);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:void msm_camera_tz_dump(void __iomem *base_addr, int size, int enable,
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:	enum msm_camera_tz_io_region_t region);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:uint32_t msm_camera_tz_set_mode(
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:struct qseecom_handle *msm_camera_tz_get_ta_handle(void);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:int32_t msm_camera_tz_load_ta(void);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:int32_t msm_camera_tz_unload_ta(void);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:void msm_camera_tz_lock(void);
media/platform/msm/camera_v2/common/msm_camera_tz_util.h:void msm_camera_tz_unlock(void);
media/platform/msm/camera_v2/fd/Makefile:ccflags-y += -Idrivers/media/video/msm
media/platform/msm/camera_v2/fd/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/fd/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/fd/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/pproc/cpp
media/platform/msm/camera_v2/fd/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/msm_buf_mgr/
media/platform/msm/camera_v2/fd/Makefile:obj-$(CONFIG_MSM_FD) += msm_fd_dev.o msm_fd_hw.o
media/platform/msm/camera_v2/fd/msm_fd_dev.c:#include <linux/msm_ion.h>
media/platform/msm/camera_v2/fd/msm_fd_dev.c:#include "msm_fd_dev.h"
media/platform/msm/camera_v2/fd/msm_fd_dev.c:#include "msm_fd_hw.h"
media/platform/msm/camera_v2/fd/msm_fd_dev.c:#include "msm_fd_regs.h"
media/platform/msm/camera_v2/fd/msm_fd_dev.c:#define MSM_FD_DRV_NAME "msm_fd"
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_angle[] = {45, 135, 359};
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_dir[] = {0, 90, 270, 180};
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_min_size[] = {20, 25, 32, 40};
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static struct msm_fd_size fd_size[] = {
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_ctx_from_fh - Get fd context from v4l2 fh.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static inline struct fd_ctx *msm_fd_ctx_from_fh(struct v4l2_fh *fh)
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_get_format_index - Get format index from v4l2 format.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_get_format_index(struct v4l2_format *f)
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_get_idx_from_value - Get array index from value.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_get_idx_from_value(int value, int *array, int array_size)
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_fill_format_from_index - Fill v4l2 format struct from size index.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_fill_format_from_index(struct v4l2_format *f, int index)
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_fill_format_from_ctx - Fill v4l2 format struct from fd context.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_fill_format_from_ctx(struct v4l2_format *f, struct fd_ctx *c)
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_queue_setup - vb2_ops queue_setup callback.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_queue_setup(struct vb2_queue *q,
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_buf_init - vb2_ops buf_init callback.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_buf_init(struct vb2_buffer *vb)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_buffer *fd_buffer =
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		(struct msm_fd_buffer *)vb;
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_buf_queue - vb2_ops buf_queue callback.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static void msm_fd_buf_queue(struct vb2_buffer *vb)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_buffer *fd_buffer =
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		(struct msm_fd_buffer *)vb;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_fd_hw_add_buffer(ctx->fd_device, fd_buffer);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		msm_fd_hw_schedule_and_start(ctx->fd_device);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_start_streaming - vb2_ops start_streaming callback.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_start_streaming(struct vb2_queue *q, unsigned int count)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	ret = msm_fd_hw_get(ctx->fd_device, ctx->settings.speed);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	ret = msm_fd_hw_schedule_and_start(ctx->fd_device);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_stop_streaming - vb2_ops stop_streaming callback.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static void msm_fd_stop_streaming(struct vb2_queue *q)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_fd_hw_remove_buffers_from_queue(ctx->fd_device, q);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_fd_hw_put(ctx->fd_device);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static struct vb2_ops msm_fd_vb2_q_ops = {
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.queue_setup     = msm_fd_queue_setup,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.buf_init        = msm_fd_buf_init,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.buf_queue       = msm_fd_buf_queue,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.start_streaming = msm_fd_start_streaming,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.stop_streaming  = msm_fd_stop_streaming,
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_get_userptr - Map and get buffer handler for user pointer buffer.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static void *msm_fd_get_userptr(struct device *alloc_ctx,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_mem_pool *pool = (void *)alloc_ctx;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_buf_handle *buf;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	ret = msm_fd_hw_map_buffer(pool, vaddr, buf);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_put_userptr - Unmap and free buffer handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static void msm_fd_put_userptr(void *buf_priv)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_fd_hw_unmap_buffer(buf_priv);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static struct vb2_mem_ops msm_fd_vb2_mem_ops = {
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.get_userptr = msm_fd_get_userptr,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.put_userptr = msm_fd_put_userptr,
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_vbif_error_handler - FD VBIF Error handler
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_vbif_error_handler(void *handle, uint32_t error)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_device *fd;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_buffer *active_buf;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	fd = (struct msm_fd_device *)ctx->fd_device;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		msm_fd_hw_put(fd);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		msm_fd_hw_get(fd, ctx->settings.speed);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		active_buf = msm_fd_hw_get_active_buffer(fd, 1);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		msm_fd_hw_add_buffer(fd, active_buf);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		ret = msm_fd_hw_schedule_next_buffer(fd, 1);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_open - Fd device open method.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_open(struct file *file)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_device *device = video_drvdata(file);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	ctx->vb2_q.mem_ops = &msm_fd_vb2_mem_ops;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	ctx->vb2_q.ops = &msm_fd_vb2_q_ops;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	ctx->vb2_q.buf_struct_size = sizeof(struct msm_fd_buffer);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_cpp_vbif_register_error_handler((void *)ctx,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		VBIF_CLIENT_FD, msm_fd_vbif_error_handler);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_release - Fd device release method.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_release(struct file *file)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(file->private_data);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_cpp_vbif_register_error_handler((void *)ctx,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		msm_fd_hw_unmap_buffer(&ctx->work_buf);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_poll - Fd device pool method.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static unsigned int msm_fd_poll(struct file *file,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(file->private_data);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_private_ioctl - V4l2 private ioctl handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static long msm_fd_private_ioctl(struct file *file, void *fh,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_result *req_result = arg;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_stats *stats;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:					sizeof(struct msm_fd_face_data));
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_compat_ioctl32 - Compat ioctl handler function.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static long msm_fd_compat_ioctl32(struct file *file,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		struct msm_fd_result32 result32;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		struct msm_fd_result result;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		ret = msm_fd_private_ioctl(file, file->private_data,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.open           = msm_fd_open,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.release        = msm_fd_release,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.poll           = msm_fd_poll,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.compat_ioctl32 = msm_fd_compat_ioctl32,
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_querycap - V4l2 ioctl query capability handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_querycap(struct file *file,
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_enum_fmt_vid_out - V4l2 ioctl enumerate format handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_enum_fmt_vid_out(struct file *file,
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_g_fmt - V4l2 ioctl get format handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_g_fmt(struct file *file, void *fh, struct v4l2_format *f)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	return msm_fd_fill_format_from_ctx(f, ctx);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_try_fmt_vid_out - V4l2 ioctl try format handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_try_fmt_vid_out(struct file *file,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	index = msm_fd_get_format_index(f);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	return msm_fd_fill_format_from_index(f, index);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_s_fmt_vid_out - V4l2 ioctl set format handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_s_fmt_vid_out(struct file *file,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	index = msm_fd_get_format_index(f);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_fd_fill_format_from_index(f, index);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_reqbufs - V4l2 ioctl request buffers handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_reqbufs(struct file *file,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_qbuf - V4l2 ioctl queue buffer handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_qbuf(struct file *file, void *fh,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_dqbuf - V4l2 ioctl dequeue buffer handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_dqbuf(struct file *file,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_streamon - V4l2 ioctl stream on handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_streamon(struct file *file,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_streamoff - V4l2 ioctl stream off handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_streamoff(struct file *file,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_subscribe_event - V4l2 ioctl subscribe for event handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_subscribe_event(struct v4l2_fh *fh,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_unsubscribe_event - V4l2 ioctl unsubscribe from event handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_unsubscribe_event(struct v4l2_fh *fh,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_guery_ctrl - V4l2 ioctl query control.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_guery_ctrl(struct file *file, void *fh,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		strlcpy(a->name, "msm fd face speed idx",
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->default_value =  msm_fd_angle[MSM_FD_DEF_ANGLE_IDX];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->minimum = msm_fd_angle[0];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->maximum = msm_fd_angle[ARRAY_SIZE(msm_fd_angle) - 1];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		strlcpy(a->name, "msm fd face angle ctrl",
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->default_value = msm_fd_dir[MSM_FD_DEF_DIR_IDX];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->minimum = msm_fd_dir[0];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->maximum = msm_fd_dir[ARRAY_SIZE(msm_fd_dir) - 1];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		strlcpy(a->name, "msm fd face direction ctrl",
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->default_value = msm_fd_min_size[MSM_FD_DEF_MIN_SIZE_IDX];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->minimum = msm_fd_min_size[0];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->maximum = msm_fd_min_size[ARRAY_SIZE(msm_fd_min_size) - 1];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		strlcpy(a->name, "msm fd minimum face size (pixels)",
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		strlcpy(a->name, "msm fd detection threshold",
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		strlcpy(a->name, "msm fd working memory size",
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		strlcpy(a->name, "msm fd ion fd of working memory",
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_g_ctrl - V4l2 ioctl get control.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_g_ctrl(struct file *file, void *fh, struct v4l2_control *a)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->value = msm_fd_angle[ctx->settings.angle_index];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->value = msm_fd_dir[ctx->settings.direction_index];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->value = msm_fd_min_size[ctx->settings.min_size_index];
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_s_ctrl - V4l2 ioctl set control.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_s_ctrl(struct file *file, void *fh, struct v4l2_control *a)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		idx = msm_fd_get_idx_from_value(a->value, msm_fd_angle,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:			ARRAY_SIZE(msm_fd_angle));
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		if (idx < ARRAY_SIZE(msm_fd_angle))
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->value = msm_fd_angle[ctx->settings.angle_index];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		idx = msm_fd_get_idx_from_value(a->value, msm_fd_dir,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:			ARRAY_SIZE(msm_fd_dir));
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		if (idx < ARRAY_SIZE(msm_fd_dir))
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->value = msm_fd_dir[ctx->settings.direction_index];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		idx = msm_fd_get_idx_from_value(a->value, msm_fd_min_size,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:			ARRAY_SIZE(msm_fd_min_size));
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		if (idx < ARRAY_SIZE(msm_fd_min_size))
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		a->value = msm_fd_min_size[ctx->settings.min_size_index];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:			msm_fd_hw_unmap_buffer(&ctx->work_buf);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:			ret = msm_fd_hw_map_buffer(&ctx->mem_pool,
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_cropcap - V4l2 ioctl crop capabilities.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_cropcap(struct file *file, void *fh, struct v4l2_cropcap *a)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_g_crop - V4l2 ioctl get crop.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_g_crop(struct file *file, void *fh, struct v4l2_crop *crop)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_s_crop - V4l2 ioctl set crop.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int msm_fd_s_crop(struct file *file, void *fh,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct fd_ctx *ctx = msm_fd_ctx_from_fh(fh);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	min_face_size = msm_fd_min_size[ctx->settings.min_size_index];
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_querycap          = msm_fd_querycap,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_enum_fmt_vid_out  = msm_fd_enum_fmt_vid_out,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_g_fmt_vid_out     = msm_fd_g_fmt,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_try_fmt_vid_out   = msm_fd_try_fmt_vid_out,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_s_fmt_vid_out     = msm_fd_s_fmt_vid_out,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_reqbufs           = msm_fd_reqbufs,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_qbuf              = msm_fd_qbuf,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_dqbuf             = msm_fd_dqbuf,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_streamon          = msm_fd_streamon,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_streamoff         = msm_fd_streamoff,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_queryctrl         = msm_fd_guery_ctrl,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_s_ctrl            = msm_fd_s_ctrl,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_g_ctrl            = msm_fd_g_ctrl,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_cropcap           = msm_fd_cropcap,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_g_crop            = msm_fd_g_crop,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_s_crop            = msm_fd_s_crop,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_subscribe_event   = msm_fd_subscribe_event,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_unsubscribe_event = msm_fd_unsubscribe_event,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	.vidioc_default           = msm_fd_private_ioctl,
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_fill_results - Read and fill face detection result.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static void msm_fd_fill_results(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_face_data *face, int idx)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_fd_hw_get_result_angle_pose(fd, idx, &face->angle, &face->pose);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_fd_hw_get_result_conf_size(fd, idx, &face->confidence,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	face->face.left = msm_fd_hw_get_result_x(fd, idx);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	face->face.top = msm_fd_hw_get_result_y(fd, idx);
media/platform/msm/camera_v2/fd/msm_fd_dev.c: * msm_fd_wq_handler - Fd device workqueue handler.
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static void msm_fd_wq_handler(struct work_struct *work)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_buffer *active_buf;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_stats *stats;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_event *fd_event;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_device *fd;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	fd = container_of(work, struct msm_fd_device, work);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	active_buf = msm_fd_hw_get_active_buffer(fd, 0);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	stats->face_cnt = msm_fd_hw_get_face_count(fd);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		msm_fd_fill_results(fd, &stats->face_data[i], i);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		msm_fd_hw_schedule_next_buffer(fd, 0);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	fd_event = (struct msm_fd_event *)event.u.data;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_fd_hw_buffer_done(fd, active_buf, 0);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_device *fd;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	fd = kzalloc(sizeof(struct msm_fd_device), GFP_KERNEL);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	ret = msm_fd_hw_get_mem_resources(pdev, fd);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	ret = msm_camera_get_regulator_info(pdev, &fd->vdd_info,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	ret = msm_camera_get_clk_info_and_rates(pdev, &fd->clk_info,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:			msm_camera_set_clk_flags(fd->clk[i],
media/platform/msm/camera_v2/fd/msm_fd_dev.c:			msm_camera_set_clk_flags(fd->clk[i],
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	ret = msm_camera_register_bus_client(pdev, CAM_BUS_CLIENT_FD);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	ret = msm_fd_hw_get(fd, 0);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	fd->hw_revision = msm_fd_hw_get_revision(fd);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_fd_hw_put(fd);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	ret = msm_fd_hw_request_irq(pdev, fd, msm_fd_wq_handler);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_fd_hw_release_irq(fd);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_camera_unregister_bus_client(CAM_BUS_CLIENT_FD);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_camera_put_clk_info_and_rates(pdev, &fd->clk_info,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_camera_put_regulators(pdev, &fd->vdd_info, fd->num_reg);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_fd_hw_release_mem_resources(fd);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	struct msm_fd_device *fd;
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_fd_hw_release_irq(fd);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_camera_unregister_bus_client(CAM_BUS_CLIENT_FD);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_camera_put_clk_info_and_rates(pdev, &fd->clk_info,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_camera_put_regulators(pdev, &fd->vdd_info, fd->num_reg);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:	msm_fd_hw_release_mem_resources(fd);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static const struct of_device_id msm_fd_dt_match[] = {
media/platform/msm/camera_v2/fd/msm_fd_dev.c:		.of_match_table = msm_fd_dt_match,
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static int __init msm_fd_init_module(void)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:static void __exit msm_fd_exit_module(void)
media/platform/msm/camera_v2/fd/msm_fd_dev.c:module_init(msm_fd_init_module);
media/platform/msm/camera_v2/fd/msm_fd_dev.c:module_exit(msm_fd_exit_module);
media/platform/msm/camera_v2/fd/msm_fd_dev.h:#include <linux/msm-bus.h>
media/platform/msm/camera_v2/fd/msm_fd_dev.h:#include <media/msm_fd.h>
media/platform/msm/camera_v2/fd/msm_fd_dev.h:#include <linux/msm_ion.h>
media/platform/msm/camera_v2/fd/msm_fd_dev.h:#include "msm_cpp.h"
media/platform/msm/camera_v2/fd/msm_fd_dev.h: * struct msm_fd_size - Structure contain FD size related values.
media/platform/msm/camera_v2/fd/msm_fd_dev.h:struct msm_fd_size {
media/platform/msm/camera_v2/fd/msm_fd_dev.h: * struct msm_fd_setings - Structure contain FD settings values.
media/platform/msm/camera_v2/fd/msm_fd_dev.h:struct msm_fd_setings {
media/platform/msm/camera_v2/fd/msm_fd_dev.h: * struct msm_fd_format - Structure contain FD format settings.
media/platform/msm/camera_v2/fd/msm_fd_dev.h:struct msm_fd_format {
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_fd_size *size;
media/platform/msm/camera_v2/fd/msm_fd_dev.h: * struct msm_fd_mem_pool - Structure contain FD memory pool information.
media/platform/msm/camera_v2/fd/msm_fd_dev.h:struct msm_fd_mem_pool {
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_fd_device *fd_device;
media/platform/msm/camera_v2/fd/msm_fd_dev.h: * struct msm_fd_buf_handle - Structure contain FD buffer handle information.
media/platform/msm/camera_v2/fd/msm_fd_dev.h:struct msm_fd_buf_handle {
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_fd_mem_pool *pool;
media/platform/msm/camera_v2/fd/msm_fd_dev.h: * struct msm_fd_buffer - Vb2 buffer wrapper structure.
media/platform/msm/camera_v2/fd/msm_fd_dev.h:struct msm_fd_buffer {
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_fd_format format;
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_fd_setings settings;
media/platform/msm/camera_v2/fd/msm_fd_dev.h: * struct msm_fd_stats - Structure contains FD result statistic information.
media/platform/msm/camera_v2/fd/msm_fd_dev.h:struct msm_fd_stats {
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_fd_face_data face_data[MSM_FD_MAX_FACES_DETECTED];
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_fd_device *fd_device;
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_fd_format format;
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_fd_setings settings;
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_fd_mem_pool mem_pool;
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_fd_stats *stats;
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_fd_buf_handle work_buf;
media/platform/msm/camera_v2/fd/msm_fd_dev.h: * enum msm_fd_device_state - FD device state.
media/platform/msm/camera_v2/fd/msm_fd_dev.h:enum msm_fd_device_state {
media/platform/msm/camera_v2/fd/msm_fd_dev.h: * enum msm_fd_mem_resources - FD device iomem resources.
media/platform/msm/camera_v2/fd/msm_fd_dev.h:enum msm_fd_mem_resources {
media/platform/msm/camera_v2/fd/msm_fd_dev.h: * struct msm_fd_device - FD device structure.
media/platform/msm/camera_v2/fd/msm_fd_dev.h:struct msm_fd_device {
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_cam_clk_info *clk_info;
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	struct msm_cam_regulator *vdd_info;
media/platform/msm/camera_v2/fd/msm_fd_dev.h:	enum msm_fd_device_state state;
media/platform/msm/camera_v2/fd/msm_fd_hw.c:#include <linux/msm_ion.h>
media/platform/msm/camera_v2/fd/msm_fd_hw.c:#include <linux/msm-bus.h>
media/platform/msm/camera_v2/fd/msm_fd_hw.c:#include <linux/msm-bus-board.h>
media/platform/msm/camera_v2/fd/msm_fd_hw.c:#include "msm_fd_dev.h"
media/platform/msm/camera_v2/fd/msm_fd_hw.c:#include "msm_fd_hw.h"
media/platform/msm/camera_v2/fd/msm_fd_hw.c:#include "msm_fd_regs.h"
media/platform/msm/camera_v2/fd/msm_fd_hw.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/fd/msm_fd_hw.c:#define MSM_FD_BUS_CLIENT_NAME "msm_face_detect"
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * enum msm_fd_reg_setting_entries - FD register setting entries in DT.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:enum msm_fd_dt_reg_setting_index {
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_read_reg - Fd read from register.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline u32 msm_fd_hw_read_reg(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	enum msm_fd_mem_resources base_idx, u32 reg)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	return msm_camera_io_r(fd->iomem_base[base_idx] + reg);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_read_reg - Fd write to register.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline void msm_fd_hw_write_reg(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	enum msm_fd_mem_resources base_idx, u32 reg, u32 value)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_camera_io_w(value, fd->iomem_base[base_idx] + reg);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_reg_clr - Fd clear register bits.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline void msm_fd_hw_reg_clr(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	enum msm_fd_mem_resources mmio_range, u32 reg, u32 clr_bits)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	u32 bits = msm_fd_hw_read_reg(fd, mmio_range, reg);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, mmio_range, reg, (bits & ~clr_bits));
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_reg_clr - Fd set register bits.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline void msm_fd_hw_reg_set(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	enum msm_fd_mem_resources mmio_range, u32 reg, u32 set_bits)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	u32 bits = msm_fd_hw_read_reg(fd, mmio_range, reg);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, mmio_range, reg, (bits | set_bits));
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_reg_clr - Fd set size mode register.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline void msm_fd_hw_set_size_mode(struct msm_fd_device *fd, u32 mode)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_IMAGE_SIZE, mode);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_reg_clr - Fd set crop registers.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline void msm_fd_hw_set_crop(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_START_X,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_START_Y,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_SIZE_X,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_SIZE_Y,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_reg_clr - Fd set bytes per line register.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline void msm_fd_hw_set_bytesperline(struct msm_fd_device *fd, u32 b)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_LINE_BYTES,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_reg_clr - Fd set image address.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline void msm_fd_hw_set_image_addr(struct msm_fd_device *fd, u32 addr)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_IMAGE_ADDR, addr);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_set_work_addr - Fd set working buffer address.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline void msm_fd_hw_set_work_addr(struct msm_fd_device *fd, u32 addr)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_WORK_ADDR, addr);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_set_direction_angle - Fd set face direction and face angle.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline void msm_fd_hw_set_direction_angle(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	reg = msm_fd_hw_read_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_CONDT);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_CONDT, reg);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_set_min_face - Fd set minimum face size register.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline void msm_fd_hw_set_min_face(struct msm_fd_device *fd, u32 size)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	reg = msm_fd_hw_read_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_CONDT);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_CONDT, reg);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_set_threshold - Fd set detection threshold register.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline void msm_fd_hw_set_threshold(struct msm_fd_device *fd, u32 thr)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_DHINT,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_srst - Sw reset control registers.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline void msm_fd_hw_srst(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_CONTROL,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_CONTROL, 0);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_get_face_count - Fd read face count register.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:int msm_fd_hw_get_face_count(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	reg = msm_fd_hw_read_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_RESULT_CNT);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_run - Starts face detection engine.
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * (see function msm_fd_hw_srst).
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static inline void msm_fd_hw_run(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_CONTROL,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_is_finished - Check if fd hw engine is done with processing.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static int msm_fd_hw_is_finished(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	reg = msm_fd_hw_read_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_CONTROL);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_is_runnig - Check if fd hw engine is busy.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static int msm_fd_hw_is_runnig(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	reg = msm_fd_hw_read_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_CONTROL);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_misc_irq_is_core - Check if fd received misc core irq.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static int msm_fd_hw_misc_irq_is_core(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	reg = msm_fd_hw_read_reg(fd, MSM_FD_IOMEM_MISC,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_misc_irq_is_halt - Check if fd received misc halt irq.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static int msm_fd_hw_misc_irq_is_halt(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	reg = msm_fd_hw_read_reg(fd, MSM_FD_IOMEM_MISC,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_misc_clear_all_irq - Clear all misc irq statuses.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static void msm_fd_hw_misc_clear_all_irq(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_MISC, MSM_FD_MISC_IRQ_CLEAR,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_misc_irq_enable - Enable fd misc core and halt irq.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static void msm_fd_hw_misc_irq_enable(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_reg_set(fd, MSM_FD_IOMEM_MISC, MSM_FD_MISC_IRQ_MASK,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_misc_irq_disable - Disable fd misc core and halt irq.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static void msm_fd_hw_misc_irq_disable(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_reg_clr(fd, MSM_FD_IOMEM_MISC, MSM_FD_MISC_IRQ_MASK,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_get_revision - Get hw revision and store in to device.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:int msm_fd_hw_get_revision(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	reg = msm_fd_hw_read_reg(fd, MSM_FD_IOMEM_MISC,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_get_result_x - Get fd result center x coordinate.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:int msm_fd_hw_get_result_x(struct msm_fd_device *fd, int idx)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	reg = msm_fd_hw_read_reg(fd, MSM_FD_IOMEM_CORE,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_get_result_y - Get fd result center y coordinate.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:int msm_fd_hw_get_result_y(struct msm_fd_device *fd, int idx)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	reg = msm_fd_hw_read_reg(fd, MSM_FD_IOMEM_CORE,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_get_result_conf_size - Get fd result confident level and size.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:void msm_fd_hw_get_result_conf_size(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	reg = msm_fd_hw_read_reg(fd, MSM_FD_IOMEM_CORE,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_get_result_angle_pose - Get fd result angle and pose.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:void msm_fd_hw_get_result_angle_pose(struct msm_fd_device *fd, int idx,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	reg = msm_fd_hw_read_reg(fd, MSM_FD_IOMEM_CORE,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_misc_irq_supported - Check if misc irq is supported.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static int msm_fd_hw_misc_irq_supported(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_halt - Halt fd core.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static void msm_fd_hw_halt(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	if (msm_fd_hw_misc_irq_supported(fd)) {
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_MISC, MSM_FD_HW_STOP, 1);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_MISC, MSM_FD_MISC_SW_RESET,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_CONTROL,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_MISC,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_fd_hw_write_reg(fd, MSM_FD_IOMEM_CORE, MSM_FD_CONTROL, 0);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_core_irq - Face detection core irq handler.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static irqreturn_t msm_fd_hw_core_irq(int irq, void *dev_id)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_device *fd = dev_id;
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	if (msm_fd_hw_is_finished(fd))
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_misc_irq - Face detection misc irq handler.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static irqreturn_t msm_fd_hw_misc_irq(int irq, void *dev_id)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_device *fd = dev_id;
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	if (msm_fd_hw_misc_irq_is_core(fd))
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_fd_hw_core_irq(irq, dev_id);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	if (msm_fd_hw_misc_irq_is_halt(fd))
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_misc_clear_all_irq(fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_request_irq - Configure and enable vbif interface.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:int msm_fd_hw_request_irq(struct platform_device *pdev,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_device *fd, work_func_t work_func)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	fd->irq = msm_camera_get_irq(pdev, "fd");
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	if (msm_fd_hw_misc_irq_supported(fd)) {
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		ret = msm_camera_register_irq(pdev,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:				fd->irq, msm_fd_hw_misc_irq,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		ret = msm_camera_register_irq(pdev,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:				fd->irq, msm_fd_hw_core_irq,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_camera_unregister_irq(pdev, fd->irq, fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_release_irq - Free core and wrap irq.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:void msm_fd_hw_release_irq(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_camera_unregister_irq(fd->pdev, fd->irq, fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_set_dt_parms_by_name() - read DT params and write to registers.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static int32_t msm_fd_hw_set_dt_parms_by_name(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:			enum msm_fd_mem_resources base_idx)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:			msm_fd_hw_reg_clr(fd, base_idx,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:			msm_fd_hw_reg_set(fd, base_idx,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_set_dt_parms() - set FD device tree configuration.
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_set_dt_parms_by_name() for each property.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static int msm_fd_hw_set_dt_parms(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		rc = msm_fd_hw_set_dt_parms_by_name(fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_release_mem_resources - Releases memory resources.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:void msm_fd_hw_release_mem_resources(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_camera_put_reg_base(fd->pdev,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_camera_put_reg_base(fd->pdev,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_camera_put_reg_base(fd->pdev,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_get_mem_resources - Get memory resources.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:int msm_fd_hw_get_mem_resources(struct platform_device *pdev,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_camera_get_reg_base(pdev, "fd_core", true);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_camera_get_reg_base(pdev, "fd_misc", true);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_camera_get_reg_base(pdev, "fd_vbif", false);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_camera_put_reg_base(pdev,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_camera_put_reg_base(pdev,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_bus_request - Request bus for memory access.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static int msm_fd_hw_bus_request(struct msm_fd_device *fd, unsigned int idx)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	ret = msm_camera_update_bus_vector(CAM_BUS_CLIENT_FD, idx);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_set_clock_rate_idx - Set clock rate based on the index.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static int msm_fd_hw_set_clock_rate_idx(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		ret = msm_camera_clk_set_rate(&fd->pdev->dev,
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_update_settings() - API to set clock rate and bus settings
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static int msm_fd_hw_update_settings(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:				struct msm_fd_buffer *buf)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		ret = msm_fd_hw_bus_request(fd, clk_rate_idx);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	ret = msm_fd_hw_set_clock_rate_idx(fd, clk_rate_idx);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_get - Get fd hw for performing any hw operation.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:int msm_fd_hw_get(struct msm_fd_device *fd, unsigned int clock_rate_idx)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:			msm_camera_regulator_enable(fd->vdd_info,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		ret = msm_fd_hw_bus_request(fd, clock_rate_idx);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		ret = msm_fd_hw_set_clock_rate_idx(fd, clock_rate_idx);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		ret = msm_camera_clk_enable(&fd->pdev->dev, fd->clk_info,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		if (msm_fd_hw_misc_irq_supported(fd))
media/platform/msm/camera_v2/fd/msm_fd_hw.c:			msm_fd_hw_misc_irq_enable(fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		ret = msm_fd_hw_set_dt_parms(fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	if (msm_fd_hw_misc_irq_supported(fd))
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_fd_hw_misc_irq_disable(fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_camera_clk_enable(&fd->pdev->dev, fd->clk_info,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_camera_regulator_enable(fd->vdd_info, fd->num_reg, false);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_get - Put fd hw.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:void msm_fd_hw_put(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_fd_hw_halt(fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		if (msm_fd_hw_misc_irq_supported(fd))
media/platform/msm/camera_v2/fd/msm_fd_hw.c:			msm_fd_hw_misc_irq_disable(fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_fd_hw_bus_request(fd, 0);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_camera_clk_enable(&fd->pdev->dev, fd->clk_info,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_camera_regulator_enable(fd->vdd_info, fd->num_reg, false);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_attach_iommu - Attach iommu to face detection engine.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static int msm_fd_hw_attach_iommu(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_detach_iommu - Detach iommu from face detection engine.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static void msm_fd_hw_detach_iommu(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_map_buffer - Map buffer to fd hw mmu.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:int msm_fd_hw_map_buffer(struct msm_fd_mem_pool *pool, int fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_buf_handle *buf)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	ret = msm_fd_hw_attach_iommu(pool->fd_device);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_unmap_buffer - Unmap buffer from fd hw mmu.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:void msm_fd_hw_unmap_buffer(struct msm_fd_buf_handle *buf)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_fd_hw_detach_iommu(buf->pool->fd_device);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_enable - Configure and enable fd hw.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static int msm_fd_hw_enable(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_buffer *buffer)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_buf_handle *buf_handle =
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	if (msm_fd_hw_is_runnig(fd)) {
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_srst(fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_set_size_mode(fd, buffer->format.size->reg_val);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_set_crop(fd, &buffer->format.crop);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_set_bytesperline(fd, buffer->format.bytesperline);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_set_image_addr(fd, buf_handle->addr);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_set_work_addr(fd, buffer->work_addr);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_set_min_face(fd, buffer->settings.min_size_index);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_set_threshold(fd, buffer->settings.threshold);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_set_direction_angle(fd, buffer->settings.direction_index,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_run(fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_try_enable - Try to enable fd hw.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:static int msm_fd_hw_try_enable(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_buffer *buffer, enum msm_fd_device_state state)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_fd_hw_enable(fd, buffer);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_next_buffer - Get next buffer from fd device processing queue.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:struct msm_fd_buffer *msm_fd_hw_get_next_buffer(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_buffer *buffer = NULL;
media/platform/msm/camera_v2/fd/msm_fd_hw.c:			struct msm_fd_buffer, list);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_add_buffer - Add buffer to fd device processing queue.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:void msm_fd_hw_add_buffer(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_buffer *buffer)
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_remove_buffers_from_queue - Removes buffer from
media/platform/msm/camera_v2/fd/msm_fd_hw.c:void msm_fd_hw_remove_buffers_from_queue(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_buffer *curr_buff;
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_buffer *temp;
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_buffer *active_buffer;
media/platform/msm/camera_v2/fd/msm_fd_hw.c:				msm_fd_hw_get_active_buffer(fd, 0);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:				msm_fd_hw_schedule_next_buffer(fd, 0);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_buffer_done - Mark as done and removes from processing queue.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:int msm_fd_hw_buffer_done(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_buffer *buffer, u8 lock_flag)
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_get_active_buffer - Get active buffer from fd processing queue.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:struct msm_fd_buffer *msm_fd_hw_get_active_buffer(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_buffer *buffer = NULL;
media/platform/msm/camera_v2/fd/msm_fd_hw.c:			struct msm_fd_buffer, list);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_schedule_and_start - Schedule active buffer and start processing.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:int msm_fd_hw_schedule_and_start(struct msm_fd_device *fd)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_buffer *buf;
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	buf = msm_fd_hw_get_next_buffer(fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		msm_fd_hw_try_enable(fd, buf, MSM_FD_DEVICE_IDLE);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_update_settings(fd, buf);
media/platform/msm/camera_v2/fd/msm_fd_hw.c: * msm_fd_hw_schedule_next_buffer - Schedule next buffer and start processing.
media/platform/msm/camera_v2/fd/msm_fd_hw.c:int msm_fd_hw_schedule_next_buffer(struct msm_fd_device *fd, u8 lock_flag)
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	struct msm_fd_buffer *buf;
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		buf = msm_fd_hw_get_next_buffer(fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:			ret = msm_fd_hw_try_enable(fd, buf,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:		buf = msm_fd_hw_get_next_buffer(fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.c:			ret = msm_fd_hw_try_enable(fd, buf,
media/platform/msm/camera_v2/fd/msm_fd_hw.c:	msm_fd_hw_update_settings(fd, buf);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:#include "msm_fd_dev.h"
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_get_face_count(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_get_result_x(struct msm_fd_device *fd, int idx);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_get_result_y(struct msm_fd_device *fd, int idx);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:void msm_fd_hw_get_result_conf_size(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.h:void msm_fd_hw_get_result_angle_pose(struct msm_fd_device *fd, int idx,
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_request_irq(struct platform_device *pdev,
media/platform/msm/camera_v2/fd/msm_fd_hw.h:	struct msm_fd_device *fd, work_func_t work_func);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:void msm_fd_hw_release_irq(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_get_revision(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:void msm_fd_hw_release_mem_resources(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_get_mem_resources(struct platform_device *pdev,
media/platform/msm/camera_v2/fd/msm_fd_hw.h:	struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_get_iommu(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:void msm_fd_hw_put_iommu(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_get_regulators(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_put_regulators(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_get_clocks(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_put_clocks(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_get_bus(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:void msm_fd_hw_put_bus(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_get(struct msm_fd_device *fd, unsigned int clock_rate_idx);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:void msm_fd_hw_put(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_map_buffer(struct msm_fd_mem_pool *pool, int fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.h:	struct msm_fd_buf_handle *buf);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:void msm_fd_hw_unmap_buffer(struct msm_fd_buf_handle *buf);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:void msm_fd_hw_add_buffer(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.h:	struct msm_fd_buffer *buffer);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:void msm_fd_hw_remove_buffers_from_queue(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_buffer_done(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.h:	struct msm_fd_buffer *buffer, u8 lock_flag);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:struct msm_fd_buffer *msm_fd_hw_get_active_buffer(struct msm_fd_device *fd,
media/platform/msm/camera_v2/fd/msm_fd_hw.h:struct msm_fd_buffer *msm_fd_hw_get_next_buffer(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_schedule_and_start(struct msm_fd_device *fd);
media/platform/msm/camera_v2/fd/msm_fd_hw.h:int msm_fd_hw_schedule_next_buffer(struct msm_fd_device *fd, u8 lock_flag);
media/platform/msm/camera_v2/isp/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/isp/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/isp/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common/
media/platform/msm/camera_v2/isp/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_isp_32.o msm_buf_mgr.o msm_isp_util_32.o msm_isp_axi_util_32.o msm_isp_stats_util_32.o
media/platform/msm/camera_v2/isp/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_isp32.o
media/platform/msm/camera_v2/isp/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_buf_mgr.o msm_isp_util.o msm_isp_axi_util.o msm_isp_stats_util.o
media/platform/msm/camera_v2/isp/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_isp48.o msm_isp47.o msm_isp46.o msm_isp44.o msm_isp40.o msm_isp.o
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:#include <media/msmb_generic_buf_mgr.h>
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:#include "msm.h"
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:#include "msm_buf_mgr.h"
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_buf_check_head_sanity(struct msm_isp_bufq *bufq)
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static struct msm_isp_bufq *msm_isp_get_bufq(
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static struct msm_isp_buffer *msm_isp_get_buf_ptr(
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static uint32_t msm_isp_get_buf_handle(
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_free_bufq_handle(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq =
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		msm_isp_get_bufq(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static void msm_isp_copy_planes_from_v4l2_buffer(
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_qbuf_buffer *qbuf_buf,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_prepare_v4l2_buf(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_qbuf_buffer *qbuf_buf,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer_mapped_info *mapped_info;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, buf_info->bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static void msm_isp_unprepare_v4l2_buf(
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer_mapped_info *mapped_info;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, buf_info->bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_map_buf(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer_mapped_info *mapped_info, uint32_t fd)
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_unmap_buf(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_buf_prepare(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_qbuf_info *info, struct vb2_v4l2_buffer *vb2_v4l2_buf)
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_qbuf_buffer buf;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	buf_info = msm_isp_get_buf_ptr(buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, buf_info->bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		msm_isp_copy_planes_from_v4l2_buffer(&buf,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	rc = msm_isp_prepare_v4l2_buf(buf_mgr, buf_info, &buf, bufq->stream_id);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_buf_unprepare_all(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, buf_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		buf_info = msm_isp_get_buf_ptr(buf_mgr, buf_handle, i);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		msm_isp_unprepare_v4l2_buf(buf_mgr, buf_info, bufq->stream_id);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_get_buf_by_index(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer **buf_info)
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *temp_buf_info;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_buf_unprepare(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, buf_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	buf_info = msm_isp_get_buf_ptr(buf_mgr, buf_handle, buf_idx);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	msm_isp_unprepare_v4l2_buf(buf_mgr, buf_info, bufq->stream_id);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_get_buf(struct msm_isp_buf_mgr *buf_mgr, uint32_t id,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer **buf_info)
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *temp_buf_info = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:				if (msm_buf_check_head_sanity(bufq) < 0) {
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_put_buf_unsafe(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	buf_info = msm_isp_get_buf_ptr(buf_mgr, bufq_handle, buf_index);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:			if (msm_buf_check_head_sanity(bufq) < 0) {
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_put_buf(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	buf_info = msm_isp_get_buf_ptr(buf_mgr, bufq_handle, buf_index);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	rc = msm_isp_put_buf_unsafe(buf_mgr, bufq_handle, buf_index);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_buf_divert(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	buf_info = msm_isp_get_buf_ptr(buf_mgr, bufq_handle, buf_index);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_buf_err(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	enum msm_isp_buffer_state state;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	buf_info = msm_isp_get_buf_ptr(buf_mgr, bufq_handle, buf_index);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		rc = msm_isp_put_buf_unsafe(buf_mgr, buf_info->bufq_handle,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_buf_done(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	enum msm_isp_buffer_state state;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	buf_info = msm_isp_get_buf_ptr(buf_mgr, bufq_handle, buf_index);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		rc = msm_isp_put_buf_unsafe(buf_mgr, buf_info->bufq_handle,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_flush_buf(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	uint32_t bufq_handle, enum msm_isp_buffer_flush_t flush_type,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		buf_info = msm_isp_get_buf_ptr(buf_mgr, bufq_handle, i);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:			msm_isp_put_buf_unsafe(buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:			msm_isp_put_buf_unsafe(buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_buf_enqueue(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_qbuf_info *info)
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, info->handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	buf_state = msm_isp_buf_prepare(buf_mgr, info, NULL);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		buf_info = msm_isp_get_buf_ptr(buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:			rc = msm_isp_put_buf(buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:				rc = msm_isp_buf_done(buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:			buf_info = msm_isp_get_buf_ptr(buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:			rc = msm_isp_put_buf(buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_buf_dequeue(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_qbuf_info *info)
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *buf_info = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	buf_info = msm_isp_get_buf_ptr(buf_mgr, info->handle, info->buf_idx);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	msm_isp_buf_unprepare(buf_mgr, info->handle, info->buf_idx);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_get_bufq_handle(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_get_buf_src(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_request_bufq(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buf_request_ver2 *buf_request)
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	buf_request->handle = msm_isp_get_buf_handle(buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, buf_request->handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq->bufs = kzalloc(sizeof(struct msm_isp_buffer) *
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		msm_isp_free_bufq_handle(buf_mgr, buf_request->handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_release_bufq(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	bufq = msm_isp_get_bufq(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	msm_isp_buf_unprepare_all(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	msm_isp_free_bufq_handle(buf_mgr, bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static void msm_isp_release_all_bufq(
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buf_mgr *buf_mgr)
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		msm_isp_buf_unprepare_all(buf_mgr, bufq->bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		msm_isp_free_bufq_handle(buf_mgr, bufq->bufq_handle);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c: * msm_isp_buf_put_scratch() - Release scratch buffers
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_buf_put_scratch(struct msm_isp_buf_mgr *buf_mgr)
media/platform/msm/camera_v2/isp/msm_buf_mgr.c: * msm_isp_buf_get_scratch() - Create scratch buffers
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_buf_get_scratch(struct msm_isp_buf_mgr *buf_mgr)
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:			msm_isp_buf_put_scratch(buf_mgr);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:int msm_isp_smmu_attach(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_vfe_smmu_attach_cmd *cmd = arg;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		rc = msm_isp_buf_get_scratch(buf_mgr);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_init_isp_buf_mgr(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_deinit_isp_buf_mgr(
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buf_mgr *buf_mgr)
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	msm_isp_release_all_bufq(buf_mgr);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	msm_isp_buf_put_scratch(buf_mgr);
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:int msm_isp_proc_buf_cmd(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		struct msm_isp_buf_request *buf_req = arg;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		struct msm_isp_buf_request_ver2 buf_req_ver2;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:			sizeof(struct msm_isp_buf_request));
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:			sizeof(struct msm_isp_buf_request));
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		struct msm_isp_buf_request_ver2 *buf_req_ver2 = arg;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		struct msm_isp_qbuf_info *qbuf_info = arg;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		struct msm_isp_qbuf_info *qbuf_info = arg;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		struct msm_isp_buf_request *buf_req = arg;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:		struct msm_isp_unmap_buf_req *unmap_req = arg;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static int msm_isp_buf_mgr_debug(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buffer *bufs = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	enum msm_isp_buffer_state debug_state = MSM_ISP_BUFFER_STATE_UNUSED;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:static struct msm_isp_buf_ops isp_buf_ops = {
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.request_buf = msm_isp_request_bufq,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.enqueue_buf = msm_isp_buf_enqueue,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.dequeue_buf = msm_isp_buf_dequeue,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.release_buf = msm_isp_release_bufq,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.get_bufq_handle = msm_isp_get_bufq_handle,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.get_buf_src = msm_isp_get_buf_src,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.get_buf = msm_isp_get_buf,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.get_buf_by_index = msm_isp_get_buf_by_index,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.map_buf = msm_isp_map_buf,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.unmap_buf = msm_isp_unmap_buf,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.put_buf = msm_isp_put_buf,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.flush_buf = msm_isp_flush_buf,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.buf_done = msm_isp_buf_done,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.buf_mgr_init = msm_isp_init_isp_buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.buf_mgr_deinit = msm_isp_deinit_isp_buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.buf_mgr_debug = msm_isp_buf_mgr_debug,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.get_bufq = msm_isp_get_bufq,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.buf_divert = msm_isp_buf_divert,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	.buf_err = msm_isp_buf_err,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:int msm_isp_create_isp_buf_mgr(
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.c:	struct msm_sd_req_vb2_q *vb2_ops,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:#include <media/msmb_isp.h>
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:#include "msm_sd.h"
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:struct msm_isp_buf_mgr;
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:enum msm_isp_buffer_src_t {
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:enum msm_isp_buffer_state {
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:enum msm_isp_buffer_put_state {
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:enum msm_isp_buffer_flush_t {
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:enum msm_isp_buf_mgr_state {
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:struct msm_isp_buffer_mapped_info {
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	struct msm_isp_buffer_mapped_info *mapped_info;
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:struct msm_isp_buffer_debug_t {
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	enum msm_isp_buffer_put_state put_state[2];
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:struct msm_isp_buffer {
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	struct msm_isp_buffer_mapped_info mapped_info[VIDEO_MAX_PLANES];
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	enum msm_isp_buffer_state state;
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	struct msm_isp_buffer_debug_t buf_debug;
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:struct msm_isp_bufq {
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	enum msm_isp_buf_type buf_type;
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	struct msm_isp_buffer *bufs;
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:struct msm_isp_buf_ops {
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*request_buf)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:		struct msm_isp_buf_request_ver2 *buf_request);
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*enqueue_buf)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:		struct msm_isp_qbuf_info *info);
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*dequeue_buf)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:		struct msm_isp_qbuf_info *info);
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*release_buf)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*get_bufq_handle)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*get_buf_src)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*get_buf)(struct msm_isp_buf_mgr *buf_mgr, uint32_t id,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:		struct msm_isp_buffer **buf_info);
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*get_buf_by_index)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:		struct msm_isp_buffer **buf_info);
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*map_buf)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:		struct msm_isp_buffer_mapped_info *mapped_info, uint32_t fd);
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*unmap_buf)(struct msm_isp_buf_mgr *buf_mgr, uint32_t fd);
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*put_buf)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*flush_buf)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	uint32_t bufq_handle, enum msm_isp_buffer_flush_t flush_type,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*buf_done)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	void (*register_ctx)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*buf_mgr_init)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*buf_mgr_deinit)(struct msm_isp_buf_mgr *buf_mgr);
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*buf_mgr_debug)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	struct msm_isp_bufq * (*get_bufq)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*buf_divert)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	int (*buf_err)(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:struct msm_isp_buf_mgr {
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	struct msm_isp_bufq bufq[BUF_MGR_NUM_BUF_Q];
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	struct msm_isp_buf_ops *ops;
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	struct msm_sd_req_vb2_q *vb2_ops;
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	enum msm_isp_buf_mgr_state attach_state;
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:int msm_isp_create_isp_buf_mgr(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:	struct msm_sd_req_vb2_q *vb2_ops, struct device *dev,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:int msm_isp_proc_buf_cmd(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_buf_mgr.h:int msm_isp_smmu_attach(struct msm_isp_buf_mgr *buf_mgr,
media/platform/msm/camera_v2/isp/msm_isp.c:#include "msm_isp.h"
media/platform/msm/camera_v2/isp/msm_isp.c:#include "msm_isp_util.h"
media/platform/msm/camera_v2/isp/msm_isp.c:#include "msm_isp_axi_util.h"
media/platform/msm/camera_v2/isp/msm_isp.c:#include "msm_isp_stats_util.h"
media/platform/msm/camera_v2/isp/msm_isp.c:#include "msm_sd.h"
media/platform/msm/camera_v2/isp/msm_isp.c:#include "msm_isp48.h"
media/platform/msm/camera_v2/isp/msm_isp.c:#include "msm_isp47.h"
media/platform/msm/camera_v2/isp/msm_isp.c:#include "msm_isp46.h"
media/platform/msm/camera_v2/isp/msm_isp.c:#include "msm_isp44.h"
media/platform/msm/camera_v2/isp/msm_isp.c:#include "msm_isp40.h"
media/platform/msm/camera_v2/isp/msm_isp.c:#include "msm_isp32.h"
media/platform/msm/camera_v2/isp/msm_isp.c:#include "msm_cam_cx_ipeak.h"
media/platform/msm/camera_v2/isp/msm_isp.c:static struct msm_sd_req_vb2_q vfe_vb2_ops;
media/platform/msm/camera_v2/isp/msm_isp.c:static struct msm_isp_buf_mgr vfe_buf_mgr;
media/platform/msm/camera_v2/isp/msm_isp.c:static struct msm_vfe_common_dev_data vfe_common_data;
media/platform/msm/camera_v2/isp/msm_isp.c:static const struct of_device_id msm_vfe_dt_match[] = {
media/platform/msm/camera_v2/isp/msm_isp.c:MODULE_DEVICE_TABLE(of, msm_vfe_dt_match);
media/platform/msm/camera_v2/isp/msm_isp.c:static int msm_isp_enable_debugfs(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp.c:	  struct msm_isp_bw_req_info *isp_req_hist);
media/platform/msm/camera_v2/isp/msm_isp.c:static struct msm_isp_bw_req_info
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_bw_request_history[MAX_DEPTH_BW_REQ_HISTORY];
media/platform/msm/camera_v2/isp/msm_isp.c:static int msm_isp_bw_request_history_idx;
media/platform/msm/camera_v2/isp/msm_isp.c:	struct msm_isp_statistics *stats = vfe_dev->stats;
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_util_get_bandwidth_stats(vfe_dev, stats);
media/platform/msm/camera_v2/isp/msm_isp.c:	struct msm_isp_statistics *stats = vfe_dev->stats;
media/platform/msm/camera_v2/isp/msm_isp.c:	memset(stats, 0, sizeof(struct msm_isp_statistics));
media/platform/msm/camera_v2/isp/msm_isp.c:	return sizeof(struct msm_isp_statistics);
media/platform/msm/camera_v2/isp/msm_isp.c:	struct msm_isp_bw_req_info *isp_req_hist =
media/platform/msm/camera_v2/isp/msm_isp.c:		(struct msm_isp_bw_req_info *) t_file->private_data;
media/platform/msm/camera_v2/isp/msm_isp.c:	struct msm_isp_bw_req_info *isp_req_hist =
media/platform/msm/camera_v2/isp/msm_isp.c:		(struct msm_isp_bw_req_info *) t_file->private_data;
media/platform/msm/camera_v2/isp/msm_isp.c:	memset(isp_req_hist, 0, sizeof(msm_isp_bw_request_history));
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_bw_request_history_idx = 0;
media/platform/msm/camera_v2/isp/msm_isp.c:	return sizeof(msm_isp_bw_request_history);
media/platform/msm/camera_v2/isp/msm_isp.c:	struct msm_isp_ub_info *ub_info = vfe_dev->ub_info;
media/platform/msm/camera_v2/isp/msm_isp.c:	struct msm_isp_ub_info *ub_info = vfe_dev->ub_info;
media/platform/msm/camera_v2/isp/msm_isp.c:	memset(ub_info, 0, sizeof(struct msm_isp_ub_info));
media/platform/msm/camera_v2/isp/msm_isp.c:	return sizeof(struct msm_isp_ub_info);
media/platform/msm/camera_v2/isp/msm_isp.c:static int msm_isp_enable_debugfs(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp.c:	struct msm_isp_bw_req_info *isp_req_hist)
media/platform/msm/camera_v2/isp/msm_isp.c:	snprintf(dirname, sizeof(dirname), "msm_isp%d", vfe_dev->pdev->id);
media/platform/msm/camera_v2/isp/msm_isp.c:void msm_isp_update_req_history(uint32_t client, uint64_t ab,
media/platform/msm/camera_v2/isp/msm_isp.c:				 struct msm_isp_bandwidth_info *client_info,
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_bw_request_history[msm_isp_bw_request_history_idx].client =
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_bw_request_history[msm_isp_bw_request_history_idx].timestamp =
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_bw_request_history[msm_isp_bw_request_history_idx].total_ab =
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_bw_request_history[msm_isp_bw_request_history_idx].total_ib =
media/platform/msm/camera_v2/isp/msm_isp.c:		msm_isp_bw_request_history[msm_isp_bw_request_history_idx]
media/platform/msm/camera_v2/isp/msm_isp.c:		msm_isp_bw_request_history[msm_isp_bw_request_history_idx]
media/platform/msm/camera_v2/isp/msm_isp.c:		msm_isp_bw_request_history[msm_isp_bw_request_history_idx]
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_bw_request_history_idx = (msm_isp_bw_request_history_idx + 1)
media/platform/msm/camera_v2/isp/msm_isp.c:void msm_isp_update_last_overflow_ab_ib(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp.c:	vfe_dev->msm_isp_last_overflow_ab =
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_bw_request_history[msm_isp_bw_request_history_idx].total_ab;
media/platform/msm/camera_v2/isp/msm_isp.c:	vfe_dev->msm_isp_last_overflow_ib =
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_bw_request_history[msm_isp_bw_request_history_idx].total_ib;
media/platform/msm/camera_v2/isp/msm_isp.c:static long msm_isp_dqevent(struct file *file, struct v4l2_fh *vfh, void *arg)
media/platform/msm/camera_v2/isp/msm_isp.c:		struct msm_isp_event_data32 *event_data32;
media/platform/msm/camera_v2/isp/msm_isp.c:		struct msm_isp_event_data  *event_data;
media/platform/msm/camera_v2/isp/msm_isp.c:			struct msm_isp_event_data_nanosec *event_data_nanosec;
media/platform/msm/camera_v2/isp/msm_isp.c:			struct msm_isp_event_data_nanosec
media/platform/msm/camera_v2/isp/msm_isp.c:				(struct msm_isp_event_data_nanosec *)
media/platform/msm/camera_v2/isp/msm_isp.c:				(struct msm_isp_event_data_nanosec *)
media/platform/msm/camera_v2/isp/msm_isp.c:				sizeof(struct msm_isp_event_data_nanosec));
media/platform/msm/camera_v2/isp/msm_isp.c:			event_data = (struct msm_isp_event_data *)
media/platform/msm/camera_v2/isp/msm_isp.c:			event_data32 = (struct msm_isp_event_data32 *)
media/platform/msm/camera_v2/isp/msm_isp.c:					sizeof(struct msm_isp_event_data32));
media/platform/msm/camera_v2/isp/msm_isp.c:static long msm_isp_dqevent(struct file *file, struct v4l2_fh *vfh, void *arg)
media/platform/msm/camera_v2/isp/msm_isp.c:static long msm_isp_subdev_do_ioctl(
media/platform/msm/camera_v2/isp/msm_isp.c:		return msm_isp_dqevent(file, vfh, arg);
media/platform/msm/camera_v2/isp/msm_isp.c:static struct v4l2_subdev_core_ops msm_vfe_v4l2_subdev_core_ops = {
media/platform/msm/camera_v2/isp/msm_isp.c:	.ioctl = msm_isp_ioctl,
media/platform/msm/camera_v2/isp/msm_isp.c:	.subscribe_event = msm_isp_subscribe_event,
media/platform/msm/camera_v2/isp/msm_isp.c:	.unsubscribe_event = msm_isp_unsubscribe_event,
media/platform/msm/camera_v2/isp/msm_isp.c:static struct v4l2_subdev_ops msm_vfe_v4l2_subdev_ops = {
media/platform/msm/camera_v2/isp/msm_isp.c:	.core = &msm_vfe_v4l2_subdev_core_ops,
media/platform/msm/camera_v2/isp/msm_isp.c:static struct v4l2_subdev_internal_ops msm_vfe_subdev_internal_ops = {
media/platform/msm/camera_v2/isp/msm_isp.c:	.open = msm_isp_open_node,
media/platform/msm/camera_v2/isp/msm_isp.c:	.close = msm_isp_close_node,
media/platform/msm/camera_v2/isp/msm_isp.c:static long msm_isp_v4l2_fops_ioctl(struct file *file, unsigned int cmd,
media/platform/msm/camera_v2/isp/msm_isp.c:	return video_usercopy(file, cmd, arg, msm_isp_subdev_do_ioctl);
media/platform/msm/camera_v2/isp/msm_isp.c:static int msm_isp_v4l2_fops_mmap(struct file *filep,
media/platform/msm/camera_v2/isp/msm_isp.c:static struct v4l2_file_operations msm_isp_v4l2_fops = {
media/platform/msm/camera_v2/isp/msm_isp.c:	.compat_ioctl32 = msm_isp_v4l2_fops_ioctl,
media/platform/msm/camera_v2/isp/msm_isp.c:	.unlocked_ioctl = msm_isp_v4l2_fops_ioctl,
media/platform/msm/camera_v2/isp/msm_isp.c:	.mmap = msm_isp_v4l2_fops_mmap
media/platform/msm/camera_v2/isp/msm_isp.c:	vfe_dev->common_data = (struct msm_vfe_common_dev_data *)
media/platform/msm/camera_v2/isp/msm_isp.c:		sizeof(struct msm_vfe_common_subdev), GFP_KERNEL);
media/platform/msm/camera_v2/isp/msm_isp.c:			msm_isp_do_tasklet,
media/platform/msm/camera_v2/isp/msm_isp.c:	/*struct msm_cam_subdev_info sd_info;*/
media/platform/msm/camera_v2/isp/msm_isp.c:	struct msm_vfe_hardware_info *hw_info;
media/platform/msm/camera_v2/isp/msm_isp.c:	vfe_dev->stats = kzalloc(sizeof(struct msm_isp_statistics), GFP_KERNEL);
media/platform/msm/camera_v2/isp/msm_isp.c:	vfe_dev->ub_info = kzalloc(sizeof(struct msm_isp_ub_info), GFP_KERNEL);
media/platform/msm/camera_v2/isp/msm_isp.c:			(struct msm_vfe_hardware_info *) match_dev->data;
media/platform/msm/camera_v2/isp/msm_isp.c:		vfe_dev->hw_info = (struct msm_vfe_hardware_info *)
media/platform/msm/camera_v2/isp/msm_isp.c:	v4l2_subdev_init(&vfe_dev->subdev.sd, &msm_vfe_v4l2_subdev_ops);
media/platform/msm/camera_v2/isp/msm_isp.c:		&msm_vfe_subdev_internal_ops;
media/platform/msm/camera_v2/isp/msm_isp.c:	rc = msm_sd_register(&vfe_dev->subdev);
media/platform/msm/camera_v2/isp/msm_isp.c:		pr_err("%s: msm_sd_register error = %d\n", __func__, rc);
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_cam_copy_v4l2_subdev_fops(&msm_isp_v4l2_fops);
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_v4l2_fops.unlocked_ioctl = msm_isp_v4l2_fops_ioctl;
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_v4l2_fops.compat_ioctl32 =
media/platform/msm/camera_v2/isp/msm_isp.c:		msm_isp_v4l2_fops_ioctl;
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_v4l2_fops.mmap = msm_isp_v4l2_fops_mmap;
media/platform/msm/camera_v2/isp/msm_isp.c:	vfe_dev->subdev.sd.devnode->fops = &msm_isp_v4l2_fops;
media/platform/msm/camera_v2/isp/msm_isp.c:	rc = msm_isp_create_isp_buf_mgr(vfe_dev->buf_mgr,
media/platform/msm/camera_v2/isp/msm_isp.c:	msm_isp_enable_debugfs(vfe_dev, msm_isp_bw_request_history);
media/platform/msm/camera_v2/isp/msm_isp.c:		.name = "msm_vfe",
media/platform/msm/camera_v2/isp/msm_isp.c:		.of_match_table = msm_vfe_dt_match,
media/platform/msm/camera_v2/isp/msm_isp.c:static int __init msm_vfe_init_module(void)
media/platform/msm/camera_v2/isp/msm_isp.c:static void __exit msm_vfe_exit_module(void)
media/platform/msm/camera_v2/isp/msm_isp.c:late_initcall(msm_vfe_init_module);
media/platform/msm/camera_v2/isp/msm_isp.c:module_exit(msm_vfe_exit_module);
media/platform/msm/camera_v2/isp/msm_isp.h:#include <media/msmb_isp.h>
media/platform/msm/camera_v2/isp/msm_isp.h:#include <linux/msm-bus.h>
media/platform/msm/camera_v2/isp/msm_isp.h:#include <linux/msm-bus-board.h>
media/platform/msm/camera_v2/isp/msm_isp.h:#include "msm_buf_mgr.h"
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_axi_stream;
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_stats_stream;
media/platform/msm/camera_v2/isp/msm_isp.h:enum msm_isp_irq_operation {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_sof_info {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_dual_hw_ms_info {
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_vfe_dual_hw_ms_type dual_hw_ms_type;
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_vfe_dual_cam_sync_mode sync_state;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_sof_info sof_info;
media/platform/msm/camera_v2/isp/msm_isp.h:enum msm_isp_pack_fmt {
media/platform/msm/camera_v2/isp/msm_isp.h:enum msm_isp_camif_update_state {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_isp_timestamp {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_irq_ops {
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp.h:		enum msm_isp_irq_operation);
media/platform/msm/camera_v2/isp/msm_isp.h:		enum msm_isp_irq_operation);
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_axi_ops {
media/platform/msm/camera_v2/isp/msm_isp.h:		enum msm_vfe_axi_stream_src stream_src,
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx);
media/platform/msm/camera_v2/isp/msm_isp.h:		enum msm_vfe_input_src frame_src);
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_core_ops {
media/platform/msm/camera_v2/isp/msm_isp.h:		enum msm_vfe_input_src frame_src);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_pix_cfg *pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp.h:		enum msm_isp_camif_update_state update_state);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_rdi_cfg *rdi_cfg,
media/platform/msm/camera_v2/isp/msm_isp.h:		enum msm_vfe_input_src input_src);
media/platform/msm/camera_v2/isp/msm_isp.h:			struct msm_isp_ahb_clk_cfg *ahb_cfg);
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_stats_ops {
media/platform/msm/camera_v2/isp/msm_isp.h:	int (*get_stats_idx)(enum msm_isp_stats_type stats_type);
media/platform/msm/camera_v2/isp/msm_isp.h:	int (*check_streams)(struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp.h:enum msm_isp_hw_client {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_isp_bandwidth_info {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_isp_bandwidth_mgr {
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_bandwidth_info client_info[MAX_ISP_CLIENT];
media/platform/msm/camera_v2/isp/msm_isp.h:	int (*update_bw)(struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr);
media/platform/msm/camera_v2/isp/msm_isp.h:	void (*deinit_bw_mgr)(struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr);
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_platform_ops {
media/platform/msm/camera_v2/isp/msm_isp.h:				struct msm_isp_clk_rates *rates);
media/platform/msm/camera_v2/isp/msm_isp.h:		struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr);
media/platform/msm/camera_v2/isp/msm_isp.h:	int (*update_bw)(struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr);
media/platform/msm/camera_v2/isp/msm_isp.h:	void (*deinit_bw_mgr)(struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr);
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_ops {
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_irq_ops irq_ops;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_axi_ops axi_ops;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_core_ops core_ops;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_stats_ops stats_ops;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_platform_ops platform_ops;
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_hardware_info {
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_ops vfe_ops;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_axi_hardware_info *axi_hw_info;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_stats_hardware_info *stats_hw_info;
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_axi_hardware_info {
media/platform/msm/camera_v2/isp/msm_isp.h:enum msm_vfe_axi_state {
media/platform/msm/camera_v2/isp/msm_isp.h:enum msm_vfe_axi_stream_type {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_frame_request_queue {
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_vfe_buff_queue_id buff_queue_id;
media/platform/msm/camera_v2/isp/msm_isp.h:enum msm_isp_comp_irq_types {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_isp_pending_buf_info {
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_buffer *buf;
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_axi_stream {
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_vfe_axi_state state;
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_vfe_axi_stream_src stream_src;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_axi_plane_cfg plane_cfg[MAX_VFE][MAX_PLANES_PER_STREAM];
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_buffer *buf[2];
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_frame_request_queue
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_vfe_axi_stream_type stream_type;
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_vfe_frame_skip_pattern frame_skip_pattern;
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_stream_rdi_input_type  rdi_input_type;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_sw_framskip sw_skip;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_pending_buf_info pending_buf_info;
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_axi_composite_info {
media/platform/msm/camera_v2/isp/msm_isp.h:enum msm_vfe_camif_state {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_src_info {
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_vfe_inputmux input_mux;
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_vfe_dual_hw_type dual_hw_type;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_dual_hw_ms_info dual_hw_ms_info;
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_fetch_engine_info {
media/platform/msm/camera_v2/isp/msm_isp.h:enum msm_wm_ub_cfg_type {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_axi_shared_data {
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_axi_hardware_info *hw_info;
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_wm_ub_cfg_type wm_ub_cfg_policy;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_axi_composite_info
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_src_info src_info[VFE_SRC_MAX];
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_stats_hardware_info {
media/platform/msm/camera_v2/isp/msm_isp.h:enum msm_vfe_stats_state {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_stats_stream {
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_isp_stats_type stats_type;
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_vfe_stats_state state;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_sw_framskip sw_skip;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_buffer *buf[2];
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_stats_shared_data {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_tasklet_queue_cmd {
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_timestamp ts;
media/platform/msm/camera_v2/isp/msm_isp.h:enum msm_vfe_overflow_state {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_error_info {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_isp_statistics {
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_isp_bw_req_info {
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_bandwidth_info client_info[MAX_ISP_CLIENT];
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_isp_ub_info {
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_wm_ub_cfg_type policy;
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_hw_init_parms {
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_stats_shared_data *stats_data[MAX_VFE];
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_axi_shared_data *axi_data[MAX_VFE];
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_vfe_dual_hw_type dual_hw_type;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_src_info *src_info[MAX_VFE * VFE_SRC_MAX];
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_vfe_dual_cam_sync_mode dual_sync_mode;
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_irq_debug_info {
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_timestamp ts;
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_irq_dump {
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_irq_debug_info
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_irq_debug_info
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_tasklet {
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_tasklet_queue_cmd
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_common_dev_data {
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_axi_stream streams[VFE_AXI_SRC_MAX * MAX_VFE];
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_stats_stream stats_streams[MSM_ISP_STATS_MAX * MAX_VFE];
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_irq_dump vfe_irq_dump;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_tasklet tasklets[MAX_VFE + 1];
media/platform/msm/camera_v2/isp/msm_isp.h:struct msm_vfe_common_subdev {
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_sd_subdev *subdev;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_buf_mgr *buf_mgr;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_common_dev_data *common_data;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_common_dev_data *common_data;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_sd_subdev subdev;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_buf_mgr *buf_mgr;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_cam_regulator *regulator_info;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_cam_clk_info *vfe_clk_info;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_cam_clk_info *hvx_clk_info;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_hardware_info *hw_info;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_axi_shared_data axi_data;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_stats_shared_data stats_data;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_error_info error_info;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_fetch_engine_info fetch_engine_info;
media/platform/msm/camera_v2/isp/msm_isp.h:	enum msm_vfe_hvx_streaming_cmd hvx_cmd;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_statistics *stats;
media/platform/msm/camera_v2/isp/msm_isp.h:	uint64_t msm_isp_last_overflow_ab;
media/platform/msm/camera_v2/isp/msm_isp.h:	uint64_t msm_isp_last_overflow_ib;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_isp_ub_info *ub_info;
media/platform/msm/camera_v2/isp/msm_isp.h:	struct msm_vfe_common_subdev *common_sd;
media/platform/msm/camera_v2/isp/msm_isp.h:void msm_isp_update_last_overflow_ab_ib(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp32.c:#include "msm_isp32.h"
media/platform/msm/camera_v2/isp/msm_isp32.c:#include "msm_isp_util_32.h"
media/platform/msm/camera_v2/isp/msm_isp32.c:#include "msm_isp_axi_util_32.h"
media/platform/msm/camera_v2/isp/msm_isp32.c:#include "msm_isp_stats_util_32.h"
media/platform/msm/camera_v2/isp/msm_isp32.c:#include "msm_isp_32.h"
media/platform/msm/camera_v2/isp/msm_isp32.c:#include "msm.h"
media/platform/msm/camera_v2/isp/msm_isp32.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/isp/msm_isp32.c:static struct msm_cam_clk_info msm_vfe32_1_clk_info[VFE_CLK_INFO_MAX];
media/platform/msm/camera_v2/isp/msm_isp32.c:static struct msm_cam_clk_info msm_vfe32_2_clk_info[] = {
media/platform/msm/camera_v2/isp/msm_isp32.c:static int32_t msm_vfe32_init_qos_parms(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:				struct msm_vfe_hw_init_parms *qos_parms,
media/platform/msm/camera_v2/isp/msm_isp32.c:				struct msm_vfe_hw_init_parms *ds_parms)
media/platform/msm/camera_v2/isp/msm_isp32.c:						msm_camera_io_w(qos_settings[i],
media/platform/msm/camera_v2/isp/msm_isp32.c:						msm_camera_io_w(ds_settings[i],
media/platform/msm/camera_v2/isp/msm_isp32.c:static int32_t msm_vfe32_init_vbif_parms(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:				struct msm_vfe_hw_init_parms *vbif_parms)
media/platform/msm/camera_v2/isp/msm_isp32.c:					msm_camera_io_w(
media/platform/msm/camera_v2/isp/msm_isp32.c:static int msm_vfe32_init_hardware(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:	rc = msm_isp_init_bandwidth_mgr(ISP_VFE0 + vfe_dev->pdev->id);
media/platform/msm/camera_v2/isp/msm_isp32.c:	rc = msm_isp_get_clk_info(vfe_dev, vfe_dev->pdev,
media/platform/msm/camera_v2/isp/msm_isp32.c:		 &msm_vfe32_1_clk_info[0]);
media/platform/msm/camera_v2/isp/msm_isp32.c:		pr_err("msm_isp_get_clk_info() failed\n");
media/platform/msm/camera_v2/isp/msm_isp32.c:	rc = msm_cam_clk_enable(&vfe_dev->pdev->dev, msm_vfe32_1_clk_info,
media/platform/msm/camera_v2/isp/msm_isp32.c:		 vfe_dev->vfe_clk, ARRAY_SIZE(msm_vfe32_1_clk_info), 1);
media/platform/msm/camera_v2/isp/msm_isp32.c:		rc = msm_cam_clk_enable(&vfe_dev->pdev->dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:			 msm_vfe32_2_clk_info, vfe_dev->vfe_clk,
media/platform/msm/camera_v2/isp/msm_isp32.c:			ARRAY_SIZE(msm_vfe32_2_clk_info), 1);
media/platform/msm/camera_v2/isp/msm_isp32.c:	rc = request_irq(vfe_dev->vfe_irq->start, msm_isp_process_irq,
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_cam_clk_enable(&vfe_dev->pdev->dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:				msm_vfe32_1_clk_info, vfe_dev->vfe_clk,
media/platform/msm/camera_v2/isp/msm_isp32.c:				ARRAY_SIZE(msm_vfe32_1_clk_info), 0);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_cam_clk_enable(&vfe_dev->pdev->dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:				msm_vfe32_2_clk_info, vfe_dev->vfe_clk,
media/platform/msm/camera_v2/isp/msm_isp32.c:				ARRAY_SIZE(msm_vfe32_2_clk_info), 0);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_isp_deinit_bandwidth_mgr(ISP_VFE0 + vfe_dev->pdev->id);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_release_hardware(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_cam_clk_enable(&vfe_dev->pdev->dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:				msm_vfe32_1_clk_info, vfe_dev->vfe_clk,
media/platform/msm/camera_v2/isp/msm_isp32.c:				ARRAY_SIZE(msm_vfe32_1_clk_info), 0);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_cam_clk_enable(&vfe_dev->pdev->dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:				msm_vfe32_2_clk_info, vfe_dev->vfe_clk,
media/platform/msm/camera_v2/isp/msm_isp32.c:				ARRAY_SIZE(msm_vfe32_2_clk_info), 0);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_isp_deinit_bandwidth_mgr(ISP_VFE0 + vfe_dev->pdev->id);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_init_hardware_reg(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_hw_init_parms qos_parms;
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_hw_init_parms vbif_parms;
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_hw_init_parms ds_parms;
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_vfe32_init_qos_parms(vfe_dev, &qos_parms, &ds_parms);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_vfe32_init_vbif_parms(vfe_dev, &vbif_parms);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0x07FFFFFF, vfe_dev->vfe_base + 0xC);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0x00000009, vfe_dev->vfe_base + 0x3C);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0x01000021, vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(0x1CFFFFFF, vfe_dev->vfe_base + 0x20);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0xFFFFFFFF, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(0x1FFFFFFF, vfe_dev->vfe_base + 0x28);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x6FC);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0x10000000, vfe_dev->vfe_base + VFE32_RDI_BASE(1));
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0x10000000, vfe_dev->vfe_base + VFE32_RDI_BASE(2));
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0x0, vfe_dev->vfe_base + VFE32_XBAR_BASE(0));
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0x0, vfe_dev->vfe_base + VFE32_XBAR_BASE(4));
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_clear_status_reg(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w((1 << 23), vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(0x0, vfe_dev->vfe_base + 0x20);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0xFFFFFFFF, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(0xFFFFFFFF, vfe_dev->vfe_base + 0x28);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_process_reset_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_process_halt_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w_mb(0, vfe_dev->vfe_base + 0x1D8);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_process_epoch_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_isp_notify(vfe_dev, ISP_EVENT_SOF, VFE_PIX_0, ts);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_process_camif_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp32.c:			msm_isp_notify(vfe_dev, ISP_EVENT_SOF, VFE_PIX_0, ts);
media/platform/msm/camera_v2/isp/msm_isp32.c:				msm_isp_axi_stream_update(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:			msm_isp_update_framedrop_reg(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_process_violation_status(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_get_overflow_mask(uint32_t *overflow_mask)
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_get_rdi_wm_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_get_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	*irq0_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:	*irq1_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x20);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_process_error_status(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_vfe32_process_violation_status(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_read_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	*irq_status0 = msm_camera_io_r(vfe_dev->vfe_base + 0x2C);
media/platform/msm/camera_v2/isp/msm_isp32.c:	*irq_status1 = msm_camera_io_r(vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(*irq_status0, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(*irq_status1, vfe_dev->vfe_base + 0x28);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(1, vfe_dev->vfe_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp32.c:			msm_camera_io_r(vfe_dev->vfe_base + 0x204);
media/platform/msm/camera_v2/isp/msm_isp32.c:			msm_camera_io_r(vfe_dev->vfe_base + 0x7B4);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_process_reg_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_isp_notify(vfe_dev, ISP_EVENT_REG_UPDATE, VFE_PIX_0, ts);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_isp_notify(vfe_dev, ISP_EVENT_SOF, VFE_RAW_0, ts);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_isp_notify(vfe_dev, ISP_EVENT_SOF, VFE_RAW_1, ts);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_isp_notify(vfe_dev, ISP_EVENT_SOF, VFE_RAW_2, ts);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_isp_axi_stream_update(vfe_dev, input_src);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_isp_stats_stream_update(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_isp_update_framedrop_reg(vfe_dev, input_src);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_isp_update_stats_framedrop_reg(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_isp_update_error_frame_count(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_reg_update(
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(input_src, vfe_dev->vfe_base + 0x260);
media/platform/msm/camera_v2/isp/msm_isp32.c:static long msm_vfe32_reset_hardware(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w_mb(0x3FF, vfe_dev->vfe_base + 0x4);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w_mb(0x3FF, vfe_dev->vfe_base + 0x4);
media/platform/msm/camera_v2/isp/msm_isp32.c:		irq_status1 = msm_camera_io_r(vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_axi_reload_wm(
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w_mb(reload_mask, vfe_dev->vfe_base + 0x38);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x28);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(0x1C800000, vfe_dev->vfe_base + 0x20);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(0x9AAAAAAA, vfe_dev->vfe_base + 0x600);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(reload_mask, vfe_dev->vfe_base + 0x38);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_axi_enable_wm(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	uint32_t val = msm_camera_io_r(
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(val,
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_axi_cfg_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp32.c:	comp_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(comp_mask, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp32.c:	irq_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(irq_mask, vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_axi_clear_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp32.c:	comp_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(comp_mask, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp32.c:	irq_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(irq_mask, vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_axi_cfg_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp32.c:	irq_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(irq_mask, vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_axi_clear_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp32.c:	irq_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(irq_mask, vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_cfg_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(framedrop_period, vfe_dev->vfe_base + 0x504);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(framedrop_period, vfe_dev->vfe_base + 0x508);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(framedrop_pattern, vfe_dev->vfe_base + 0x50C);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(framedrop_pattern, vfe_dev->vfe_base + 0x510);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(framedrop_period, vfe_dev->vfe_base + 0x514);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(framedrop_period, vfe_dev->vfe_base + 0x518);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(framedrop_pattern, vfe_dev->vfe_base + 0x51C);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(framedrop_pattern, vfe_dev->vfe_base + 0x520);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x260);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_clear_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(0, vfe_dev->vfe_base + 0x50C);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(0, vfe_dev->vfe_base + 0x510);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(0, vfe_dev->vfe_base + 0x51C);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(0, vfe_dev->vfe_base + 0x520);
media/platform/msm/camera_v2/isp/msm_isp32.c:static int32_t msm_vfe32_cfg_io_format(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	enum msm_vfe_axi_stream_src stream_src, uint32_t io_format)
media/platform/msm/camera_v2/isp/msm_isp32.c:	bpp = msm_isp_get_bit_per_pixel(io_format);
media/platform/msm/camera_v2/isp/msm_isp32.c:		pack_fmt = msm_isp_get_pack_format(io_format);
media/platform/msm/camera_v2/isp/msm_isp32.c:	io_format_reg = msm_camera_io_r(vfe_dev->vfe_base + 0x6F8);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(io_format_reg, vfe_dev->vfe_base + 0x6F8);
media/platform/msm/camera_v2/isp/msm_isp32.c:static int msm_vfe32_start_fetch_engine(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_cfg_fetch_engine(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_cfg_camif(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_camif_cfg *camif_cfg = &pix_cfg->camif_cfg;
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(pix_cfg->input_mux << 16 | pix_cfg->pixel_pattern,
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(camif_cfg->lines_per_frame << 16 |
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(first_pixel << 16 | last_pixel,
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(first_line << 16 | last_line,
media/platform/msm/camera_v2/isp/msm_isp32.c:	val = msm_camera_io_r(vfe_dev->vfe_base + 0x6FC);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(val, vfe_dev->vfe_base + 0x6FC);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_cfg_input_mux(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_vfe32_cfg_camif(vfe_dev, pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_vfe32_cfg_fetch_engine(vfe_dev, pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_update_camif_state(
media/platform/msm/camera_v2/isp/msm_isp32.c:	enum msm_isp_camif_update_state update_state)
media/platform/msm/camera_v2/isp/msm_isp32.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w_mb(val, vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w_mb(0xA, vfe_dev->vfe_base + 0x200);
media/platform/msm/camera_v2/isp/msm_isp32.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x1E4);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x1E4);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w_mb(0x4, vfe_dev->vfe_base + 0x1E0);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x1E0);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w_mb(0x0, vfe_dev->vfe_base + 0x1E0);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w_mb(0x6, vfe_dev->vfe_base + 0x1E0);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_cfg_rdi_reg(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_rdi_cfg *rdi_cfg, enum msm_vfe_input_src input_src)
media/platform/msm/camera_v2/isp/msm_isp32.c:	rdi_reg_cfg = msm_camera_io_r(
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(rdi_reg_cfg,
media/platform/msm/camera_v2/isp/msm_isp32.c:	rdi_reg_cfg = msm_camera_io_r(
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_axi_cfg_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp32.c:			((msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x10);
media/platform/msm/camera_v2/isp/msm_isp32.c:			msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(0x2, vfe_dev->vfe_base + wm_base);
media/platform/msm/camera_v2/isp/msm_isp32.c:			msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_axi_clear_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx)
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x10);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_axi_cfg_wm_xbar_reg(
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx)
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_plane_cfg *plane_cfg =
media/platform/msm/camera_v2/isp/msm_isp32.c:	xbar_reg_cfg = msm_camera_io_r(vfe_dev->vfe_base + VFE32_XBAR_BASE(wm));
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(xbar_reg_cfg, vfe_dev->vfe_base + VFE32_XBAR_BASE(wm));
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_axi_clear_wm_xbar_reg(
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx)
media/platform/msm/camera_v2/isp/msm_isp32.c:	xbar_reg_cfg = msm_camera_io_r(vfe_dev->vfe_base + VFE32_XBAR_BASE(wm));
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(xbar_reg_cfg, vfe_dev->vfe_base + VFE32_XBAR_BASE(wm));
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_cfg_axi_ub_equal_default(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp32.c:			msm_camera_io_w(ub_offset << 16 |
media/platform/msm/camera_v2/isp/msm_isp32.c:			msm_camera_io_w(0,
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_cfg_axi_ub_equal_slicing(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp32.c:			msm_camera_io_w(ub_offset << 16 |
media/platform/msm/camera_v2/isp/msm_isp32.c:			msm_camera_io_w(ub_offset << 16 |
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_cfg_axi_ub(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_vfe32_cfg_axi_ub_equal_slicing(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_vfe32_cfg_axi_ub_equal_default(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_update_ping_pong_addr(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(paddr32, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp32.c:static int msm_vfe32_axi_halt(struct vfe_device *vfe_dev, uint32_t blocking)
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0x01800000, vfe_dev->vfe_base + 0x20);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0xFE7FFFFF, vfe_dev->vfe_base + 0x28);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x1D8);
media/platform/msm/camera_v2/isp/msm_isp32.c:		if (msm_camera_io_r(
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(0, vfe_dev->vfe_base + 0x1D8);
media/platform/msm/camera_v2/isp/msm_isp32.c:static int msm_vfe32_axi_restart(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0xFE7FFFFF, vfe_dev->vfe_base + 0x28);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x1D8);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w_mb(0xA, vfe_dev->vfe_base + 0x200);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x1D8);
media/platform/msm/camera_v2/isp/msm_isp32.c:static uint32_t msm_vfe32_get_wm_mask(
media/platform/msm/camera_v2/isp/msm_isp32.c:static uint32_t msm_vfe32_get_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp32.c:static uint32_t msm_vfe32_get_pingpong_status(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:	return msm_camera_io_r(vfe_dev->vfe_base + 0x180);
media/platform/msm/camera_v2/isp/msm_isp32.c:static int msm_vfe32_get_stats_idx(enum msm_isp_stats_type stats_type)
media/platform/msm/camera_v2/isp/msm_isp32.c:static int msm_vfe32_stats_check_streams(
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_stats_cfg_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_stats_cfg_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp32.c:	irq_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(irq_mask, vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_stats_clear_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp32.c:	irq_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(irq_mask, vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_stats_cfg_wm_reg(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_stats_clear_wm_reg(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_stats_cfg_ub(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:		msm_camera_io_w(ub_offset << 16 | (ub_size[i] - 1),
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_stats_enable_module(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	module_cfg = msm_camera_io_r(vfe_dev->vfe_base + 0x10);
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(module_cfg, vfe_dev->vfe_base + 0x10);
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_stats_update_ping_pong_addr(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp32.c:	struct msm_vfe_stats_stream *stream_info, uint32_t pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(paddr32, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp32.c:static uint32_t msm_vfe32_stats_get_wm_mask(uint32_t irq_status0,
media/platform/msm/camera_v2/isp/msm_isp32.c:static uint32_t msm_vfe32_stats_get_comp_mask(uint32_t irq_status0,
media/platform/msm/camera_v2/isp/msm_isp32.c:static uint32_t msm_vfe32_stats_get_frame_id(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:static int msm_vfe32_get_platform_data(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_get_error_mask(uint32_t *error_mask0,
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_restore_irq_mask(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(vfe_dev->error_info.overflow_recover_irq_mask0,
media/platform/msm/camera_v2/isp/msm_isp32.c:	msm_camera_io_w(vfe_dev->error_info.overflow_recover_irq_mask1,
media/platform/msm/camera_v2/isp/msm_isp32.c:static void msm_vfe32_get_halt_restart_mask(uint32_t *irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:static struct msm_vfe_axi_hardware_info msm_vfe32_axi_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp32.c:static struct msm_vfe_stats_hardware_info msm_vfe32_stats_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp32.c:static struct v4l2_subdev_core_ops msm_vfe32_subdev_core_ops = {
media/platform/msm/camera_v2/isp/msm_isp32.c:	.ioctl = msm_isp_ioctl,
media/platform/msm/camera_v2/isp/msm_isp32.c:	.subscribe_event = msm_isp_subscribe_event,
media/platform/msm/camera_v2/isp/msm_isp32.c:	.unsubscribe_event = msm_isp_unsubscribe_event,
media/platform/msm/camera_v2/isp/msm_isp32.c:static struct v4l2_subdev_ops msm_vfe32_subdev_ops = {
media/platform/msm/camera_v2/isp/msm_isp32.c:	.core = &msm_vfe32_subdev_core_ops,
media/platform/msm/camera_v2/isp/msm_isp32.c:static struct v4l2_subdev_internal_ops msm_vfe32_internal_ops = {
media/platform/msm/camera_v2/isp/msm_isp32.c:	.open = msm_isp_open_node,
media/platform/msm/camera_v2/isp/msm_isp32.c:	.close = msm_isp_close_node,
media/platform/msm/camera_v2/isp/msm_isp32.c:struct msm_vfe_hardware_info vfe32_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp32.c:			.read_irq_status = msm_vfe32_read_irq_status,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.process_camif_irq = msm_vfe32_process_camif_irq,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.process_reset_irq = msm_vfe32_process_reset_irq,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.process_halt_irq = msm_vfe32_process_halt_irq,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.process_reg_update = msm_vfe32_process_reg_update,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.process_epoch_irq = msm_vfe32_process_epoch_irq,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.process_axi_irq = msm_isp_process_axi_irq,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.process_stats_irq = msm_isp_process_stats_irq,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.reload_wm = msm_vfe32_axi_reload_wm,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.enable_wm = msm_vfe32_axi_enable_wm,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.cfg_io_format = msm_vfe32_cfg_io_format,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.cfg_comp_mask = msm_vfe32_axi_cfg_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.clear_comp_mask = msm_vfe32_axi_clear_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.cfg_wm_irq_mask = msm_vfe32_axi_cfg_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.clear_wm_irq_mask = msm_vfe32_axi_clear_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.cfg_framedrop = msm_vfe32_cfg_framedrop,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.clear_framedrop = msm_vfe32_clear_framedrop,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.cfg_wm_reg = msm_vfe32_axi_cfg_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.clear_wm_reg = msm_vfe32_axi_clear_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.cfg_wm_xbar_reg = msm_vfe32_axi_cfg_wm_xbar_reg,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.clear_wm_xbar_reg = msm_vfe32_axi_clear_wm_xbar_reg,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.cfg_ub = msm_vfe32_cfg_axi_ub,
media/platform/msm/camera_v2/isp/msm_isp32.c:				msm_vfe32_update_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.get_comp_mask = msm_vfe32_get_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.get_wm_mask = msm_vfe32_get_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.get_pingpong_status = msm_vfe32_get_pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.halt = msm_vfe32_axi_halt,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.restart = msm_vfe32_axi_restart,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.reg_update = msm_vfe32_reg_update,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.cfg_input_mux = msm_vfe32_cfg_input_mux,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.update_camif_state = msm_vfe32_update_camif_state,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.start_fetch_eng = msm_vfe32_start_fetch_engine,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.cfg_rdi_reg = msm_vfe32_cfg_rdi_reg,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.reset_hw = msm_vfe32_reset_hardware,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.init_hw = msm_vfe32_init_hardware,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.init_hw_reg = msm_vfe32_init_hardware_reg,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.clear_status_reg = msm_vfe32_clear_status_reg,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.release_hw = msm_vfe32_release_hardware,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.get_platform_data = msm_vfe32_get_platform_data,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.get_error_mask = msm_vfe32_get_error_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.get_overflow_mask = msm_vfe32_get_overflow_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.get_rdi_wm_mask = msm_vfe32_get_rdi_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.get_irq_mask = msm_vfe32_get_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.restore_irq_mask = msm_vfe32_restore_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:				msm_vfe32_get_halt_restart_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.process_error_status = msm_vfe32_process_error_status,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.get_stats_idx = msm_vfe32_get_stats_idx,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.check_streams = msm_vfe32_stats_check_streams,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.cfg_comp_mask = msm_vfe32_stats_cfg_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.cfg_wm_irq_mask = msm_vfe32_stats_cfg_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.clear_wm_irq_mask = msm_vfe32_stats_clear_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.cfg_wm_reg = msm_vfe32_stats_cfg_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.clear_wm_reg = msm_vfe32_stats_clear_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.cfg_ub = msm_vfe32_stats_cfg_ub,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.enable_module = msm_vfe32_stats_enable_module,
media/platform/msm/camera_v2/isp/msm_isp32.c:				msm_vfe32_stats_update_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.get_comp_mask = msm_vfe32_stats_get_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.get_wm_mask = msm_vfe32_stats_get_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.get_frame_id = msm_vfe32_stats_get_frame_id,
media/platform/msm/camera_v2/isp/msm_isp32.c:			.get_pingpong_status = msm_vfe32_get_pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp32.c:	.axi_hw_info = &msm_vfe32_axi_hw_info,
media/platform/msm/camera_v2/isp/msm_isp32.c:	.stats_hw_info = &msm_vfe32_stats_hw_info,
media/platform/msm/camera_v2/isp/msm_isp32.c:	.subdev_ops = &msm_vfe32_subdev_ops,
media/platform/msm/camera_v2/isp/msm_isp32.c:	.subdev_internal_ops = &msm_vfe32_internal_ops,
media/platform/msm/camera_v2/isp/msm_isp32.h:extern struct msm_vfe_hardware_info vfe32_hw_info;
media/platform/msm/camera_v2/isp/msm_isp40.c:#include "msm_isp40.h"
media/platform/msm/camera_v2/isp/msm_isp40.c:#include "msm_isp_util.h"
media/platform/msm/camera_v2/isp/msm_isp40.c:#include "msm_isp_axi_util.h"
media/platform/msm/camera_v2/isp/msm_isp40.c:#include "msm_isp_stats_util.h"
media/platform/msm/camera_v2/isp/msm_isp40.c:#include "msm_isp.h"
media/platform/msm/camera_v2/isp/msm_isp40.c:#include "msm.h"
media/platform/msm/camera_v2/isp/msm_isp40.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/isp/msm_isp40.c:#include "msm_isp47.h"
media/platform/msm/camera_v2/isp/msm_isp40.c:static uint32_t msm_vfe40_ub_reg_offset(struct vfe_device *vfe_dev, int idx)
media/platform/msm/camera_v2/isp/msm_isp40.c:static uint32_t msm_vfe40_get_ub_size(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_config_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:		enum msm_isp_irq_operation oper)
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(irq0_mask, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(irq0_mask, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0x1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(irq0_mask, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(irq0_mask, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0x1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(vfe_dev->irq0_mask, vfe_dev->vfe_base + 0x28);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(vfe_dev->irq1_mask, vfe_dev->vfe_base + 0x2C);
media/platform/msm/camera_v2/isp/msm_isp40.c:static int32_t msm_vfe40_init_qos_parms(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:				struct msm_vfe_hw_init_parms *qos_parms,
media/platform/msm/camera_v2/isp/msm_isp40.c:				struct msm_vfe_hw_init_parms *ds_parms)
media/platform/msm/camera_v2/isp/msm_isp40.c:						msm_camera_io_w(qos_settings[i],
media/platform/msm/camera_v2/isp/msm_isp40.c:						msm_camera_io_w(ds_settings[i],
media/platform/msm/camera_v2/isp/msm_isp40.c:static int32_t msm_vfe40_init_vbif_parms(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:				struct msm_vfe_hw_init_parms *vbif_parms)
media/platform/msm/camera_v2/isp/msm_isp40.c:					msm_camera_io_w(
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_init_hardware_reg(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_hw_init_parms qos_parms;
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_hw_init_parms vbif_parms;
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_hw_init_parms ds_parms;
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_init_qos_parms(vfe_dev, &qos_parms, &ds_parms);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_init_vbif_parms(vfe_dev, &vbif_parms);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(0x10000001, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_config_irq(vfe_dev, 0x800000E0, 0xFEFFFF7E,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_clear_status_reg(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_config_irq(vfe_dev, (1 << 31), 0,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(0xFFFFFFFF, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(0xFFFFFFFF, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_process_reset_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_process_halt_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x2C0);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_process_input_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_isp_increment_frame_id(vfe_dev, VFE_PIX_0, ts);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_isp_fetch_engine_done_notify(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_process_violation_status(
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_process_error_status(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_dump(vfe_dev->vfe_base + 0x2F4, 0x30, 1);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_vfe40_process_violation_status(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_isp_update_last_overflow_ab_ib(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_read_and_clear_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	*irq_status0 = msm_camera_io_r(vfe_dev->vfe_base + 0x38);
media/platform/msm/camera_v2/isp/msm_isp40.c:	*irq_status1 = msm_camera_io_r(vfe_dev->vfe_base + 0x3C);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(*irq_status0, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(*irq_status1, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp40.c:		(*irq_status0 == msm_camera_io_r(vfe_dev->vfe_base + 0x38))) {
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(*irq_status0, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_r(vfe_dev->vfe_base + 0x31C);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_vfe40_config_irq(vfe_dev, 0, (1 << 0), MSM_ISP_IRQ_DISABLE);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_r(vfe_dev->vfe_base + 0x48);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_read_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	*irq_status0 = msm_camera_io_r(vfe_dev->vfe_base + 0x38);
media/platform/msm/camera_v2/isp/msm_isp40.c:	*irq_status1 = msm_camera_io_r(vfe_dev->vfe_base + 0x3C);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_process_reg_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp40.c:	enum msm_vfe_input_src i;
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_isp_notify(vfe_dev, ISP_EVENT_REG_UPDATE,
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_isp_process_reg_upd_epoch_irq(vfe_dev, i,
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_isp_process_stats_reg_upd_epoch_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_isp_increment_frame_id(vfe_dev, i, ts);
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_isp_notify(vfe_dev, ISP_EVENT_SOF, i, ts);
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_isp_process_reg_upd_epoch_irq(vfe_dev, i,
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_isp_process_reg_upd_epoch_irq(vfe_dev, i,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_reg_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	enum msm_vfe_input_src frame_src)
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(update_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(update_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(update_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_process_epoch_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_isp_process_reg_upd_epoch_irq(vfe_dev, VFE_PIX_0,
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_isp_process_stats_reg_upd_epoch_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_isp_update_error_frame_count(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_isp_notify(vfe_dev, ISP_EVENT_SOF, VFE_PIX_0, ts);
media/platform/msm/camera_v2/isp/msm_isp40.c:			msm_isp_notify(vfe_dev, ISP_EVENT_SOF, VFE_PIX_0, ts);
media/platform/msm/camera_v2/isp/msm_isp40.c:			msm_isp_process_reg_upd_epoch_irq(vfe_dev, VFE_PIX_0,
media/platform/msm/camera_v2/isp/msm_isp40.c:static long msm_vfe40_reset_hardware(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(0x1FF, vfe_dev->vfe_base + 0xC);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(0x1EF, vfe_dev->vfe_base + 0xC);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0x7FFFFFFF, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0xFEFFFEFF, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0x1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_axi_reload_wm(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(reload_mask, vfe_base + 0x4C);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_axi_update_cgc_override(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	val = msm_camera_io_r(vfe_dev->vfe_base + 0x974);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(val, vfe_dev->vfe_base + 0x974);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_axi_enable_wm(void __iomem *vfe_base,
media/platform/msm/camera_v2/isp/msm_isp40.c:	val = msm_camera_io_r(vfe_base + VFE40_WM_BASE(wm_idx));
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(val,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_axi_cfg_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp40.c:	comp_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x40);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(comp_mask, vfe_dev->vfe_base + 0x40);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_config_irq(vfe_dev, 1 << (comp_mask_index + 25), 0,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_axi_clear_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp40.c:	comp_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x40);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(comp_mask, vfe_dev->vfe_base + 0x40);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_config_irq(vfe_dev, (1 << (comp_mask_index + 25)), 0,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_axi_cfg_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_config_irq(vfe_dev, 1 << (stream_info->wm[vfe_idx][0] + 8), 0,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_axi_clear_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_config_irq(vfe_dev, (1 << (stream_info->wm[vfe_idx][0] + 8)),
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_cfg_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_axi_stream *stream_info, uint32_t framedrop_pattern,
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(framedrop_pattern, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp40.c:		temp = msm_camera_io_r(vfe_base +
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(temp | (framedrop_period - 1) << 2,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_clear_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp40.c:static int32_t msm_vfe40_convert_bpp_to_reg(int32_t bpp, uint32_t *bpp_reg)
media/platform/msm/camera_v2/isp/msm_isp40.c:static int32_t msm_vfe40_convert_io_fmt_to_reg(
media/platform/msm/camera_v2/isp/msm_isp40.c:		enum msm_isp_pack_fmt pack_format, uint32_t *pack_reg)
media/platform/msm/camera_v2/isp/msm_isp40.c:static int32_t msm_vfe40_cfg_io_format(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	enum msm_vfe_axi_stream_src stream_src, uint32_t io_format)
media/platform/msm/camera_v2/isp/msm_isp40.c:	enum msm_isp_pack_fmt pack_fmt = 0, read_pack_fmt = 0;
media/platform/msm/camera_v2/isp/msm_isp40.c:	io_format_reg = msm_camera_io_r(vfe_dev->vfe_base + 0x54);
media/platform/msm/camera_v2/isp/msm_isp40.c:		read_bpp = msm_isp_get_bit_per_pixel(
media/platform/msm/camera_v2/isp/msm_isp40.c:		rc = msm_vfe40_convert_bpp_to_reg(read_bpp, &read_bpp_reg);
media/platform/msm/camera_v2/isp/msm_isp40.c:		read_pack_fmt = msm_isp_get_pack_format(
media/platform/msm/camera_v2/isp/msm_isp40.c:		rc = msm_vfe40_convert_io_fmt_to_reg(
media/platform/msm/camera_v2/isp/msm_isp40.c:	bpp = msm_isp_get_bit_per_pixel(io_format);
media/platform/msm/camera_v2/isp/msm_isp40.c:	rc = msm_vfe40_convert_bpp_to_reg(bpp, &bpp_reg);
media/platform/msm/camera_v2/isp/msm_isp40.c:		pack_fmt = msm_isp_get_pack_format(io_format);
media/platform/msm/camera_v2/isp/msm_isp40.c:		rc = msm_vfe40_convert_io_fmt_to_reg(pack_fmt, &pack_reg);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(io_format_reg, vfe_dev->vfe_base + 0x54);
media/platform/msm/camera_v2/isp/msm_isp40.c:static int msm_vfe40_start_fetch_engine(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_isp_buffer *buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_fetch_eng_start *fe_cfg = arg;
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_isp_buffer_mapped_info mapped_info;
media/platform/msm/camera_v2/isp/msm_isp40.c:	memset(&mapped_info, 0, sizeof(struct msm_isp_buffer_mapped_info));
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(mapped_info.paddr, vfe_dev->vfe_base + 0x228);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x378);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(0x10000, vfe_dev->vfe_base + 0x4C);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(0x20000, vfe_dev->vfe_base + 0x4C);
media/platform/msm/camera_v2/isp/msm_isp40.c:static int msm_vfe40_start_fetch_engine_multi_pass(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_isp_buffer *buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_fetch_eng_multi_pass_start *fe_cfg = arg;
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_isp_buffer_mapped_info mapped_info;
media/platform/msm/camera_v2/isp/msm_isp40.c:	memset(&mapped_info, 0, sizeof(struct msm_isp_buffer_mapped_info));
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(mapped_info.paddr + fe_cfg->input_buf_offset,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x378);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(0x10000, vfe_dev->vfe_base + 0x4C);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(0x20000, vfe_dev->vfe_base + 0x4C);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_cfg_fetch_engine(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_fetch_engine_cfg *fe_cfg = NULL;
media/platform/msm/camera_v2/isp/msm_isp40.c:	temp = msm_camera_io_r(vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(temp, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_config_irq(vfe_dev, (1 << 24), 0,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w((fe_cfg->fetch_height - 1),
media/platform/msm/camera_v2/isp/msm_isp40.c:	x_size_word = msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w((x_size_word - 1) << 16, vfe_dev->vfe_base + 0x23C);
media/platform/msm/camera_v2/isp/msm_isp40.c:	x_size_word = msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp40.c:	temp = msm_camera_io_r(vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(temp, vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(x_size_word  << 17 |
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0 << 29 | 2 << 26 |
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(x_size_word  << 16 |
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0 << 28 | 2 << 25 |
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(main_unpack_pattern,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(0xF, vfe_dev->vfe_base + 0x264);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_cfg_testgen(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:		struct msm_vfe_testgen_cfg *testgen_cfg)
media/platform/msm/camera_v2/isp/msm_isp40.c:	bit_per_pixel = msm_isp_get_bit_per_pixel(
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(bpp_reg << 16 | testgen_cfg->burst_num_frame,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(((testgen_cfg->lines_per_frame - 1) << 16) |
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(testgen_cfg->h_blank, vfe_dev->vfe_base + 0x958);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w((1 << 16) | testgen_cfg->v_blank,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w((testgen_cfg->rotate_period << 8) |
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_cfg_camif(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_camif_cfg *camif_cfg = &pix_cfg->camif_cfg;
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_camif_subsample_cfg *subsample_cfg =
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(pix_cfg->input_mux << 16 | pix_cfg->pixel_pattern,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(camif_cfg->lines_per_frame << 16 |
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(first_pixel << 16 | last_pixel,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(first_line << 16 | last_line,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(0x140000 | epoch_line1,
media/platform/msm/camera_v2/isp/msm_isp40.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x2F8);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x2F8);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x314);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0xFFFFFFFF, vfe_dev->vfe_base + 0x314);
media/platform/msm/camera_v2/isp/msm_isp40.c:	val = msm_camera_io_r(vfe_dev->vfe_base + 0x2E8);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(val, vfe_dev->vfe_base + 0x2E8);
media/platform/msm/camera_v2/isp/msm_isp40.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x2F8);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x2F8);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w((subsample_cfg->line_skip << 16) |
media/platform/msm/camera_v2/isp/msm_isp40.c:			msm_camera_io_w(
media/platform/msm/camera_v2/isp/msm_isp40.c:			msm_camera_io_w(
media/platform/msm/camera_v2/isp/msm_isp40.c:			val = msm_camera_io_r(
media/platform/msm/camera_v2/isp/msm_isp40.c:			msm_camera_io_w(val,
media/platform/msm/camera_v2/isp/msm_isp40.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x54);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x54);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_cfg_input_mux(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp40.c:	core_cfg =  msm_camera_io_r(vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(core_cfg, vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_vfe40_cfg_camif(vfe_dev, pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp40.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x974);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x974);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(core_cfg, vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_vfe40_cfg_camif(vfe_dev, pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_vfe40_cfg_testgen(vfe_dev, &pix_cfg->testgen_cfg);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(core_cfg, vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_vfe40_cfg_fetch_engine(vfe_dev, pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_update_camif_state(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	enum msm_isp_camif_update_state update_state)
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(0x81, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_vfe40_config_irq(vfe_dev, 0xFF, 0x81,
media/platform/msm/camera_v2/isp/msm_isp40.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x2F8);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x2F8);
media/platform/msm/camera_v2/isp/msm_isp40.c:			msm_camera_io_w(1, vfe_dev->vfe_base + 0x93C);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(0x4, vfe_dev->vfe_base + 0x2F4);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x2F4);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_vfe40_config_irq(vfe_dev, 0, 0x81,
media/platform/msm/camera_v2/isp/msm_isp40.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x464);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(val & ~(1 << 8), vfe_dev->vfe_base + 0x464);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb((update_state == DISABLE_CAMIF ? 0x0 : 0x6),
media/platform/msm/camera_v2/isp/msm_isp40.c:			msm_camera_io_w(1 << 1, vfe_dev->vfe_base + 0x93C);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w((1 << 0), vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_vfe40_config_irq(vfe_dev, vfe_dev->irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_cfg_rdi_reg(
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct vfe_device *vfe_dev, struct msm_vfe_rdi_cfg *rdi_cfg,
media/platform/msm/camera_v2/isp/msm_isp40.c:	enum msm_vfe_input_src input_src)
media/platform/msm/camera_v2/isp/msm_isp40.c:	rdi_reg_cfg = msm_camera_io_r(
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(rdi_reg_cfg,
media/platform/msm/camera_v2/isp/msm_isp40.c:	rdi_reg_cfg = msm_camera_io_r(
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_axi_cfg_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0x0, vfe_dev->vfe_base + wm_base);
media/platform/msm/camera_v2/isp/msm_isp40.c:			((msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp40.c:			msm_isp_cal_word_per_line(stream_info->output_format,
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(0x2, vfe_dev->vfe_base + wm_base);
media/platform/msm/camera_v2/isp/msm_isp40.c:			msm_isp_cal_word_per_line(stream_info->output_format,
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(0xFFFFFFFF,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_axi_clear_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx)
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0xC);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x20);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_axi_cfg_wm_xbar_reg(
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_axi_plane_cfg *plane_cfg;
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_r(vfe_dev->vfe_base + VFE40_XBAR_BASE(wm));
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(xbar_reg_cfg,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_axi_clear_wm_xbar_reg(
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx)
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_r(vfe_dev->vfe_base + VFE40_XBAR_BASE(wm));
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(xbar_reg_cfg,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_read_wm_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_dump(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_update_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(paddr32, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_set_halt_restart_mask(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_config_irq(vfe_dev, BIT(31), BIT(8), MSM_ISP_IRQ_SET);
media/platform/msm/camera_v2/isp/msm_isp40.c:static int msm_vfe40_axi_halt(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	enum msm_vfe_input_src i;
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_isp_timestamp ts;
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_config_irq(vfe_dev, (1 << 31), (1 << 8),
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_isp_get_timestamp(&ts, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_isp_axi_stream_update(vfe_dev, i, &ts);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_isp_axi_stream_update(vfe_dev, i, &ts);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_isp_stats_stream_update(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_isp_stats_stream_update(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x2C0);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x2C0);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_axi_restart(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_config_irq(vfe_dev, vfe_dev->recovery_irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w_mb(0x140000, vfe_dev->vfe_base + 0x318);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x2C0);
media/platform/msm/camera_v2/isp/msm_isp40.c:static uint32_t msm_vfe40_get_wm_mask(
media/platform/msm/camera_v2/isp/msm_isp40.c:static uint32_t msm_vfe40_get_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp40.c:static uint32_t msm_vfe40_get_pingpong_status(
media/platform/msm/camera_v2/isp/msm_isp40.c:	return msm_camera_io_r(vfe_dev->vfe_base + 0x268);
media/platform/msm/camera_v2/isp/msm_isp40.c:static int msm_vfe40_get_stats_idx(enum msm_isp_stats_type stats_type)
media/platform/msm/camera_v2/isp/msm_isp40.c:static int msm_vfe40_stats_check_streams(
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_stats_cfg_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
media/platform/msm/camera_v2/isp/msm_isp40.c:	comp_mask_reg = msm_camera_io_r(vfe_dev->vfe_base + 0x44);
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_vfe40_config_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_vfe40_config_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(comp_mask_reg, vfe_dev->vfe_base + 0x44);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_stats_cfg_wm_irq_mask(
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_config_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_stats_clear_wm_irq_mask(
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_vfe40_config_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_stats_cfg_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w((stream_info->framedrop_period - 1) << 2,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(stream_info->framedrop_pattern,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(0xFFFFFFFF,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_stats_clear_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(val, vfe_dev->vfe_base + stats_base + 0x8);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(val, vfe_dev->vfe_base + stats_base + 0x10);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(val, vfe_dev->vfe_base + stats_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_stats_cfg_ub(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp40.c:		msm_camera_io_w(stats_burst_len << 30 |
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_stats_update_cgc_override(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	module_cfg = msm_camera_io_r(vfe_dev->vfe_base + 0x974);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(module_cfg, vfe_dev->vfe_base + 0x974);
media/platform/msm/camera_v2/isp/msm_isp40.c:static bool msm_vfe40_is_module_cfg_lock_needed(
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_stats_enable_module(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	module_cfg = msm_camera_io_r(vfe_dev->vfe_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(module_cfg, vfe_dev->vfe_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_stats_update_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp40.c:	struct vfe_device *vfe_dev, struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp40.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:	msm_camera_io_w(paddr32, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp40.c:static uint32_t msm_vfe40_stats_get_wm_mask(
media/platform/msm/camera_v2/isp/msm_isp40.c:static uint32_t msm_vfe40_stats_get_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp40.c:static uint32_t msm_vfe40_stats_get_frame_id(
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_get_error_mask(
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_get_overflow_mask(uint32_t *overflow_mask)
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_get_rdi_wm_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_get_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp40.c:static void msm_vfe40_get_halt_restart_mask(uint32_t *irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:static struct msm_vfe_axi_hardware_info msm_vfe40_axi_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp40.c:static struct msm_vfe_stats_hardware_info msm_vfe40_stats_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp40.c:struct msm_vfe_hardware_info vfe40_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_vfe40_read_and_clear_irq_status,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.read_irq_status = msm_vfe40_read_irq_status,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.process_camif_irq = msm_vfe40_process_input_irq,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.process_reset_irq = msm_vfe40_process_reset_irq,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.process_halt_irq = msm_vfe40_process_halt_irq,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.process_reg_update = msm_vfe40_process_reg_update,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.process_axi_irq = msm_isp_process_axi_irq,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.process_stats_irq = msm_isp_process_stats_irq,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.process_epoch_irq = msm_vfe40_process_epoch_irq,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.config_irq = msm_vfe40_config_irq,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.preprocess_camif_irq = msm_isp47_preprocess_camif_irq,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.reload_wm = msm_vfe40_axi_reload_wm,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.enable_wm = msm_vfe40_axi_enable_wm,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.cfg_io_format = msm_vfe40_cfg_io_format,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.cfg_comp_mask = msm_vfe40_axi_cfg_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.clear_comp_mask = msm_vfe40_axi_clear_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.cfg_wm_irq_mask = msm_vfe40_axi_cfg_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.clear_wm_irq_mask = msm_vfe40_axi_clear_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.cfg_framedrop = msm_vfe40_cfg_framedrop,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.clear_framedrop = msm_vfe40_clear_framedrop,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.cfg_wm_reg = msm_vfe40_axi_cfg_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.clear_wm_reg = msm_vfe40_axi_clear_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.cfg_wm_xbar_reg = msm_vfe40_axi_cfg_wm_xbar_reg,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.clear_wm_xbar_reg = msm_vfe40_axi_clear_wm_xbar_reg,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.cfg_ub = msm_vfe47_cfg_axi_ub,
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_vfe40_read_wm_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_vfe40_update_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_comp_mask = msm_vfe40_get_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_wm_mask = msm_vfe40_get_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_pingpong_status = msm_vfe40_get_pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.halt = msm_vfe40_axi_halt,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.restart = msm_vfe40_axi_restart,
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_vfe40_axi_update_cgc_override,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.ub_reg_offset = msm_vfe40_ub_reg_offset,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_ub_size = msm_vfe40_get_ub_size,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.reg_update = msm_vfe40_reg_update,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.cfg_input_mux = msm_vfe40_cfg_input_mux,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.update_camif_state = msm_vfe40_update_camif_state,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.start_fetch_eng = msm_vfe40_start_fetch_engine,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.cfg_rdi_reg = msm_vfe40_cfg_rdi_reg,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.reset_hw = msm_vfe40_reset_hardware,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.init_hw = msm_vfe47_init_hardware,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.init_hw_reg = msm_vfe40_init_hardware_reg,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.clear_status_reg = msm_vfe40_clear_status_reg,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.release_hw = msm_vfe47_release_hardware,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_error_mask = msm_vfe40_get_error_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_overflow_mask = msm_vfe40_get_overflow_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_rdi_wm_mask = msm_vfe40_get_rdi_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_irq_mask = msm_vfe40_get_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_vfe40_get_halt_restart_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.process_error_status = msm_vfe40_process_error_status,
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_vfe40_is_module_cfg_lock_needed,
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_vfe40_start_fetch_engine_multi_pass,
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_vfe40_set_halt_restart_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_stats_idx = msm_vfe40_get_stats_idx,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.check_streams = msm_vfe40_stats_check_streams,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.cfg_comp_mask = msm_vfe40_stats_cfg_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.cfg_wm_irq_mask = msm_vfe40_stats_cfg_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.clear_wm_irq_mask = msm_vfe40_stats_clear_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.cfg_wm_reg = msm_vfe40_stats_cfg_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.clear_wm_reg = msm_vfe40_stats_clear_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.cfg_ub = msm_vfe40_stats_cfg_ub,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.enable_module = msm_vfe40_stats_enable_module,
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_vfe40_stats_update_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_comp_mask = msm_vfe40_stats_get_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_wm_mask = msm_vfe40_stats_get_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_frame_id = msm_vfe40_stats_get_frame_id,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_pingpong_status = msm_vfe40_get_pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp40.c:				msm_vfe40_stats_update_cgc_override,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_platform_data = msm_vfe47_get_platform_data,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.enable_regulators = msm_vfe47_enable_regulators,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_regulators = msm_vfe47_get_regulators,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.put_regulators = msm_vfe47_put_regulators,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.enable_clks = msm_vfe47_enable_clks,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_clks = msm_vfe47_get_clks,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.put_clks = msm_vfe47_put_clks,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_clk_rates = msm_vfe47_get_clk_rates,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.get_max_clk_rate = msm_vfe47_get_max_clk_rate,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.set_clk_rate = msm_vfe47_set_clk_rate,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.init_bw_mgr = msm_vfe47_init_bandwidth_mgr,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.deinit_bw_mgr = msm_vfe47_deinit_bandwidth_mgr,
media/platform/msm/camera_v2/isp/msm_isp40.c:			.update_bw = msm_vfe47_update_bandwidth,
media/platform/msm/camera_v2/isp/msm_isp40.c:	.axi_hw_info = &msm_vfe40_axi_hw_info,
media/platform/msm/camera_v2/isp/msm_isp40.c:	.stats_hw_info = &msm_vfe40_stats_hw_info,
media/platform/msm/camera_v2/isp/msm_isp40.c:static const struct of_device_id msm_vfe40_dt_match[] = {
media/platform/msm/camera_v2/isp/msm_isp40.c:MODULE_DEVICE_TABLE(of, msm_vfe40_dt_match);
media/platform/msm/camera_v2/isp/msm_isp40.c:		.name = "msm_vfe40",
media/platform/msm/camera_v2/isp/msm_isp40.c:		.of_match_table = msm_vfe40_dt_match,
media/platform/msm/camera_v2/isp/msm_isp40.c:static int __init msm_vfe40_init_module(void)
media/platform/msm/camera_v2/isp/msm_isp40.c:static void __exit msm_vfe40_exit_module(void)
media/platform/msm/camera_v2/isp/msm_isp40.c:module_init(msm_vfe40_init_module);
media/platform/msm/camera_v2/isp/msm_isp40.c:module_exit(msm_vfe40_exit_module);
media/platform/msm/camera_v2/isp/msm_isp40.h:extern struct msm_vfe_hardware_info vfe40_hw_info;
media/platform/msm/camera_v2/isp/msm_isp44.c:#include "msm_isp44.h"
media/platform/msm/camera_v2/isp/msm_isp44.c:#include "msm_isp_util.h"
media/platform/msm/camera_v2/isp/msm_isp44.c:#include "msm_isp_axi_util.h"
media/platform/msm/camera_v2/isp/msm_isp44.c:#include "msm_isp_stats_util.h"
media/platform/msm/camera_v2/isp/msm_isp44.c:#include "msm_isp.h"
media/platform/msm/camera_v2/isp/msm_isp44.c:#include "msm.h"
media/platform/msm/camera_v2/isp/msm_isp44.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/isp/msm_isp44.c:#include "msm_isp47.h"
media/platform/msm/camera_v2/isp/msm_isp44.c:static uint32_t msm_vfe44_ub_reg_offset(struct vfe_device *vfe_dev, int wm_idx)
media/platform/msm/camera_v2/isp/msm_isp44.c:static uint32_t msm_vfe44_get_ub_size(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_config_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:		enum msm_isp_irq_operation oper)
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(irq0_mask, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(irq1_mask, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0x1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(irq0_mask, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(irq1_mask, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0x1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w_mb(irq0_mask, vfe_dev->vfe_base + 0x28);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w_mb(irq1_mask, vfe_dev->vfe_base + 0x2C);
media/platform/msm/camera_v2/isp/msm_isp44.c:static int32_t msm_vfe44_init_dt_parms(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:				struct msm_vfe_hw_init_parms *dt_parms)
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_camera_io_w(dt_settings[i],
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_init_hardware_reg(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_hw_init_parms qos_parms;
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_hw_init_parms vbif_parms;
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_hw_init_parms ds_parms;
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_init_dt_parms(vfe_dev, &qos_parms);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_init_dt_parms(vfe_dev, &ds_parms);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_init_dt_parms(vfe_dev, &vbif_parms);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(0x10000001, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_config_irq(vfe_dev, 0x800000E0, 0xFFFFFF7E,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_clear_status_reg(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_config_irq(vfe_dev, 0x80000000, 0,
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(0xFFFFFFFF, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w_mb(0xFFFFFFFF, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_process_reset_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_process_halt_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x2C0);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_process_input_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_isp_increment_frame_id(vfe_dev, VFE_PIX_0, ts);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_isp_fetch_engine_done_notify(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_process_violation_status(
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_process_error_status(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_dump(vfe_dev->vfe_base + 0x2f4, 0x30, 1);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_vfe44_process_violation_status(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_read_and_clear_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	*irq_status0 = msm_camera_io_r(vfe_dev->vfe_base + 0x38);
media/platform/msm/camera_v2/isp/msm_isp44.c:	*irq_status1 = msm_camera_io_r(vfe_dev->vfe_base + 0x3C);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(*irq_status0, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(*irq_status1, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w_mb(1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_r(vfe_dev->vfe_base + 0x31C);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_vfe44_config_irq(vfe_dev, 0, (1 << 0), MSM_ISP_IRQ_DISABLE);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_r(vfe_dev->vfe_base + 0x48);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_read_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	*irq_status0 = msm_camera_io_r(vfe_dev->vfe_base + 0x38);
media/platform/msm/camera_v2/isp/msm_isp44.c:	*irq_status1 = msm_camera_io_r(vfe_dev->vfe_base + 0x3C);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_process_reg_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp44.c:	enum msm_vfe_input_src i;
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_isp_notify(vfe_dev, ISP_EVENT_REG_UPDATE,
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_isp_process_reg_upd_epoch_irq(vfe_dev, i,
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_isp_process_stats_reg_upd_epoch_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_isp_increment_frame_id(vfe_dev, i, ts);
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_isp_notify(vfe_dev, ISP_EVENT_SOF, i, ts);
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_isp_process_reg_upd_epoch_irq(vfe_dev, i,
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_isp_process_reg_upd_epoch_irq(vfe_dev, i,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_process_epoch_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_isp_notify(vfe_dev, ISP_EVENT_SOF, VFE_PIX_0, ts);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_isp_process_reg_upd_epoch_irq(vfe_dev, VFE_PIX_0,
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_isp_process_stats_reg_upd_epoch_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_isp_update_error_frame_count(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp44.c:			msm_isp_notify(vfe_dev, ISP_EVENT_SOF, VFE_PIX_0, ts);
media/platform/msm/camera_v2/isp/msm_isp44.c:			msm_isp_process_reg_upd_epoch_irq(vfe_dev, VFE_PIX_0,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_reg_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	enum msm_vfe_input_src frame_src)
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(update_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(update_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(update_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:static long msm_vfe44_reset_hardware(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(0x1FF, vfe_dev->vfe_base + 0xC);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(0x1EF, vfe_dev->vfe_base + 0xC);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0x7FFFFFFF, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0xFEFFFEFF, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0x1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_axi_reload_wm(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w_mb(reload_mask, vfe_base + 0x4C);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_axi_enable_wm(void __iomem *vfe_base,
media/platform/msm/camera_v2/isp/msm_isp44.c:	val = msm_camera_io_r(vfe_base + VFE44_WM_BASE(wm_idx));
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w_mb(val,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_axi_update_cgc_override(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	val = msm_camera_io_r(vfe_dev->vfe_base + 0x974);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w_mb(val, vfe_dev->vfe_base + 0x974);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_axi_cfg_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp44.c:	comp_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x40);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(comp_mask, vfe_dev->vfe_base + 0x40);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_config_irq(vfe_dev, 1 << (comp_mask_index + 25), 0,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_axi_clear_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp44.c:	comp_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x40);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(comp_mask, vfe_dev->vfe_base + 0x40);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_config_irq(vfe_dev, (1 << (comp_mask_index + 25)), 0,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_axi_cfg_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_config_irq(vfe_dev, 1 << (stream_info->wm[vfe_idx][0] + 8), 0,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_axi_clear_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_config_irq(vfe_dev, (1 << (stream_info->wm[vfe_idx][0] + 8)),
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_cfg_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_axi_stream *stream_info, uint32_t framedrop_pattern,
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(framedrop_pattern, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp44.c:		temp = msm_camera_io_r(vfe_base +
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(temp | (framedrop_period - 1) << 2,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_clear_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp44.c:static int32_t msm_vfe44_convert_bpp_to_reg(int32_t bpp, uint32_t *bpp_reg)
media/platform/msm/camera_v2/isp/msm_isp44.c:static int32_t msm_vfe44_convert_io_fmt_to_reg(
media/platform/msm/camera_v2/isp/msm_isp44.c:	enum msm_isp_pack_fmt pack_format, uint32_t *pack_reg)
media/platform/msm/camera_v2/isp/msm_isp44.c:static int32_t msm_vfe44_cfg_io_format(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	enum msm_vfe_axi_stream_src stream_src, uint32_t io_format)
media/platform/msm/camera_v2/isp/msm_isp44.c:	enum msm_isp_pack_fmt pack_fmt = 0, read_pack_fmt = 0;
media/platform/msm/camera_v2/isp/msm_isp44.c:	io_format_reg = msm_camera_io_r(vfe_dev->vfe_base + 0x54);
media/platform/msm/camera_v2/isp/msm_isp44.c:		read_bpp = msm_isp_get_bit_per_pixel(
media/platform/msm/camera_v2/isp/msm_isp44.c:		rc = msm_vfe44_convert_bpp_to_reg(read_bpp, &read_bpp_reg);
media/platform/msm/camera_v2/isp/msm_isp44.c:		read_pack_fmt = msm_isp_get_pack_format(
media/platform/msm/camera_v2/isp/msm_isp44.c:		rc = msm_vfe44_convert_io_fmt_to_reg(
media/platform/msm/camera_v2/isp/msm_isp44.c:	bpp = msm_isp_get_bit_per_pixel(io_format);
media/platform/msm/camera_v2/isp/msm_isp44.c:	rc = msm_vfe44_convert_bpp_to_reg(bpp, &bpp_reg);
media/platform/msm/camera_v2/isp/msm_isp44.c:		pack_fmt = msm_isp_get_pack_format(io_format);
media/platform/msm/camera_v2/isp/msm_isp44.c:		rc = msm_vfe44_convert_io_fmt_to_reg(pack_fmt, &pack_reg);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(io_format_reg, vfe_dev->vfe_base + 0x54);
media/platform/msm/camera_v2/isp/msm_isp44.c:static int msm_vfe44_fetch_engine_start(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_isp_buffer *buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_fetch_eng_start *fe_cfg = arg;
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_isp_buffer_mapped_info mapped_info;
media/platform/msm/camera_v2/isp/msm_isp44.c:	memset(&mapped_info, 0, sizeof(struct msm_isp_buffer_mapped_info));
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(mapped_info.paddr, vfe_dev->vfe_base + 0x228);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w_mb(0x10000, vfe_dev->vfe_base + 0x4C);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w_mb(0x20000, vfe_dev->vfe_base + 0x4C);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_cfg_fetch_engine(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_fetch_engine_cfg *fe_cfg = NULL;
media/platform/msm/camera_v2/isp/msm_isp44.c:		temp = msm_camera_io_r(vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(temp, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_vfe44_config_irq(vfe_dev, (1 << 24), 0,
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w((fe_cfg->fetch_height - 1) & 0xFFF,
media/platform/msm/camera_v2/isp/msm_isp44.c:		x_size_word = msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w((x_size_word - 1) << 16,
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(x_size_word << 16 |
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0 << 28 | 2 << 25 |
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0xF6543210, vfe_dev->vfe_base + 0x248);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0xF, vfe_dev->vfe_base + 0x264);
media/platform/msm/camera_v2/isp/msm_isp44.c:		temp = msm_camera_io_r(vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(temp, vfe_dev->vfe_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_cfg_camif(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_camif_cfg *camif_cfg = &pix_cfg->camif_cfg;
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_camif_subsample_cfg *subsample_cfg =
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(pix_cfg->input_mux << 16 | pix_cfg->pixel_pattern,
media/platform/msm/camera_v2/isp/msm_isp44.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x2F8);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x2F8);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w((subsample_cfg->line_skip << 16) |
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(camif_cfg->lines_per_frame << 16 |
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(first_pixel << 16 | last_pixel,
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(first_line << 16 | last_line,
media/platform/msm/camera_v2/isp/msm_isp44.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x2F8);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x2F8);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x314);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0xFFFFFFFF, vfe_dev->vfe_base + 0x314);
media/platform/msm/camera_v2/isp/msm_isp44.c:	val = msm_camera_io_r(vfe_dev->vfe_base + 0x2E8);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(val, vfe_dev->vfe_base + 0x2E8);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_cfg_input_mux(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_vfe44_cfg_camif(vfe_dev, pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_vfe44_cfg_fetch_engine(vfe_dev, pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_update_camif_state(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	enum msm_isp_camif_update_state update_state)
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(0x81, vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_vfe44_config_irq(vfe_dev, 0xF7, 0x81,
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(0x140000, vfe_dev->vfe_base + 0x318);
media/platform/msm/camera_v2/isp/msm_isp44.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x2F8);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x2F8);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(0x4, vfe_dev->vfe_base + 0x2F4);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x2F4);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_vfe44_config_irq(vfe_dev, 0,
media/platform/msm/camera_v2/isp/msm_isp44.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0xC18);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(val & ~(1 << 8), vfe_dev->vfe_base + 0xC18);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb((update_state == DISABLE_CAMIF ? 0x0 : 0x6),
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w((1 << 0), vfe_dev->vfe_base + 0x34);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(1, vfe_dev->vfe_base + 0x24);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_vfe44_config_irq(vfe_dev, vfe_dev->irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_cfg_rdi_reg(
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct vfe_device *vfe_dev, struct msm_vfe_rdi_cfg *rdi_cfg,
media/platform/msm/camera_v2/isp/msm_isp44.c:	enum msm_vfe_input_src input_src)
media/platform/msm/camera_v2/isp/msm_isp44.c:	rdi_reg_cfg = msm_camera_io_r(
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(rdi_reg_cfg,
media/platform/msm/camera_v2/isp/msm_isp44.c:	rdi_reg_cfg = msm_camera_io_r(
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_axi_cfg_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0x0, vfe_dev->vfe_base + wm_base);
media/platform/msm/camera_v2/isp/msm_isp44.c:			((msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp44.c:			msm_isp_cal_word_per_line(stream_info->output_format,
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(0x2, vfe_dev->vfe_base + wm_base);
media/platform/msm/camera_v2/isp/msm_isp44.c:			msm_isp_cal_word_per_line(stream_info->output_format,
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(0xFFFFFFFF,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_axi_clear_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx)
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0xC);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x20);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_axi_cfg_wm_xbar_reg(
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_axi_plane_cfg *plane_cfg;
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_r(vfe_dev->vfe_base + VFE44_XBAR_BASE(wm));
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(xbar_reg_cfg,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_axi_clear_wm_xbar_reg(
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx)
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_r(vfe_dev->vfe_base + VFE44_XBAR_BASE(wm));
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(xbar_reg_cfg,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_read_wm_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_dump(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_update_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(paddr32, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_set_halt_restart_mask(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_config_irq(vfe_dev, BIT(31), BIT(8), MSM_ISP_IRQ_SET);
media/platform/msm/camera_v2/isp/msm_isp44.c:static int msm_vfe44_axi_halt(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	enum msm_vfe_input_src i;
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_isp_timestamp ts;
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_config_irq(vfe_dev, (1 << 31), (1 << 8),
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x2C0);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x2C0);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_isp_get_timestamp(&ts, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_isp_axi_stream_update(vfe_dev, i, &ts);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_isp_axi_stream_update(vfe_dev, i, &ts);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_isp_stats_stream_update(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_isp_stats_stream_update(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_axi_restart(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_config_irq(vfe_dev, vfe_dev->recovery_irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w_mb(0x140000, vfe_dev->vfe_base + 0x318);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x2C0);
media/platform/msm/camera_v2/isp/msm_isp44.c:static uint32_t msm_vfe44_get_wm_mask(
media/platform/msm/camera_v2/isp/msm_isp44.c:static uint32_t msm_vfe44_get_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp44.c:static uint32_t msm_vfe44_get_pingpong_status(
media/platform/msm/camera_v2/isp/msm_isp44.c:	return msm_camera_io_r(vfe_dev->vfe_base + 0x268);
media/platform/msm/camera_v2/isp/msm_isp44.c:static int msm_vfe44_get_stats_idx(enum msm_isp_stats_type stats_type)
media/platform/msm/camera_v2/isp/msm_isp44.c:static int msm_vfe44_stats_check_streams(
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_stats_cfg_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
media/platform/msm/camera_v2/isp/msm_isp44.c:	comp_mask_reg = msm_camera_io_r(vfe_dev->vfe_base + 0x44);
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_vfe44_config_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_vfe44_config_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(comp_mask_reg, vfe_dev->vfe_base + 0x44);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_stats_cfg_wm_irq_mask(
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_config_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_stats_clear_wm_irq_mask(
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_vfe44_config_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_stats_cfg_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w((stream_info->framedrop_period - 1) << 2,
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(stream_info->framedrop_pattern,
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(0xFFFFFFFF,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_stats_clear_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(val, vfe_dev->vfe_base + stats_base + 0x8);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(val, vfe_dev->vfe_base + stats_base + 0x10);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(val, vfe_dev->vfe_base + stats_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_stats_cfg_ub(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp44.c:		msm_camera_io_w(VFE44_STATS_BURST_LEN << 30 |
media/platform/msm/camera_v2/isp/msm_isp44.c:static bool msm_vfe44_is_module_cfg_lock_needed(
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_stats_enable_module(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	module_cfg = msm_camera_io_r(vfe_dev->vfe_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(module_cfg, vfe_dev->vfe_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp44.c:	stats_cfg = msm_camera_io_r(vfe_dev->vfe_base + 0x888);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(stats_cfg, vfe_dev->vfe_base + 0x888);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_stats_update_cgc_override(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	val = msm_camera_io_r(vfe_dev->vfe_base + 0x974);
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(val, vfe_dev->vfe_base + 0x974);
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_stats_update_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp44.c:	struct vfe_device *vfe_dev, struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp44.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:	msm_camera_io_w(paddr32, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp44.c:static uint32_t msm_vfe44_stats_get_wm_mask(
media/platform/msm/camera_v2/isp/msm_isp44.c:static uint32_t msm_vfe44_stats_get_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp44.c:static uint32_t msm_vfe44_stats_get_frame_id(
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_get_error_mask(
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_get_overflow_mask(uint32_t *overflow_mask)
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_get_rdi_wm_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_get_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp44.c:static void msm_vfe44_get_halt_restart_mask(uint32_t *irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:static struct msm_vfe_axi_hardware_info msm_vfe44_axi_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp44.c:static struct msm_vfe_stats_hardware_info msm_vfe44_stats_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp44.c:struct msm_vfe_hardware_info vfe44_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_vfe44_read_and_clear_irq_status,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.read_irq_status = msm_vfe44_read_irq_status,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.process_camif_irq = msm_vfe44_process_input_irq,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.process_reset_irq = msm_vfe44_process_reset_irq,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.process_halt_irq = msm_vfe44_process_halt_irq,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.process_reg_update = msm_vfe44_process_reg_update,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.process_axi_irq = msm_isp_process_axi_irq,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.process_stats_irq = msm_isp_process_stats_irq,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.process_epoch_irq = msm_vfe44_process_epoch_irq,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.config_irq = msm_vfe44_config_irq,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.preprocess_camif_irq = msm_isp47_preprocess_camif_irq,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.reload_wm = msm_vfe44_axi_reload_wm,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.enable_wm = msm_vfe44_axi_enable_wm,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.cfg_io_format = msm_vfe44_cfg_io_format,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.cfg_comp_mask = msm_vfe44_axi_cfg_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.clear_comp_mask = msm_vfe44_axi_clear_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.cfg_wm_irq_mask = msm_vfe44_axi_cfg_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.clear_wm_irq_mask = msm_vfe44_axi_clear_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.cfg_framedrop = msm_vfe44_cfg_framedrop,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.clear_framedrop = msm_vfe44_clear_framedrop,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.cfg_wm_reg = msm_vfe44_axi_cfg_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.clear_wm_reg = msm_vfe44_axi_clear_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.cfg_wm_xbar_reg = msm_vfe44_axi_cfg_wm_xbar_reg,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.clear_wm_xbar_reg = msm_vfe44_axi_clear_wm_xbar_reg,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.cfg_ub = msm_vfe47_cfg_axi_ub,
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_vfe44_read_wm_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_vfe44_update_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_comp_mask = msm_vfe44_get_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_wm_mask = msm_vfe44_get_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_pingpong_status = msm_vfe44_get_pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.halt = msm_vfe44_axi_halt,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.restart = msm_vfe44_axi_restart,
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_vfe44_axi_update_cgc_override,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.ub_reg_offset = msm_vfe44_ub_reg_offset,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_ub_size = msm_vfe44_get_ub_size,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.reg_update = msm_vfe44_reg_update,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.cfg_input_mux = msm_vfe44_cfg_input_mux,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.update_camif_state = msm_vfe44_update_camif_state,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.start_fetch_eng = msm_vfe44_fetch_engine_start,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.cfg_rdi_reg = msm_vfe44_cfg_rdi_reg,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.reset_hw = msm_vfe44_reset_hardware,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.init_hw = msm_vfe47_init_hardware,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.init_hw_reg = msm_vfe44_init_hardware_reg,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.clear_status_reg = msm_vfe44_clear_status_reg,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.release_hw = msm_vfe47_release_hardware,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_error_mask = msm_vfe44_get_error_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_overflow_mask = msm_vfe44_get_overflow_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_rdi_wm_mask = msm_vfe44_get_rdi_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_irq_mask = msm_vfe44_get_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_vfe44_get_halt_restart_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.process_error_status = msm_vfe44_process_error_status,
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_vfe44_is_module_cfg_lock_needed,
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_vfe44_set_halt_restart_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_stats_idx = msm_vfe44_get_stats_idx,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.check_streams = msm_vfe44_stats_check_streams,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.cfg_comp_mask = msm_vfe44_stats_cfg_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.cfg_wm_irq_mask = msm_vfe44_stats_cfg_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.clear_wm_irq_mask = msm_vfe44_stats_clear_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.cfg_wm_reg = msm_vfe44_stats_cfg_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.clear_wm_reg = msm_vfe44_stats_clear_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.cfg_ub = msm_vfe44_stats_cfg_ub,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.enable_module = msm_vfe44_stats_enable_module,
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_vfe44_stats_update_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_comp_mask = msm_vfe44_stats_get_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_wm_mask = msm_vfe44_stats_get_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_frame_id = msm_vfe44_stats_get_frame_id,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_pingpong_status = msm_vfe44_get_pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp44.c:				msm_vfe44_stats_update_cgc_override,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_platform_data = msm_vfe47_get_platform_data,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.enable_regulators = msm_vfe47_enable_regulators,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_regulators = msm_vfe47_get_regulators,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.put_regulators = msm_vfe47_put_regulators,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.enable_clks = msm_vfe47_enable_clks,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_clks = msm_vfe47_get_clks,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.put_clks = msm_vfe47_put_clks,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_clk_rates = msm_vfe47_get_clk_rates,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.get_max_clk_rate = msm_vfe47_get_max_clk_rate,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.set_clk_rate = msm_vfe47_set_clk_rate,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.init_bw_mgr = msm_vfe47_init_bandwidth_mgr,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.deinit_bw_mgr = msm_vfe47_deinit_bandwidth_mgr,
media/platform/msm/camera_v2/isp/msm_isp44.c:			.update_bw = msm_vfe47_update_bandwidth,
media/platform/msm/camera_v2/isp/msm_isp44.c:	.axi_hw_info = &msm_vfe44_axi_hw_info,
media/platform/msm/camera_v2/isp/msm_isp44.c:	.stats_hw_info = &msm_vfe44_stats_hw_info,
media/platform/msm/camera_v2/isp/msm_isp44.c:static const struct of_device_id msm_vfe44_dt_match[] = {
media/platform/msm/camera_v2/isp/msm_isp44.c:MODULE_DEVICE_TABLE(of, msm_vfe44_dt_match);
media/platform/msm/camera_v2/isp/msm_isp44.c:		.name = "msm_vfe44",
media/platform/msm/camera_v2/isp/msm_isp44.c:		.of_match_table = msm_vfe44_dt_match,
media/platform/msm/camera_v2/isp/msm_isp44.c:static int __init msm_vfe44_init_module(void)
media/platform/msm/camera_v2/isp/msm_isp44.c:static void __exit msm_vfe44_exit_module(void)
media/platform/msm/camera_v2/isp/msm_isp44.c:module_init(msm_vfe44_init_module);
media/platform/msm/camera_v2/isp/msm_isp44.c:module_exit(msm_vfe44_exit_module);
media/platform/msm/camera_v2/isp/msm_isp44.h:extern struct msm_vfe_hardware_info vfe44_hw_info;
media/platform/msm/camera_v2/isp/msm_isp46.c:#include "msm_isp46.h"
media/platform/msm/camera_v2/isp/msm_isp46.c:#include "msm_isp_util.h"
media/platform/msm/camera_v2/isp/msm_isp46.c:#include "msm_isp_axi_util.h"
media/platform/msm/camera_v2/isp/msm_isp46.c:#include "msm_isp_stats_util.h"
media/platform/msm/camera_v2/isp/msm_isp46.c:#include "msm_isp.h"
media/platform/msm/camera_v2/isp/msm_isp46.c:#include "msm.h"
media/platform/msm/camera_v2/isp/msm_isp46.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/isp/msm_isp46.c:#include "msm_isp47.h"
media/platform/msm/camera_v2/isp/msm_isp46.c:static uint32_t msm_vfe46_ub_reg_offset(struct vfe_device *vfe_dev, int wm_idx)
media/platform/msm/camera_v2/isp/msm_isp46.c:static uint32_t msm_vfe46_get_ub_size(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_config_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:		enum msm_isp_irq_operation oper)
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(irq0_mask, vfe_dev->vfe_base + 0x64);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(irq1_mask, vfe_dev->vfe_base + 0x68);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x58);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(irq1_mask, vfe_dev->vfe_base + 0x64);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(irq1_mask, vfe_dev->vfe_base + 0x68);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x58);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w_mb(vfe_dev->irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w_mb(vfe_dev->irq1_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:static int32_t msm_vfe46_init_dt_parms(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_hw_init_parms *dt_parms, void __iomem *dev_mem_base)
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_camera_io_w(dt_settings[i],
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_init_hardware_reg(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_hw_init_parms qos_parms;
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_hw_init_parms vbif_parms;
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_hw_init_parms ds_parms;
media/platform/msm/camera_v2/isp/msm_isp46.c:	memset(&qos_parms, 0, sizeof(struct msm_vfe_hw_init_parms));
media/platform/msm/camera_v2/isp/msm_isp46.c:	memset(&vbif_parms, 0, sizeof(struct msm_vfe_hw_init_parms));
media/platform/msm/camera_v2/isp/msm_isp46.c:	memset(&ds_parms, 0, sizeof(struct msm_vfe_hw_init_parms));
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_init_dt_parms(vfe_dev, &qos_parms, vfe_dev->vfe_base);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_init_dt_parms(vfe_dev, &ds_parms, vfe_dev->vfe_base);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_init_dt_parms(vfe_dev, &vbif_parms, vfe_dev->vfe_vbif_base);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(0x00000001, vfe_dev->vfe_base + 0x84);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_config_irq(vfe_dev, 0x810000E0, 0xFFFFFF7E,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_clear_status_reg(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_config_irq(vfe_dev, 0x80000000, 0, MSM_ISP_IRQ_SET);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(0xFFFFFFFF, vfe_dev->vfe_base + 0x64);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w_mb(0xFFFFFFFF, vfe_dev->vfe_base + 0x68);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x58);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_process_reset_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_process_halt_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x374);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_process_input_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_isp_fetch_engine_done_notify(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_isp_increment_frame_id(vfe_dev, VFE_PIX_0, ts);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_process_violation_status(
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_process_error_status(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_dump(vfe_dev->vfe_base + 0x3A8, 0x30, 1);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_vfe46_process_violation_status(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_read_and_clear_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	*irq_status0 = msm_camera_io_r(vfe_dev->vfe_base + 0x6C);
media/platform/msm/camera_v2/isp/msm_isp46.c:	*irq_status1 = msm_camera_io_r(vfe_dev->vfe_base + 0x70);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(*irq_status0, vfe_dev->vfe_base + 0x64);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(*irq_status1, vfe_dev->vfe_base + 0x68);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w_mb(1, vfe_dev->vfe_base + 0x58);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_r(vfe_dev->vfe_base + 0x3D0);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_vfe46_config_irq(vfe_dev, 0, (1 << 0), MSM_ISP_IRQ_DISABLE);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_r(vfe_dev->vfe_base + 0x7C);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_read_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	*irq_status0 = msm_camera_io_r(vfe_dev->vfe_base + 0x6C);
media/platform/msm/camera_v2/isp/msm_isp46.c:	*irq_status1 = msm_camera_io_r(vfe_dev->vfe_base + 0x70);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_process_reg_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp46.c:	enum msm_vfe_input_src i;
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_isp_notify(vfe_dev, ISP_EVENT_REG_UPDATE,
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_isp_process_reg_upd_epoch_irq(vfe_dev, i,
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_isp_process_stats_reg_upd_epoch_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_isp_stats_stream_update(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_isp_increment_frame_id(vfe_dev, i, ts);
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_isp_notify(vfe_dev, ISP_EVENT_SOF, i, ts);
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_isp_process_reg_upd_epoch_irq(vfe_dev, i,
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_isp_process_reg_upd_epoch_irq(vfe_dev, i,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_process_epoch_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_isp_notify(vfe_dev, ISP_EVENT_SOF, VFE_PIX_0, ts);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_isp_process_reg_upd_epoch_irq(vfe_dev, VFE_PIX_0,
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_isp_process_stats_reg_upd_epoch_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_isp_update_error_frame_count(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp46.c:			msm_isp_process_reg_upd_epoch_irq(vfe_dev, VFE_PIX_0,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_reg_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	enum msm_vfe_input_src frame_src)
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(update_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(update_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(update_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:static long msm_vfe46_reset_hardware(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(0x1FF, vfe_dev->vfe_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(0x1EF, vfe_dev->vfe_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(0x7FFFFFFF, vfe_dev->vfe_base + 0x64);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(0xFFFFFEFF, vfe_dev->vfe_base + 0x68);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(0x1, vfe_dev->vfe_base + 0x58);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_axi_reload_wm(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w_mb(reload_mask, vfe_base + 0x80);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_axi_update_cgc_override(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	val = msm_camera_io_r(vfe_dev->vfe_base + 0x3C);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w_mb(val, vfe_dev->vfe_base + 0x3C);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_axi_enable_wm(void __iomem *vfe_base,
media/platform/msm/camera_v2/isp/msm_isp46.c:	val = msm_camera_io_r(vfe_base + VFE46_WM_BASE(wm_idx));
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w_mb(val,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_axi_cfg_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp46.c:	comp_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x74);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(comp_mask, vfe_dev->vfe_base + 0x74);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_config_irq(vfe_dev, 1 << (comp_mask_index + 25), 0,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_axi_clear_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp46.c:	comp_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x74);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(comp_mask, vfe_dev->vfe_base + 0x74);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_config_irq(vfe_dev, 1 << (comp_mask_index + 25), 0,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_axi_cfg_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_config_irq(vfe_dev, 1 << (stream_info->wm[vfe_idx][0] + 8), 0,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_axi_clear_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_config_irq(vfe_dev, (1 << (stream_info->wm[vfe_idx][0] + 8)),
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_cfg_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_axi_stream *stream_info, uint32_t framedrop_pattern,
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(framedrop_pattern, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp46.c:		temp = msm_camera_io_r(vfe_base +
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(temp | (framedrop_period - 1) << 2,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_clear_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(0, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp46.c:static int32_t msm_vfe46_convert_bpp_to_reg(int32_t bpp, uint32_t *bpp_reg)
media/platform/msm/camera_v2/isp/msm_isp46.c:static int32_t msm_vfe46_convert_io_fmt_to_reg(
media/platform/msm/camera_v2/isp/msm_isp46.c:	enum msm_isp_pack_fmt pack_format, uint32_t *pack_reg)
media/platform/msm/camera_v2/isp/msm_isp46.c:static int32_t msm_vfe46_cfg_io_format(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	enum msm_vfe_axi_stream_src stream_src, uint32_t io_format)
media/platform/msm/camera_v2/isp/msm_isp46.c:	enum msm_isp_pack_fmt pack_fmt = 0, read_pack_fmt = 0;
media/platform/msm/camera_v2/isp/msm_isp46.c:	io_format_reg = msm_camera_io_r(vfe_dev->vfe_base + 0x88);
media/platform/msm/camera_v2/isp/msm_isp46.c:		read_bpp = msm_isp_get_bit_per_pixel(
media/platform/msm/camera_v2/isp/msm_isp46.c:		rc = msm_vfe46_convert_bpp_to_reg(read_bpp, &read_bpp_reg);
media/platform/msm/camera_v2/isp/msm_isp46.c:		read_pack_fmt = msm_isp_get_pack_format(
media/platform/msm/camera_v2/isp/msm_isp46.c:		rc = msm_vfe46_convert_io_fmt_to_reg(
media/platform/msm/camera_v2/isp/msm_isp46.c:	bpp = msm_isp_get_bit_per_pixel(io_format);
media/platform/msm/camera_v2/isp/msm_isp46.c:	rc = msm_vfe46_convert_bpp_to_reg(bpp, &bpp_reg);
media/platform/msm/camera_v2/isp/msm_isp46.c:		pack_fmt = msm_isp_get_pack_format(io_format);
media/platform/msm/camera_v2/isp/msm_isp46.c:		rc = msm_vfe46_convert_io_fmt_to_reg(pack_fmt, &pack_reg);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(io_format_reg, vfe_dev->vfe_base + 0x88);
media/platform/msm/camera_v2/isp/msm_isp46.c:static int msm_vfe46_start_fetch_engine(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_isp_buffer *buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_fetch_eng_start *fe_cfg = arg;
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_isp_buffer_mapped_info mapped_info;
media/platform/msm/camera_v2/isp/msm_isp46.c:	memset(&mapped_info, 0, sizeof(struct msm_isp_buffer_mapped_info));
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(mapped_info.paddr, vfe_dev->vfe_base + 0x268);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w_mb(0x100000, vfe_dev->vfe_base + 0x80);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w_mb(0x200000, vfe_dev->vfe_base + 0x80);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_cfg_fetch_engine(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_fetch_engine_cfg *fe_cfg = NULL;
media/platform/msm/camera_v2/isp/msm_isp46.c:		temp = msm_camera_io_r(vfe_dev->vfe_base + 0x84);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(temp, vfe_dev->vfe_base + 0x84);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_vfe46_config_irq(vfe_dev, 1 << 24, 0,
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(temp & 0x3FFF, vfe_dev->vfe_base + 0x278);
media/platform/msm/camera_v2/isp/msm_isp46.c:		x_size_word = msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w((x_size_word - 1) << 16,
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(x_size_word << 16 |
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(temp, vfe_dev->vfe_base + 0x284);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(0xF6543210, vfe_dev->vfe_base + 0x288);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(0xF, vfe_dev->vfe_base + 0x2A4);
media/platform/msm/camera_v2/isp/msm_isp46.c:		temp = msm_camera_io_r(vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(temp, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_cfg_testgen(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_testgen_cfg *testgen_cfg)
media/platform/msm/camera_v2/isp/msm_isp46.c:	bit_per_pixel = msm_isp_get_bit_per_pixel(
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(bpp_reg << 16 | testgen_cfg->burst_num_frame,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(((testgen_cfg->lines_per_frame - 1) << 16) |
media/platform/msm/camera_v2/isp/msm_isp46.c:	temp = msm_camera_io_r(vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(temp, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w((1 << 16) | testgen_cfg->v_blank,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w((testgen_cfg->rotate_period << 8) |
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_cfg_camif(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_camif_cfg *camif_cfg = &pix_cfg->camif_cfg;
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_camif_subsample_cfg *subsample_cfg =
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(pix_cfg->input_mux << 5 | pix_cfg->pixel_pattern,
media/platform/msm/camera_v2/isp/msm_isp46.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x3AC);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x3AC);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w((subsample_cfg->line_skip << 16) |
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(camif_cfg->lines_per_frame << 16 |
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(first_pixel << 16 | last_pixel,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(first_line << 16 | last_line,
media/platform/msm/camera_v2/isp/msm_isp46.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x3AC);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x3AC);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x3C8);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(0xFFFFFFFF, vfe_dev->vfe_base + 0x3C8);
media/platform/msm/camera_v2/isp/msm_isp46.c:	val = msm_camera_io_r(vfe_dev->vfe_base + 0x39C);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(val, vfe_dev->vfe_base + 0x39C);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_cfg_input_mux(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp46.c:	core_cfg =  msm_camera_io_r(vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(core_cfg, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_vfe46_cfg_camif(vfe_dev, pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp46.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x3C);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x3C);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(core_cfg, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_vfe46_cfg_camif(vfe_dev, pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_vfe46_cfg_testgen(vfe_dev, &pix_cfg->testgen_cfg);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(core_cfg, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_vfe46_cfg_fetch_engine(vfe_dev, pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_update_camif_state(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	enum msm_isp_camif_update_state update_state)
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x64);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(0x81, vfe_dev->vfe_base + 0x68);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(0x1, vfe_dev->vfe_base + 0x58);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_vfe46_config_irq(vfe_dev, 0x15, 0x81,
media/platform/msm/camera_v2/isp/msm_isp46.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x3AC);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x3AC);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(0x4, vfe_dev->vfe_base + 0x3A8);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x3A8);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(0x140000, vfe_dev->vfe_base + 0x3CC);
media/platform/msm/camera_v2/isp/msm_isp46.c:			msm_camera_io_w(1, vfe_dev->vfe_base + 0xAF4);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_vfe46_config_irq(vfe_dev, 0, 0x81,
media/platform/msm/camera_v2/isp/msm_isp46.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0xC18);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(val, vfe_dev->vfe_base + 0xC18);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb((update_state == DISABLE_CAMIF ? 0x0 : 0x6),
media/platform/msm/camera_v2/isp/msm_isp46.c:			msm_camera_io_w(1 << 1, vfe_dev->vfe_base + 0xAF4);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_cfg_rdi_reg(
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct vfe_device *vfe_dev, struct msm_vfe_rdi_cfg *rdi_cfg,
media/platform/msm/camera_v2/isp/msm_isp46.c:	enum msm_vfe_input_src input_src)
media/platform/msm/camera_v2/isp/msm_isp46.c:	rdi_reg_cfg = msm_camera_io_r(
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_axi_cfg_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp46.c:	val = msm_camera_io_r(vfe_dev->vfe_base + wm_base + 0xC);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0xC);
media/platform/msm/camera_v2/isp/msm_isp46.c:			((msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp46.c:			((msm_isp_cal_word_per_line(stream_info->output_format,
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(0xFFFFFFFF,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_axi_clear_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx)
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0xC);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x20);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_axi_cfg_wm_xbar_reg(
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_axi_plane_cfg *plane_cfg;
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_r(vfe_dev->vfe_base + VFE46_XBAR_BASE(wm));
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(xbar_reg_cfg,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_axi_clear_wm_xbar_reg(
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx)
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_r(vfe_dev->vfe_base + VFE46_XBAR_BASE(wm));
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(xbar_reg_cfg,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_read_wm_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_dump(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_update_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(paddr32, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_set_halt_restart_mask(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_config_irq(vfe_dev, BIT(31), BIT(8), MSM_ISP_IRQ_SET);
media/platform/msm/camera_v2/isp/msm_isp46.c:static int msm_vfe46_axi_halt(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	enum msm_vfe_input_src i;
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_isp_timestamp ts;
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_config_irq(vfe_dev, (1 << 31), (1 << 8),
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x374);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x374);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_isp_get_timestamp(&ts, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_isp_axi_stream_update(vfe_dev, i, &ts);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_isp_axi_stream_update(vfe_dev, i, &ts);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_isp_stats_stream_update(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_isp_stats_stream_update(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_axi_restart(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_config_irq(vfe_dev, vfe_dev->recovery_irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w_mb(0x20000, vfe_dev->vfe_base + 0x3CC);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x374);
media/platform/msm/camera_v2/isp/msm_isp46.c:static uint32_t msm_vfe46_get_wm_mask(
media/platform/msm/camera_v2/isp/msm_isp46.c:static uint32_t msm_vfe46_get_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp46.c:static uint32_t msm_vfe46_get_pingpong_status(
media/platform/msm/camera_v2/isp/msm_isp46.c:	return msm_camera_io_r(vfe_dev->vfe_base + 0x2A8);
media/platform/msm/camera_v2/isp/msm_isp46.c:static int msm_vfe46_get_stats_idx(enum msm_isp_stats_type stats_type)
media/platform/msm/camera_v2/isp/msm_isp46.c:static int msm_vfe46_stats_check_streams(
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_stats_cfg_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
media/platform/msm/camera_v2/isp/msm_isp46.c:	comp_mask_reg = msm_camera_io_r(vfe_dev->vfe_base + 0x78);
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_vfe46_config_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_vfe46_config_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(comp_mask_reg, vfe_dev->vfe_base + 0x78);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_stats_cfg_wm_irq_mask(
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_config_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_stats_clear_wm_irq_mask(
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_vfe46_config_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_stats_cfg_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w((stream_info->framedrop_period - 1) << 2,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(stream_info->framedrop_pattern,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(0xFFFFFFFF,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_stats_clear_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(val, vfe_dev->vfe_base + stats_base + 0x8);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(val, vfe_dev->vfe_base + stats_base + 0x10);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(val, vfe_dev->vfe_base + stats_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_stats_cfg_ub(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp46.c:		msm_camera_io_w(VFE46_STATS_BURST_LEN << 30 |
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_stats_update_cgc_override(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	module_cfg = msm_camera_io_r(vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(module_cfg, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp46.c:static bool msm_vfe46_is_module_cfg_lock_needed(
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_stats_enable_module(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	module_cfg = msm_camera_io_r(vfe_dev->vfe_base + 0x44);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(module_cfg, vfe_dev->vfe_base + 0x44);
media/platform/msm/camera_v2/isp/msm_isp46.c:	stats_cfg = msm_camera_io_r(vfe_dev->vfe_base + 0x9B8);
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(stats_cfg, vfe_dev->vfe_base + 0x9B8);
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_stats_update_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp46.c:	struct vfe_device *vfe_dev, struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp46.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:	msm_camera_io_w(paddr32, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp46.c:static uint32_t msm_vfe46_stats_get_wm_mask(
media/platform/msm/camera_v2/isp/msm_isp46.c:static uint32_t msm_vfe46_stats_get_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp46.c:static uint32_t msm_vfe46_stats_get_frame_id(
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_get_error_mask(
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_get_overflow_mask(uint32_t *overflow_mask)
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_get_rdi_wm_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_get_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp46.c:static void msm_vfe46_get_halt_restart_mask(uint32_t *irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:static struct msm_vfe_axi_hardware_info msm_vfe46_axi_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp46.c:static struct msm_vfe_stats_hardware_info msm_vfe46_stats_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp46.c:struct msm_vfe_hardware_info vfe46_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_vfe46_read_and_clear_irq_status,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.read_irq_status = msm_vfe46_read_irq_status,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.process_camif_irq = msm_vfe46_process_input_irq,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.process_reset_irq = msm_vfe46_process_reset_irq,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.process_halt_irq = msm_vfe46_process_halt_irq,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.process_reg_update = msm_vfe46_process_reg_update,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.process_axi_irq = msm_isp_process_axi_irq,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.process_stats_irq = msm_isp_process_stats_irq,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.process_epoch_irq = msm_vfe46_process_epoch_irq,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.config_irq = msm_vfe46_config_irq,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.preprocess_camif_irq = msm_isp47_preprocess_camif_irq,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.reload_wm = msm_vfe46_axi_reload_wm,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.enable_wm = msm_vfe46_axi_enable_wm,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.cfg_io_format = msm_vfe46_cfg_io_format,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.cfg_comp_mask = msm_vfe46_axi_cfg_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.clear_comp_mask = msm_vfe46_axi_clear_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.cfg_wm_irq_mask = msm_vfe46_axi_cfg_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.clear_wm_irq_mask = msm_vfe46_axi_clear_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.cfg_framedrop = msm_vfe46_cfg_framedrop,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.clear_framedrop = msm_vfe46_clear_framedrop,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.cfg_wm_reg = msm_vfe46_axi_cfg_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.clear_wm_reg = msm_vfe46_axi_clear_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.cfg_wm_xbar_reg = msm_vfe46_axi_cfg_wm_xbar_reg,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.clear_wm_xbar_reg = msm_vfe46_axi_clear_wm_xbar_reg,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.cfg_ub = msm_vfe47_cfg_axi_ub,
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_vfe46_read_wm_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_vfe46_update_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_comp_mask = msm_vfe46_get_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_wm_mask = msm_vfe46_get_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_pingpong_status = msm_vfe46_get_pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.halt = msm_vfe46_axi_halt,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.restart = msm_vfe46_axi_restart,
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_vfe46_axi_update_cgc_override,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.ub_reg_offset = msm_vfe46_ub_reg_offset,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_ub_size = msm_vfe46_get_ub_size,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.reg_update = msm_vfe46_reg_update,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.cfg_input_mux = msm_vfe46_cfg_input_mux,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.update_camif_state = msm_vfe46_update_camif_state,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.start_fetch_eng = msm_vfe46_start_fetch_engine,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.cfg_rdi_reg = msm_vfe46_cfg_rdi_reg,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.reset_hw = msm_vfe46_reset_hardware,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.init_hw = msm_vfe47_init_hardware,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.init_hw_reg = msm_vfe46_init_hardware_reg,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.clear_status_reg = msm_vfe46_clear_status_reg,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.release_hw = msm_vfe47_release_hardware,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_error_mask = msm_vfe46_get_error_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_overflow_mask = msm_vfe46_get_overflow_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_rdi_wm_mask = msm_vfe46_get_rdi_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_irq_mask = msm_vfe46_get_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_vfe46_get_halt_restart_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.process_error_status = msm_vfe46_process_error_status,
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_vfe46_is_module_cfg_lock_needed,
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_vfe46_set_halt_restart_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_stats_idx = msm_vfe46_get_stats_idx,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.check_streams = msm_vfe46_stats_check_streams,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.cfg_comp_mask = msm_vfe46_stats_cfg_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.cfg_wm_irq_mask = msm_vfe46_stats_cfg_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.clear_wm_irq_mask = msm_vfe46_stats_clear_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.cfg_wm_reg = msm_vfe46_stats_cfg_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.clear_wm_reg = msm_vfe46_stats_clear_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.cfg_ub = msm_vfe46_stats_cfg_ub,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.enable_module = msm_vfe46_stats_enable_module,
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_vfe46_stats_update_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_comp_mask = msm_vfe46_stats_get_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_wm_mask = msm_vfe46_stats_get_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_frame_id = msm_vfe46_stats_get_frame_id,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_pingpong_status = msm_vfe46_get_pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp46.c:				msm_vfe46_stats_update_cgc_override,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_platform_data = msm_vfe47_get_platform_data,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.enable_regulators = msm_vfe47_enable_regulators,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_regulators = msm_vfe47_get_regulators,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.put_regulators = msm_vfe47_put_regulators,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.enable_clks = msm_vfe47_enable_clks,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_clks = msm_vfe47_get_clks,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.put_clks = msm_vfe47_put_clks,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_clk_rates = msm_vfe47_get_clk_rates,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.get_max_clk_rate = msm_vfe47_get_max_clk_rate,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.set_clk_rate = msm_vfe47_set_clk_rate,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.init_bw_mgr = msm_vfe47_init_bandwidth_mgr,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.deinit_bw_mgr = msm_vfe47_deinit_bandwidth_mgr,
media/platform/msm/camera_v2/isp/msm_isp46.c:			.update_bw = msm_vfe47_update_bandwidth,
media/platform/msm/camera_v2/isp/msm_isp46.c:	.axi_hw_info = &msm_vfe46_axi_hw_info,
media/platform/msm/camera_v2/isp/msm_isp46.c:	.stats_hw_info = &msm_vfe46_stats_hw_info,
media/platform/msm/camera_v2/isp/msm_isp46.c:static const struct of_device_id msm_vfe46_dt_match[] = {
media/platform/msm/camera_v2/isp/msm_isp46.c:MODULE_DEVICE_TABLE(of, msm_vfe46_dt_match);
media/platform/msm/camera_v2/isp/msm_isp46.c:		.name = "msm_vfe46",
media/platform/msm/camera_v2/isp/msm_isp46.c:		.of_match_table = msm_vfe46_dt_match,
media/platform/msm/camera_v2/isp/msm_isp46.c:static int __init msm_vfe46_init_module(void)
media/platform/msm/camera_v2/isp/msm_isp46.c:static void __exit msm_vfe46_exit_module(void)
media/platform/msm/camera_v2/isp/msm_isp46.c:module_init(msm_vfe46_init_module);
media/platform/msm/camera_v2/isp/msm_isp46.c:module_exit(msm_vfe46_exit_module);
media/platform/msm/camera_v2/isp/msm_isp46.h:extern struct msm_vfe_hardware_info vfe46_hw_info;
media/platform/msm/camera_v2/isp/msm_isp47.c:#include "msm.h"
media/platform/msm/camera_v2/isp/msm_isp47.c:#include "msm_isp_util.h"
media/platform/msm/camera_v2/isp/msm_isp47.c:#include "msm_isp_axi_util.h"
media/platform/msm/camera_v2/isp/msm_isp47.c:#include "msm_isp_stats_util.h"
media/platform/msm/camera_v2/isp/msm_isp47.c:#include "msm_isp.h"
media/platform/msm/camera_v2/isp/msm_isp47.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/isp/msm_isp47.c:#include "msm_isp47.h"
media/platform/msm/camera_v2/isp/msm_isp47.c:#include "msm_isp48.h"
media/platform/msm/camera_v2/isp/msm_isp47.c:#include "msm_cam_cx_ipeak.h"
media/platform/msm/camera_v2/isp/msm_isp47.c:static struct msm_bus_vectors msm_isp_init_vectors[] = {
media/platform/msm/camera_v2/isp/msm_isp47.c:static struct msm_bus_vectors msm_isp_ping_vectors[] = {
media/platform/msm/camera_v2/isp/msm_isp47.c:static struct msm_bus_vectors msm_isp_pong_vectors[] = {
media/platform/msm/camera_v2/isp/msm_isp47.c:static struct msm_bus_paths msm_isp_bus_client_config[] = {
media/platform/msm/camera_v2/isp/msm_isp47.c:		ARRAY_SIZE(msm_isp_init_vectors),
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_isp_init_vectors,
media/platform/msm/camera_v2/isp/msm_isp47.c:		ARRAY_SIZE(msm_isp_ping_vectors),
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_isp_ping_vectors,
media/platform/msm/camera_v2/isp/msm_isp47.c:		ARRAY_SIZE(msm_isp_pong_vectors),
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_isp_pong_vectors,
media/platform/msm/camera_v2/isp/msm_isp47.c:static struct msm_bus_scale_pdata msm_isp_bus_client_pdata = {
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_isp_bus_client_config,
media/platform/msm/camera_v2/isp/msm_isp47.c:	ARRAY_SIZE(msm_isp_bus_client_config),
media/platform/msm/camera_v2/isp/msm_isp47.c:	.name = "msm_camera_isp",
media/platform/msm/camera_v2/isp/msm_isp47.c:uint32_t msm_vfe47_ub_reg_offset(struct vfe_device *vfe_dev, int wm_idx)
media/platform/msm/camera_v2/isp/msm_isp47.c:uint32_t msm_vfe47_get_ub_size(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_config_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:		enum msm_isp_irq_operation oper)
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(irq0_mask, vfe_dev->vfe_base + 0x64);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(irq1_mask, vfe_dev->vfe_base + 0x68);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x58);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(irq0_mask, vfe_dev->vfe_base + 0x64);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(irq1_mask, vfe_dev->vfe_base + 0x68);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x58);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(irq0_mask, vfe_dev->vfe_base + 0x5C);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(irq1_mask, vfe_dev->vfe_base + 0x60);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(vfe_dev->irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(vfe_dev->irq1_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:static int32_t msm_vfe47_init_dt_parms(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_hw_init_parms *dt_parms, void __iomem *dev_mem_base)
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_camera_io_w(dt_settings[i],
media/platform/msm/camera_v2/isp/msm_isp47.c:static enum cam_ahb_clk_vote msm_isp47_get_cam_clk_vote(
media/platform/msm/camera_v2/isp/msm_isp47.c:	 enum msm_vfe_ahb_clk_vote vote)
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_isp47_ahb_clk_cfg(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:			struct msm_isp_ahb_clk_cfg *ahb_cfg)
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_isp_clk_rates clk_rates;
media/platform/msm/camera_v2/isp/msm_isp47.c:		vote = msm_isp47_get_cam_clk_vote(ahb_cfg->vote);
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_init_hardware(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_isp_update_bandwidth(vfe_dev->pdev->id, 0x1000, 0x1000);
media/platform/msm/camera_v2/isp/msm_isp47.c:	rc = msm_camera_enable_irq(vfe_dev->vfe_irq, 1);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_release_hardware(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_enable_irq(vfe_dev->vfe_irq, 0);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_isp_flush_tasklet(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_isp_update_bandwidth(ISP_VFE0 + vfe_dev->pdev->id, 0, 0);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_vfe47_configure_hvx(vfe_dev, 0);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_init_hardware_reg(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_hw_init_parms qos_parms;
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_hw_init_parms vbif_parms;
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_hw_init_parms ds_parms;
media/platform/msm/camera_v2/isp/msm_isp47.c:	memset(&qos_parms, 0, sizeof(struct msm_vfe_hw_init_parms));
media/platform/msm/camera_v2/isp/msm_isp47.c:	memset(&vbif_parms, 0, sizeof(struct msm_vfe_hw_init_parms));
media/platform/msm/camera_v2/isp/msm_isp47.c:	memset(&ds_parms, 0, sizeof(struct msm_vfe_hw_init_parms));
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_vfe47_init_dt_parms(vfe_dev, &qos_parms, vfe_dev->vfe_base);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_vfe47_init_dt_parms(vfe_dev, &ds_parms, vfe_dev->vfe_base);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_vfe47_init_dt_parms(vfe_dev, &vbif_parms, vfe_dev->vfe_vbif_base);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(0x00000101, vfe_dev->vfe_base + 0x84);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_clear_status_reg(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(0xFFFFFFFF, vfe_dev->vfe_base + 0x64);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w_mb(0xFFFFFFFF, vfe_dev->vfe_base + 0x68);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x58);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_process_reset_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_process_halt_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x400);
media/platform/msm/camera_v2/isp/msm_isp47.c:	val = msm_camera_io_r(vfe_dev->vfe_vbif_base + VFE47_VBIF_CLK_OFFSET);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(val, vfe_dev->vfe_vbif_base + VFE47_VBIF_CLK_OFFSET);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_process_input_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_isp_increment_frame_id(vfe_dev, VFE_PIX_0, ts);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_isp_fetch_engine_done_notify(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_process_violation_status(
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_process_error_status(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_dump(vfe_dev->vfe_base + 0x478, 0x3C, 1);
media/platform/msm/camera_v2/isp/msm_isp47.c:			msm_camera_io_dump(vfe_dev->vfe_base + 0xC58, 0x28, 1);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_vfe47_process_violation_status(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_read_and_clear_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	*irq_status0 = msm_camera_io_r(vfe_dev->vfe_base + 0x6C);
media/platform/msm/camera_v2/isp/msm_isp47.c:	*irq_status1 = msm_camera_io_r(vfe_dev->vfe_base + 0x70);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(*irq_status0, vfe_dev->vfe_base + 0x64);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(*irq_status1, vfe_dev->vfe_base + 0x68);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w_mb(1, vfe_dev->vfe_base + 0x58);
media/platform/msm/camera_v2/isp/msm_isp47.c:		(*irq_status0 & msm_camera_io_r(vfe_dev->vfe_base + 0x6C)) &&
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(*irq_status0, vfe_dev->vfe_base + 0x64);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(1, vfe_dev->vfe_base + 0x58);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_r(vfe_dev->vfe_base + 0x4A4);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_r(vfe_dev->vfe_base + 0x7C);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_read_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	*irq_status0 = msm_camera_io_r(vfe_dev->vfe_base + 0x6C);
media/platform/msm/camera_v2/isp/msm_isp47.c:	*irq_status1 = msm_camera_io_r(vfe_dev->vfe_base + 0x70);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_process_reg_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp47.c:	enum msm_vfe_input_src i;
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_isp_notify(vfe_dev, ISP_EVENT_REG_UPDATE,
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_isp_process_stats_reg_upd_epoch_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_isp_process_reg_upd_epoch_irq(vfe_dev, i,
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_isp_increment_frame_id(vfe_dev, i, ts);
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_isp_notify(vfe_dev, ISP_EVENT_SOF, i, ts);
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_isp_process_reg_upd_epoch_irq(vfe_dev, i,
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_isp_process_reg_upd_epoch_irq(vfe_dev, i,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_process_epoch_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_isp_process_reg_upd_epoch_irq(vfe_dev, VFE_PIX_0,
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_isp_process_stats_reg_upd_epoch_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_isp_update_error_frame_count(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_isp_notify(vfe_dev, ISP_EVENT_SOF, VFE_PIX_0, ts);
media/platform/msm/camera_v2/isp/msm_isp47.c:			msm_isp_process_reg_upd_epoch_irq(vfe_dev, VFE_PIX_0,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_isp47_preprocess_camif_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_common_dev_data *c_data;
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_reg_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	enum msm_vfe_input_src frame_src)
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(update_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(update_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(update_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:long msm_vfe47_reset_hardware(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:		if (msm_vfe_is_vfe48(vfe_dev))
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(reset, vfe_dev->vfe_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp47.c:		if (msm_vfe_is_vfe48(vfe_dev))
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(reset, vfe_dev->vfe_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(0x7FFFFFFF, vfe_dev->vfe_base + 0x64);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(0xFFFFFEFF, vfe_dev->vfe_base + 0x68);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(0x1, vfe_dev->vfe_base + 0x58);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_axi_reload_wm(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w_mb(reload_mask, vfe_base + 0x80);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_axi_update_cgc_override(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	val = msm_camera_io_r(vfe_dev->vfe_base + 0x3C);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w_mb(val, vfe_dev->vfe_base + 0x3C);
media/platform/msm/camera_v2/isp/msm_isp47.c:static void msm_vfe47_axi_enable_wm(void __iomem *vfe_base,
media/platform/msm/camera_v2/isp/msm_isp47.c:	val = msm_camera_io_r(vfe_base + VFE47_WM_BASE(wm_idx));
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w_mb(val,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_axi_cfg_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.c:	comp_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x74);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(comp_mask, vfe_dev->vfe_base + 0x74);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_axi_clear_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.c:	comp_mask = msm_camera_io_r(vfe_dev->vfe_base + 0x74);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(comp_mask, vfe_dev->vfe_base + 0x74);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_axi_cfg_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_axi_clear_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_cfg_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_stream *stream_info, uint32_t framedrop_pattern,
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(framedrop_pattern, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp47.c:		temp = msm_camera_io_r(vfe_base +
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(temp | (framedrop_period - 1) << 2,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_clear_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(0, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp47.c:static int32_t msm_vfe47_convert_bpp_to_reg(int32_t bpp, uint32_t *bpp_reg)
media/platform/msm/camera_v2/isp/msm_isp47.c:static int32_t msm_vfe47_convert_io_fmt_to_reg(
media/platform/msm/camera_v2/isp/msm_isp47.c:	enum msm_isp_pack_fmt pack_format, uint32_t *pack_reg)
media/platform/msm/camera_v2/isp/msm_isp47.c:int32_t msm_vfe47_cfg_io_format(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	enum msm_vfe_axi_stream_src stream_src, uint32_t io_format)
media/platform/msm/camera_v2/isp/msm_isp47.c:	enum msm_isp_pack_fmt pack_fmt = 0, read_pack_fmt = 0;
media/platform/msm/camera_v2/isp/msm_isp47.c:	io_format_reg = msm_camera_io_r(vfe_dev->vfe_base + 0x88);
media/platform/msm/camera_v2/isp/msm_isp47.c:		read_bpp = msm_isp_get_bit_per_pixel(
media/platform/msm/camera_v2/isp/msm_isp47.c:		rc = msm_vfe47_convert_bpp_to_reg(read_bpp, &read_bpp_reg);
media/platform/msm/camera_v2/isp/msm_isp47.c:		read_pack_fmt = msm_isp_get_pack_format(
media/platform/msm/camera_v2/isp/msm_isp47.c:		rc = msm_vfe47_convert_io_fmt_to_reg(
media/platform/msm/camera_v2/isp/msm_isp47.c:	bpp = msm_isp_get_bit_per_pixel(io_format);
media/platform/msm/camera_v2/isp/msm_isp47.c:	rc = msm_vfe47_convert_bpp_to_reg(bpp, &bpp_reg);
media/platform/msm/camera_v2/isp/msm_isp47.c:		pack_fmt = msm_isp_get_pack_format(io_format);
media/platform/msm/camera_v2/isp/msm_isp47.c:		rc = msm_vfe47_convert_io_fmt_to_reg(pack_fmt, &pack_reg);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(io_format_reg, vfe_dev->vfe_base + 0x88);
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_start_fetch_engine(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_isp_buffer *buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_fetch_eng_start *fe_cfg = arg;
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_isp_buffer_mapped_info mapped_info;
media/platform/msm/camera_v2/isp/msm_isp47.c:	memset(&mapped_info, 0, sizeof(struct msm_isp_buffer_mapped_info));
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(mapped_info.paddr, vfe_dev->vfe_base + 0x2F4);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w_mb(0x100000, vfe_dev->vfe_base + 0x80);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w_mb(0x200000, vfe_dev->vfe_base + 0x80);
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_start_fetch_engine_multi_pass(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_isp_buffer *buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_fetch_eng_multi_pass_start *fe_cfg = arg;
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_isp_buffer_mapped_info mapped_info;
media/platform/msm/camera_v2/isp/msm_isp47.c:	memset(&mapped_info, 0, sizeof(struct msm_isp_buffer_mapped_info));
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(mapped_info.paddr + fe_cfg->input_buf_offset,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w_mb(0x100000, vfe_dev->vfe_base + 0x80);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w_mb(0x200000, vfe_dev->vfe_base + 0x80);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_cfg_fetch_engine(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_fetch_engine_cfg *fe_cfg = NULL;
media/platform/msm/camera_v2/isp/msm_isp47.c:		temp = msm_camera_io_r(vfe_dev->vfe_base + 0x84);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(temp, vfe_dev->vfe_base + 0x84);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(temp & 0x3FFF, vfe_dev->vfe_base + 0x308);
media/platform/msm/camera_v2/isp/msm_isp47.c:		x_size_word = msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w((x_size_word - 1) << 16,
media/platform/msm/camera_v2/isp/msm_isp47.c:		x_size_word = msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(x_size_word << 16 |
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(temp, vfe_dev->vfe_base + 0x314);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(main_unpack_pattern,
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(0xF, vfe_dev->vfe_base + 0x334);
media/platform/msm/camera_v2/isp/msm_isp47.c:		temp = msm_camera_io_r(vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(temp, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_cfg_testgen(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_testgen_cfg *testgen_cfg)
media/platform/msm/camera_v2/isp/msm_isp47.c:	bit_per_pixel = msm_isp_get_bit_per_pixel(
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(bpp_reg << 16 | testgen_cfg->burst_num_frame,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(((testgen_cfg->lines_per_frame - 1) << 16) |
media/platform/msm/camera_v2/isp/msm_isp47.c:	temp = msm_camera_io_r(vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(temp, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w((1 << 16) | testgen_cfg->v_blank,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w((testgen_cfg->rotate_period << 8) |
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_cfg_camif(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_camif_cfg *camif_cfg = &pix_cfg->camif_cfg;
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_testgen_cfg *testgen_cfg = &pix_cfg->testgen_cfg;
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_camif_subsample_cfg *subsample_cfg =
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(pix_cfg->input_mux << 5 | pix_cfg->pixel_pattern,
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w((testgen_cfg->lines_per_frame - 1) << 16 |
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w((camif_cfg->lines_per_frame - 1) << 16 |
media/platform/msm/camera_v2/isp/msm_isp47.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x47C);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x47C);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w((subsample_cfg->line_skip << 16) |
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(first_pixel << 16 | last_pixel,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(first_line << 16 | last_line,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w_mb(0x140000 | epoch_line1,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(((irq_sub_period - 1) << 8) | 0 << 5 |
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(0xFFFFFFFF, vfe_dev->vfe_base + 0x498);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(0xFFFFFFFF, vfe_dev->vfe_base + 0x49C);
media/platform/msm/camera_v2/isp/msm_isp47.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x494);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x494);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x49C);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(0xFFFFFFFF, vfe_dev->vfe_base + 0x49C);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(
media/platform/msm/camera_v2/isp/msm_isp47.c:		val = msm_camera_io_r(
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(val,
media/platform/msm/camera_v2/isp/msm_isp47.c:	val = msm_camera_io_r(vfe_dev->vfe_base + 0x88);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(val, vfe_dev->vfe_base + 0x88);
media/platform/msm/camera_v2/isp/msm_isp47.c:	val = msm_camera_io_r(vfe_dev->vfe_base + 0x46C);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(val, vfe_dev->vfe_base + 0x46C);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_cfg_input_mux(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_pix_cfg *pix_cfg)
media/platform/msm/camera_v2/isp/msm_isp47.c:	core_cfg =  msm_camera_io_r(vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(core_cfg, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_vfe47_cfg_camif(vfe_dev, pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp47.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x3C);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x3C);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(core_cfg, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_vfe47_cfg_camif(vfe_dev, pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_vfe47_cfg_testgen(vfe_dev, &pix_cfg->testgen_cfg);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(core_cfg, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_vfe47_cfg_fetch_engine(vfe_dev, pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_configure_hvx(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:			rc = msm_camera_clk_enable(&vfe_dev->pdev->dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(val, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(val, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp47.c:		rc = msm_camera_clk_enable(&vfe_dev->pdev->dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(val, vfe_dev->vfe_base + 0x50);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_update_camif_state(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	enum msm_isp_camif_update_state update_state)
media/platform/msm/camera_v2/isp/msm_isp47.c:	val = msm_camera_io_r(vfe_dev->vfe_base + 0x47C);
media/platform/msm/camera_v2/isp/msm_isp47.c:			msm_vfe47_configure_hvx(vfe_dev, 1);
media/platform/msm/camera_v2/isp/msm_isp47.c:			msm_vfe47_configure_hvx(vfe_dev, 0);
media/platform/msm/camera_v2/isp/msm_isp47.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x47C);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(val, vfe_dev->vfe_base + 0x47C);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(0x4, vfe_dev->vfe_base + 0x478);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x478);
media/platform/msm/camera_v2/isp/msm_isp47.c:			msm_camera_io_w(1, vfe_dev->vfe_base + 0xC58);
media/platform/msm/camera_v2/isp/msm_isp47.c:		val = msm_camera_io_r(vfe_dev->vfe_base + 0x464);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(val & ~(1 << 8), vfe_dev->vfe_base + 0x464);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb((update_state == DISABLE_CAMIF ? 0x0 : 0x6),
media/platform/msm/camera_v2/isp/msm_isp47.c:			msm_camera_io_w(1 << 1, vfe_dev->vfe_base + 0xC58);
media/platform/msm/camera_v2/isp/msm_isp47.c:			msm_vfe47_configure_hvx(vfe_dev, 0);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_cfg_rdi_reg(
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct vfe_device *vfe_dev, struct msm_vfe_rdi_cfg *rdi_cfg,
media/platform/msm/camera_v2/isp/msm_isp47.c:	enum msm_vfe_input_src input_src)
media/platform/msm/camera_v2/isp/msm_isp47.c:	rdi_reg_cfg = msm_camera_io_r(
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_axi_cfg_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.c:	val = msm_camera_io_r(vfe_dev->vfe_base + wm_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp47.c:		val = ((msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp47.c:			((msm_isp_cal_word_per_line(stream_info->output_format,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x20);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(0xFFFFFFFF,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_axi_clear_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx)
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x14);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x20);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(val, vfe_dev->vfe_base + wm_base + 0x28);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_axi_cfg_wm_xbar_reg(
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_plane_cfg *plane_cfg;
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_r(vfe_dev->vfe_base + VFE47_XBAR_BASE(wm));
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(xbar_reg_cfg,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_axi_clear_wm_xbar_reg(
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx)
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_r(vfe_dev->vfe_base + VFE47_XBAR_BASE(wm));
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(xbar_reg_cfg,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_cfg_axi_ub_equal_default(
media/platform/msm/camera_v2/isp/msm_isp47.c:	enum msm_vfe_input_src frame_src)
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_shared_data *axi_data =
media/platform/msm/camera_v2/isp/msm_isp47.c:			msm_camera_io_w(0,
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(ub_offset << 16 | (wm_ub_size - 1),
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_cfg_axi_ub_equal_slicing(
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(ub_offset << 16 | (ub_equal_slice - 1),
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_cfg_axi_ub(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	enum msm_vfe_input_src frame_src)
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_vfe47_cfg_axi_ub_equal_slicing(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_vfe47_cfg_axi_ub_equal_default(vfe_dev, frame_src);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_read_wm_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_dump(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_update_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(paddr32, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(paddr32_max, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_set_halt_restart_mask(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_vfe47_config_irq(vfe_dev, BIT(31), BIT(8), MSM_ISP_IRQ_SET);
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_axi_halt(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	enum msm_vfe_input_src i;
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_isp_timestamp ts;
media/platform/msm/camera_v2/isp/msm_isp47.c:	val = msm_camera_io_r(vfe_dev->vfe_vbif_base + VFE47_VBIF_CLK_OFFSET);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(val, vfe_dev->vfe_vbif_base + VFE47_VBIF_CLK_OFFSET);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x400);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w_mb(0x1, vfe_dev->vfe_base + 0x400);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_isp_get_timestamp(&ts, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_isp_axi_stream_update(vfe_dev, i, &ts);
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_isp_axi_stream_update(vfe_dev, i, &ts);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_isp_stats_stream_update(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_isp_stats_stream_update(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_axi_restart(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(0x0, vfe_dev->vfe_base + 0x400);
media/platform/msm/camera_v2/isp/msm_isp47.c:uint32_t msm_vfe47_get_wm_mask(
media/platform/msm/camera_v2/isp/msm_isp47.c:uint32_t msm_vfe47_get_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp47.c:uint32_t msm_vfe47_get_pingpong_status(
media/platform/msm/camera_v2/isp/msm_isp47.c:	return msm_camera_io_r(vfe_dev->vfe_base + 0x338);
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_get_stats_idx(enum msm_isp_stats_type stats_type)
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_stats_check_streams(
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_stats_cfg_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
media/platform/msm/camera_v2/isp/msm_isp47.c:	comp_mask_reg = msm_camera_io_r(vfe_dev->vfe_base + 0x78);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(comp_mask_reg, vfe_dev->vfe_base + 0x78);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_stats_cfg_wm_irq_mask(
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_stats_clear_wm_irq_mask(
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_stats_cfg_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w((stream_info->framedrop_period - 1) << 2,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(stream_info->framedrop_pattern,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(0xFFFFFFFF,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_stats_clear_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(val, vfe_dev->vfe_base + stats_base + 0x10);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(val, vfe_dev->vfe_base + stats_base + 0x18);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(val, vfe_dev->vfe_base + stats_base + 0x1C);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_stats_cfg_ub(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_io_w(VFE47_STATS_BURST_LEN << 30 |
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_stats_update_cgc_override(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	module_cfg = msm_camera_io_r(vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(module_cfg, vfe_dev->vfe_base + 0x30);
media/platform/msm/camera_v2/isp/msm_isp47.c:bool msm_vfe47_is_module_cfg_lock_needed(
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_stats_enable_module(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	module_cfg = msm_camera_io_r(vfe_dev->vfe_base + 0x44);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(module_cfg, vfe_dev->vfe_base + 0x44);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_stats_update_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct vfe_device *vfe_dev, struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp47.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(paddr32, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_io_w(paddr32_max, vfe_base +
media/platform/msm/camera_v2/isp/msm_isp47.c:uint32_t msm_vfe47_stats_get_wm_mask(
media/platform/msm/camera_v2/isp/msm_isp47.c:uint32_t msm_vfe47_stats_get_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp47.c:uint32_t msm_vfe47_stats_get_frame_id(
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_deinit_bandwidth_mgr(
media/platform/msm/camera_v2/isp/msm_isp47.c:		struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr)
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_bus_scale_client_update_request(
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_bus_scale_unregister_client(isp_bandwidth_mgr->bus_client);
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_init_bandwidth_mgr(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr)
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_bus_scale_register_client(&msm_isp_bus_client_pdata);
media/platform/msm/camera_v2/isp/msm_isp47.c:	rc = msm_bus_scale_client_update_request(
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_vfe47_deinit_bandwidth_mgr(isp_bandwidth_mgr);
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_update_bandwidth(
media/platform/msm/camera_v2/isp/msm_isp47.c:		struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr)
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_bus_paths *path = NULL;
media/platform/msm/camera_v2/isp/msm_isp47.c:	path = &(msm_isp_bus_client_pdata.usecase[
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_bus_scale_client_update_request(isp_bandwidth_mgr->bus_client,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_isp_update_req_history(isp_bandwidth_mgr->bus_client,
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_get_clks(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_cam_clk_info clk_info;
media/platform/msm/camera_v2/isp/msm_isp47.c:	rc = msm_camera_get_clk_info(vfe_dev->pdev, &vfe_dev->vfe_clk_info,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_put_clks(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_put_clk_info(vfe_dev->pdev, &vfe_dev->vfe_clk_info,
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_enable_clks(struct vfe_device *vfe_dev, int enable)
media/platform/msm/camera_v2/isp/msm_isp47.c:	return msm_camera_clk_enable(&vfe_dev->pdev->dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_set_clk_rate(struct vfe_device *vfe_dev, long *rate)
media/platform/msm/camera_v2/isp/msm_isp47.c:	rc = msm_camera_clk_set_rate(&vfe_dev->pdev->dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_get_max_clk_rate(struct vfe_device *vfe_dev, long *rate)
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_get_clk_rates(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	struct msm_isp_clk_rates *rates)
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_put_regulators(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_get_regulators(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp47.c:				sizeof(struct msm_cam_regulator), GFP_KERNEL);
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_enable_regulators(struct vfe_device *vfe_dev, int enable)
media/platform/msm/camera_v2/isp/msm_isp47.c:		return msm_camera_regulator_enable(vfe_dev->regulator_info,
media/platform/msm/camera_v2/isp/msm_isp47.c:		return msm_camera_regulator_disable(vfe_dev->regulator_info,
media/platform/msm/camera_v2/isp/msm_isp47.c:int msm_vfe47_get_platform_data(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp47.c:	vfe_dev->vfe_base = msm_camera_get_reg_base(vfe_dev->pdev, "vfe", 0);
media/platform/msm/camera_v2/isp/msm_isp47.c:	vfe_dev->vfe_vbif_base = msm_camera_get_reg_base(vfe_dev->pdev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	vfe_dev->vfe_irq = msm_camera_get_irq(vfe_dev->pdev, "vfe");
media/platform/msm/camera_v2/isp/msm_isp47.c:	vfe_dev->vfe_base_size = msm_camera_get_res_size(vfe_dev->pdev, "vfe");
media/platform/msm/camera_v2/isp/msm_isp47.c:	vfe_dev->vfe_vbif_base_size = msm_camera_get_res_size(vfe_dev->pdev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	vfe_fuse_base = msm_camera_get_reg_base(vfe_dev->pdev,
media/platform/msm/camera_v2/isp/msm_isp47.c:	vfe_fuse_base_size = msm_camera_get_res_size(vfe_dev->pdev,
media/platform/msm/camera_v2/isp/msm_isp47.c:				(msm_camera_io_r(vfe_fuse_base) >> 5) & 0x1;
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_camera_put_reg_base(vfe_dev->pdev, vfe_fuse_base,
media/platform/msm/camera_v2/isp/msm_isp47.c:	rc = msm_camera_register_irq(vfe_dev->pdev, vfe_dev->vfe_irq,
media/platform/msm/camera_v2/isp/msm_isp47.c:		msm_isp_process_irq,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_enable_irq(vfe_dev->vfe_irq, 0);
media/platform/msm/camera_v2/isp/msm_isp47.c:	rc = msm_isp_init_bandwidth_mgr(vfe_dev, ISP_VFE0 + vfe_dev->pdev->id);
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_unregister_irq(vfe_dev->pdev, vfe_dev->vfe_irq, "vfe");
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_put_reg_base(vfe_dev->pdev, vfe_dev->vfe_base,
media/platform/msm/camera_v2/isp/msm_isp47.c:	msm_camera_put_reg_base(vfe_dev->pdev, vfe_dev->vfe_base, "vfe", 0);
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_get_error_mask(
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_get_overflow_mask(uint32_t *overflow_mask)
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_get_rdi_wm_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_get_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.c:void msm_vfe47_get_halt_restart_mask(uint32_t *irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:static struct msm_vfe_axi_hardware_info msm_vfe47_axi_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp47.c:static struct msm_vfe_stats_hardware_info msm_vfe47_stats_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp47.c:struct msm_vfe_hardware_info vfe47_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_vfe47_read_and_clear_irq_status,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.process_camif_irq = msm_vfe47_process_input_irq,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.process_reset_irq = msm_vfe47_process_reset_irq,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.process_halt_irq = msm_vfe47_process_halt_irq,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.process_reg_update = msm_vfe47_process_reg_update,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.process_axi_irq = msm_isp_process_axi_irq,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.process_stats_irq = msm_isp_process_stats_irq,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.process_epoch_irq = msm_vfe47_process_epoch_irq,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.config_irq = msm_vfe47_config_irq,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.read_irq_status = msm_vfe47_read_irq_status,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.preprocess_camif_irq = msm_isp47_preprocess_camif_irq,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.reload_wm = msm_vfe47_axi_reload_wm,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.enable_wm = msm_vfe47_axi_enable_wm,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.cfg_io_format = msm_vfe47_cfg_io_format,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.cfg_comp_mask = msm_vfe47_axi_cfg_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.clear_comp_mask = msm_vfe47_axi_clear_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.cfg_wm_irq_mask = msm_vfe47_axi_cfg_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.clear_wm_irq_mask = msm_vfe47_axi_clear_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.cfg_framedrop = msm_vfe47_cfg_framedrop,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.clear_framedrop = msm_vfe47_clear_framedrop,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.cfg_wm_reg = msm_vfe47_axi_cfg_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.clear_wm_reg = msm_vfe47_axi_clear_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.cfg_wm_xbar_reg = msm_vfe47_axi_cfg_wm_xbar_reg,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.clear_wm_xbar_reg = msm_vfe47_axi_clear_wm_xbar_reg,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.cfg_ub = msm_vfe47_cfg_axi_ub,
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_vfe47_read_wm_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_vfe47_update_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_comp_mask = msm_vfe47_get_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_wm_mask = msm_vfe47_get_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_pingpong_status = msm_vfe47_get_pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.halt = msm_vfe47_axi_halt,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.restart = msm_vfe47_axi_restart,
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_vfe47_axi_update_cgc_override,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.ub_reg_offset = msm_vfe47_ub_reg_offset,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_ub_size = msm_vfe47_get_ub_size,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.reg_update = msm_vfe47_reg_update,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.cfg_input_mux = msm_vfe47_cfg_input_mux,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.update_camif_state = msm_vfe47_update_camif_state,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.start_fetch_eng = msm_vfe47_start_fetch_engine,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.cfg_rdi_reg = msm_vfe47_cfg_rdi_reg,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.reset_hw = msm_vfe47_reset_hardware,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.init_hw = msm_vfe47_init_hardware,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.init_hw_reg = msm_vfe47_init_hardware_reg,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.clear_status_reg = msm_vfe47_clear_status_reg,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.release_hw = msm_vfe47_release_hardware,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_error_mask = msm_vfe47_get_error_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_overflow_mask = msm_vfe47_get_overflow_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_rdi_wm_mask = msm_vfe47_get_rdi_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_irq_mask = msm_vfe47_get_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_vfe47_get_halt_restart_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.process_error_status = msm_vfe47_process_error_status,
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_vfe47_is_module_cfg_lock_needed,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.ahb_clk_cfg = msm_isp47_ahb_clk_cfg,
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_vfe47_start_fetch_engine_multi_pass,
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_vfe47_set_halt_restart_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_stats_idx = msm_vfe47_get_stats_idx,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.check_streams = msm_vfe47_stats_check_streams,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.cfg_comp_mask = msm_vfe47_stats_cfg_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.cfg_wm_irq_mask = msm_vfe47_stats_cfg_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.clear_wm_irq_mask = msm_vfe47_stats_clear_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.cfg_wm_reg = msm_vfe47_stats_cfg_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.clear_wm_reg = msm_vfe47_stats_clear_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.cfg_ub = msm_vfe47_stats_cfg_ub,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.enable_module = msm_vfe47_stats_enable_module,
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_vfe47_stats_update_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_comp_mask = msm_vfe47_stats_get_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_wm_mask = msm_vfe47_stats_get_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_frame_id = msm_vfe47_stats_get_frame_id,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_pingpong_status = msm_vfe47_get_pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp47.c:				msm_vfe47_stats_update_cgc_override,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_platform_data = msm_vfe47_get_platform_data,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.enable_regulators = msm_vfe47_enable_regulators,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_regulators = msm_vfe47_get_regulators,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.put_regulators = msm_vfe47_put_regulators,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.enable_clks = msm_vfe47_enable_clks,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_clks = msm_vfe47_get_clks,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.put_clks = msm_vfe47_put_clks,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_clk_rates = msm_vfe47_get_clk_rates,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.get_max_clk_rate = msm_vfe47_get_max_clk_rate,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.set_clk_rate = msm_vfe47_set_clk_rate,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.init_bw_mgr = msm_vfe47_init_bandwidth_mgr,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.deinit_bw_mgr = msm_vfe47_deinit_bandwidth_mgr,
media/platform/msm/camera_v2/isp/msm_isp47.c:			.update_bw = msm_vfe47_update_bandwidth,
media/platform/msm/camera_v2/isp/msm_isp47.c:	.axi_hw_info = &msm_vfe47_axi_hw_info,
media/platform/msm/camera_v2/isp/msm_isp47.c:	.stats_hw_info = &msm_vfe47_stats_hw_info,
media/platform/msm/camera_v2/isp/msm_isp47.c:static const struct of_device_id msm_vfe47_dt_match[] = {
media/platform/msm/camera_v2/isp/msm_isp47.c:MODULE_DEVICE_TABLE(of, msm_vfe47_dt_match);
media/platform/msm/camera_v2/isp/msm_isp47.c:		.name = "msm_vfe47",
media/platform/msm/camera_v2/isp/msm_isp47.c:		.of_match_table = msm_vfe47_dt_match,
media/platform/msm/camera_v2/isp/msm_isp47.c:static int __init msm_vfe47_init_module(void)
media/platform/msm/camera_v2/isp/msm_isp47.c:static void __exit msm_vfe47_exit_module(void)
media/platform/msm/camera_v2/isp/msm_isp47.c:module_init(msm_vfe47_init_module);
media/platform/msm/camera_v2/isp/msm_isp47.c:module_exit(msm_vfe47_exit_module);
media/platform/msm/camera_v2/isp/msm_isp47.h:enum msm_vfe47_stats_comp_idx {
media/platform/msm/camera_v2/isp/msm_isp47.h:extern struct msm_vfe_hardware_info vfe47_hw_info;
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_read_and_clear_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_read_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_enable_camif_error(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_process_reg_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_process_epoch_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_isp47_preprocess_camif_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_reg_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	enum msm_vfe_input_src frame_src);
media/platform/msm/camera_v2/isp/msm_isp47.h:long msm_vfe47_reset_hardware(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_axi_reload_wm(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_axi_update_cgc_override(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_axi_cfg_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_axi_clear_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_axi_cfg_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_axi_clear_wm_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_cfg_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_axi_stream *stream_info, uint32_t framedrop_pattern,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_clear_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.h:int32_t msm_vfe47_cfg_io_format(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	enum msm_vfe_axi_stream_src stream_src, uint32_t io_format);
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_start_fetch_engine(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_start_fetch_engine_multi_pass(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_cfg_fetch_engine(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_pix_cfg *pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_cfg_testgen(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_testgen_cfg *testgen_cfg);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_cfg_camif(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_pix_cfg *pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_cfg_input_mux(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_pix_cfg *pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_configure_hvx(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_update_camif_state(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	enum msm_isp_camif_update_state update_state);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_cfg_rdi_reg(
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct vfe_device *vfe_dev, struct msm_vfe_rdi_cfg *rdi_cfg,
media/platform/msm/camera_v2/isp/msm_isp47.h:	enum msm_vfe_input_src input_src);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_axi_cfg_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_axi_clear_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_axi_cfg_wm_xbar_reg(
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_axi_clear_wm_xbar_reg(
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_cfg_axi_ub_equal_default(
media/platform/msm/camera_v2/isp/msm_isp47.h:	enum msm_vfe_input_src frame_src);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_cfg_axi_ub_equal_slicing(
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_cfg_axi_ub(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	enum msm_vfe_input_src frame_src);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_read_wm_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_update_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_axi_halt(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_axi_restart(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:uint32_t msm_vfe47_get_wm_mask(
media/platform/msm/camera_v2/isp/msm_isp47.h:uint32_t msm_vfe47_get_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp47.h:uint32_t msm_vfe47_get_pingpong_status(
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_get_stats_idx(enum msm_isp_stats_type stats_type);
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_stats_check_streams(
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_stats_cfg_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_stats_cfg_wm_irq_mask(
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_stats_clear_wm_irq_mask(
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_stats_cfg_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_stats_clear_wm_reg(
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_stats_cfg_ub(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_stats_update_cgc_override(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:bool msm_vfe47_is_module_cfg_lock_needed(
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_stats_enable_module(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_stats_update_ping_pong_addr(
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct vfe_device *vfe_dev, struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp47.h:uint32_t msm_vfe47_stats_get_wm_mask(
media/platform/msm/camera_v2/isp/msm_isp47.h:uint32_t msm_vfe47_stats_get_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp47.h:uint32_t msm_vfe47_stats_get_frame_id(
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_get_error_mask(
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_get_overflow_mask(uint32_t *overflow_mask);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_get_rdi_wm_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_get_irq_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_restore_irq_mask(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_get_halt_restart_mask(uint32_t *irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_init_hardware(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_release_hardware(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_init_hardware_reg(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_process_reset_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_process_halt_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_process_input_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:	struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_process_violation_status(
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_process_error_status(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_clear_status_reg(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_get_platform_data(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_enable_regulators(struct vfe_device *vfe_dev, int enable);
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_get_regulators(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_put_regulators(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_enable_clks(struct vfe_device *vfe_dev, int enable);
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_get_clks(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_put_clks(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_get_clk_rates(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:			struct msm_isp_clk_rates *rates);
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_get_max_clk_rate(struct vfe_device *vfe_dev, long *rate);
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_set_clk_rate(struct vfe_device *vfe_dev, long *rate);
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_init_bandwidth_mgr(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:		struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_deinit_bandwidth_mgr(
media/platform/msm/camera_v2/isp/msm_isp47.h:		struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr);
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_vfe47_update_bandwidth(
media/platform/msm/camera_v2/isp/msm_isp47.h:		struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_config_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:		enum msm_isp_irq_operation oper);
media/platform/msm/camera_v2/isp/msm_isp47.h:int msm_isp47_ahb_clk_cfg(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:			struct msm_isp_ahb_clk_cfg *ahb_cfg);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_set_halt_restart_mask(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:uint32_t msm_vfe47_ub_reg_offset(struct vfe_device *vfe_dev, int wm_idx);
media/platform/msm/camera_v2/isp/msm_isp47.h:uint32_t msm_vfe47_get_ub_size(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_clear_dual_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_dual_config_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp47.h:		enum msm_isp_irq_operation oper);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_set_dual_vfe_mode(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp47.h:void msm_vfe47_clear_dual_vfe_mode(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp48.c:#include "msm_isp_util.h"
media/platform/msm/camera_v2/isp/msm_isp48.c:#include "msm_isp_axi_util.h"
media/platform/msm/camera_v2/isp/msm_isp48.c:#include "msm_isp_stats_util.h"
media/platform/msm/camera_v2/isp/msm_isp48.c:#include "msm_isp.h"
media/platform/msm/camera_v2/isp/msm_isp48.c:#include "msm.h"
media/platform/msm/camera_v2/isp/msm_isp48.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/isp/msm_isp48.c:#include "msm_isp47.h"
media/platform/msm/camera_v2/isp/msm_isp48.c:#include "msm_isp48.h"
media/platform/msm/camera_v2/isp/msm_isp48.c:static struct msm_vfe_axi_hardware_info msm_vfe48_axi_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp48.c:static struct msm_vfe_stats_hardware_info msm_vfe48_stats_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp48.c:static void msm_vfe48_axi_enable_wm(void __iomem *vfe_base,
media/platform/msm/camera_v2/isp/msm_isp48.c:	msm_camera_io_w_mb(val, vfe_base + 0xCEC);
media/platform/msm/camera_v2/isp/msm_isp48.c:static void msm_vfe48_enable_stats_wm(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp48.c:		msm_vfe48_axi_enable_wm(vfe_dev->vfe_base,
media/platform/msm/camera_v2/isp/msm_isp48.c:static void msm_vfe48_deinit_bandwidth_mgr(
media/platform/msm/camera_v2/isp/msm_isp48.c:		struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr)
media/platform/msm/camera_v2/isp/msm_isp48.c:	msm_camera_unregister_bus_client(CAM_BUS_CLIENT_VFE);
media/platform/msm/camera_v2/isp/msm_isp48.c:static int msm_vfe48_init_bandwidth_mgr(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp48.c:	struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr)
media/platform/msm/camera_v2/isp/msm_isp48.c:	rc = msm_camera_register_bus_client(vfe_dev->pdev, CAM_BUS_CLIENT_VFE);
media/platform/msm/camera_v2/isp/msm_isp48.c:					msm_vfe47_init_bandwidth_mgr;
media/platform/msm/camera_v2/isp/msm_isp48.c:					msm_vfe47_deinit_bandwidth_mgr;
media/platform/msm/camera_v2/isp/msm_isp48.c:					msm_vfe47_update_bandwidth;
media/platform/msm/camera_v2/isp/msm_isp48.c:static int msm_vfe48_update_bandwidth(
media/platform/msm/camera_v2/isp/msm_isp48.c:		struct msm_isp_bandwidth_mgr *isp_bandwidth_mgr)
media/platform/msm/camera_v2/isp/msm_isp48.c:	rc = msm_camera_update_bus_bw(CAM_BUS_CLIENT_VFE, ab, ib);
media/platform/msm/camera_v2/isp/msm_isp48.c:		msm_isp_update_req_history(isp_bandwidth_mgr->bus_client,
media/platform/msm/camera_v2/isp/msm_isp48.c:static void msm_vfe48_put_clks(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp48.c:	msm_camera_put_clk_info_and_rates(vfe_dev->pdev, &vfe_dev->vfe_clk_info,
media/platform/msm/camera_v2/isp/msm_isp48.c:static int msm_vfe48_get_clks(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp48.c:	struct msm_cam_clk_info clk_info;
media/platform/msm/camera_v2/isp/msm_isp48.c:	rc = msm_camera_get_clk_info_and_rates(vfe_dev->pdev,
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_clk_set_rate(&vfe_dev->pdev->dev,
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_set_clk_flags(vfe_dev->vfe_clk[i],
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_set_clk_flags(vfe_dev->vfe_clk[i],
media/platform/msm/camera_v2/isp/msm_isp48.c:static int msm_vfe48_get_clk_rates(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp48.c:			struct msm_isp_clk_rates *rates)
media/platform/msm/camera_v2/isp/msm_isp48.c:static int msm_vfe48_get_regulators(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp48.c:	return msm_camera_get_regulator_info(vfe_dev->pdev,
media/platform/msm/camera_v2/isp/msm_isp48.c:static void msm_vfe48_put_regulators(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp48.c:	msm_camera_put_regulators(vfe_dev->pdev,
media/platform/msm/camera_v2/isp/msm_isp48.c:static void msm_vfe48_get_bus_err_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp48.c:	*bus_err = msm_camera_io_r(vfe_dev->vfe_base + 0xC94);
media/platform/msm/camera_v2/isp/msm_isp48.c:static void msm_vfe48_set_bus_err_ign_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp48.c:void msm_vfe48_stats_cfg_ub(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp48.c:		msm_camera_io_w(stats_burst_len << 30 |
media/platform/msm/camera_v2/isp/msm_isp48.c:uint32_t msm_vfe48_get_ub_size(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp48.c:int msm_vfe48_get_dual_sync_platform_data(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_get_irq(vfe_dev->pdev, "dual-vfe-irq");
media/platform/msm/camera_v2/isp/msm_isp48.c:		msm_camera_get_reg_base(vfe_dev->pdev, "msm-cam", 0);
media/platform/msm/camera_v2/isp/msm_isp48.c:		rc = msm_camera_register_irq(vfe_dev->pdev,
media/platform/msm/camera_v2/isp/msm_isp48.c:		vfe_dev->dual_vfe_irq, msm_isp_process_irq_dual_sync,
media/platform/msm/camera_v2/isp/msm_isp48.c:		msm_camera_enable_irq(vfe_dev->dual_vfe_irq, 0);
media/platform/msm/camera_v2/isp/msm_isp48.c:	msm_camera_put_reg_base(vfe_dev->pdev, vfe_dev->camss_base,
media/platform/msm/camera_v2/isp/msm_isp48.c:					"msm-cam", 0);
media/platform/msm/camera_v2/isp/msm_isp48.c:void msm_vfe48_set_dual_vfe_mode(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_get_irq(vfe_dev->pdev, "dual-vfe-irq");
media/platform/msm/camera_v2/isp/msm_isp48.c:	msm_camera_io_w(0x1, vfe_dev->vfe_base + 0xC88);
media/platform/msm/camera_v2/isp/msm_isp48.c:		msm_camera_enable_irq(vfe_dev->dual_vfe_irq, 1);
media/platform/msm/camera_v2/isp/msm_isp48.c:		msm_camera_io_w(1, vfe_dev->camss_base + 0x130);
media/platform/msm/camera_v2/isp/msm_isp48.c:void msm_vfe48_clear_dual_vfe_mode(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_get_irq(vfe_dev->pdev, "dual-vfe-irq");
media/platform/msm/camera_v2/isp/msm_isp48.c:	msm_camera_io_w(0x0, vfe_dev->vfe_base + 0xC88);
media/platform/msm/camera_v2/isp/msm_isp48.c:		msm_camera_enable_irq(vfe_dev->dual_vfe_irq, 0);
media/platform/msm/camera_v2/isp/msm_isp48.c:		msm_camera_io_w(0, vfe_dev->camss_base + 0x130);
media/platform/msm/camera_v2/isp/msm_isp48.c:void msm_vfe48_clear_dual_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_get_irq(vfe_dev->pdev, "dual-vfe-irq");
media/platform/msm/camera_v2/isp/msm_isp48.c:		*dual_irq_status = msm_camera_io_r(vfe_dev->camss_base + 0x140);
media/platform/msm/camera_v2/isp/msm_isp48.c:		msm_camera_io_w(*dual_irq_status, vfe_dev->camss_base + 0x13C);
media/platform/msm/camera_v2/isp/msm_isp48.c:		msm_camera_io_w_mb(1, vfe_dev->camss_base + 0x134);
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_io_r(vfe_dev->camss_base + 0x140)) &&
media/platform/msm/camera_v2/isp/msm_isp48.c:			__func__, msm_camera_io_r(vfe_dev->camss_base + 0x140));
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_io_w(*dual_irq_status,
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_io_w_mb(1, vfe_dev->camss_base + 0x134);
media/platform/msm/camera_v2/isp/msm_isp48.c:void msm_vfe48_dual_config_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp48.c:		enum msm_isp_irq_operation oper)
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_get_irq(vfe_dev->pdev, "dual-vfe-irq");
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_io_w_mb(irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_io_w_mb(irq1_mask, vfe_dev->vfe_base + 0x68);
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_io_w_mb(0x1, vfe_dev->camss_base + 0x134);
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_io_w_mb(irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_io_w_mb(irq1_mask, vfe_dev->vfe_base + 0x68);
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_io_w_mb(0x1,
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_io_w_mb(irq0_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_io_w_mb(irq1_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_io_w_mb(vfe_dev->dual_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			msm_camera_io_w_mb(vfe_dev->irq1_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:struct msm_vfe_hardware_info vfe48_hw_info = {
media/platform/msm/camera_v2/isp/msm_isp48.c:				msm_vfe47_read_and_clear_irq_status,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.read_irq_status = msm_vfe47_read_irq_status,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.process_camif_irq = msm_vfe47_process_input_irq,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.process_reset_irq = msm_vfe47_process_reset_irq,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.process_halt_irq = msm_vfe47_process_halt_irq,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.process_reg_update = msm_vfe47_process_reg_update,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.process_axi_irq = msm_isp_process_axi_irq,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.process_stats_irq = msm_isp_process_stats_irq,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.process_epoch_irq = msm_vfe47_process_epoch_irq,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.config_irq = msm_vfe47_config_irq,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.preprocess_camif_irq = msm_isp47_preprocess_camif_irq,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.dual_config_irq = msm_vfe48_dual_config_irq,
media/platform/msm/camera_v2/isp/msm_isp48.c:				msm_vfe48_clear_dual_irq_status,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.reload_wm = msm_vfe47_axi_reload_wm,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.enable_wm = msm_vfe48_axi_enable_wm,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.cfg_io_format = msm_vfe47_cfg_io_format,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.cfg_comp_mask = msm_vfe47_axi_cfg_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.clear_comp_mask = msm_vfe47_axi_clear_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.cfg_wm_irq_mask = msm_vfe47_axi_cfg_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.clear_wm_irq_mask = msm_vfe47_axi_clear_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.cfg_framedrop = msm_vfe47_cfg_framedrop,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.clear_framedrop = msm_vfe47_clear_framedrop,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.cfg_wm_reg = msm_vfe47_axi_cfg_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.clear_wm_reg = msm_vfe47_axi_clear_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.cfg_wm_xbar_reg = msm_vfe47_axi_cfg_wm_xbar_reg,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.clear_wm_xbar_reg = msm_vfe47_axi_clear_wm_xbar_reg,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.cfg_ub = msm_vfe47_cfg_axi_ub,
media/platform/msm/camera_v2/isp/msm_isp48.c:				msm_vfe47_read_wm_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp48.c:				msm_vfe47_update_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_comp_mask = msm_vfe47_get_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_wm_mask = msm_vfe47_get_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_pingpong_status = msm_vfe47_get_pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.halt = msm_vfe47_axi_halt,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.restart = msm_vfe47_axi_restart,
media/platform/msm/camera_v2/isp/msm_isp48.c:				msm_vfe47_axi_update_cgc_override,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.ub_reg_offset = msm_vfe47_ub_reg_offset,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_ub_size = msm_vfe48_get_ub_size,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.reg_update = msm_vfe47_reg_update,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.cfg_input_mux = msm_vfe47_cfg_input_mux,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.update_camif_state = msm_vfe47_update_camif_state,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.start_fetch_eng = msm_vfe47_start_fetch_engine,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.cfg_rdi_reg = msm_vfe47_cfg_rdi_reg,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.reset_hw = msm_vfe47_reset_hardware,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.init_hw = msm_vfe47_init_hardware,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.init_hw_reg = msm_vfe47_init_hardware_reg,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.clear_status_reg = msm_vfe47_clear_status_reg,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.release_hw = msm_vfe47_release_hardware,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_error_mask = msm_vfe47_get_error_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_overflow_mask = msm_vfe47_get_overflow_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_rdi_wm_mask = msm_vfe47_get_rdi_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_irq_mask = msm_vfe47_get_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:				msm_vfe47_get_halt_restart_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.process_error_status = msm_vfe47_process_error_status,
media/platform/msm/camera_v2/isp/msm_isp48.c:				msm_vfe47_is_module_cfg_lock_needed,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.ahb_clk_cfg = msm_isp47_ahb_clk_cfg,
media/platform/msm/camera_v2/isp/msm_isp48.c:				msm_vfe47_start_fetch_engine_multi_pass,
media/platform/msm/camera_v2/isp/msm_isp48.c:				msm_vfe47_set_halt_restart_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.set_bus_err_ign_mask = msm_vfe48_set_bus_err_ign_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_bus_err_mask = msm_vfe48_get_bus_err_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_stats_idx = msm_vfe47_get_stats_idx,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.check_streams = msm_vfe47_stats_check_streams,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.cfg_comp_mask = msm_vfe47_stats_cfg_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.cfg_wm_irq_mask = msm_vfe47_stats_cfg_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.clear_wm_irq_mask = msm_vfe47_stats_clear_wm_irq_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.cfg_wm_reg = msm_vfe47_stats_cfg_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.clear_wm_reg = msm_vfe47_stats_clear_wm_reg,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.cfg_ub = msm_vfe48_stats_cfg_ub,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.enable_module = msm_vfe47_stats_enable_module,
media/platform/msm/camera_v2/isp/msm_isp48.c:				msm_vfe47_stats_update_ping_pong_addr,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_comp_mask = msm_vfe47_stats_get_comp_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_wm_mask = msm_vfe47_stats_get_wm_mask,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_frame_id = msm_vfe47_stats_get_frame_id,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_pingpong_status = msm_vfe47_get_pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp48.c:				msm_vfe47_stats_update_cgc_override,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.enable_stats_wm = msm_vfe48_enable_stats_wm,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_platform_data = msm_vfe47_get_platform_data,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.enable_regulators = msm_vfe47_enable_regulators,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_regulators = msm_vfe48_get_regulators,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.put_regulators = msm_vfe48_put_regulators,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.enable_clks = msm_vfe47_enable_clks,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.update_bw = msm_vfe48_update_bandwidth,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.init_bw_mgr = msm_vfe48_init_bandwidth_mgr,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.deinit_bw_mgr = msm_vfe48_deinit_bandwidth_mgr,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_clks = msm_vfe48_get_clks,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.put_clks = msm_vfe48_put_clks,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.set_clk_rate = msm_vfe47_set_clk_rate,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_max_clk_rate = msm_vfe47_get_max_clk_rate,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.get_clk_rates = msm_vfe48_get_clk_rates,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.set_dual_vfe_mode = msm_vfe48_set_dual_vfe_mode,
media/platform/msm/camera_v2/isp/msm_isp48.c:			.clear_dual_vfe_mode = msm_vfe48_clear_dual_vfe_mode,
media/platform/msm/camera_v2/isp/msm_isp48.c:				msm_vfe48_get_dual_sync_platform_data,
media/platform/msm/camera_v2/isp/msm_isp48.c:	.axi_hw_info = &msm_vfe48_axi_hw_info,
media/platform/msm/camera_v2/isp/msm_isp48.c:	.stats_hw_info = &msm_vfe48_stats_hw_info,
media/platform/msm/camera_v2/isp/msm_isp48.c:static const struct of_device_id msm_vfe48_dt_match[] = {
media/platform/msm/camera_v2/isp/msm_isp48.c:MODULE_DEVICE_TABLE(of, msm_vfe48_dt_match);
media/platform/msm/camera_v2/isp/msm_isp48.c:		.name = "msm_vfe48",
media/platform/msm/camera_v2/isp/msm_isp48.c:		.of_match_table = msm_vfe48_dt_match,
media/platform/msm/camera_v2/isp/msm_isp48.c:static int __init msm_vfe47_init_module(void)
media/platform/msm/camera_v2/isp/msm_isp48.c:static void __exit msm_vfe47_exit_module(void)
media/platform/msm/camera_v2/isp/msm_isp48.c:module_init(msm_vfe47_init_module);
media/platform/msm/camera_v2/isp/msm_isp48.c:module_exit(msm_vfe47_exit_module);
media/platform/msm/camera_v2/isp/msm_isp48.h:extern struct msm_vfe_hardware_info vfe48_hw_info;
media/platform/msm/camera_v2/isp/msm_isp48.h:enum msm_vfe_clk_rates {
media/platform/msm/camera_v2/isp/msm_isp48.h:static inline int msm_vfe_is_vfe48(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp48.h:void msm_vfe48_stats_cfg_ub(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp48.h:uint32_t msm_vfe48_get_ub_size(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp48.h:void msm_vfe48_clear_dual_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp48.h:void msm_vfe48_dual_config_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp48.h:		enum msm_isp_irq_operation oper);
media/platform/msm/camera_v2/isp/msm_isp48.h:void msm_vfe48_set_dual_vfe_mode(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp48.h:void msm_vfe48_clear_dual_vfe_mode(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp48.h:int msm_vfe48_get_dual_sync_platform_data(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp48.h:void msm_vfe48_clear_dual_irq_status(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp48.h:void msm_vfe48_dual_config_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp48.h:		enum msm_isp_irq_operation oper);
media/platform/msm/camera_v2/isp/msm_isp_32.c:#include "msm_isp_32.h"
media/platform/msm/camera_v2/isp/msm_isp_32.c:#include "msm_isp_util_32.h"
media/platform/msm/camera_v2/isp/msm_isp_32.c:#include "msm_isp_axi_util_32.h"
media/platform/msm/camera_v2/isp/msm_isp_32.c:#include "msm_isp_stats_util_32.h"
media/platform/msm/camera_v2/isp/msm_isp_32.c:#include "msm_sd.h"
media/platform/msm/camera_v2/isp/msm_isp_32.c:#include "msm_isp32.h"
media/platform/msm/camera_v2/isp/msm_isp_32.c:static struct msm_sd_req_vb2_q vfe_vb2_ops;
media/platform/msm/camera_v2/isp/msm_isp_32.c:static const struct of_device_id msm_vfe_dt_match[] = {
media/platform/msm/camera_v2/isp/msm_isp_32.c:MODULE_DEVICE_TABLE(of, msm_vfe_dt_match);
media/platform/msm/camera_v2/isp/msm_isp_32.c:static const struct platform_device_id msm_vfe_dev_id[] = {
media/platform/msm/camera_v2/isp/msm_isp_32.c:	{"msm_vfe32", (kernel_ulong_t) &vfe32_hw_info},
media/platform/msm/camera_v2/isp/msm_isp_32.c:static struct msm_isp_buf_mgr vfe_buf_mgr;
media/platform/msm/camera_v2/isp/msm_isp_32.c:static int msm_isp_enable_debugfs(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_32.c:				  struct msm_isp_bw_req_info *isp_req_hist);
media/platform/msm/camera_v2/isp/msm_isp_32.c:static struct msm_isp_bw_req_info
media/platform/msm/camera_v2/isp/msm_isp_32.c:		msm_isp_bw_request_history[MAX_DEPTH_BW_REQ_HISTORY];
media/platform/msm/camera_v2/isp/msm_isp_32.c:static int msm_isp_bw_request_history_idx;
media/platform/msm/camera_v2/isp/msm_isp_32.c:	struct msm_isp_statistics *stats = vfe_dev->stats;
media/platform/msm/camera_v2/isp/msm_isp_32.c:	msm_isp_util_get_bandwidth_stats(vfe_dev, stats);
media/platform/msm/camera_v2/isp/msm_isp_32.c:	struct msm_isp_statistics *stats = vfe_dev->stats;
media/platform/msm/camera_v2/isp/msm_isp_32.c:	memset(stats, 0, sizeof(struct msm_isp_statistics));
media/platform/msm/camera_v2/isp/msm_isp_32.c:	return sizeof(struct msm_isp_statistics);
media/platform/msm/camera_v2/isp/msm_isp_32.c:	struct msm_isp_bw_req_info *isp_req_hist =
media/platform/msm/camera_v2/isp/msm_isp_32.c:		(struct msm_isp_bw_req_info *) t_file->private_data;
media/platform/msm/camera_v2/isp/msm_isp_32.c:	struct msm_isp_bw_req_info *isp_req_hist =
media/platform/msm/camera_v2/isp/msm_isp_32.c:		(struct msm_isp_bw_req_info *) t_file->private_data;
media/platform/msm/camera_v2/isp/msm_isp_32.c:	memset(isp_req_hist, 0, sizeof(msm_isp_bw_request_history));
media/platform/msm/camera_v2/isp/msm_isp_32.c:	msm_isp_bw_request_history_idx = 0;
media/platform/msm/camera_v2/isp/msm_isp_32.c:	return sizeof(msm_isp_bw_request_history);
media/platform/msm/camera_v2/isp/msm_isp_32.c:	struct msm_isp_ub_info *ub_info = vfe_dev->ub_info;
media/platform/msm/camera_v2/isp/msm_isp_32.c:	struct msm_isp_ub_info *ub_info = vfe_dev->ub_info;
media/platform/msm/camera_v2/isp/msm_isp_32.c:	memset(ub_info, 0, sizeof(struct msm_isp_ub_info));
media/platform/msm/camera_v2/isp/msm_isp_32.c:	return sizeof(struct msm_isp_ub_info);
media/platform/msm/camera_v2/isp/msm_isp_32.c:static int msm_isp_enable_debugfs(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_32.c:				  struct msm_isp_bw_req_info *isp_req_hist)
media/platform/msm/camera_v2/isp/msm_isp_32.c:	snprintf(dirname, sizeof(dirname), "msm_isp%d", vfe_dev->pdev->id);
media/platform/msm/camera_v2/isp/msm_isp_32.c:void msm_isp_update_req_history(uint32_t client, uint64_t ab,
media/platform/msm/camera_v2/isp/msm_isp_32.c:				 struct msm_isp_bandwidth_info *client_info,
media/platform/msm/camera_v2/isp/msm_isp_32.c:	msm_isp_bw_request_history[msm_isp_bw_request_history_idx].client =
media/platform/msm/camera_v2/isp/msm_isp_32.c:	msm_isp_bw_request_history[msm_isp_bw_request_history_idx].timestamp =
media/platform/msm/camera_v2/isp/msm_isp_32.c:	msm_isp_bw_request_history[msm_isp_bw_request_history_idx].total_ab =
media/platform/msm/camera_v2/isp/msm_isp_32.c:	msm_isp_bw_request_history[msm_isp_bw_request_history_idx].total_ib =
media/platform/msm/camera_v2/isp/msm_isp_32.c:		msm_isp_bw_request_history[
media/platform/msm/camera_v2/isp/msm_isp_32.c:			msm_isp_bw_request_history_idx].client_info[i].active =
media/platform/msm/camera_v2/isp/msm_isp_32.c:		msm_isp_bw_request_history[
media/platform/msm/camera_v2/isp/msm_isp_32.c:			msm_isp_bw_request_history_idx].client_info[i].ab =
media/platform/msm/camera_v2/isp/msm_isp_32.c:		msm_isp_bw_request_history[
media/platform/msm/camera_v2/isp/msm_isp_32.c:			msm_isp_bw_request_history_idx].client_info[i].ib =
media/platform/msm/camera_v2/isp/msm_isp_32.c:	msm_isp_bw_request_history_idx = (msm_isp_bw_request_history_idx + 1)
media/platform/msm/camera_v2/isp/msm_isp_32.c:static long msm_isp_dqevent(struct file *file, struct v4l2_fh *vfh, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_32.c:		struct msm_isp32_event_data32 *event_data32;
media/platform/msm/camera_v2/isp/msm_isp_32.c:		struct msm_isp32_event_data  *event_data;
media/platform/msm/camera_v2/isp/msm_isp_32.c:		event_data = (struct msm_isp32_event_data *)
media/platform/msm/camera_v2/isp/msm_isp_32.c:		event_data32 = (struct msm_isp32_event_data32 *)
media/platform/msm/camera_v2/isp/msm_isp_32.c:				sizeof(struct msm_isp32_event_data32));
media/platform/msm/camera_v2/isp/msm_isp_32.c:static long msm_isp_dqevent(struct file *file, struct v4l2_fh *vfh, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_32.c:static long msm_isp_subdev_do_ioctl(
media/platform/msm/camera_v2/isp/msm_isp_32.c:		return msm_isp_dqevent(file, vfh, arg);
media/platform/msm/camera_v2/isp/msm_isp_32.c:static long msm_isp_subdev_fops_ioctl(struct file *file, unsigned int cmd,
media/platform/msm/camera_v2/isp/msm_isp_32.c:	return video_usercopy(file, cmd, arg, msm_isp_subdev_do_ioctl);
media/platform/msm/camera_v2/isp/msm_isp_32.c:static struct v4l2_file_operations msm_isp_v4l2_subdev_fops = {
media/platform/msm/camera_v2/isp/msm_isp_32.c:	.compat_ioctl32 = msm_isp_subdev_fops_ioctl,
media/platform/msm/camera_v2/isp/msm_isp_32.c:	.unlocked_ioctl = msm_isp_subdev_fops_ioctl
media/platform/msm/camera_v2/isp/msm_isp_32.c:	/*struct msm_cam_subdev_info sd_info;*/
media/platform/msm/camera_v2/isp/msm_isp_32.c:	vfe_dev->stats = kzalloc(sizeof(struct msm_isp_statistics), GFP_KERNEL);
media/platform/msm/camera_v2/isp/msm_isp_32.c:	vfe_dev->ub_info = kzalloc(sizeof(struct msm_isp_ub_info), GFP_KERNEL);
media/platform/msm/camera_v2/isp/msm_isp_32.c:		match_dev = of_match_device(msm_vfe_dt_match, &pdev->dev);
media/platform/msm/camera_v2/isp/msm_isp_32.c:			(struct msm_vfe_hardware_info *) match_dev->data;
media/platform/msm/camera_v2/isp/msm_isp_32.c:		vfe_dev->hw_info = (struct msm_vfe_hardware_info *)
media/platform/msm/camera_v2/isp/msm_isp_32.c:		msm_isp_do_tasklet, (unsigned long)vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_32.c:	rc = msm_sd_register(&vfe_dev->subdev);
media/platform/msm/camera_v2/isp/msm_isp_32.c:		pr_err("%s: msm_sd_register error = %d\n", __func__, rc);
media/platform/msm/camera_v2/isp/msm_isp_32.c:	msm_isp_v4l2_subdev_fops.owner = v4l2_subdev_fops.owner;
media/platform/msm/camera_v2/isp/msm_isp_32.c:	msm_isp_v4l2_subdev_fops.open = v4l2_subdev_fops.open;
media/platform/msm/camera_v2/isp/msm_isp_32.c:	msm_isp_v4l2_subdev_fops.release = v4l2_subdev_fops.release;
media/platform/msm/camera_v2/isp/msm_isp_32.c:	msm_isp_v4l2_subdev_fops.poll = v4l2_subdev_fops.poll;
media/platform/msm/camera_v2/isp/msm_isp_32.c:	vfe_dev->subdev.sd.devnode->fops = &msm_isp_v4l2_subdev_fops;
media/platform/msm/camera_v2/isp/msm_isp_32.c:	rc = msm_isp_create_isp_buf_mgr(vfe_dev->buf_mgr,
media/platform/msm/camera_v2/isp/msm_isp_32.c:	msm_isp_enable_debugfs(vfe_dev, msm_isp_bw_request_history);
media/platform/msm/camera_v2/isp/msm_isp_32.c:		.name = "msm_vfe",
media/platform/msm/camera_v2/isp/msm_isp_32.c:		.of_match_table = msm_vfe_dt_match,
media/platform/msm/camera_v2/isp/msm_isp_32.c:	.id_table = msm_vfe_dev_id,
media/platform/msm/camera_v2/isp/msm_isp_32.c:static int __init msm_vfe_init_module(void)
media/platform/msm/camera_v2/isp/msm_isp_32.c:static void __exit msm_vfe_exit_module(void)
media/platform/msm/camera_v2/isp/msm_isp_32.c:module_init(msm_vfe_init_module);
media/platform/msm/camera_v2/isp/msm_isp_32.c:module_exit(msm_vfe_exit_module);
media/platform/msm/camera_v2/isp/msm_isp_32.h:#include <media/msmb_isp.h>
media/platform/msm/camera_v2/isp/msm_isp_32.h:#include <linux/msm-bus.h>
media/platform/msm/camera_v2/isp/msm_isp_32.h:#include <linux/msm-bus-board.h>
media/platform/msm/camera_v2/isp/msm_isp_32.h:#include "msm_buf_mgr.h"
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_axi_stream;
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_stats_stream;
media/platform/msm/camera_v2/isp/msm_isp_32.h:enum msm_isp_pack_fmt {
media/platform/msm/camera_v2/isp/msm_isp_32.h:enum msm_isp_camif_update_state {
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_isp_timestamp {
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_irq_ops {
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_axi_ops {
media/platform/msm/camera_v2/isp/msm_isp_32.h:		enum msm_vfe_axi_stream_src stream_src,
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_axi_stream *stream_info, uint8_t plane_idx);
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_core_ops {
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_pix_cfg *pix_cfg);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		enum msm_isp_camif_update_state update_state);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_rdi_cfg *rdi_cfg,
media/platform/msm/camera_v2/isp/msm_isp_32.h:		enum msm_vfe_input_src input_src);
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_stats_ops {
media/platform/msm/camera_v2/isp/msm_isp_32.h:	int (*get_stats_idx)(enum msm_isp_stats_type stats_type);
media/platform/msm/camera_v2/isp/msm_isp_32.h:	int (*check_streams)(struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_32.h:		struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_ops {
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_irq_ops irq_ops;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_axi_ops axi_ops;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_core_ops core_ops;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_stats_ops stats_ops;
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_hardware_info {
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_ops vfe_ops;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_axi_hardware_info *axi_hw_info;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_stats_hardware_info *stats_hw_info;
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_axi_hardware_info {
media/platform/msm/camera_v2/isp/msm_isp_32.h:enum msm_vfe_axi_state {
media/platform/msm/camera_v2/isp/msm_isp_32.h:enum msm_vfe_axi_cfg_update_state {
media/platform/msm/camera_v2/isp/msm_isp_32.h:enum msm_vfe_axi_stream_type {
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_axi_stream {
media/platform/msm/camera_v2/isp/msm_isp_32.h:	enum msm_vfe_axi_state state;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	enum msm_vfe_axi_stream_src stream_src;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_axi_plane_cfg plane_cfg[MAX_PLANES_PER_STREAM];
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_isp_buffer *buf[2];
media/platform/msm/camera_v2/isp/msm_isp_32.h:	enum msm_vfe_axi_stream_type stream_type;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	enum msm_vfe_frame_skip_pattern frame_skip_pattern;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	enum msm_stream_memory_input_t  memory_input;
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_axi_composite_info {
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_src_info {
media/platform/msm/camera_v2/isp/msm_isp_32.h:	enum msm_vfe_inputmux input_mux;
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_fetch_engine_info {
media/platform/msm/camera_v2/isp/msm_isp_32.h:enum msm_wm_ub_cfg_type {
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_axi_shared_data {
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_axi_hardware_info *hw_info;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_axi_stream stream_info[VFE_AXI_SRC_MAX];
media/platform/msm/camera_v2/isp/msm_isp_32.h:	enum msm_wm_ub_cfg_type wm_ub_cfg_policy;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_axi_composite_info
media/platform/msm/camera_v2/isp/msm_isp_32.h:	enum msm_isp_camif_update_state pipeline_update;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_src_info src_info[VFE_SRC_MAX];
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_stats_hardware_info {
media/platform/msm/camera_v2/isp/msm_isp_32.h:enum msm_vfe_stats_state {
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_stats_stream {
media/platform/msm/camera_v2/isp/msm_isp_32.h:	enum msm_isp_stats_type stats_type;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	enum msm_vfe_stats_state state;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_isp_buffer *buf[2];
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_stats_shared_data {
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_stats_stream stream_info[MSM_ISP_STATS_MAX];
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_tasklet_queue_cmd {
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_isp_timestamp ts;
media/platform/msm/camera_v2/isp/msm_isp_32.h:enum msm_vfe_overflow_state {
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_error_info {
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_isp_statistics {
media/platform/msm/camera_v2/isp/msm_isp_32.h:enum msm_isp_hw_client {
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_isp_bandwidth_info {
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_isp_bw_req_info {
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_isp_bandwidth_info client_info[MAX_ISP_CLIENT];
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_isp_ub_info {
media/platform/msm/camera_v2/isp/msm_isp_32.h:	enum msm_wm_ub_cfg_type policy;
media/platform/msm/camera_v2/isp/msm_isp_32.h:struct msm_vfe_hw_init_parms {
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_sd_subdev subdev;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_tasklet_queue_cmd
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_hardware_info *hw_info;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_axi_shared_data axi_data;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_stats_shared_data stats_data;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_error_info error_info;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_isp_buf_mgr *buf_mgr;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_isp_statistics *stats;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_vfe_fetch_engine_info fetch_engine_info;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	uint64_t msm_isp_last_overflow_ab;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	uint64_t msm_isp_last_overflow_ib;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	uint64_t msm_isp_vfe_clk_rate;
media/platform/msm/camera_v2/isp/msm_isp_32.h:	struct msm_isp_ub_info *ub_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:#include "msm_isp_util.h"
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:#include "msm_isp_stats_util.h"
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:#include "msm_isp_axi_util.h"
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:#include "msm_isp48.h"
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:#include "trace/events/msm_cam.h"
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_reload_ping_pong_offset(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void __msm_isp_axi_stream_update(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_process_done_buf(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info, struct msm_isp_buffer *buf,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_free_pending_buffer(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_update_stream_bandwidth(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		struct msm_vfe_axi_stream *stream_info, int enable);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_axi_create_stream(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream_request_cmd *stream_cfg_cmd,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_axi_destroy_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct vfe_device *vfe_dev, struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_validate_axi_request(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream_request_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_print_fourcc_error(__func__,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static uint32_t msm_isp_axi_get_plane_size(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info, int vfe_idx, int plane_idx)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_plane_cfg *plane_cfg =
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_print_fourcc_error(__func__,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_axi_reserve_wm(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:					msm_isp_axi_get_plane_size(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_axi_free_wm(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_axi_reserve_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_axi_free_comp_mask(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c: * msm_isp_cfg_framedrop_reg() - Program the period and pattern
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_cfg_framedrop_reg(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	enum msm_vfe_input_src frame_src = SRC_TO_INTF(stream_info->stream_src);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_composite_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				enum msm_isp_comp_irq_types irq)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_dump_ping_pong_mismatch(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c: * msm_isp_update_framedrop_reg() - Update frame period pattern on h/w
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_update_framedrop_reg(struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_cfg_framedrop_reg(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_process_reg_upd_epoch_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	enum msm_vfe_input_src frame_src,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	enum msm_isp_comp_irq_types irq,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev, i);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			ret = msm_isp_composite_irq(vfe_dev, stream_info, irq);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:					msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_free_pending_buffer(vfe_dev, stream_info, ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			__msm_isp_axi_stream_update(stream_info, ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				struct msm_vfe_common_dev_data *c_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				msm_isp_update_framedrop_reg(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c: * msm_isp_reset_framedrop() - Compute the framedrop period pattern
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_reset_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	msm_isp_cfg_framedrop_reg(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_check_for_output_error(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_timestamp *ts, struct msm_isp_sof_info *sof_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				if (msm_isp_drop_frame(vfe_dev, stream_info, ts,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_sync_dual_cam_frame_id(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		enum msm_vfe_input_src frame_src,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_src_info *src_info =
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_increment_frame_id(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	enum msm_vfe_input_src frame_src, struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_src_info *src_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_sof_info *sof_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	enum msm_vfe_dual_hw_type dual_hw_type;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	enum msm_vfe_dual_hw_ms_type ms_type;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_sync_dual_cam_frame_id(vfe_dev, ms_res, frame_src, ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_update_pd_stats_idx(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	enum msm_vfe_input_src frame_src)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *pd_stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_buffer *done_buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	pd_stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		vfe_idx = msm_isp_get_vfe_idx_for_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_notify(struct vfe_device *vfe_dev, uint32_t event_type,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	enum msm_vfe_input_src frame_src, struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_event_data event_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_sof_info *sof_info = NULL, *self_sof = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	enum msm_vfe_dual_hw_ms_type ms_type;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_check_for_output_error(vfe_dev, ts,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_update_pd_stats_idx(vfe_dev, frame_src);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		struct msm_isp_event_data_nanosec event_data_nanosec;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_send_event_update_nanosec(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	msm_isp_send_event(vfe_dev, event_type | frame_src, &event_data);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c: * msm_isp_calculate_framedrop() - Setup frame period and pattern
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_calculate_framedrop(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream_request_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	framedrop_period = msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_calculate_bandwidth(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			bpp = msm_isp_get_bit_per_pixel(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c: * msm_isp_set_avtimer_fptr() - Set avtimer function pointer
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_set_avtimer_fptr(struct avtimer_fptr_t avtimer)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:EXPORT_SYMBOL(msm_isp_set_avtimer_fptr);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_start_avtimer(void)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_stop_avtimer(void)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_get_avtimer_ts(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		struct msm_isp_timestamp *time_stamp)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_start_avtimer(void)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_get_avtimer_ts(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		struct msm_isp_timestamp *time_stamp)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:int msm_isp_request_axi_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream_request_cmd *stream_cfg_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = msm_isp_axi_create_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	rc = msm_isp_validate_axi_request(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_destroy_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	msm_isp_axi_reserve_wm(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			rc = msm_isp_calculate_framedrop(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_start_avtimer();
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_reserve_comp_mask(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_reserve_comp_mask(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_cfg_stream_scratch(stream_info, VFE_PING_FLAG);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_cfg_stream_scratch(stream_info, VFE_PONG_FLAG);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_free_wm(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_destroy_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:int msm_isp_release_axi_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream_release_cmd *stream_release_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream_cfg_cmd stream_cfg;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	vfe_idx = msm_isp_get_vfe_idx_for_stream_user(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_cfg_axi_stream(vfe_dev, (void *) &stream_cfg);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_free_comp_mask(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_free_comp_mask(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	msm_isp_axi_free_wm(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	msm_isp_axi_destroy_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_release_all_axi_stream(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream_release_cmd
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream_cfg_cmd stream_cfg_cmd;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev, i);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		vfe_idx = msm_isp_get_vfe_idx_for_stream_user(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_cfg_axi_stream(vfe_dev, (void *) &stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_release_axi_stream(vfe_dev, &stream_release_cmd[i]);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_axi_stream_enable_cfg(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_free_pending_buffer(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_buffer *done_buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_get_avtimer_ts(ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = msm_isp_process_done_buf(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void __msm_isp_axi_stream_update(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_stream_enable_cfg(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_stream_enable_cfg(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_reload_ping_pong_offset(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_stream_enable_cfg(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_notify(stream_info->vfe_dev[j],
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_axi_stream_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	enum msm_vfe_input_src frame_src,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev, i);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		__msm_isp_axi_stream_update(stream_info, ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_reload_ping_pong_offset(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_buffer *buf;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				word_per_line = msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_update_deliver_count(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info, uint32_t pingpong_bit,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_buffer *done_buf)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_halt_send_error(struct vfe_device *vfe_dev, uint32_t event)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_event_data error_event;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_halt_cmd halt_cmd;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_process_overflow_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	memset(&halt_cmd, 0, sizeof(struct msm_vfe_axi_halt_cmd));
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	memset(&error_event, 0, sizeof(struct msm_isp_event_data));
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	msm_isp_send_event(vfe_dev, event, &error_event);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:int msm_isp_print_ping_pong_address(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_buffer *buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev, j);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static struct msm_isp_buffer *msm_isp_get_stream_buffer(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_buffer *buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_frame_request_queue *queue_req;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			struct msm_vfe_frame_request_queue, list);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:int msm_isp_cfg_offline_ping_pong_address(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info, uint32_t pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_buffer *buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			word_per_line = msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_cfg_ping_pong_address(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info, uint32_t pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_buffer *buf)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		buf = msm_isp_get_stream_buffer(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_cfg_stream_scratch(stream_info, pingpong_status);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				msm_isp_cal_word_per_line(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_handle_done_buf_frame_id_mismatch(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct vfe_device *vfe_dev, struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_buffer *buf, struct timeval *time_stamp,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_event_data error_event;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_halt_send_error(vfe_dev, ISP_EVENT_BUF_FATAL_ERROR);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	msm_isp_send_event(vfe_dev, ISP_EVENT_ERROR,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_process_done_buf(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info, struct msm_isp_buffer *buf,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_event_data buf_event;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:					sizeof(struct msm_isp_sw_framskip));
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_send_event(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_send_event(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_send_event(vfe_dev, ISP_EVENT_BUF_DONE,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:int msm_isp_drop_frame(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info, struct msm_isp_timestamp *ts,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_sof_info *sof_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_buffer *done_buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			rc = msm_isp_cfg_ping_pong_address(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_cfg_framedrop_reg(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_process_axi_irq_stream(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c: * msm_isp_input_disable() - Disable the input for given vfe
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_input_disable(struct vfe_device *vfe_dev, int cmd_type)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_src_info *src_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_hardware_info *hw_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_flush_tasklet(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		if (msm_vfe_is_vfe48(vfe_dev))
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c: * msm_isp_input_enable() - Enable the input for given vfe
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_input_enable(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c: * msm_isp_update_intf_stream_cnt() - Update the stream count in axi interface
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_update_intf_stream_cnt(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_update_stream_bandwidth(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info, int enable)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = msm_isp_update_bandwidth(ISP_VFE0 + vfe_dev->pdev->id,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:int msm_isp_ab_ib_update_lpm_mode(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_dual_lpm_mode *ab_ib_vote = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	ab_ib_vote = (struct msm_vfe_dual_lpm_mode *)arg;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_update_stream_bandwidth(stream_info, 0);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_update_stream_bandwidth(stream_info, 1);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_init_stream_ping_pong_reg(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	rc = msm_isp_cfg_ping_pong_address(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = msm_isp_cfg_ping_pong_address(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_get_stream_wm_mask(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	int vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:int msm_isp_axi_halt(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_halt_cmd *halt_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	msm_isp_flush_tasklet(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:int msm_isp_axi_reset(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_reset_cmd *reset_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_timestamp timestamp;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_frame_request_queue *queue_req;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	msm_isp_get_timestamp(&timestamp, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				msm_isp_process_done_buf(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				msm_isp_process_done_buf(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_cfg_stream_scratch(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_cfg_stream_scratch(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				struct msm_vfe_frame_request_queue, list);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			vfe_idx = msm_isp_get_vfe_idx_for_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_reset_burst_count_and_frame_drop(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	if (msm_vfe_is_vfe48(vfe_dev))
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:int msm_isp_axi_restart(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_restart_cmd *restart_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			vfe_idx = msm_isp_get_vfe_idx_for_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_get_stream_wm_mask(temp_vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_init_stream_ping_pong_reg(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_axi_update_cgc_override(struct vfe_device *vfe_dev_ioctl,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev_ioctl,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				vfe_idx = msm_isp_get_vfe_idx_for_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c: * msm_isp_axi_wait_for_stream_cfg_done() - Wait for a stream completion
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_axi_wait_for_stream_cfg_done(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			struct msm_vfe_axi_stream *stream_info, int active)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c: * msm_isp_axi_wait_for_streams() - Wait for completion of a number of streams
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_axi_wait_for_streams(struct msm_vfe_axi_stream **streams,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc |= msm_isp_axi_wait_for_stream_cfg_done(stream_info, active);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int __msm_isp_check_stream_state(struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void __msm_isp_stop_axi_streams(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream **streams, int num_streams, int cmd_type)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_timestamp timestamp;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	msm_isp_get_timestamp(&timestamp, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_update_intf_stream_cnt(stream_info, 0);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_input_disable(update_vfes[k], cmd_type);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			sizeof(struct msm_isp_sw_framskip));
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				__msm_isp_axi_stream_update(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_cfg_stream_scratch(stream_info, VFE_PING_FLAG);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_cfg_stream_scratch(stream_info, VFE_PONG_FLAG);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_free_pending_buffer(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				__msm_isp_axi_stream_update(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_stop_all_stats_stream(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				__msm_isp_axi_stream_update(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	rc = msm_isp_axi_wait_for_streams(streams, num_streams, 0);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			__msm_isp_axi_stream_update(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = msm_isp_axi_wait_for_streams(streams, num_streams, 0);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:					__msm_isp_axi_stream_update(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_update_stream_bandwidth(stream_info, 0);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_start_axi_stream(struct vfe_device *vfe_dev_ioctl,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *streams[MAX_NUM_STREAM];
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_timestamp timestamp;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev_ioctl->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	msm_isp_get_timestamp(&timestamp, vfe_dev_ioctl);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev_ioctl,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = __msm_isp_check_stream_state(stream_info, 1);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_calculate_bandwidth(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_get_stream_wm_mask(stream_info->vfe_dev[k],
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_reset_framedrop(vfe_dev_ioctl, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = msm_isp_init_stream_ping_pong_reg(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_update_stream_bandwidth(stream_info, 1);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_update_intf_stream_cnt(stream_info, 1);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:					__msm_isp_axi_stream_update(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:					msm_camera_io_dump(vfe_dev->vfe_base,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				__msm_isp_axi_stream_update(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_input_enable(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	rc = msm_isp_axi_wait_for_streams(streams, num_streams, 1);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	__msm_isp_stop_axi_streams(vfe_dev_ioctl, streams, num_streams,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_stop_axi_stream(struct vfe_device *vfe_dev_ioctl,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *streams[MAX_NUM_STREAM];
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev_ioctl,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = __msm_isp_check_stream_state(stream_info, 0);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	__msm_isp_stop_axi_streams(vfe_dev_ioctl, streams, num_streams,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:int msm_isp_cfg_axi_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		vfe_idx = msm_isp_get_vfe_idx_for_stream_user(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_update_cgc_override(vfe_dev, stream_cfg_cmd, 1);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = msm_isp_start_axi_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = msm_isp_stop_axi_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_update_cgc_override(vfe_dev, stream_cfg_cmd, 0);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		 * msm_isp_stop_axi_stream
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_return_empty_buffer(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info, uint32_t user_stream_id,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	enum msm_vfe_input_src frame_src)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_buffer *buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_event_data error_event;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_timestamp timestamp;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_halt_send_error(vfe_dev, ISP_EVENT_BUF_FATAL_ERROR);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	msm_isp_get_timestamp(&timestamp, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	msm_isp_send_event(vfe_dev, ISP_EVENT_ERROR, &error_event);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_request_frame(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info, uint32_t user_stream_id,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream_request_cmd stream_cfg_cmd;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_frame_request_queue *queue_req;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	enum msm_vfe_input_src frame_src = 0;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			rc = msm_isp_return_empty_buffer(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = msm_isp_cfg_ping_pong_address(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				struct msm_vfe_frame_request_queue, list);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_get_stream_wm_mask(stream_info->vfe_dev[k],
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			rc = msm_isp_cfg_ping_pong_address(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			rc = msm_isp_cfg_ping_pong_address(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				struct msm_vfe_frame_request_queue, list);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	rc = msm_isp_calculate_framedrop(vfe_dev, &stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_reset_framedrop(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	rc = msm_isp_return_empty_buffer(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_add_buf_queue(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info, uint32_t stream_id)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static void msm_isp_remove_buf_queue(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info, uint32_t stream_id)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_wait_for_stream_cfg_done(stream_info, 1);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c: * msm_isp_stream_axi_cfg_update() - Apply axi config update to a stream
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:static int msm_isp_stream_axi_cfg_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			struct msm_vfe_axi_stream_cfg_update_info *update_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_axi_stream_enable_cfg(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:int msm_isp_update_axi_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream_update_cmd *update_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream_cfg_update_info *update_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_sw_framskip *sw_skip_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_timestamp timestamp;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		update_info = (struct msm_vfe_axi_stream_cfg_update_info *)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				(struct msm_vfe_axi_stream_cfg_update_info *)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				(struct msm_vfe_axi_stream_cfg_update_info *)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_get_timestamp(&timestamp, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_cfg_stream_scratch(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_cfg_stream_scratch(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				(struct msm_vfe_axi_stream_cfg_update_info *)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				msm_isp_cfg_framedrop_reg(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				(struct msm_vfe_axi_stream_cfg_update_info *)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				(struct msm_vfe_axi_stream_cfg_update_info *)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			rc = msm_isp_stream_axi_cfg_update(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				(struct msm_vfe_axi_stream_cfg_update_info *)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			rc = msm_isp_request_frame(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				(struct msm_vfe_axi_stream_cfg_update_info *)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			rc = msm_isp_add_buf_queue(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				(struct msm_vfe_axi_stream_cfg_update_info *)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_remove_buf_queue(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		struct msm_vfe_axi_stream_cfg_update_info_req_frm *req_frm =
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = msm_isp_request_frame(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				(struct msm_vfe_axi_stream_cfg_update_info *)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			vfe_idx = msm_isp_get_vfe_idx_for_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_process_axi_irq_stream(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_isp_buffer *done_buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_get_avtimer_ts(ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_dump_ping_pong_mismatch(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = msm_isp_composite_irq(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		rc = msm_isp_cfg_ping_pong_address(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_cfg_stream_scratch(stream_info, pingpong_status);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	rc = msm_isp_update_deliver_count(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		msm_isp_handle_done_buf_frame_id_mismatch(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_cfg_stream_scratch(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_process_done_buf(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_process_axi_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	uint32_t pingpong_status, struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_composite_info *comp_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:						msm_isp_cfg_wm_scratch(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_process_axi_irq_stream(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:				msm_isp_cfg_wm_scratch(vfe_dev, i,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:			msm_isp_process_axi_irq_stream(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:void msm_isp_axi_disable_all_wm(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev, i);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.c:		vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:#include "msm_isp.h"
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:int msm_isp_axi_check_stream_state(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_reset_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:int msm_isp_request_axi_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_start_avtimer(void);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_stop_avtimer(void);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_get_avtimer_ts(struct msm_isp_timestamp *time_stamp);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:int msm_isp_cfg_axi_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:int msm_isp_release_axi_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:int msm_isp_update_axi_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_axi_cfg_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	enum msm_vfe_input_src frame_src);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:int msm_isp_axi_halt(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_vfe_axi_halt_cmd *halt_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:int msm_isp_axi_reset(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_vfe_axi_reset_cmd *reset_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:int msm_isp_axi_restart(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_vfe_axi_restart_cmd *restart_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_axi_stream_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	enum msm_vfe_input_src frame_src,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_process_reg_upd_epoch_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	enum msm_vfe_input_src frame_src,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	enum msm_isp_comp_irq_types irq,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_notify(struct vfe_device *vfe_dev, uint32_t event_type,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	enum msm_vfe_input_src frame_src, struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_process_axi_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	uint32_t pingpong_status, struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_axi_disable_all_wm(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:int msm_isp_print_ping_pong_address(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_increment_frame_id(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	enum msm_vfe_input_src frame_src, struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:int msm_isp_drop_frame(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_vfe_axi_stream *stream_info, struct msm_isp_timestamp *ts,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_isp_sof_info *sof_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_halt(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_halt_send_error(struct vfe_device *vfe_dev, uint32_t event);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_process_axi_irq_stream(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_release_all_axi_stream(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_axi_free_wm(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:void msm_isp_check_for_output_error(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_isp_timestamp *ts, struct msm_isp_sof_info *sof_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:static inline int msm_isp_get_vfe_idx_for_stream_user(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:				struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:static inline int msm_isp_get_vfe_idx_for_stream(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:				struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	int vfe_idx = msm_isp_get_vfe_idx_for_stream_user(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:static inline void msm_isp_cfg_wm_scratch(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:static inline void msm_isp_cfg_stream_scratch(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:				struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:			vfe_idx = msm_isp_get_vfe_idx_for_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:			msm_isp_cfg_wm_scratch(stream_info->vfe_dev[j],
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:static inline struct msm_vfe_axi_stream *msm_isp_get_stream_common_data(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_vfe_common_dev_data *common_data = vfe_dev->common_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:static inline struct msm_vfe_axi_stream *msm_isp_vfe_get_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	return msm_isp_get_stream_common_data(dual_vfe_res->vfe_dev[vfe_id],
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:int msm_isp_cfg_offline_ping_pong_address(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:	struct msm_vfe_axi_stream *stream_info, uint32_t pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp_axi_util.h:int msm_isp_ab_ib_update_lpm_mode(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:#include "msm_isp_util_32.h"
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:#include "msm_isp_axi_util_32.h"
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:int msm_isp_axi_create_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe32_axi_stream_request_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		   sizeof(struct msm_vfe_axi_stream));
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:void msm_isp_axi_destroy_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data, int stream_idx)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:int msm_isp_validate_axi_request(struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe32_axi_stream_request_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_print_fourcc_error(__func__,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static uint32_t msm_isp_axi_get_plane_size(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info, int plane_idx)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_plane_cfg *plane_cfg = stream_info->plane_cfg;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_print_fourcc_error(__func__,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:void msm_isp_axi_reserve_wm(struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:					msm_isp_axi_get_plane_size(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:void msm_isp_axi_free_wm(struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:void msm_isp_axi_reserve_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static void msm_isp_axi_free_comp_mask(struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static int msm_isp_axi_get_bufq_handles(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:int msm_isp_axi_check_stream_state(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	enum msm_vfe_axi_state valid_state =
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			rc = msm_isp_axi_get_bufq_handles(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:void msm_isp_update_framedrop_reg(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:void msm_isp_reset_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:void msm_isp_notify(struct vfe_device *vfe_dev, uint32_t event_type,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	enum msm_vfe_input_src frame_src, struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp32_event_data event_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_send_event(vfe_dev, event_type | frame_src, &event_data);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:void msm_isp_calculate_framedrop(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe32_axi_stream_request_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	framedrop_period = msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static void msm_isp_calculate_bandwidth(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		bpp = msm_isp_get_bit_per_pixel(stream_info->output_format);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:void msm_isp_start_avtimer(void)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static inline void msm_isp_get_avtimer_ts(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		struct msm_isp_timestamp *time_stamp)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:void msm_isp_start_avtimer(void)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:inline void msm_isp_get_avtimer_ts(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		struct msm_isp_timestamp *time_stamp)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:int msm_isp_request_axi_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe32_axi_stream_request_cmd *stream_cfg_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	rc = msm_isp_axi_create_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	rc = msm_isp_validate_axi_request(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			msm_isp_axi_destroy_stream(&vfe_dev->axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_axi_reserve_wm(&vfe_dev->axi_data, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			msm_isp_axi_free_wm(&vfe_dev->axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			msm_isp_axi_destroy_stream(&vfe_dev->axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_calculate_framedrop(&vfe_dev->axi_data, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_start_avtimer();
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_axi_reserve_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:int msm_isp_release_axi_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream_release_cmd *stream_release_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream_cfg_cmd stream_cfg;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_cfg_axi_stream(vfe_dev, (void *) &stream_cfg);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_axi_free_comp_mask(&vfe_dev->axi_data, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_axi_free_wm(axi_data, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_axi_destroy_stream(&vfe_dev->axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static void msm_isp_axi_stream_enable_cfg(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:void msm_isp_axi_stream_update(struct vfe_device *vfe_dev, uint8_t input_src)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:				msm_isp_axi_stream_enable_cfg(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static void msm_isp_reload_ping_pong_offset(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp_buffer *buf;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:void msm_isp_axi_cfg_update(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			msm_isp_reload_ping_pong_offset(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			msm_isp_axi_stream_enable_cfg(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static void msm_isp_cfg_pong_address(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp_buffer *buf = stream_info->buf[0];
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static void msm_isp_get_done_buf(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info, uint32_t pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp_buffer **done_buf)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static int msm_isp_cfg_ping_pong_address(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info, uint32_t pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp_buffer *buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static void msm_isp_process_done_buf(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info, struct msm_isp_buffer *buf,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp32_event_data buf_event;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			msm_isp_get_avtimer_ts(ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:				msm_isp_send_event(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			msm_isp_send_event(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static enum msm_isp_camif_update_state
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_get_camif_update_state(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static void msm_isp_update_camif_output_count(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static void msm_isp_update_rdi_output_count(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	  struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static uint8_t msm_isp_get_curr_stream_cnt(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static int msm_isp_update_stream_bandwidth(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		rc = msm_isp_update_bandwidth(ISP_VFE0 + vfe_dev->pdev->id,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		rc = msm_isp_update_bandwidth(ISP_VFE0 + vfe_dev->pdev->id,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static int msm_isp_axi_wait_for_cfg_done(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	enum msm_isp_camif_update_state camif_update)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static int msm_isp_init_stream_ping_pong_reg(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	rc = msm_isp_cfg_ping_pong_address(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_cfg_pong_address(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		rc = msm_isp_cfg_ping_pong_address(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static void msm_isp_deinit_stream_ping_pong_reg(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		struct msm_isp_buffer *buf;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static void msm_isp_get_stream_wm_mask(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:int msm_isp_axi_halt(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_halt_cmd *halt_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:int msm_isp_axi_reset(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_reset_cmd *reset_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp_bufq *bufq = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp_timestamp timestamp;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_get_timestamp(&timestamp, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			msm_isp_deinit_stream_ping_pong_reg(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_reset_burst_count_and_frame_drop(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:int msm_isp_axi_restart(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_restart_cmd *restart_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_get_stream_wm_mask(stream_info, &wm_reload_mask);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_init_stream_ping_pong_reg(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static int msm_isp_axi_update_cgc_override(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static int msm_isp_start_axi_stream(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			enum msm_isp_camif_update_state camif_update)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_calculate_bandwidth(axi_data, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_reset_framedrop(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_get_stream_wm_mask(stream_info, &wm_reload_mask);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		rc = msm_isp_init_stream_ping_pong_reg(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:				msm_camera_io_dump_2(vfe_dev->vfe_base, 0x900);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			msm_isp_axi_stream_enable_cfg(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_update_stream_bandwidth(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_update_camif_output_count(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_update_rdi_output_count(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		rc = msm_isp_axi_wait_for_cfg_done(vfe_dev, camif_update);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static int msm_isp_stop_axi_stream(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			enum msm_isp_camif_update_state camif_update)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_update_camif_output_count(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_update_rdi_output_count(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	cur_stream_cnt = msm_isp_get_curr_stream_cnt(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			msm_isp_axi_stream_enable_cfg(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		rc = msm_isp_axi_wait_for_cfg_done(vfe_dev, camif_update);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:				msm_isp_axi_stream_enable_cfg(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_update_stream_bandwidth(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_deinit_stream_ping_pong_reg(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:int msm_isp_cfg_axi_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	enum msm_isp_camif_update_state camif_update;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	rc = msm_isp_axi_check_stream_state(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	camif_update = msm_isp_get_camif_update_state(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_axi_update_cgc_override(vfe_dev, stream_cfg_cmd, 1);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		rc = msm_isp_start_axi_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		rc = msm_isp_stop_axi_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_axi_update_cgc_override(vfe_dev, stream_cfg_cmd, 0);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:static int msm_isp_request_frame(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info, uint32_t request_frm_num)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe32_axi_stream_request_cmd stream_cfg_cmd;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_calculate_framedrop(&vfe_dev->axi_data, &stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	msm_isp_reset_framedrop(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			rc = msm_isp_cfg_ping_pong_address(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			rc = msm_isp_cfg_ping_pong_address(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			rc = msm_isp_cfg_ping_pong_address(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			rc = msm_isp_cfg_ping_pong_address(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:		msm_isp_get_stream_wm_mask(stream_info, &wm_reload_mask);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:int msm_isp_update_axi_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream_update_cmd *update_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream_cfg_update_info *update_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp_timestamp timestamp;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			msm_isp_get_timestamp(&timestamp, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:				msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:				msm_isp_axi_stream_enable_cfg(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			rc = msm_isp_request_frame(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:void msm_isp_process_axi_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp_buffer *done_buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_composite_info *comp_info;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:				msm_isp_get_done_buf(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:					rc = msm_isp_cfg_ping_pong_address(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:					msm_isp_process_done_buf(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:			msm_isp_get_done_buf(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:				rc = msm_isp_cfg_ping_pong_address(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:				msm_isp_process_done_buf(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:int msm_isp_user_buf_done(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp32_event_data *buf_cmd)
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.c:	struct msm_isp32_event_data buf_event;
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:#include "msm_isp_32.h"
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:int msm_isp_axi_create_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe32_axi_stream_request_cmd *stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:void msm_isp_axi_destroy_stream(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_shared_data *axi_data, int stream_idx);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:int msm_isp_validate_axi_request(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe32_axi_stream_request_cmd *stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:void msm_isp_axi_reserve_wm(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:void msm_isp_axi_reserve_comp_mask(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:int msm_isp_axi_check_stream_state(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_stream_cfg_cmd *stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:void msm_isp_calculate_framedrop(
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe32_axi_stream_request_cmd *stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:void msm_isp_reset_framedrop(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:void msm_isp_start_avtimer(void);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:int msm_isp_request_axi_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:int msm_isp_cfg_axi_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:int msm_isp_release_axi_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:int msm_isp_update_axi_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:void msm_isp_axi_cfg_update(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:int msm_isp_axi_halt(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_halt_cmd *halt_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:int msm_isp_axi_reset(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_reset_cmd *reset_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:int msm_isp_axi_restart(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_restart_cmd *restart_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:int msm_isp_user_buf_done(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_isp32_event_data *buf_cmd);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:void msm_isp_axi_stream_update(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:void msm_isp_update_framedrop_reg(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:void msm_isp_notify(struct vfe_device *vfe_dev, uint32_t event_type,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	enum msm_vfe_input_src frame_src, struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:void msm_isp_process_axi_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:void msm_isp_axi_free_wm(struct msm_vfe_axi_shared_data *axi_data,
media/platform/msm/camera_v2/isp/msm_isp_axi_util_32.h:	struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:#include <media/msmb_isp.h>
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:#include "msm_isp_util.h"
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:#include "msm_isp_axi_util.h"
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:#include "msm_isp_stats_util.h"
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static inline void msm_isp_stats_cfg_wm_scratch(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:				struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static inline void msm_isp_stats_cfg_stream_scratch(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:				struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_stats_cfg_wm_scratch(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static int msm_isp_composite_stats_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:				struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:				enum msm_isp_comp_irq_types irq)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static int msm_isp_stats_cfg_ping_pong_address(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info, uint32_t pingpong_status)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_isp_buffer *buf = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_halt_send_error(vfe_dev, ISP_EVENT_BUF_FATAL_ERROR);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_halt_send_error(vfe_dev, ISP_EVENT_BUF_FATAL_ERROR);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_stats_cfg_stream_scratch(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static int32_t msm_isp_stats_buf_divert(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_isp_timestamp *ts,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_isp_event_data *buf_event,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_isp_stats_event *stats_event = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_isp_sw_framskip *sw_skip = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_isp_buffer *done_buf;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:				(struct msm_isp_sw_framskip));
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	vfe_idx = msm_isp_get_vfe_idx_for_stats_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	rc = msm_isp_composite_stats_irq(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:			msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	rc = msm_isp_stats_cfg_ping_pong_address(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_send_event(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static int32_t msm_isp_stats_configure(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	uint32_t stats_irq_mask, struct msm_isp_timestamp *ts,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_isp_event_data buf_event;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_isp_stats_event *stats_event = &buf_event.u.stats;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	memset(&buf_event, 0, sizeof(struct msm_isp_event_data));
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		stream_info = msm_isp_get_stats_stream_common_data(vfe_dev, i);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		rc = msm_isp_stats_buf_divert(vfe_dev, ts,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_send_event(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:void msm_isp_process_stats_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	uint32_t pingpong_status, struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		rc = msm_isp_stats_configure(vfe_dev, stats_irq_mask, ts,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:			rc = msm_isp_stats_configure(vfe_dev, atomic_stats_mask,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:int msm_isp_stats_create_stream(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream_request_cmd *stream_req_cmd,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		framedrop_period = msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		framedrop_period = msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:int msm_isp_request_stats_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream_request_cmd *stream_req_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	stream_info = msm_isp_get_stats_stream_common_data(vfe_dev, stats_idx);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	rc = msm_isp_stats_create_stream(vfe_dev, stream_req_cmd, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_stats_cfg_stream_scratch(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_stats_cfg_stream_scratch(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:int msm_isp_release_stats_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream_cfg_cmd stream_cfg_cmd;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream_release_cmd *stream_release_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	stream_info = msm_isp_get_stats_stream_common_data(vfe_dev, stats_idx);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	vfe_idx = msm_isp_get_vfe_idx_for_stats_stream_user(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_cfg_stats_stream(vfe_dev, &stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:void msm_isp_stop_all_stats_stream(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream_cfg_cmd stream_cfg_cmd;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		stream_info =  msm_isp_get_stats_stream_common_data(vfe_dev, i);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		vfe_idx = msm_isp_get_vfe_idx_for_stats_stream_user(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_cfg_stats_stream(vfe_dev, &stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:void msm_isp_release_all_stats_stream(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream_release_cmd
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	msm_isp_stop_all_stats_stream(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		stream_info =  msm_isp_get_stats_stream_common_data(vfe_dev, i);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		vfe_idx = msm_isp_get_vfe_idx_for_stats_stream_user(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_release_stats_stream(vfe_dev, &stream_release_cmd[i]);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static int msm_isp_init_stats_ping_pong_reg(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	rc = msm_isp_stats_cfg_ping_pong_address(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	rc = msm_isp_stats_cfg_ping_pong_address(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static void __msm_isp_update_stats_framedrop_reg(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static void __msm_isp_stats_stream_update(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:void msm_isp_stats_stream_update(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		stream_info = msm_isp_get_stats_stream_common_data(vfe_dev, i);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		__msm_isp_stats_stream_update(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:void msm_isp_process_stats_reg_upd_epoch_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:			enum msm_isp_comp_irq_types irq)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		stream_info = msm_isp_get_stats_stream_common_data(vfe_dev, i);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		rc = msm_isp_composite_stats_irq(vfe_dev, stream_info, irq);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:				msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:			__msm_isp_stats_stream_update(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:			__msm_isp_update_stats_framedrop_reg(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static int msm_isp_stats_wait_for_stream_cfg_done(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static int msm_isp_stats_wait_for_streams(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		struct msm_vfe_stats_stream **streams,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		rc |= msm_isp_stats_wait_for_stream_cfg_done(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static int msm_isp_stats_update_cgc_override(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream_cfg_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		stream_info =  msm_isp_get_stats_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:int msm_isp_stats_reset(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_isp_timestamp timestamp;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	msm_isp_get_timestamp(&timestamp, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		stream_info = msm_isp_get_stats_stream_common_data(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_stats_cfg_stream_scratch(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_stats_cfg_stream_scratch(stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:			msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:int msm_isp_stats_restart(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		stream_info = msm_isp_get_stats_stream_common_data(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_init_stats_ping_pong_reg(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static int msm_isp_check_stream_cfg_cmd(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream_cfg_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		stream_info = msm_isp_get_stats_stream_common_data(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		vfe_idx = msm_isp_get_vfe_idx_for_stats_stream_user(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static void __msm_isp_stop_stats_streams(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		struct msm_vfe_stats_stream **streams,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		struct msm_isp_timestamp timestamp)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_shared_data *stats_data;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:				__msm_isp_stats_stream_update(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_stats_cfg_stream_scratch(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_stats_cfg_stream_scratch(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:			msm_isp_halt_send_error(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	if (msm_isp_stats_wait_for_streams(streams, num_streams, 0)) {
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:				__msm_isp_stats_stream_update(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static int msm_isp_check_stats_stream_state(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:			struct msm_vfe_stats_stream *stream_info,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static int msm_isp_start_stats_stream(struct vfe_device *vfe_dev_ioctl,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream_cfg_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_shared_data *stats_data = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *streams[MSM_ISP_STATS_MAX];
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_isp_timestamp timestamp;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	msm_isp_get_timestamp(&timestamp, vfe_dev_ioctl);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		stream_info = msm_isp_get_stats_stream_common_data(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		rc = msm_isp_check_stats_stream_state(stream_info, 1);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		rc = msm_isp_init_stats_ping_pong_reg(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:				__msm_isp_stats_stream_update(stream_info);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	rc = msm_isp_stats_wait_for_streams(streams, num_stream, 1);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	__msm_isp_stop_stats_streams(streams, num_stream, timestamp);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:static int msm_isp_stop_stats_stream(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream_cfg_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_isp_timestamp timestamp;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *streams[MSM_ISP_STATS_MAX];
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	msm_isp_get_timestamp(&timestamp, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		stream_info = msm_isp_get_stats_stream_common_data(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		rc = msm_isp_check_stats_stream_state(stream_info, 0);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	__msm_isp_stop_stats_streams(streams, num_stream, timestamp);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:int msm_isp_cfg_stats_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream_cfg_cmd *stream_cfg_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	rc = msm_isp_check_stream_cfg_cmd(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_stats_update_cgc_override(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		rc = msm_isp_start_stats_stream(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		rc = msm_isp_stop_stats_stream(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		msm_isp_stats_update_cgc_override(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:int msm_isp_update_stats_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_axi_stream_update_cmd *update_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_vfe_axi_stream_cfg_update_info *update_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:	struct msm_isp_sw_framskip *sw_skip_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		update_info = (struct msm_vfe_axi_stream_cfg_update_info *)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		update_info = (struct msm_vfe_axi_stream_cfg_update_info *)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		stream_info = msm_isp_get_stats_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:		vfe_idx = msm_isp_get_vfe_idx_for_stats_stream_user(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:				msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.c:void msm_isp_stats_disable(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:#include "msm_isp.h"
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:void msm_isp_process_stats_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:	uint32_t pingpong_status, struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:int msm_isp_stats_create_stream(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:	struct msm_vfe_stats_stream_request_cmd *stream_req_cmd,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:	struct msm_vfe_stats_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:void msm_isp_stats_stream_update(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:int msm_isp_cfg_stats_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:int msm_isp_update_stats_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:int msm_isp_release_stats_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:int msm_isp_request_stats_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:void msm_isp_stats_disable(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:int msm_isp_stats_reset(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:int msm_isp_stats_restart(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:void msm_isp_release_all_stats_stream(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:void msm_isp_process_stats_reg_upd_epoch_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:		enum msm_isp_comp_irq_types irq);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:void msm_isp_stop_all_stats_stream(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:static inline int msm_isp_get_vfe_idx_for_stats_stream_user(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:				struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:static inline int msm_isp_get_vfe_idx_for_stats_stream(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:				struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:	int vfe_idx = msm_isp_get_vfe_idx_for_stats_stream_user(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:static inline struct msm_vfe_stats_stream *
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:				msm_isp_get_stats_stream_common_data(
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:				enum msm_isp_stats_type idx)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:static inline struct msm_vfe_stats_stream *
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:	msm_isp_get_stats_stream(struct dual_vfe_resource *dual_vfe_res,
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:					enum msm_isp_stats_type idx)
media/platform/msm/camera_v2/isp/msm_isp_stats_util.h:	return msm_isp_get_stats_stream_common_data(
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:#include <media/msmb_isp.h>
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:#include "msm_isp_util_32.h"
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:#include "msm_isp_stats_util_32.h"
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:static int msm_isp_stats_cfg_ping_pong_address(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream *stream_info, uint32_t pingpong_status,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_isp_buffer **done_buf)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_isp_buffer *buf;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:void msm_isp_process_stats_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_isp_timestamp *ts)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_isp32_event_data buf_event;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_isp_stats_event *stats_event = &buf_event.u.stats;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_isp_buffer *done_buf;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:		memset(&buf_event, 0, sizeof(struct msm_isp32_event_data));
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:			msm_isp_stats_cfg_ping_pong_address(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:					msm_isp_send_event(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:			msm_isp_send_event(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:int msm_isp_stats_create_stream(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream_request_cmd *stream_req_cmd)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:int msm_isp_request_stats_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream_request_cmd *stream_req_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	rc = msm_isp_stats_create_stream(vfe_dev, stream_req_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	framedrop_period = msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:int msm_isp_release_stats_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream_cfg_cmd stream_cfg_cmd;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream_release_cmd *stream_release_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:		rc = msm_isp_cfg_stats_stream(vfe_dev, &stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	memset(stream_info, 0, sizeof(struct msm_vfe_stats_stream));
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:static int msm_isp_init_stats_ping_pong_reg(
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	rc = msm_isp_stats_cfg_ping_pong_address(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	rc = msm_isp_stats_cfg_ping_pong_address(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:static void msm_isp_deinit_stats_ping_pong_reg(
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_isp_buffer *buf;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:void msm_isp_update_stats_framedrop_reg(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:void msm_isp_stats_stream_update(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:static int msm_isp_stats_wait_for_cfg_done(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:static int msm_isp_stats_update_cgc_override(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream_cfg_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:static int msm_isp_start_stats_stream(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream_cfg_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:		rc = msm_isp_init_stats_ping_pong_reg(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:		rc = msm_isp_stats_wait_for_cfg_done(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:static int msm_isp_stop_stats_stream(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream_cfg_cmd *stream_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:		rc = msm_isp_stats_wait_for_cfg_done(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:		msm_isp_deinit_stats_ping_pong_reg(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:int msm_isp_cfg_stats_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream_cfg_cmd *stream_cfg_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:		msm_isp_stats_update_cgc_override(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:		rc = msm_isp_start_stats_stream(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:		rc = msm_isp_stop_stats_stream(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:		msm_isp_stats_update_cgc_override(vfe_dev, stream_cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:int msm_isp_update_stats_stream(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_stream *stream_info;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_stats_shared_data *stats_data = &vfe_dev->stats_data;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_axi_stream_update_cmd *update_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:	struct msm_vfe_axi_stream_cfg_update_info *update_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.c:				msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.h:#include "msm_isp_32.h"
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.h:void msm_isp_process_stats_irq(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.h:	struct msm_isp_timestamp *ts);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.h:int msm_isp_stats_create_stream(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.h:	struct msm_vfe_stats_stream_request_cmd *stream_req_cmd);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.h:void msm_isp_stats_stream_update(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.h:int msm_isp_cfg_stats_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.h:int msm_isp_update_stats_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.h:int msm_isp_release_stats_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.h:int msm_isp_request_stats_stream(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_stats_util_32.h:void msm_isp_update_stats_framedrop_reg(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.c:#include "msm.h"
media/platform/msm/camera_v2/isp/msm_isp_util.c:#include "msm_isp_util.h"
media/platform/msm/camera_v2/isp/msm_isp_util.c:#include "msm_isp_axi_util.h"
media/platform/msm/camera_v2/isp/msm_isp_util.c:#include "msm_isp_stats_util.h"
media/platform/msm/camera_v2/isp/msm_isp_util.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/isp/msm_isp_util.c:#include "msm_isp48.h"
media/platform/msm/camera_v2/isp/msm_isp_util.c:static struct msm_isp_bandwidth_mgr isp_bandwidth_mgr;
media/platform/msm/camera_v2/isp/msm_isp_util.c:static uint64_t msm_isp_cpp_clk_rate;
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_print_fourcc_error(const char *origin, uint32_t fourcc_format)
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_init_bandwidth_mgr(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:			enum msm_isp_hw_client client)
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_update_bandwidth(enum msm_isp_hw_client client,
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_deinit_bandwidth_mgr(enum msm_isp_hw_client client)
media/platform/msm/camera_v2/isp/msm_isp_util.c:			sizeof(struct msm_isp_bandwidth_info));
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_util_get_bandwidth_stats(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:				      struct msm_isp_statistics *stats)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	stats->last_overflow_ab = vfe_dev->msm_isp_last_overflow_ab;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	stats->last_overflow_ib = vfe_dev->msm_isp_last_overflow_ib;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	stats->cpp_clk_rate = msm_isp_cpp_clk_rate;
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_util_update_clk_rate(long clock_rate)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	msm_isp_cpp_clk_rate = clock_rate;
media/platform/msm/camera_v2/isp/msm_isp_util.c:uint32_t msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_util.c:	enum msm_vfe_frame_skip_pattern frame_skip_pattern)
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_get_timestamp(struct msm_isp_timestamp *time_stamp,
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_get_avtimer_ts(time_stamp);
media/platform/msm/camera_v2/isp/msm_isp_util.c:static inline u32 msm_isp_evt_mask_to_isp_event(u32 evt_mask)
media/platform/msm/camera_v2/isp/msm_isp_util.c:static inline int msm_isp_subscribe_event_mask(struct v4l2_fh *fh,
media/platform/msm/camera_v2/isp/msm_isp_util.c:static inline int msm_isp_process_event_subscription(struct v4l2_fh *fh,
media/platform/msm/camera_v2/isp/msm_isp_util.c:			evt_id = msm_isp_evt_mask_to_isp_event(evt_mask_index);
media/platform/msm/camera_v2/isp/msm_isp_util.c:			rc = msm_isp_subscribe_event_mask(fh, sub,
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	return msm_isp_process_event_subscription(fh, sub, true);
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_unsubscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	return msm_isp_process_event_subscription(fh, sub, false);
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_start_fetch_engine(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_fetch_eng_start *fe_cfg = arg;
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_start_fetch_engine_multi_pass(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_fetch_eng_multi_pass_start *fe_cfg = arg;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_axi_stream *stream_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_util.c:		stream_info = msm_isp_get_stream_common_data(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:		vfe_idx = msm_isp_get_vfe_idx_for_stream(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_reset_framedrop(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_cfg_offline_ping_pong_address(vfe_dev, stream_info,
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_fetch_engine_done_notify(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_fetch_engine_info *fetch_engine_info)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_isp_event_data fe_rd_done_event;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	memset(&fe_rd_done_event, 0, sizeof(struct msm_isp_event_data));
media/platform/msm/camera_v2/isp/msm_isp_util.c:	msm_isp_send_event(vfe_dev, ISP_EVENT_FE_READ_DONE, &fe_rd_done_event);
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_cfg_pix(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_input_cfg *input_cfg)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_pix_cfg *pix_cfg = NULL;
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_cfg_rdi(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_input_cfg *input_cfg)
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_set_dual_vfe_sync_mode(
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_dual_vfe_sync_mode *mode = arg;
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_nano_sec_timestamp(
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_nano_sec_timestamp *mode = arg;
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_cfg_input(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_input_cfg *input_cfg = arg;
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_cfg_pix(vfe_dev, input_cfg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_cfg_rdi(vfe_dev, input_cfg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_dual_hw_master_slave_sync(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_isp_dual_hw_master_slave_sync *link = arg;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_src_info *src_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_set_dual_HW_master_slave_mode(
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_isp_set_dual_hw_ms_cmd *dual_hw_ms_cmd = NULL;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_src_info *src_info = NULL;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	dual_hw_ms_cmd = (struct msm_isp_set_dual_hw_ms_cmd *)arg;
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_proc_cmd_list_unlocked(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_cfg_cmd_list *proc_cmd =
media/platform/msm/camera_v2/isp/msm_isp_util.c:		(struct msm_vfe_cfg_cmd_list *)arg;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_cfg_cmd_list cmd, cmd_next;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	rc = msm_isp_proc_cmd(vfe_dev, &proc_cmd->cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		if (cmd.next_size != sizeof(struct msm_vfe_cfg_cmd_list)) {
media/platform/msm/camera_v2/isp/msm_isp_util.c:				sizeof(struct msm_vfe_cfg_cmd_list));
media/platform/msm/camera_v2/isp/msm_isp_util.c:			sizeof(struct msm_vfe_cfg_cmd_list))) {
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_proc_cmd(vfe_dev, &cmd_next.cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_util.c:struct msm_vfe_cfg_cmd2_32 {
media/platform/msm/camera_v2/isp/msm_isp_util.c:struct msm_vfe_cfg_cmd_list_32 {
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_cfg_cmd2_32   cfg_cmd;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	_IOWR('V', BASE_VIDIOC_PRIVATE, struct msm_vfe_cfg_cmd2_32)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	_IOWR('V', BASE_VIDIOC_PRIVATE+14, struct msm_vfe_cfg_cmd_list_32)
media/platform/msm/camera_v2/isp/msm_isp_util.c:static void msm_isp_compat_to_proc_cmd(struct msm_vfe_cfg_cmd2 *proc_cmd,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_cfg_cmd2_32 *proc_cmd_ptr32)
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_proc_cmd_list_compat(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_cfg_cmd_list_32 *proc_cmd =
media/platform/msm/camera_v2/isp/msm_isp_util.c:		(struct msm_vfe_cfg_cmd_list_32 *)arg;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_cfg_cmd_list_32 cmd, cmd_next;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_cfg_cmd2 current_cmd;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	msm_isp_compat_to_proc_cmd(&current_cmd, &proc_cmd->cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_util.c:	rc = msm_isp_proc_cmd(vfe_dev, &current_cmd);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		if (cmd.next_size != sizeof(struct msm_vfe_cfg_cmd_list_32)) {
media/platform/msm/camera_v2/isp/msm_isp_util.c:				sizeof(struct msm_vfe_cfg_cmd_list));
media/platform/msm/camera_v2/isp/msm_isp_util.c:			sizeof(struct msm_vfe_cfg_cmd_list_32))) {
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_compat_to_proc_cmd(&current_cmd,
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_proc_cmd(vfe_dev, &current_cmd);
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_proc_cmd_list(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util.c:		return msm_isp_proc_cmd_list_compat(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		return msm_isp_proc_cmd_list_unlocked(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_proc_cmd_list(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	return msm_isp_proc_cmd_list_unlocked(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:static long msm_isp_ioctl_unlocked(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_proc_cmd(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_proc_cmd_list(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_proc_buf_cmd(vfe_dev->buf_mgr, cmd, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_proc_buf_cmd(vfe_dev->buf_mgr, cmd, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_request_axi_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_release_axi_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_cfg_axi_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_axi_halt(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:			rc = msm_isp_stats_reset(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.c:			rc2 = msm_isp_axi_reset(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:			rc = msm_isp_stats_restart(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.c:			rc2 = msm_isp_axi_restart(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_cfg_input(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_set_dual_HW_master_slave_mode(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_dual_hw_master_slave_sync(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_ab_ib_update_lpm_mode(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_start_fetch_engine(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_start_fetch_engine_multi_pass(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:			enum msm_vfe_input_src frame_src =
media/platform/msm/camera_v2/isp/msm_isp_util.c:				*((enum msm_vfe_input_src *)arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_set_src_state(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_request_stats_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_release_stats_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_cfg_stats_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_update_stats_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_update_axi_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_smmu_attach(vfe_dev->buf_mgr, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_set_dual_vfe_sync_mode(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_nano_sec_timestamp(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:static long msm_isp_ioctl_compat(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/isp/msm_isp_util.c:		struct msm_vfe_cfg_cmd2 proc_cmd;
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_compat_to_proc_cmd(&proc_cmd,
media/platform/msm/camera_v2/isp/msm_isp_util.c:			(struct msm_vfe_cfg_cmd2_32 *) arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_proc_cmd(vfe_dev, &proc_cmd);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_proc_cmd_list(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		return msm_isp_ioctl_unlocked(sd, cmd, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:long msm_isp_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	return msm_isp_ioctl_compat(sd, cmd, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:long msm_isp_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	return msm_isp_ioctl_unlocked(sd, cmd, arg);
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_send_hw_cmd(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_reg_cfg_cmd *reg_cfg_cmd,
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_camera_io_memcpy(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_camera_io_memcpy_mb(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util.c:		temp = msm_camera_io_r(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_camera_io_w(temp, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util.c:				msm_camera_io_w(lo_val1, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util.c:				msm_camera_io_w(hi_val, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util.c:			msm_camera_io_w(lo_val, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util.c:			lo_val = msm_camera_io_r(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util.c:				lo_val1 = msm_camera_io_r(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util.c:				hi_val = msm_camera_io_r(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util.c:			*data_ptr++ = msm_camera_io_r(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util.c:		struct msm_isp_clk_rates rates;
media/platform/msm/camera_v2/isp/msm_isp_util.c:		struct msm_isp_clk_rates *user_data =
media/platform/msm/camera_v2/isp/msm_isp_util.c:			(struct msm_isp_clk_rates *)cfg_data;
media/platform/msm/camera_v2/isp/msm_isp_util.c:		if (cmd_len != sizeof(struct msm_isp_clk_rates)) {
media/platform/msm/camera_v2/isp/msm_isp_util.c:				sizeof(struct msm_isp_clk_rates));
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_proc_cmd(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_cfg_cmd2 *proc_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_reg_cfg_cmd *reg_cfg_cmd = NULL;
media/platform/msm/camera_v2/isp/msm_isp_util.c:			sizeof(struct msm_vfe_reg_cfg_cmd), GFP_KERNEL);
media/platform/msm/camera_v2/isp/msm_isp_util.c:			sizeof(struct msm_vfe_reg_cfg_cmd)
media/platform/msm/camera_v2/isp/msm_isp_util.c:		rc = msm_isp_send_hw_cmd(vfe_dev, &reg_cfg_cmd[i],
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_send_event(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_isp_event_data *event_data)
media/platform/msm/camera_v2/isp/msm_isp_util.c:		sizeof(struct msm_isp_event_data));
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_send_event_update_nanosec(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_isp_event_data_nanosec *event_data)
media/platform/msm/camera_v2/isp/msm_isp_util.c:		sizeof(struct msm_isp_event_data_nanosec));
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_cal_word_per_line(uint32_t output_format,
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_print_fourcc_error(__func__, output_format);
media/platform/msm/camera_v2/isp/msm_isp_util.c:enum msm_isp_pack_fmt msm_isp_get_pack_format(uint32_t output_format)
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_print_fourcc_error(__func__, output_format);
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_get_bit_per_pixel(uint32_t output_format)
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_print_fourcc_error(__func__, output_format);
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_update_error_frame_count(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_error_info *error_info = &vfe_dev->error_info;
media/platform/msm/camera_v2/isp/msm_isp_util.c:static int msm_isp_process_iommu_page_fault(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_halt_send_error(vfe_dev, ISP_EVENT_PING_PONG_MISMATCH);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_halt_send_error(vfe_dev, ISP_EVENT_IOMMU_P_FAULT);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_print_ping_pong_address(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_process_error_info(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_error_info *error_info = &vfe_dev->error_info;
media/platform/msm/camera_v2/isp/msm_isp_util.c:static inline void msm_isp_update_error_info(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_process_overflow_irq(
media/platform/msm/camera_v2/isp/msm_isp_util.c:		struct msm_isp_event_data error_event;
media/platform/msm/camera_v2/isp/msm_isp_util.c:		struct msm_vfe_axi_shared_data *axi_data = &vfe_dev->axi_data;
media/platform/msm/camera_v2/isp/msm_isp_util.c:			msm_isp_send_event(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_reset_burst_count_and_frame_drop(
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct vfe_device *vfe_dev, struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_reset_framedrop(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_prepare_irq_debug_info(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_irq_debug_info *irq_debug;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	msm_isp_get_timestamp(&irq_debug->ts, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_prepare_tasklet_debug_info(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_isp_timestamp ts)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_irq_debug_info *irq_debug;
media/platform/msm/camera_v2/isp/msm_isp_util.c:static void msm_isp_enqueue_tasklet_cmd(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_tasklet_queue_cmd *queue_cmd = NULL;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_tasklet *tasklet;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	msm_isp_get_timestamp(&queue_cmd->ts, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.c:irqreturn_t msm_isp_process_irq_dual_sync(int irq_num, void *data)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	msm_isp_enqueue_tasklet_cmd(vfe_dev, 0, 0,
media/platform/msm/camera_v2/isp/msm_isp_util.c:irqreturn_t msm_isp_process_irq(int irq_num, void *data)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_hardware_info *hw_info;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	if (msm_isp_process_overflow_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_update_error_info(vfe_dev, error_mask0, error_mask1);
media/platform/msm/camera_v2/isp/msm_isp_util.c:	msm_isp_prepare_irq_debug_info(vfe_dev, irq_status0, irq_status1);
media/platform/msm/camera_v2/isp/msm_isp_util.c:	msm_isp_enqueue_tasklet_cmd(vfe_dev, irq_status0, irq_status1,
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_do_tasklet(unsigned long data)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_tasklet *tasklet = (struct msm_vfe_tasklet *)data;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_irq_ops *irq_ops;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_tasklet_queue_cmd *queue_cmd;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_isp_timestamp ts;
media/platform/msm/camera_v2/isp/msm_isp_util.c:			struct msm_vfe_tasklet_queue_cmd, list);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_prepare_tasklet_debug_info(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_process_error_info(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_set_src_state(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_axi_src_state *src_state = arg;
media/platform/msm/camera_v2/isp/msm_isp_util.c:static void msm_vfe_iommu_fault_handler(struct iommu_domain *domain,
media/platform/msm/camera_v2/isp/msm_isp_util.c:			msm_isp_process_iommu_page_fault(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_open_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	vfe_dev->vfe_hw_version = msm_camera_io_r(vfe_dev->vfe_base);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		"msm_isp");
media/platform/msm/camera_v2/isp/msm_isp_util.c:	memset(&vfe_dev->axi_data, 0, sizeof(struct msm_vfe_axi_shared_data));
media/platform/msm/camera_v2/isp/msm_isp_util.c:		sizeof(struct msm_vfe_stats_shared_data));
media/platform/msm/camera_v2/isp/msm_isp_util.c:			msm_vfe_iommu_fault_handler,
media/platform/msm/camera_v2/isp/msm_isp_util.c:static void msm_isp_end_avtimer(void)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	msm_isp_stop_avtimer();
media/platform/msm/camera_v2/isp/msm_isp_util.c:static void msm_isp_end_avtimer(void)
media/platform/msm/camera_v2/isp/msm_isp_util.c:int msm_isp_close_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	msm_isp_release_all_axi_stream(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.c:	msm_isp_release_all_stats_stream(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_cfg_wm_scratch(vfe_dev, wm, VFE_PING_FLAG);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_cfg_wm_scratch(vfe_dev, wm, VFE_PONG_FLAG);
media/platform/msm/camera_v2/isp/msm_isp_util.c:		msm_isp_end_avtimer();
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_flush_tasklet(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_tasklet_queue_cmd *queue_cmd, *q_cmd_next;
media/platform/msm/camera_v2/isp/msm_isp_util.c:	struct msm_vfe_tasklet *tasklet;
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_irq_debug_dump(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_tasklet_debug_dump(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_util.c:void msm_isp_dump_ping_pong_mismatch(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_util.c:	msm_isp_irq_debug_dump(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.c:	msm_isp_tasklet_debug_dump(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.h:#include "msm_isp.h"
media/platform/msm/camera_v2/isp/msm_isp_util.h:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/isp/msm_isp_util.h:uint32_t msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_util.h:	enum msm_vfe_frame_skip_pattern frame_skip_pattern);
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_reset_burst_count_and_frame_drop(
media/platform/msm/camera_v2/isp/msm_isp_util.h:	struct vfe_device *vfe_dev, struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_init_bandwidth_mgr(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.h:			enum msm_isp_hw_client client);
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_update_bandwidth(enum msm_isp_hw_client client,
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_util_get_bandwidth_stats(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.h:				      struct msm_isp_statistics *stats);
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_util_update_last_overflow_ab_ib(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_util_update_clk_rate(long clock_rate);
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_update_req_history(uint32_t client, uint64_t ab,
media/platform/msm/camera_v2/isp/msm_isp_util.h:				struct msm_isp_bandwidth_info *client_info,
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_deinit_bandwidth_mgr(enum msm_isp_hw_client client);
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_unsubscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_proc_cmd(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_send_event(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.h:	uint32_t type, struct msm_isp_event_data *event_data);
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_send_event_update_nanosec(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.h:	uint32_t type, struct msm_isp_event_data_nanosec *event_data);
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_cal_word_per_line(uint32_t output_format,
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_get_bit_per_pixel(uint32_t output_format);
media/platform/msm/camera_v2/isp/msm_isp_util.h:enum msm_isp_pack_fmt msm_isp_get_pack_format(uint32_t output_format);
media/platform/msm/camera_v2/isp/msm_isp_util.h:irqreturn_t msm_isp_process_irq(int irq_num, void *data);
media/platform/msm/camera_v2/isp/msm_isp_util.h:irqreturn_t msm_isp_process_irq_dual_sync(int irq_num, void *data);
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_set_src_state(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_do_tasklet(unsigned long data);
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_update_error_frame_count(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_process_error_info(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_open_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh);
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_close_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh);
media/platform/msm/camera_v2/isp/msm_isp_util.h:long msm_isp_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_fetch_engine_done_notify(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.h:	struct msm_vfe_fetch_engine_info *fetch_engine_info);
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_print_fourcc_error(const char *origin, uint32_t fourcc_format);
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_flush_tasklet(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_get_timestamp(struct msm_isp_timestamp *time_stamp,
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_dump_ping_pong_mismatch(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_process_overflow_irq(
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_prepare_irq_debug_info(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_prepare_tasklet_debug_info(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util.h:	struct msm_isp_timestamp ts);
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_irq_debug_dump(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.h:void msm_isp_tasklet_debug_dump(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util.h:int msm_isp_cfg_input(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:#include "msm.h"
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:#include "msm_isp_util_32.h"
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:#include "msm_isp_axi_util_32.h"
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:#include "msm_isp_stats_util_32.h"
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static struct msm_isp_bandwidth_mgr isp_bandwidth_mgr;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static uint64_t msm_isp_cpp_clk_rate;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static struct msm_bus_vectors msm_isp_init_vectors[] = {
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static struct msm_bus_vectors msm_isp_ping_vectors[] = {
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static struct msm_bus_vectors msm_isp_pong_vectors[] = {
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static struct msm_bus_paths msm_isp_bus_client_config[] = {
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		ARRAY_SIZE(msm_isp_init_vectors),
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_init_vectors,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		ARRAY_SIZE(msm_isp_ping_vectors),
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_ping_vectors,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		ARRAY_SIZE(msm_isp_pong_vectors),
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_pong_vectors,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static struct msm_bus_scale_pdata msm_isp_bus_client_pdata = {
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	msm_isp_bus_client_config,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	ARRAY_SIZE(msm_isp_bus_client_config),
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	.name = "msm_camera_isp",
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:void msm_camera_io_dump_2(void __iomem *addr, int size)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:void msm_isp_print_fourcc_error(const char *origin, uint32_t fourcc_format)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:int msm_isp_init_bandwidth_mgr(enum msm_isp_hw_client client)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_bus_scale_register_client(&msm_isp_bus_client_pdata);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	msm_bus_scale_client_update_request(
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:int msm_isp_update_bandwidth(enum msm_isp_hw_client client,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_bus_paths *path;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		&(msm_isp_bus_client_pdata.usecase[
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	msm_bus_scale_client_update_request(isp_bandwidth_mgr.bus_client,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	msm_isp_update_req_history(isp_bandwidth_mgr.bus_client,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:void msm_isp_deinit_bandwidth_mgr(enum msm_isp_hw_client client)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		   sizeof(struct msm_isp_bandwidth_info));
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	msm_bus_scale_client_update_request(
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	msm_bus_scale_unregister_client(isp_bandwidth_mgr.bus_client);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:void msm_isp_util_get_bandwidth_stats(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:				      struct msm_isp_statistics *stats)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	stats->last_overflow_ab = vfe_dev->msm_isp_last_overflow_ab;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	stats->last_overflow_ib = vfe_dev->msm_isp_last_overflow_ib;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	stats->vfe_clk_rate = vfe_dev->msm_isp_vfe_clk_rate;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	stats->cpp_clk_rate = msm_isp_cpp_clk_rate;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:void msm_isp_util_update_last_overflow_ab_ib(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_bus_paths *path;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	 path = &(msm_isp_bus_client_pdata.usecase[
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	vfe_dev->msm_isp_last_overflow_ab = path->vectors[0].ab;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	vfe_dev->msm_isp_last_overflow_ib = path->vectors[0].ib;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:void msm_isp_util_update_clk_rate(long clock_rate)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	msm_isp_cpp_clk_rate = clock_rate;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:uint32_t msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	enum msm_vfe_frame_skip_pattern frame_skip_pattern)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:int msm_isp_get_clk_info(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct platform_device *pdev, struct msm_cam_clk_info *vfe_clk_info)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:void msm_isp_get_timestamp(struct msm_isp_timestamp *time_stamp,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_get_avtimer_ts(time_stamp);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:int msm_isp_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:int msm_isp_unsubscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static int msm_isp_get_max_clk_rate(struct vfe_device *vfe_dev, long *rate)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static int msm_isp_set_clk_rate(struct vfe_device *vfe_dev, long *rate)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	vfe_dev->msm_isp_vfe_clk_rate = round_rate;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:void msm_isp_fetch_engine_done_notify(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_fetch_engine_info *fetch_engine_info)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_isp32_event_data fe_rd_done_event;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	memset(&fe_rd_done_event, 0, sizeof(struct msm_isp32_event_data));
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	msm_isp_send_event(vfe_dev, ISP_EVENT_FE_READ_DONE, &fe_rd_done_event);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static int msm_isp_cfg_pix(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_input_cfg *input_cfg)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	rc = msm_isp_set_clk_rate(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static int msm_isp_cfg_rdi(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_input_cfg *input_cfg)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:int msm_isp_cfg_input(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_input_cfg *input_cfg = arg;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_cfg_pix(vfe_dev, input_cfg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_cfg_rdi(vfe_dev, input_cfg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static int msm_isp_proc_cmd_list_unlocked(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_cfg_cmd_list *proc_cmd =
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		(struct msm_vfe_cfg_cmd_list *)arg;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_cfg_cmd_list cmd, cmd_next;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_cfg_cmd2 cfg_cmd;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	rc = msm_isp_proc_cmd(vfe_dev, &proc_cmd->cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		if (cmd.next_size != sizeof(struct msm_vfe_cfg_cmd_list)) {
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:				sizeof(struct msm_vfe_cfg_cmd_list));
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:			sizeof(struct msm_vfe_cfg_cmd_list))) {
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_proc_cmd(vfe_dev, &cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:struct msm_vfe_cfg_cmd2_32 {
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:struct msm_vfe_cfg_cmd_list_32 {
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_cfg_cmd2_32   cfg_cmd;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	_IOWR('V', BASE_VIDIOC_PRIVATE, struct msm_vfe_cfg_cmd2_32)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	_IOWR('V', BASE_VIDIOC_PRIVATE+14, struct msm_vfe_cfg_cmd_list_32)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static void msm_isp_compat_to_proc_cmd(struct msm_vfe_cfg_cmd2 *proc_cmd,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_cfg_cmd2_32 *proc_cmd_ptr32)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static int msm_isp_proc_cmd_list_compat(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_cfg_cmd_list_32 *proc_cmd =
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		(struct msm_vfe_cfg_cmd_list_32 *)arg;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_cfg_cmd_list_32 cmd, cmd_next;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_cfg_cmd2 current_cmd;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	msm_isp_compat_to_proc_cmd(&current_cmd, &proc_cmd->cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	rc = msm_isp_proc_cmd(vfe_dev, &current_cmd);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		if (cmd.next_size != sizeof(struct msm_vfe_cfg_cmd_list_32)) {
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:				sizeof(struct msm_vfe_cfg_cmd_list));
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:			sizeof(struct msm_vfe_cfg_cmd_list_32))) {
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_compat_to_proc_cmd(&current_cmd, &cmd_next.cfg_cmd);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_proc_cmd(vfe_dev, &current_cmd);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static int msm_isp_proc_cmd_list(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		return msm_isp_proc_cmd_list_compat(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		return msm_isp_proc_cmd_list_unlocked(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static int msm_isp_proc_cmd_list(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	return msm_isp_proc_cmd_list_unlocked(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static long msm_isp_ioctl_unlocked(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_proc_cmd(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_proc_cmd_list(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_proc_buf_cmd(vfe_dev->buf_mgr, cmd, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_request_axi_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_release_axi_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_cfg_axi_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_axi_halt(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_axi_reset(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_axi_restart(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_cfg_input(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:			enum msm_vfe_input_src frame_src =
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:				*((enum msm_vfe_input_src *)arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_set_src_state(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_request_stats_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_release_stats_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_cfg_stats_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_update_stats_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_update_axi_stream(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_smmu_attach(vfe_dev->buf_mgr, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_user_buf_done(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:			msm_isp_close_node(sd, NULL);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static long msm_isp_ioctl_compat(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		struct msm_vfe_cfg_cmd2 proc_cmd;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_compat_to_proc_cmd(&proc_cmd,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:			(struct msm_vfe_cfg_cmd2_32 *) arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_proc_cmd(vfe_dev, &proc_cmd);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_proc_cmd_list(vfe_dev, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		return msm_isp_ioctl_unlocked(sd, cmd, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:long msm_isp_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	return msm_isp_ioctl_compat(sd, cmd, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:long msm_isp_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	return msm_isp_ioctl_unlocked(sd, cmd, arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static int msm_isp_send_hw_cmd(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_reg_cfg_cmd *reg_cfg_cmd,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_camera_io_memcpy(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_camera_io_memcpy_mb(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		temp = msm_camera_io_r(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_camera_io_w(temp, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:				msm_camera_io_w(lo_val1, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:				msm_camera_io_w(hi_val, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:			msm_camera_io_w(lo_val, vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:			lo_val = msm_camera_io_r(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:				lo_val1 = msm_camera_io_r(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:				hi_val = msm_camera_io_r(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:			*data_ptr++ = msm_camera_io_r(vfe_dev->vfe_base +
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_get_max_clk_rate(vfe_dev, &rate);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:int msm_isp_proc_cmd(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_cfg_cmd2 *proc_cmd = arg;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_reg_cfg_cmd *reg_cfg_cmd;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:			sizeof(struct msm_vfe_reg_cfg_cmd)*proc_cmd->num_cfg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		rc = msm_isp_send_hw_cmd(vfe_dev, &reg_cfg_cmd[i],
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:int msm_isp_send_event(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_isp32_event_data *event_data)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		sizeof(struct msm_isp32_event_data));
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:int msm_isp_cal_word_per_line(uint32_t output_format,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_print_fourcc_error(__func__, output_format);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:enum msm_isp_pack_fmt msm_isp_get_pack_format(uint32_t output_format)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_print_fourcc_error(__func__, output_format);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:int msm_isp_get_bit_per_pixel(uint32_t output_format)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_print_fourcc_error(__func__, output_format);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:void msm_isp_update_error_frame_count(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_error_info *error_info = &vfe_dev->error_info;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:void msm_isp_process_error_info(struct vfe_device *vfe_dev)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_error_info *error_info = &vfe_dev->error_info;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static inline void msm_isp_update_error_info(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static void msm_isp_process_overflow_irq(
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		struct msm_isp32_event_data error_event;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_send_event(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:void msm_isp_reset_burst_count_and_frame_drop(
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct vfe_device *vfe_dev, struct msm_vfe_axi_stream *stream_info)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		framedrop_period = msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_reset_framedrop(vfe_dev, stream_info);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:irqreturn_t msm_isp_process_irq(int irq_num, void *data)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_tasklet_queue_cmd *queue_cmd;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	msm_isp_process_overflow_irq(vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_update_error_info(vfe_dev, error_mask0, error_mask1);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	msm_isp_get_timestamp(&queue_cmd->ts, vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:void msm_isp_do_tasklet(unsigned long data)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_irq_ops *irq_ops = &vfe_dev->hw_info->vfe_ops.irq_ops;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_tasklet_queue_cmd *queue_cmd;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_isp_timestamp ts;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		struct msm_vfe_tasklet_queue_cmd, list);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_process_error_info(vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:int msm_isp_set_src_state(struct vfe_device *vfe_dev, void *arg)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	struct msm_vfe_axi_src_state *src_state = arg;
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static void msm_vfe_iommu_fault_handler(struct iommu_domain *domain,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:int msm_isp_open_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	vfe_dev->vfe_hw_version = msm_camera_io_r(vfe_dev->vfe_base);
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	vfe_dev->buf_mgr->ops->buf_mgr_init(vfe_dev->buf_mgr, "msm_isp");
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:	memset(&vfe_dev->axi_data, 0, sizeof(struct msm_vfe_axi_shared_data));
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		sizeof(struct msm_vfe_stats_shared_data));
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:			msm_vfe_iommu_fault_handler,
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static void msm_isp_end_avtimer(void)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:static void msm_isp_end_avtimer(void)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:int msm_isp_close_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
media/platform/msm/camera_v2/isp/msm_isp_util_32.c:		msm_isp_end_avtimer();
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:#include "msm_isp_32.h"
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:struct msm_isp_bandwidth_mgr {
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:	struct msm_isp_bandwidth_info client_info[MAX_ISP_CLIENT];
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:uint32_t msm_isp_get_framedrop_period(
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:	enum msm_vfe_frame_skip_pattern frame_skip_pattern);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_isp_reset_burst_count_and_frame_drop(
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:	struct vfe_device *vfe_dev, struct msm_vfe_axi_stream *stream_info);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:int msm_isp_init_bandwidth_mgr(enum msm_isp_hw_client client);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:int msm_isp_update_bandwidth(enum msm_isp_hw_client client,
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_isp_util_get_bandwidth_stats(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:				      struct msm_isp_statistics *stats);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_isp_util_update_last_overflow_ab_ib(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_isp_util_update_clk_rate(long clock_rate);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_isp_update_req_history(uint32_t client, uint64_t ab,
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:				struct msm_isp_bandwidth_info *client_info,
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_isp_deinit_bandwidth_mgr(enum msm_isp_hw_client client);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:int msm_isp_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:int msm_isp_unsubscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:int msm_isp_proc_cmd(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:int msm_isp_send_event(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:	uint32_t type, struct msm_isp32_event_data *event_data);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:int msm_isp_cal_word_per_line(uint32_t output_format,
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:int msm_isp_get_bit_per_pixel(uint32_t output_format);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:enum msm_isp_pack_fmt msm_isp_get_pack_format(uint32_t output_format);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:irqreturn_t msm_isp_process_irq(int irq_num, void *data);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:int msm_isp_set_src_state(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_isp_do_tasklet(unsigned long data);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_isp_update_error_frame_count(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_isp_process_error_info(struct vfe_device *vfe_dev);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:int msm_isp_open_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:int msm_isp_close_node(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:long msm_isp_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:int msm_isp_get_clk_info(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:	struct platform_device *pdev, struct msm_cam_clk_info *vfe_clk_info);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_isp_fetch_engine_done_notify(struct vfe_device *vfe_dev,
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:	struct msm_vfe_fetch_engine_info *fetch_engine_info);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_camera_io_dump_2(void __iomem *addr, int size);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_isp_print_fourcc_error(const char *origin, uint32_t fourcc_format);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_isp_get_timestamp(struct msm_isp_timestamp *time_stamp,
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:void msm_isp_get_avtimer_ts(struct msm_isp_timestamp *time_stamp);
media/platform/msm/camera_v2/isp/msm_isp_util_32.h:int msm_isp_cfg_input(struct vfe_device *vfe_dev, void *arg);
media/platform/msm/camera_v2/ispif/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/ispif/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/ispif/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/ispif/Makefile:obj-$(CONFIG_MSM_CSID) += msm_ispif_32.o
media/platform/msm/camera_v2/ispif/Makefile:obj-$(CONFIG_MSM_CSID) += msm_ispif.o
media/platform/msm/camera_v2/ispif/msm_ispif.c:#include <media/msmb_isp.h>
media/platform/msm/camera_v2/ispif/msm_ispif.c:#include "msm_ispif.h"
media/platform/msm/camera_v2/ispif/msm_ispif.c:#include "msm.h"
media/platform/msm/camera_v2/ispif/msm_ispif.c:#include "msm_sd.h"
media/platform/msm/camera_v2/ispif/msm_ispif.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/ispif/msm_ispif.c:#include "msm_ispif_hwreg_v1.h"
media/platform/msm/camera_v2/ispif/msm_ispif.c:#include "msm_ispif_hwreg_v2.h"
media/platform/msm/camera_v2/ispif/msm_ispif.c:#include "msm_ispif_hwreg_v3.h"
media/platform/msm/camera_v2/ispif/msm_ispif.c:#define MSM_ISPIF_DRV_NAME                    "msm_ispif"
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_clk_ahb_enable(struct ispif_device *ispif, int enable);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static long msm_ispif_subdev_ioctl_unlocked(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static long msm_ispif_dispatch_cmd(enum ispif_cfg_type_t cmd,
media/platform/msm/camera_v2/ispif/msm_ispif.c:				struct msm_ispif_param_data_ext *params);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_get_clk_info(struct ispif_device *ispif_dev,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static void msm_ispif_io_dump_reg(struct ispif_device *ispif)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_dump(ispif->base, 0x250, 0);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static inline int msm_ispif_is_intf_valid(uint32_t csid_version,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	enum msm_ispif_vfe_intf intf_type)
media/platform/msm/camera_v2/ispif/msm_ispif.c:static void msm_ispif_get_pack_mask_from_cfg(
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_pack_cfg *pack_cfg,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_params_entry *entry,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_config2(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	enum msm_ispif_intftype intftype;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	enum msm_ispif_vfe_intf vfe_intf;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_param_data_ext *params =
media/platform/msm/camera_v2/ispif/msm_ispif.c:		(struct msm_ispif_param_data_ext *)data;
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_get_pack_mask_from_cfg(params->pack_cfg,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_cfg_pack_mode(ispif, intftype, vfe_intf,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static long msm_ispif_cmd_ext(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_param_data_ext *params = NULL;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	if (pcdata.size != sizeof(struct msm_ispif_param_data_ext)) {
media/platform/msm/camera_v2/ispif/msm_ispif.c:	params = kzalloc(sizeof(struct msm_ispif_param_data_ext), GFP_KERNEL);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_ispif_dispatch_cmd(pcdata.cfg_type, ispif, params);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static long msm_ispif_subdev_ioctl_compat(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		return msm_ispif_cmd_ext(sd, arg);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		return msm_ispif_subdev_ioctl_unlocked(sd, cmd, arg);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static long msm_ispif_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		return msm_ispif_subdev_ioctl_compat(sd, cmd, arg);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		return msm_ispif_subdev_ioctl_unlocked(sd, cmd, arg);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static long msm_ispif_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	return msm_ispif_subdev_ioctl_unlocked(sd, cmd, arg);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static void msm_ispif_put_regulator(struct ispif_device *ispif_dev)
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_get_regulator_info(struct ispif_device *ispif_dev,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_set_regulators(struct regulator **regs, int count,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_reset_hw(struct ispif_device *ispif)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_ispif_set_regulators(ispif->vfe_vdd, ispif->vfe_vdd_count, 1);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_camera_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_w(ISPIF_RST_CMD_MASK,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(ISPIF_RST_CMD_1_MASK,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		rc = rc ? rc : msm_camera_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = rc ? rc :  msm_ispif_set_regulators(ispif->vfe_vdd,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_get_clk_info(struct ispif_device *ispif_dev,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_cam_clk_info *clk_info, *temp_clk_info;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_camera_get_clk_info(pdev, &clk_info,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	temp_clk_info = kcalloc(num_clks, sizeof(struct msm_cam_clk_info),
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_put_clk_info(pdev, &clk_info, &clks, num_clks);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_clk_ahb_enable(struct ispif_device *ispif, int enable)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_reset(struct ispif_device *ispif)
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(1 << PIX0_LINE_BUF_EN_BIT,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0, ispif->base + ISPIF_VFE_m_IRQ_MASK_0(i));
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0, ispif->base + ISPIF_VFE_m_IRQ_MASK_1(i));
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0, ispif->base + ISPIF_VFE_m_IRQ_MASK_2(i));
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0xFFFFFFFF, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0xFFFFFFFF, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0xFFFFFFFF, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0, ispif->base + ISPIF_VFE_m_INPUT_SEL(i));
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(ISPIF_STOP_INTF_IMMEDIATELY,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(ISPIF_STOP_INTF_IMMEDIATELY,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_w_mb(ISPIF_IRQ_GLOBAL_CLEAR_CMD, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:static void msm_ispif_sel_csid_core(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	if (!msm_ispif_is_intf_valid(ispif->csid_version, vfe_intf)) {
media/platform/msm/camera_v2/ispif/msm_ispif.c:	data = msm_camera_io_r(ispif->base + ISPIF_VFE_m_INPUT_SEL(vfe_intf));
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_w_mb(data, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:static void msm_ispif_enable_crop(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	if (!msm_ispif_is_intf_valid(ispif->csid_version, vfe_intf)) {
media/platform/msm/camera_v2/ispif/msm_ispif.c:	data = msm_camera_io_r(ispif->base + ISPIF_VFE_m_CTRL_0(vfe_intf));
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_w(data,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w_mb(start_pixel | (end_pixel << 16),
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w_mb(start_pixel | (end_pixel << 16),
media/platform/msm/camera_v2/ispif/msm_ispif.c:static void msm_ispif_enable_intf_cids(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	if (!msm_ispif_is_intf_valid(ispif->csid_version, vfe_intf)) {
media/platform/msm/camera_v2/ispif/msm_ispif.c:	data = msm_camera_io_r(ispif->base + intf_addr);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_w_mb(data, ispif->base + intf_addr);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_validate_intf_status(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	if (!msm_ispif_is_intf_valid(ispif->csid_version, vfe_intf)) {
media/platform/msm/camera_v2/ispif/msm_ispif.c:		data = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		data = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		data = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		data = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		data = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:static void msm_ispif_select_clk_mux(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		data = msm_camera_io_r(ispif->clk_mux_base);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(data, ispif->clk_mux_base);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		data = msm_camera_io_r(ispif->clk_mux_base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(data, ispif->clk_mux_base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		data = msm_camera_io_r(ispif->clk_mux_base);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(data, ispif->clk_mux_base);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		data = msm_camera_io_r(ispif->clk_mux_base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(data, ispif->clk_mux_base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		data = msm_camera_io_r(ispif->clk_mux_base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(data, ispif->clk_mux_base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:static uint16_t msm_ispif_get_cids_mask_from_cfg(
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_params_entry *entry)
media/platform/msm/camera_v2/ispif/msm_ispif.c:static uint16_t msm_ispif_get_right_cids_mask_from_cfg(
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_right_param_entry *entry, int num_cids)
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_config(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	enum msm_ispif_intftype intftype;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	enum msm_ispif_vfe_intf vfe_intf;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_param_data_ext *params =
media/platform/msm/camera_v2/ispif/msm_ispif.c:		(struct msm_ispif_param_data_ext *)data;
media/platform/msm/camera_v2/ispif/msm_ispif.c:		if (!msm_ispif_is_intf_valid(ispif->csid_version,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0x0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(0x0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w_mb(0x0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_ispif_select_clk_mux(ispif, intftype,
media/platform/msm/camera_v2/ispif/msm_ispif.c:				msm_ispif_select_clk_mux(ispif, PIX1,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		rc = msm_ispif_validate_intf_status(ispif, intftype, vfe_intf);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_sel_csid_core(ispif, intftype,
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_ispif_sel_csid_core(ispif, PIX1,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		cid_mask = msm_ispif_get_cids_mask_from_cfg(
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_enable_intf_cids(ispif, intftype,
media/platform/msm/camera_v2/ispif/msm_ispif.c:			cid_right_mask = msm_ispif_get_right_cids_mask_from_cfg(
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_ispif_enable_intf_cids(ispif, PIX1,
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_ispif_enable_crop(ispif, intftype, vfe_intf,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(ISPIF_IRQ_STATUS_MASK, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(ISPIF_IRQ_STATUS_MASK, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(ISPIF_IRQ_STATUS_1_MASK, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(ISPIF_IRQ_STATUS_1_MASK, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(ISPIF_IRQ_STATUS_2_MASK, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(ISPIF_IRQ_STATUS_2_MASK, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_w_mb(ISPIF_IRQ_GLOBAL_CLEAR_CMD, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:static void msm_ispif_config_stereo(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_param_data_ext *params, int use_line_width)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	enum msm_ispif_vfe_intf vfe_intf;
media/platform/msm/camera_v2/ispif/msm_ispif.c:		if (!msm_ispif_is_intf_valid(ispif->csid_version, vfe_intf)) {
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_camera_io_w_mb(0x3,
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_camera_io_w_mb(stereo_3d_threshold,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static void msm_ispif_intf_cmd(struct ispif_device *ispif, uint32_t cmd_bits,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_param_data_ext *params)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	enum msm_ispif_intftype intf_type;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	enum msm_ispif_cid cid;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	enum msm_ispif_vfe_intf vfe_intf;
media/platform/msm/camera_v2/ispif/msm_ispif.c:		if (!msm_ispif_is_intf_valid(ispif->csid_version, vfe_intf)) {
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_camera_io_w_mb(
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_camera_io_w_mb(
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_stop_immediately(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_param_data_ext *params)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_ispif_intf_cmd(ispif, ISPIF_INTF_CMD_DISABLE_IMMEDIATELY, params);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		cid_mask = msm_ispif_get_cids_mask_from_cfg(
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_enable_intf_cids(ispif, params->entries[i].intftype,
media/platform/msm/camera_v2/ispif/msm_ispif.c:			cid_mask = msm_ispif_get_right_cids_mask_from_cfg(
media/platform/msm/camera_v2/ispif/msm_ispif.c:				msm_ispif_enable_intf_cids(ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_start_frame_boundary(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_param_data_ext *params)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_ispif_config_stereo(ispif, params, ISPIF_USE_DEFAULT_THRESHOLD);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_ispif_intf_cmd(ispif, ISPIF_INTF_CMD_ENABLE_FRAME_BOUNDARY, params);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_restart_frame_boundary(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_param_data_ext *params)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	enum msm_ispif_intftype intftype;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	enum msm_ispif_vfe_intf vfe_intf;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_ispif_set_regulators(ispif->vfe_vdd,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_camera_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(ISPIF_RST_CMD_MASK_RESTART,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(ISPIF_RST_CMD_1_MASK_RESTART,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_camera_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_ispif_set_regulators(ispif->vfe_vdd, ispif->vfe_vdd_count, 0);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_intf_cmd(ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		cid_mask = msm_ispif_get_cids_mask_from_cfg(
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_enable_intf_cids(ispif, intftype,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_ispif_set_regulators(ispif->vfe_vdd, ispif->vfe_vdd_count, 0);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_stop_frame_boundary(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_param_data_ext *params)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	enum msm_ispif_vfe_intf vfe_intf;
media/platform/msm/camera_v2/ispif/msm_ispif.c:		if (!msm_ispif_is_intf_valid(ispif->csid_version,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_ispif_intf_cmd(ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_ispif_get_cids_mask_from_cfg(&params->entries[i]);
media/platform/msm/camera_v2/ispif/msm_ispif.c:				msm_ispif_get_right_cids_mask_from_cfg(
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_enable_intf_cids(ispif, params->entries[i].intftype,
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_ispif_enable_intf_cids(ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct ispif_irq_status *out, enum msm_ispif_vfe_intf vfe_id)
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_reconfig_3d_output(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		enum msm_ispif_vfe_intf vfe_id)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_w_mb(reg_data, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_w_mb(reg_data, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w_mb(reg_data, ispif->base + ISPIF_RST_CMD_ADDR);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w_mb(reg_data, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_w_mb(reg_data, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:static inline void msm_ispif_read_irq_status(struct ispif_irq_status *out,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	out[VFE0].ispifIrqStatus0 = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_w(out[VFE0].ispifIrqStatus0,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	out[VFE0].ispifIrqStatus1 = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_w(out[VFE0].ispifIrqStatus1,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	out[VFE0].ispifIrqStatus2 = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_w_mb(out[VFE0].ispifIrqStatus2,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		out[VFE1].ispifIrqStatus0 = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(out[VFE1].ispifIrqStatus0,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		out[VFE1].ispifIrqStatus1 = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w(out[VFE1].ispifIrqStatus1,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		out[VFE1].ispifIrqStatus2 = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_camera_io_w_mb(out[VFE1].ispifIrqStatus2,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_io_w_mb(ISPIF_IRQ_GLOBAL_CLEAR_CMD, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:		reg_data = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:				msm_ispif_reconfig_3d_output(ispif, VFE0);
media/platform/msm/camera_v2/ispif/msm_ispif.c:			reg_data = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif.c:					msm_ispif_reconfig_3d_output(ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_camera_io_w(0x0,
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_camera_io_w(0x0,
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_camera_io_w(0x0,
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_camera_io_w(ISPIF_STOP_INTF_IMMEDIATELY,
media/platform/msm/camera_v2/ispif/msm_ispif.c:			msm_camera_io_w(ISPIF_STOP_INTF_IMMEDIATELY,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static irqreturn_t msm_io_ispif_irq(int irq_num, void *data)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_ispif_read_irq_status(irq, data);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_set_vfe_info(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_vfe_info *vfe_info)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	memcpy(&ispif->vfe_info, vfe_info, sizeof(struct msm_ispif_vfe_info));
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int msm_ispif_init(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_camera_enable_irq(ispif->irq, 1);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		ispif->clk_mux_base = msm_camera_get_reg_base(ispif->pdev,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_ispif_reset_hw(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_ispif_reset(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static void msm_ispif_release(struct ispif_device *ispif)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_enable_irq(ispif->irq, 0);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static long msm_ispif_dispatch_cmd(enum ispif_cfg_type_t cmd,
media/platform/msm/camera_v2/ispif/msm_ispif.c:				struct msm_ispif_param_data_ext *params)
media/platform/msm/camera_v2/ispif/msm_ispif.c:		rc = msm_ispif_config(ispif, params);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_io_dump_reg(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		rc = msm_ispif_start_frame_boundary(ispif, params);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_io_dump_reg(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		rc = msm_ispif_restart_frame_boundary(ispif, params);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_io_dump_reg(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		rc = msm_ispif_stop_frame_boundary(ispif, params);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_io_dump_reg(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		rc = msm_ispif_stop_immediately(ispif, params);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_io_dump_reg(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_reset(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_reset_hw(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		rc = msm_ispif_config2(ispif, params);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_io_dump_reg(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_config_stereo(ispif, params,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static long msm_ispif_cmd(struct v4l2_subdev *sd, void *arg)
media/platform/msm/camera_v2/ispif/msm_ispif.c:	struct msm_ispif_param_data_ext params;
media/platform/msm/camera_v2/ispif/msm_ispif.c:		rc = msm_ispif_init(ispif, pcdata->csid_version);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_io_dump_reg(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		rc = msm_ispif_set_vfe_info(ispif, &pcdata->vfe_info);
media/platform/msm/camera_v2/ispif/msm_ispif.c:					sizeof(struct msm_ispif_params_entry));
media/platform/msm/camera_v2/ispif/msm_ispif.c:			rc = msm_ispif_dispatch_cmd(pcdata->cfg_type, ispif,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static struct v4l2_file_operations msm_ispif_v4l2_subdev_fops;
media/platform/msm/camera_v2/ispif/msm_ispif.c:static long msm_ispif_subdev_ioctl_unlocked(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		return msm_ispif_cmd(sd, arg);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		return msm_ispif_cmd_ext(sd, arg);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static long msm_ispif_subdev_do_ioctl(
media/platform/msm/camera_v2/ispif/msm_ispif.c:	return msm_ispif_subdev_ioctl(sd, cmd, arg);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static long msm_ispif_subdev_fops_ioctl(struct file *file, unsigned int cmd,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	return video_usercopy(file, cmd, arg, msm_ispif_subdev_do_ioctl);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		rc = msm_ispif_set_regulators(ispif->ispif_vdd,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		rc = msm_ispif_clk_ahb_enable(ispif, 1);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_ispif_set_regulators(ispif->ispif_vdd, ispif->ispif_vdd_count, 0);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_release(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_clk_ahb_enable(ispif, 0);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_set_regulators(ispif->ispif_vdd,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static struct v4l2_subdev_core_ops msm_ispif_subdev_core_ops = {
media/platform/msm/camera_v2/ispif/msm_ispif.c:	.ioctl = &msm_ispif_subdev_ioctl,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static const struct v4l2_subdev_ops msm_ispif_subdev_ops = {
media/platform/msm/camera_v2/ispif/msm_ispif.c:	.core = &msm_ispif_subdev_core_ops,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static const struct v4l2_subdev_internal_ops msm_ispif_internal_ops = {
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_ispif_get_regulator_info(ispif, pdev);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_ispif_get_clk_info(ispif, pdev);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		pr_err("%s: msm_isp_get_clk_info() failed\n", __func__);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	ispif->base = msm_camera_get_reg_base(pdev, "ispif", 1);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	ispif->irq = msm_camera_get_irq(pdev, "ispif");
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_camera_register_irq(pdev, ispif->irq, msm_io_ispif_irq,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_camera_enable_irq(ispif->irq, 0);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	v4l2_subdev_init(&ispif->msm_sd.sd, &msm_ispif_subdev_ops);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	ispif->msm_sd.sd.internal_ops = &msm_ispif_internal_ops;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	ispif->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	snprintf(ispif->msm_sd.sd.name,
media/platform/msm/camera_v2/ispif/msm_ispif.c:		ARRAY_SIZE(ispif->msm_sd.sd.name), MSM_ISPIF_DRV_NAME);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	v4l2_set_subdevdata(&ispif->msm_sd.sd, ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	platform_set_drvdata(pdev, &ispif->msm_sd.sd);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	media_entity_pads_init(&ispif->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	ispif->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_ISPIF;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	ispif->msm_sd.sd.entity.name = pdev->name;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	ispif->msm_sd.close_seq = MSM_SD_CLOSE_1ST_CATEGORY | 0x1;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	rc = msm_sd_register(&ispif->msm_sd);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		pr_err("%s: msm_sd_register error = %d\n", __func__, rc);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_cam_copy_v4l2_subdev_fops(&msm_ispif_v4l2_subdev_fops);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_ispif_v4l2_subdev_fops.unlocked_ioctl =
media/platform/msm/camera_v2/ispif/msm_ispif.c:		msm_ispif_subdev_fops_ioctl;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_ispif_v4l2_subdev_fops.compat_ioctl32 = msm_ispif_subdev_fops_ioctl;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	ispif->msm_sd.sd.devnode->fops = &msm_ispif_v4l2_subdev_fops;
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_unregister_irq(pdev, ispif->irq, ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_put_reg_base(pdev, ispif->base, "ispif", 1);
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_camera_put_clk_info(pdev, &ispif->ahb_clk_info,
media/platform/msm/camera_v2/ispif/msm_ispif.c:	msm_ispif_put_regulator(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif.c:static const struct of_device_id msm_ispif_dt_match[] = {
media/platform/msm/camera_v2/ispif/msm_ispif.c:MODULE_DEVICE_TABLE(of, msm_ispif_dt_match);
media/platform/msm/camera_v2/ispif/msm_ispif.c:		.of_match_table = msm_ispif_dt_match,
media/platform/msm/camera_v2/ispif/msm_ispif.c:static int __init msm_ispif_init_module(void)
media/platform/msm/camera_v2/ispif/msm_ispif.c:static void __exit msm_ispif_exit_module(void)
media/platform/msm/camera_v2/ispif/msm_ispif.c:module_init(msm_ispif_init_module);
media/platform/msm/camera_v2/ispif/msm_ispif.c:module_exit(msm_ispif_exit_module);
media/platform/msm/camera_v2/ispif/msm_ispif.h:#include <media/msmb_ispif.h>
media/platform/msm/camera_v2/ispif/msm_ispif.h:#include "msm_sd.h"
media/platform/msm/camera_v2/ispif/msm_ispif.h:enum msm_ispif_state_t {
media/platform/msm/camera_v2/ispif/msm_ispif.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/ispif/msm_ispif.h:	enum msm_ispif_state_t ispif_state;
media/platform/msm/camera_v2/ispif/msm_ispif.h:	struct msm_ispif_vfe_info vfe_info;
media/platform/msm/camera_v2/ispif/msm_ispif.h:	struct msm_cam_clk_info *ahb_clk_info;
media/platform/msm/camera_v2/ispif/msm_ispif.h:	struct msm_cam_clk_info *clk_info;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:#include <media/msmb_isp.h>
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:#include "msm_ispif_32.h"
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:#include "msm.h"
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:#include "msm_sd.h"
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:#include "msm_ispif_hwreg_v1.h"
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:#include "msm_ispif_hwreg_v2.h"
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:#define MSM_ISPIF_DRV_NAME                    "msm_ispif"
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static void msm_ispif_io_dump_reg(struct ispif_device *ispif)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_camera_io_dump(ispif->base, 0x250, 1);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static inline int msm_ispif_is_intf_valid(uint32_t csid_version,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static struct msm_cam_clk_info ispif_8626_reset_clk_info[] = {
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static struct msm_cam_clk_info ispif_8974_ahb_clk_info[ISPIF_CLK_INFO_MAX];
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static struct msm_cam_clk_info ispif_8974_reset_clk_info[] = {
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int msm_ispif_reset_hw(struct ispif_device *ispif)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_camera_io_w(ISPIF_RST_CMD_MASK,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(ISPIF_RST_CMD_1_MASK,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:			rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:			msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int msm_ispif_get_ahb_clk_info(struct ispif_device *ispif_dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	struct msm_cam_clk_info *ahb_clk_info)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int msm_ispif_clk_ahb_enable(struct ispif_device *ispif, int enable)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	rc = msm_ispif_get_ahb_clk_info(ispif, ispif->pdev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		pr_err("%s: msm_isp_get_clk_info() failed\n", __func__);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int msm_ispif_reset(struct ispif_device *ispif)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(1 << PIX0_LINE_BUF_EN_BIT,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0, ispif->base + ISPIF_VFE_m_IRQ_MASK_0(i));
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0, ispif->base + ISPIF_VFE_m_IRQ_MASK_1(i));
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0, ispif->base + ISPIF_VFE_m_IRQ_MASK_2(i));
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0xFFFFFFFF, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0xFFFFFFFF, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0xFFFFFFFF, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0, ispif->base + ISPIF_VFE_m_INPUT_SEL(i));
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(ISPIF_STOP_INTF_IMMEDIATELY,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(ISPIF_STOP_INTF_IMMEDIATELY,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_camera_io_w_mb(ISPIF_IRQ_GLOBAL_CLEAR_CMD, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static void msm_ispif_sel_csid_core(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	if (!msm_ispif_is_intf_valid(ispif->csid_version, vfe_intf)) {
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	data = msm_camera_io_r(ispif->base + ISPIF_VFE_m_INPUT_SEL(vfe_intf));
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_camera_io_w_mb(data, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static void msm_ispif_enable_crop(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	if (!msm_ispif_is_intf_valid(ispif->csid_version, vfe_intf)) {
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	data = msm_camera_io_r(ispif->base + ISPIF_VFE_m_CTRL_0(vfe_intf));
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_camera_io_w(data,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w_mb(start_pixel | (end_pixel << 16),
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w_mb(start_pixel | (end_pixel << 16),
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static void msm_ispif_enable_intf_cids(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	if (!msm_ispif_is_intf_valid(ispif->csid_version, vfe_intf)) {
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	data = msm_camera_io_r(ispif->base + intf_addr);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_camera_io_w_mb(data, ispif->base + intf_addr);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int msm_ispif_validate_intf_status(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	if (!msm_ispif_is_intf_valid(ispif->csid_version, vfe_intf)) {
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		data = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		data = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		data = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		data = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		data = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static void msm_ispif_select_clk_mux(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		data = msm_camera_io_r(ispif->clk_mux_base);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(data, ispif->clk_mux_base);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		data = msm_camera_io_r(ispif->clk_mux_base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(data, ispif->clk_mux_base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		data = msm_camera_io_r(ispif->clk_mux_base);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(data, ispif->clk_mux_base);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		data = msm_camera_io_r(ispif->clk_mux_base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(data, ispif->clk_mux_base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		data = msm_camera_io_r(ispif->clk_mux_base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(data, ispif->clk_mux_base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static uint16_t msm_ispif_get_cids_mask_from_cfg(
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	struct msm_ispif_params_entry *entry)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int msm_ispif_config(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	struct msm_ispif_param_data *params)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	enum msm_ispif_intftype intftype;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	enum msm_ispif_vfe_intf vfe_intf;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		if (!msm_ispif_is_intf_valid(ispif->csid_version,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0x0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0x0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w_mb(0x0, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:			msm_ispif_select_clk_mux(ispif, intftype,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_ispif_validate_intf_status(ispif, intftype, vfe_intf);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_sel_csid_core(ispif, intftype,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		cid_mask = msm_ispif_get_cids_mask_from_cfg(
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_enable_intf_cids(ispif, intftype,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:			msm_ispif_enable_crop(ispif, intftype, vfe_intf,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(ISPIF_IRQ_STATUS_MASK, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(ISPIF_IRQ_STATUS_MASK, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(ISPIF_IRQ_STATUS_1_MASK, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(ISPIF_IRQ_STATUS_1_MASK, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(ISPIF_IRQ_STATUS_2_MASK, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(ISPIF_IRQ_STATUS_2_MASK, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_camera_io_w_mb(ISPIF_IRQ_GLOBAL_CLEAR_CMD, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int msm_ispif_intf_cmd(struct ispif_device *ispif, uint32_t cmd_bits,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	struct msm_ispif_param_data *params)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	enum msm_ispif_intftype intf_type;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	enum msm_ispif_cid cid;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	enum msm_ispif_vfe_intf vfe_intf;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		if (!msm_ispif_is_intf_valid(ispif->csid_version, vfe_intf)) {
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:			msm_camera_io_w_mb(
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:			msm_camera_io_w_mb(
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int msm_ispif_stop_immediately(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	struct msm_ispif_param_data *params)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_ispif_intf_cmd(ispif, ISPIF_INTF_CMD_DISABLE_IMMEDIATELY, params);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		cid_mask = msm_ispif_get_cids_mask_from_cfg(
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_enable_intf_cids(ispif, params->entries[i].intftype,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int msm_ispif_start_frame_boundary(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	struct msm_ispif_param_data *params)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_ispif_intf_cmd(ispif, ISPIF_INTF_CMD_ENABLE_FRAME_BOUNDARY, params);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int msm_ispif_restart_frame_boundary(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	struct msm_ispif_param_data *params)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	enum msm_ispif_intftype intftype;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	enum msm_ispif_vfe_intf vfe_intf;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(0x00001FF9,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:				msm_camera_io_w(0x00001FF9,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_intf_cmd(ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		cid_mask = msm_ispif_get_cids_mask_from_cfg(
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_enable_intf_cids(ispif, intftype,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_cam_clk_enable(&ispif->pdev->dev,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int msm_ispif_stop_frame_boundary(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	struct msm_ispif_param_data *params)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	enum msm_ispif_vfe_intf vfe_intf;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		if (!msm_ispif_is_intf_valid(ispif->csid_version,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_ispif_intf_cmd(ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:			msm_ispif_get_cids_mask_from_cfg(&params->entries[i]);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_enable_intf_cids(ispif, params->entries[i].intftype,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	struct ispif_irq_status *out, enum msm_ispif_vfe_intf vfe_id)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static inline void msm_ispif_read_irq_status(struct ispif_irq_status *out,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	out[VFE0].ispifIrqStatus0 = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_camera_io_w(out[VFE0].ispifIrqStatus0,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	out[VFE0].ispifIrqStatus1 = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_camera_io_w(out[VFE0].ispifIrqStatus1,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	out[VFE0].ispifIrqStatus2 = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_camera_io_w_mb(out[VFE0].ispifIrqStatus2,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		out[VFE1].ispifIrqStatus0 = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(out[VFE1].ispifIrqStatus0,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		out[VFE1].ispifIrqStatus1 = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w(out[VFE1].ispifIrqStatus1,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		out[VFE1].ispifIrqStatus2 = msm_camera_io_r(ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_camera_io_w_mb(out[VFE1].ispifIrqStatus2,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_camera_io_w_mb(ISPIF_IRQ_GLOBAL_CLEAR_CMD, ispif->base +
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static irqreturn_t msm_io_ispif_irq(int irq_num, void *data)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_ispif_read_irq_status(irq, data);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int msm_ispif_set_vfe_info(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	struct msm_ispif_vfe_info *vfe_info)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	memcpy(&ispif->vfe_info, vfe_info, sizeof(struct msm_ispif_vfe_info));
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int msm_ispif_init(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	rc = request_irq(ispif->irq->start, msm_io_ispif_irq,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	rc = msm_ispif_clk_ahb_enable(ispif, 1);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_ispif_reset_hw(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	rc = msm_ispif_reset(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static void msm_ispif_release(struct ispif_device *ispif)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_ispif_reset(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_ispif_clk_ahb_enable(ispif, 0);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static long msm_ispif_cmd(struct v4l2_subdev *sd, void *arg)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_ispif_init(ispif, pcdata->csid_version);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_io_dump_reg(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_ispif_config(ispif, &pcdata->params);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_io_dump_reg(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_ispif_start_frame_boundary(ispif, &pcdata->params);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_io_dump_reg(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_ispif_restart_frame_boundary(ispif, &pcdata->params);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_io_dump_reg(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_ispif_stop_frame_boundary(ispif, &pcdata->params);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_io_dump_reg(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_ispif_stop_immediately(ispif, &pcdata->params);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_io_dump_reg(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_release(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		rc = msm_ispif_set_vfe_info(ispif, &pcdata->vfe_info);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static struct v4l2_file_operations msm_ispif_v4l2_subdev_fops;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static long msm_ispif_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		return msm_ispif_cmd(sd, arg);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:			msm_ispif_release(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static long msm_ispif_subdev_do_ioctl(
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	return msm_ispif_subdev_ioctl(sd, cmd, arg);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static long msm_ispif_subdev_fops_ioctl(struct file *file, unsigned int cmd,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	return video_usercopy(file, cmd, arg, msm_ispif_subdev_do_ioctl);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		msm_ispif_release(ispif);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static struct v4l2_subdev_core_ops msm_ispif_subdev_core_ops = {
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	/* .g_chip_ident = &msm_ispif_subdev_g_chip_ident, */
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	.ioctl = &msm_ispif_subdev_ioctl,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static const struct v4l2_subdev_ops msm_ispif_subdev_ops = {
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	.core = &msm_ispif_subdev_core_ops,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static const struct v4l2_subdev_internal_ops msm_ispif_internal_ops = {
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	v4l2_subdev_init(&ispif->msm_sd.sd, &msm_ispif_subdev_ops);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	ispif->msm_sd.sd.internal_ops = &msm_ispif_internal_ops;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	ispif->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	snprintf(ispif->msm_sd.sd.name,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		ARRAY_SIZE(ispif->msm_sd.sd.name), MSM_ISPIF_DRV_NAME);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	v4l2_set_subdevdata(&ispif->msm_sd.sd, ispif);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	platform_set_drvdata(pdev, &ispif->msm_sd.sd);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	media_entity_pads_init(&ispif->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	ispif->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_ISPIF;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	ispif->msm_sd.sd.entity.name = pdev->name;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	ispif->msm_sd.close_seq = MSM_SD_CLOSE_1ST_CATEGORY | 0x1;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	rc = msm_sd_register(&ispif->msm_sd);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		pr_err("%s: msm_sd_register error = %d\n", __func__, rc);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_ispif_v4l2_subdev_fops.owner = v4l2_subdev_fops.owner;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_ispif_v4l2_subdev_fops.open = v4l2_subdev_fops.open;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_ispif_v4l2_subdev_fops.unlocked_ioctl = msm_ispif_subdev_fops_ioctl;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_ispif_v4l2_subdev_fops.release = v4l2_subdev_fops.release;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_ispif_v4l2_subdev_fops.poll = v4l2_subdev_fops.poll;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	msm_ispif_v4l2_subdev_fops.compat_ioctl32 = msm_ispif_subdev_fops_ioctl;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:	ispif->msm_sd.sd.devnode->fops = &msm_ispif_v4l2_subdev_fops;
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static const struct of_device_id msm_ispif_dt_match[] = {
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:MODULE_DEVICE_TABLE(of, msm_ispif_dt_match);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:		.of_match_table = msm_ispif_dt_match,
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static int __init msm_ispif_init_module(void)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:static void __exit msm_ispif_exit_module(void)
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:module_init(msm_ispif_init_module);
media/platform/msm/camera_v2/ispif/msm_ispif_32.c:module_exit(msm_ispif_exit_module);
media/platform/msm/camera_v2/ispif/msm_ispif_32.h:#include <media/msmb_ispif.h>
media/platform/msm/camera_v2/ispif/msm_ispif_32.h:#include "msm_sd.h"
media/platform/msm/camera_v2/ispif/msm_ispif_32.h:enum msm_ispif_state_t {
media/platform/msm/camera_v2/ispif/msm_ispif_32.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/ispif/msm_ispif_32.h:	enum msm_ispif_state_t ispif_state;
media/platform/msm/camera_v2/ispif/msm_ispif_32.h:	struct msm_ispif_vfe_info vfe_info;
media/platform/msm/camera_v2/ispif/msm_ispif_hwreg_v1.h:static inline void msm_ispif_cfg_pack_mode(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_hwreg_v2.h:static inline void msm_ispif_cfg_pack_mode(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_hwreg_v3.h:static inline void msm_ispif_cfg_pack_mode(struct ispif_device *ispif,
media/platform/msm/camera_v2/ispif/msm_ispif_hwreg_v3.h:	msm_camera_io_w_mb(pack_cfg_mask[0], ispif->base + pack_addr[0]);
media/platform/msm/camera_v2/ispif/msm_ispif_hwreg_v3.h:	msm_camera_io_w_mb(pack_cfg_mask[1], ispif->base + pack_addr[1]);
media/platform/msm/camera_v2/jpeg_10/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/jpeg_10
media/platform/msm/camera_v2/jpeg_10/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/jpeg_10/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/jpeg_10/Makefile:obj-$(CONFIG_MSMB_JPEG) += msm_jpeg_dev.o msm_jpeg_sync.o msm_jpeg_core.o msm_jpeg_hw.o msm_jpeg_platform.o
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:#include "msm_jpeg_hw.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:#include "msm_jpeg_core.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:#include "msm_jpeg_platform.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:#include "msm_jpeg_common.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:int msm_jpeg_core_reset(struct msm_jpeg_device *pgmn_dev, uint8_t op_mode,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpeg_hw_reset(base, size);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpeg_hw_reset_dma(base, size);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:void msm_jpeg_core_release(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:			msm_jpeg_platform_p2v(pgmn_dev->iommu_hdl,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:void msm_jpeg_core_init(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:int msm_jpeg_core_fe_start(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	msm_jpeg_hw_fe_start(pgmn_dev->base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:int msm_jpeg_core_fe_buf_update(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	struct msm_jpeg_core_buf *buf)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		rc = msm_jpeg_hw_pingpong_update(&pgmn_dev->fe_pingpong_buf,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpeg_hw_fe_mmu_prefetch(buf, pgmn_dev->base,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		rc = msm_jpegdma_hw_pingpong_update(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpegdma_hw_fe_mmu_prefetch(buf, pgmn_dev->base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:static void *msm_jpeg_core_fe_pingpong_irq(int jpeg_irq_status,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	return msm_jpeg_hw_pingpong_irq(&pgmn_dev->fe_pingpong_buf);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:int msm_jpeg_core_we_buf_update(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	struct msm_jpeg_core_buf *buf)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpeg_hw_we_buffer_update(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpeg_hw_we_mmu_prefetch(buf, pgmn_dev->base,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpegdma_hw_we_buffer_update(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpegdma_hw_we_mmu_prefetch(buf, pgmn_dev->base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:int msm_jpeg_core_we_buf_reset(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	struct msm_jpeg_hw_buf *buf)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:static void *msm_jpeg_core_we_pingpong_irq(int jpeg_irq_status,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	return msm_jpeg_hw_pingpong_irq(&pgmn_dev->we_pingpong_buf);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:static void *msm_jpeg_core_framedone_irq(int jpeg_irq_status,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	struct msm_jpeg_hw_buf *buf_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	buf_p = msm_jpeg_hw_pingpong_active_buffer(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:			msm_jpeg_hw_encode_output_size(pgmn_dev->base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:static void *msm_jpeg_core_reset_ack_irq(int jpeg_irq_status,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	/* @todo return the status back to msm_jpeg_core_reset */
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:static void *msm_jpeg_core_err_irq(int jpeg_irq_status,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:static int (*msm_jpeg_irq_handler)(int, void *, void *);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:static void msm_jpeg_core_return_buffers(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	data = msm_jpeg_core_fe_pingpong_irq(jpeg_irq_status,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	if (msm_jpeg_irq_handler)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpeg_irq_handler(MSM_JPEG_HW_MASK_COMP_FE,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	data = msm_jpeg_core_we_pingpong_irq(jpeg_irq_status,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	if (msm_jpeg_irq_handler)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpeg_irq_handler(MSM_JPEG_HW_MASK_COMP_WE,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:irqreturn_t msm_jpeg_core_irq(int irq_num, void *context)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	struct msm_jpeg_device *pgmn_dev = (struct msm_jpeg_device *)context;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	jpeg_irq_status = msm_jpeg_hw_irq_get_status(pgmn_dev->base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpeg_hw_irq_clear(JPEG_IRQ_CLEAR_BMSK,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpeg_hw_irq_clear(JPEG_IRQ_CLEAR_BMSK,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpeg_hw_irq_clear(JPEG_IRQ_CLEAR_BMSK,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:			msm_jpeg_decode_status(pgmn_dev->base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpeg_hw_irq_clear(JPEG_IRQ_CLEAR_BMSK,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	if (msm_jpeg_hw_irq_is_frame_done(jpeg_irq_status)) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		data = msm_jpeg_core_fe_pingpong_irq(jpeg_irq_status,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		if (msm_jpeg_irq_handler)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:			msm_jpeg_irq_handler(MSM_JPEG_HW_MASK_COMP_FE,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		data = msm_jpeg_core_framedone_irq(jpeg_irq_status,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		if (msm_jpeg_irq_handler)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:			msm_jpeg_irq_handler(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	if (msm_jpeg_hw_irq_is_reset_ack(jpeg_irq_status)) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		data = msm_jpeg_core_reset_ack_irq(jpeg_irq_status,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		if (msm_jpeg_irq_handler)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:			msm_jpeg_irq_handler(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	if (msm_jpeg_hw_irq_is_err(jpeg_irq_status)) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:			msm_jpeg_hw_irq_clear(JPEG_IRQ_CLEAR_BMSK,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:				msm_jpeg_decode_status(pgmn_dev->base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:			msm_jpeg_core_return_buffers(pgmn_dev, jpeg_irq_status);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:			data = msm_jpeg_core_err_irq(jpeg_irq_status, pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:			if (msm_jpeg_irq_handler) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:				msm_jpeg_irq_handler(MSM_JPEG_HW_MASK_COMP_ERR,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:irqreturn_t msm_jpegdma_core_irq(int irq_num, void *context)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	struct msm_jpeg_device *pgmn_dev = context;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	jpeg_irq_status = msm_jpegdma_hw_irq_get_status(pgmn_dev->base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpegdma_hw_irq_clear(JPEGDMA_IRQ_CLEAR_BMSK,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpegdma_hw_irq_clear(JPEGDMA_IRQ_CLEAR_BMSK,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpegdma_hw_irq_clear(JPEGDMA_IRQ_CLEAR_BMSK,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		msm_jpegdma_hw_irq_clear(JPEGDMA_IRQ_CLEAR_BMSK,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	if (msm_jpegdma_hw_irq_is_frame_done(jpeg_irq_status)) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		data = msm_jpeg_core_fe_pingpong_irq(jpeg_irq_status,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		if (msm_jpeg_irq_handler)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:			msm_jpeg_irq_handler(MSM_JPEG_HW_MASK_COMP_FE,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		data = msm_jpeg_core_framedone_irq(jpeg_irq_status,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		if (msm_jpeg_irq_handler)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:			msm_jpeg_irq_handler(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	if (msm_jpegdma_hw_irq_is_reset_ack(jpeg_irq_status)) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		data = msm_jpeg_core_reset_ack_irq(jpeg_irq_status,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:		if (msm_jpeg_irq_handler)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:			msm_jpeg_irq_handler(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:void msm_jpeg_core_irq_install(int (*irq_handler) (int, void *, void *))
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	msm_jpeg_irq_handler = irq_handler;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:void msm_jpeg_core_irq_remove(void)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.c:	msm_jpeg_irq_handler = NULL;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:#include "msm_jpeg_hw.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:#include "msm_jpeg_sync.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:#define msm_jpeg_core_buf msm_jpeg_hw_buf
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:irqreturn_t msm_jpeg_core_irq(int irq_num, void *context);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:irqreturn_t msm_jpegdma_core_irq(int irq_num, void *context);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:void msm_jpeg_core_irq_install(int (*irq_handler) (int, void *, void *));
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:void msm_jpeg_core_irq_remove(void);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:int msm_jpeg_core_fe_buf_update(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:	struct msm_jpeg_core_buf *buf);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:int msm_jpeg_core_we_buf_update(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:	struct msm_jpeg_core_buf *buf);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:int msm_jpeg_core_we_buf_reset(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:	struct msm_jpeg_hw_buf *buf);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:int msm_jpeg_core_reset(struct msm_jpeg_device *pgmn_dev, uint8_t op_mode,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:int msm_jpeg_core_fe_start(struct msm_jpeg_device *pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:void msm_jpeg_core_release(struct msm_jpeg_device *pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_core.h:void msm_jpeg_core_init(struct msm_jpeg_device *pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:#include <media/msm_jpeg.h>
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:#include "msm_jpeg_sync.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:#include "msm_jpeg_common.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static int msm_jpeg_open(struct inode *inode, struct file *filp)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	struct msm_jpeg_device *pgmn_dev = container_of(inode->i_cdev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:		struct msm_jpeg_device, cdev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	rc = __msm_jpeg_open(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static int msm_jpeg_release(struct inode *inode, struct file *filp)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	struct msm_jpeg_device *pgmn_dev = filp->private_data;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	rc = __msm_jpeg_release(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static long msm_jpeg_compat_ioctl(struct file *filp, unsigned int cmd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	struct msm_jpeg_device *pgmn_dev = filp->private_data;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	rc = __msm_jpeg_compat_ioctl(pgmn_dev, cmd, arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static long msm_jpeg_ioctl(struct file *filp, unsigned int cmd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	struct msm_jpeg_device *pgmn_dev = filp->private_data;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	rc = __msm_jpeg_ioctl(pgmn_dev, cmd, arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static const struct file_operations msm_jpeg_fops = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	.open		 = msm_jpeg_open,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	.release	= msm_jpeg_release,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	.unlocked_ioctl = msm_jpeg_ioctl,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	.compat_ioctl = msm_jpeg_compat_ioctl,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static long msm_jpeg_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	struct msm_jpeg_device *pgmn_dev =
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:		(struct msm_jpeg_device *)sd->host_priv;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	JPEG_DBG("%s: Calling __msm_jpeg_ioctl\n", __func__);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	rc = __msm_jpeg_ioctl(pgmn_dev, cmd, (unsigned long)arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static const struct v4l2_subdev_core_ops msm_jpeg_subdev_core_ops = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	.ioctl = msm_jpeg_subdev_ioctl,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static const struct v4l2_subdev_ops msm_jpeg_subdev_ops = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	.core = &msm_jpeg_subdev_core_ops,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:struct msm_jpeg_priv_data {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	enum msm_jpeg_core_type core_type;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static const struct msm_jpeg_priv_data msm_jpeg_priv_data_jpg = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static const struct msm_jpeg_priv_data msm_jpeg_priv_data_dma = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static const struct of_device_id msm_jpeg_dt_match[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	{.compatible = "qcom,jpeg", .data = &msm_jpeg_priv_data_jpg},
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	{.compatible = "qcom,jpeg_dma", .data = &msm_jpeg_priv_data_dma},
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:MODULE_DEVICE_TABLE(of, msm_jpeg_dt_match);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static int msm_jpeg_init_dev(struct platform_device *pdev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	struct msm_jpeg_device *msm_jpeg_device_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	const struct msm_jpeg_priv_data *priv_data;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	msm_jpeg_device_p = kzalloc(sizeof(struct msm_jpeg_device), GFP_ATOMIC);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	if (!msm_jpeg_device_p) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	msm_jpeg_device_p->pdev = pdev;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	device_id = of_match_device(msm_jpeg_dt_match, &pdev->dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	msm_jpeg_device_p->core_type = priv_data->core_type;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	rc = __msm_jpeg_init(msm_jpeg_device_p);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	v4l2_subdev_init(&msm_jpeg_device_p->subdev, &msm_jpeg_subdev_ops);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	v4l2_set_subdev_hostdata(&msm_jpeg_device_p->subdev, msm_jpeg_device_p);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	JPEG_DBG("%s: msm_jpeg_device_p 0x%lx", __func__,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:			(unsigned long)msm_jpeg_device_p);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	rc = alloc_chrdev_region(&msm_jpeg_device_p->msm_jpeg_devno, 0, 1,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	if (!msm_jpeg_device_p->msm_jpeg_class) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:		msm_jpeg_device_p->msm_jpeg_class =
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:		if (IS_ERR(msm_jpeg_device_p->msm_jpeg_class)) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:			rc = PTR_ERR(msm_jpeg_device_p->msm_jpeg_class);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	dev = device_create(msm_jpeg_device_p->msm_jpeg_class, NULL,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:		MKDEV(MAJOR(msm_jpeg_device_p->msm_jpeg_devno),
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:		MINOR(msm_jpeg_device_p->msm_jpeg_devno)), NULL,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	cdev_init(&msm_jpeg_device_p->cdev, &msm_jpeg_fops);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	msm_jpeg_device_p->cdev.owner = THIS_MODULE;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	msm_jpeg_device_p->cdev.ops	 =
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:		(const struct file_operations *) &msm_jpeg_fops;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	rc = cdev_add(&msm_jpeg_device_p->cdev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:			msm_jpeg_device_p->msm_jpeg_devno, 1);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	platform_set_drvdata(pdev, msm_jpeg_device_p);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	device_destroy(msm_jpeg_device_p->msm_jpeg_class,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:			msm_jpeg_device_p->msm_jpeg_devno);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	class_destroy(msm_jpeg_device_p->msm_jpeg_class);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	unregister_chrdev_region(msm_jpeg_device_p->msm_jpeg_devno, 1);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	__msm_jpeg_exit(msm_jpeg_device_p);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	kfree(msm_jpeg_device_p);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static void msm_jpeg_exit(struct msm_jpeg_device *msm_jpeg_device_p)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	cdev_del(&msm_jpeg_device_p->cdev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	device_destroy(msm_jpeg_device_p->msm_jpeg_class,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:			msm_jpeg_device_p->msm_jpeg_devno);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	class_destroy(msm_jpeg_device_p->msm_jpeg_class);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	unregister_chrdev_region(msm_jpeg_device_p->msm_jpeg_devno, 1);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	cam_smmu_destroy_handle(msm_jpeg_device_p->iommu_hdl);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	__msm_jpeg_exit(msm_jpeg_device_p);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static int __msm_jpeg_probe(struct platform_device *pdev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	return msm_jpeg_init_dev(pdev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static int __msm_jpeg_remove(struct platform_device *pdev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	struct msm_jpeg_device *msm_jpegd_device_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	msm_jpegd_device_p = platform_get_drvdata(pdev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	if (msm_jpegd_device_p)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:		msm_jpeg_exit(msm_jpegd_device_p);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static struct platform_driver msm_jpeg_driver = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	.probe	= __msm_jpeg_probe,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	.remove = __msm_jpeg_remove,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:		.name = "msm_jpeg",
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:		.of_match_table = msm_jpeg_dt_match,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static int __init msm_jpeg_driver_init(void)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	rc = platform_driver_register(&msm_jpeg_driver);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:static void __exit msm_jpeg_driver_exit(void)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:	platform_driver_unregister(&msm_jpeg_driver);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:MODULE_DESCRIPTION("msm jpeg jpeg driver");
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:module_init(msm_jpeg_driver_init);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_dev.c:module_exit(msm_jpeg_driver_exit);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:#include "msm_jpeg_hw.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:#include "msm_jpeg_common.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:int msm_jpeg_hw_pingpong_update(struct msm_jpeg_hw_pingpong *pingpong_hw,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_buf *buf, void *base)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_fe_buffer_update(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_we_buffer_update(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:int msm_jpegdma_hw_pingpong_update(struct msm_jpeg_hw_pingpong *pingpong_hw,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_buf *buf, void *base)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpegdma_hw_fe_buffer_update(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpegdma_hw_we_buffer_update(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void *msm_jpeg_hw_pingpong_irq(struct msm_jpeg_hw_pingpong *pingpong_hw)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_buf *buf_p = NULL;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void *msm_jpeg_hw_pingpong_active_buffer(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_pingpong *pingpong_hw)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_buf *buf_p = NULL;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_cmd_irq_get_status[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:int msm_jpeg_hw_irq_get_status(void *base)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	n_irq_status = msm_jpeg_hw_read(&hw_cmd_irq_get_status[0], base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_cmd_irq_get_dmastatus[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:int msm_jpegdma_hw_irq_get_status(void *base)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	n_irq_status = msm_jpeg_hw_read(&hw_cmd_irq_get_dmastatus[0], base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_cmd_encode_output_size[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:long msm_jpeg_hw_encode_output_size(void *base)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	encode_output_size = msm_jpeg_hw_read(&hw_cmd_encode_output_size[0],
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpeg_hw_irq_clear(uint32_t mask, uint32_t data, void *base)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd cmd_irq_clear;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(&cmd_irq_clear, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpegdma_hw_irq_clear(uint32_t mask, uint32_t data, void *base)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd cmd_irq_clear;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(&cmd_irq_clear, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_cmd_fe_ping_update[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpeg_hw_fe_buffer_update(struct msm_jpeg_hw_buf *p_input,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd *hw_cmd_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd tmp_hw_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_dma_cmd_fe_ping_update[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpegdma_hw_fe_buffer_update(struct msm_jpeg_hw_buf *p_input,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd *hw_cmd_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd tmp_hw_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_cmd_fe_start[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpeg_hw_fe_start(void *base)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(&hw_cmd_fe_start[0], base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_cmd_we_ping_update[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpeg_decode_status(void *base)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	data = msm_camera_io_r(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	data = msm_camera_io_r(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	data = msm_camera_io_r(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	data = msm_camera_io_r(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	data = msm_camera_io_r(
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpeg_hw_we_buffer_update(struct msm_jpeg_hw_buf *p_input,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd *hw_cmd_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd tmp_hw_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_dma_cmd_we_ping_update[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpegdma_hw_we_buffer_update(struct msm_jpeg_hw_buf *p_input,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd *hw_cmd_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd tmp_hw_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_cmd_fe_mmu_prefetch[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c: * msm_jpeg_hw_fe_mmu_prefetch() - writes fe min/max addrs for each plane to
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpeg_hw_fe_mmu_prefetch(struct msm_jpeg_hw_buf *buf, void *base,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd *hw_cmd_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd tmp_hw_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_cmd_we_mmu_prefetch[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c: * msm_jpeg_hw_we_mmu_prefetch() - write we min/max addrs for each plane to
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpeg_hw_we_mmu_prefetch(struct msm_jpeg_hw_buf *buf, void *base,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd *hw_cmd_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd tmp_hw_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_dma_cmd_fe_mmu_prefetch[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c: * msm_jpegdma_hw_fe_mmu_prefetch() - write DMA fe min/max addrs to
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpegdma_hw_fe_mmu_prefetch(struct msm_jpeg_hw_buf *buf, void *base)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd *hw_cmd_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd tmp_hw_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_dma_cmd_we_mmu_prefetch[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c: * msm_jpegdma_hw_we_mmu_prefetch() - write DMA we min/max addrs to
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpegdma_hw_we_mmu_prefetch(struct msm_jpeg_hw_buf *buf, void *base)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd *hw_cmd_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd tmp_hw_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(&tmp_hw_cmd, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_cmd_reset[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpeg_hw_reset(void *base, int size)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd *hw_cmd_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(hw_cmd_p, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:static struct msm_jpeg_hw_cmd hw_cmd_reset_dma[] = {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpeg_hw_reset_dma(void *base, int size)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	struct msm_jpeg_hw_cmd *hw_cmd_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(hw_cmd_p++, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_jpeg_hw_write(hw_cmd_p, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:uint32_t msm_jpeg_hw_read(struct msm_jpeg_hw_cmd *hw_cmd_p,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	data = msm_camera_io_r((void __iomem *)paddr);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpeg_hw_write(struct msm_jpeg_hw_cmd *hw_cmd_p,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		old_data = msm_camera_io_r((void __iomem *)paddr);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	msm_camera_io_w(new_data, (void __iomem *)paddr);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:int msm_jpeg_hw_wait(struct msm_jpeg_hw_cmd *hw_cmd_p, int m_us,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:	data = msm_jpeg_hw_read(hw_cmd_p, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:			data = msm_jpeg_hw_read(hw_cmd_p, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpeg_hw_delay(struct msm_jpeg_hw_cmd *hw_cmd_p, int m_us)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:int msm_jpeg_hw_exec_cmds(struct msm_jpeg_hw_cmd *hw_cmd_p, uint32_t m_cmds,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:			hw_cmd_p->data = msm_jpeg_hw_read(hw_cmd_p, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:			msm_jpeg_hw_write(hw_cmd_p, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:			data = msm_jpeg_hw_read(hw_cmd_p, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:			msm_jpeg_hw_write(hw_cmd_p, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:			msm_jpeg_hw_wait(hw_cmd_p, 1, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:			msm_jpeg_hw_wait(hw_cmd_p, 1000, base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:			msm_jpeg_hw_delay(hw_cmd_p, 1);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:			msm_jpeg_hw_delay(hw_cmd_p, 1000);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:void msm_jpeg_io_dump(void *base, int size)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.c:		data = msm_camera_io_r(p+i);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:#include <media/msm_jpeg.h>
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:#include "msm_jpeg_hw_reg.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:struct msm_jpeg_hw_buf {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:	struct msm_jpeg_buf vbuf;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:struct msm_jpeg_hw_pingpong {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:	struct  msm_jpeg_hw_buf buf[2];
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:int msm_jpeg_hw_pingpong_update(struct msm_jpeg_hw_pingpong *pingpong_hw,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:	struct msm_jpeg_hw_buf *buf, void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:int msm_jpegdma_hw_pingpong_update(struct msm_jpeg_hw_pingpong *pingpong_hw,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:	struct msm_jpeg_hw_buf *buf, void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void *msm_jpeg_hw_pingpong_irq(struct msm_jpeg_hw_pingpong *pingpong_hw);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void *msm_jpeg_hw_pingpong_active_buffer(struct msm_jpeg_hw_pingpong
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_irq_clear(uint32_t mask, uint32_t data, void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpegdma_hw_irq_clear(uint32_t mask, uint32_t data, void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:int msm_jpeg_hw_irq_get_status(void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:int msm_jpegdma_hw_irq_get_status(void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:long msm_jpeg_hw_encode_output_size(void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:#define msm_jpeg_hw_irq_is_frame_done(jpeg_irq_status) \
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:#define msm_jpeg_hw_irq_is_fe_pingpong(jpeg_irq_status) \
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:#define msm_jpeg_hw_irq_is_we_pingpong(jpeg_irq_status) \
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:#define msm_jpeg_hw_irq_is_reset_ack(jpeg_irq_status) \
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:#define msm_jpeg_hw_irq_is_err(jpeg_irq_status) \
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:#define msm_jpegdma_hw_irq_is_frame_done(jpeg_irq_status) \
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:#define msm_jpegdma_hw_irq_is_fe_pingpong(jpeg_irq_status) \
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:#define msm_jpegdma_hw_irq_is_we_pingpong(jpeg_irq_status) \
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:#define msm_jpegdma_hw_irq_is_reset_ack(jpeg_irq_status) \
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_fe_buffer_update(struct msm_jpeg_hw_buf *p_input,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_we_buffer_update(struct msm_jpeg_hw_buf *p_input,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpegdma_hw_fe_buffer_update(struct msm_jpeg_hw_buf *p_input,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpegdma_hw_we_buffer_update(struct msm_jpeg_hw_buf *p_input,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_we_buffer_cfg(uint8_t is_realtime);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_fe_mmu_prefetch(struct msm_jpeg_hw_buf *buf, void *base,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_we_mmu_prefetch(struct msm_jpeg_hw_buf *buf, void *base,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpegdma_hw_fe_mmu_prefetch(struct msm_jpeg_hw_buf *buf, void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpegdma_hw_we_mmu_prefetch(struct msm_jpeg_hw_buf *buf, void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_fe_start(void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_clk_cfg(void);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_reset(void *base, int size);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_irq_cfg(void);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:uint32_t msm_jpeg_hw_read(struct msm_jpeg_hw_cmd *hw_cmd_p, void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_write(struct msm_jpeg_hw_cmd *hw_cmd_p, void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:int msm_jpeg_hw_wait(struct msm_jpeg_hw_cmd *hw_cmd_p, int m_us, void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_delay(struct msm_jpeg_hw_cmd *hw_cmd_p, int m_us);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:int msm_jpeg_hw_exec_cmds(struct msm_jpeg_hw_cmd *hw_cmd_p,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_region_dump(int size);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_io_dump(void *base, int size);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_decode_status(void *base);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_hw.h:void msm_jpeg_hw_reset_dma(void *base, int size);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:#include <linux/msm-bus.h>
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:#include <linux/msm-bus-board.h>
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:#include "msm_jpeg_platform.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:#include "msm_jpeg_sync.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:#include "msm_jpeg_common.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:#include "msm_jpeg_hw.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:static int msm_jpeg_get_clock_index(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:int msm_jpeg_platform_set_clk_rate(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	int msm_jpeg_idx;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_jpeg_idx = msm_jpeg_get_clock_index(pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	if (msm_jpeg_idx < 0)  {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_clk_set_rate(&pgmn_dev->pdev->dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		pgmn_dev->jpeg_clk[msm_jpeg_idx], clk_rate);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:void msm_jpeg_platform_p2v(int iommu_hdl, int fd)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:uint32_t msm_jpeg_platform_v2p(struct msm_jpeg_device *pgmn_dev, int fd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:static void set_vbif_params(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_io_w(0x1,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x10101010,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x10101010,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x10101010,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x10101010,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x10101010,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x10101010,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x00001010,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x00000110,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x00000707,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x00000FFF,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x0FFF0FFF,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x2222,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_io_w(0x7,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_io_w(0x00000030,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x00000003,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		msm_camera_io_w(0x00000001,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_io_w(0x22222222,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c: * msm_jpeg_set_init_dt_parms() - get device tree config and write to registers.
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:static int32_t msm_jpeg_set_init_dt_parms(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:			msm_camera_io_w(dt_reg_settings[i + 1],
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:static int msm_jpeg_attach_iommu(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:static int msm_jpeg_detach_iommu(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:int msm_jpeg_platform_init(irqreturn_t (*handler)(int, void *),
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	struct msm_jpeg_device *pgmn_dev =
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		(struct msm_jpeg_device *) context;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	rc = msm_camera_regulator_enable(pgmn_dev->jpeg_vdd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	rc = msm_camera_clk_enable(&pgmn_dev->pdev->dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	rc = msm_jpeg_attach_iommu(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	rc = msm_jpeg_set_init_dt_parms(pgmn_dev, "qcom,vbif-reg-settings",
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	rc = msm_camera_register_irq(pgmn_dev->pdev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	pgmn_dev->hw_version = msm_camera_io_r((void __iomem *)(pgmn_dev->base +
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	rc = msm_jpeg_set_init_dt_parms(pgmn_dev, "qcom,vbif-qos-setting",
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_jpeg_detach_iommu(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_clk_enable(&pdev->dev, pgmn_dev->jpeg_clk_info,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_regulator_enable(pgmn_dev->jpeg_vdd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:int msm_jpeg_platform_setup(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	jpeg_base = msm_camera_get_reg_base(pdev, "jpeg_hw", true);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	vbif_base = msm_camera_get_reg_base(pdev, "jpeg_vbif", false);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	jpeg_irq_res = msm_camera_get_irq(pdev, "jpeg");
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	rc = msm_camera_get_clk_info(pdev, &pgmn_dev->jpeg_clk_info,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:			msm_camera_set_clk_flags(pgmn_dev->jpeg_clk[i],
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:			msm_camera_set_clk_flags(pgmn_dev->jpeg_clk[i],
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	rc = msm_camera_get_regulator_info(pdev, &pgmn_dev->jpeg_vdd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	rc = msm_camera_register_bus_client(pgmn_dev->pdev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	pgmn_dev->res_size = msm_camera_get_res_size(pdev, "jpeg_hw");
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_unregister_bus_client(pgmn_dev->bus_client);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_put_regulators(pdev, &pgmn_dev->jpeg_vdd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_put_clk_info(pdev, &pgmn_dev->jpeg_clk_info,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_put_reg_base(pdev, vbif_base, "jpeg_vbif", false);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_put_reg_base(pdev, jpeg_base, "jpeg_hw", true);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:void msm_jpeg_platform_cleanup(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_unregister_bus_client(pgmn_dev->bus_client);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_put_regulators(pgmn_dev->pdev, &pgmn_dev->jpeg_vdd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_put_clk_info(pgmn_dev->pdev, &pgmn_dev->jpeg_clk_info,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_put_reg_base(pgmn_dev->pdev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_put_reg_base(pgmn_dev->pdev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:int msm_jpeg_platform_release(void *context)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	struct msm_jpeg_device *pgmn_dev =
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		(struct msm_jpeg_device *) context;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_unregister_irq(pgmn_dev->pdev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_jpeg_detach_iommu(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:			msm_camera_update_bus_vector(pgmn_dev->bus_client, 0);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_clk_enable(&pgmn_dev->pdev->dev, pgmn_dev->jpeg_clk_info,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:	msm_camera_regulator_enable(pgmn_dev->jpeg_vdd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c: * msm_jpeg_platform_set_dt_config() - set jpeg device tree configuration.
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c: * msm_jpeg_set_init_dt_parms() for each property.
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:int msm_jpeg_platform_set_dt_config(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.c:		rc = msm_jpeg_set_init_dt_parms(pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.h:#include "msm_jpeg_sync.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.h:int msm_jpeg_platform_set_clk_rate(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.h:void msm_jpeg_platform_p2v(int iommu_hdl, int fd);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.h:uint32_t msm_jpeg_platform_v2p(struct msm_jpeg_device *pgmn_dev, int fd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.h:int msm_jpeg_platform_clk_enable(void);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.h:int msm_jpeg_platform_clk_disable(void);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.h:int msm_jpeg_platform_init(irqreturn_t (*handler)(int, void *),
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.h:int msm_jpeg_platform_release(void *context);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.h:int msm_jpeg_platform_set_dt_config(struct msm_jpeg_device *pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.h:int msm_jpeg_platform_setup(struct msm_jpeg_device *pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_platform.h:void msm_jpeg_platform_cleanup(struct msm_jpeg_device *pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:#include <media/msm_jpeg.h>
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:#include <linux/msm-bus.h>
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:#include "msm_jpeg_sync.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:#include "msm_jpeg_core.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:#include "msm_jpeg_platform.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:#include "msm_jpeg_common.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	_IOW(MSM_JPEG_IOCTL_MAGIC, 1, struct msm_jpeg_hw_cmd32)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	_IOW(MSM_JPEG_IOCTL_MAGIC, 2, struct msm_jpeg_ctrl_cmd32)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	_IOW(MSM_JPEG_IOCTL_MAGIC, 3, struct msm_jpeg_hw_cmds32)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	_IOW(MSM_JPEG_IOCTL_MAGIC, 4, struct msm_jpeg_hw_cmds32)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	_IOW(MSM_JPEG_IOCTL_MAGIC, 5, struct msm_jpeg_buf32)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	_IOW(MSM_JPEG_IOCTL_MAGIC, 6, struct msm_jpeg_buf32)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	_IOW(MSM_JPEG_IOCTL_MAGIC, 8, struct msm_jpeg_buf32)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	_IOW(MSM_JPEG_IOCTL_MAGIC, 9, struct msm_jpeg_buf32)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	_IOW(MSM_JPEG_IOCTL_MAGIC, 11, struct msm_jpeg_ctrl_cmd32)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	_IOW(MSM_JPEG_IOCTL_MAGIC, 13, struct msm_jpeg_hw_cmd32)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	_IOW(MSM_JPEG_IOCTL_MAGIC, 14, struct msm_jpeg_hw_cmds32)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:struct msm_jpeg_ctrl_cmd32 {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:struct msm_jpeg_buf32 {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:struct msm_jpeg_hw_cmd32 {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:struct msm_jpeg_hw_cmds32 {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_hw_cmd32 hw_cmd[1];
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:inline void msm_jpeg_q_init(char const *name, struct msm_jpeg_q *q_p)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:inline void *msm_jpeg_q_out(struct msm_jpeg_q *q_p)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_q_entry *q_entry_p = NULL;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		q_entry_p = list_first_entry(&q_p->q, struct msm_jpeg_q_entry,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:inline int msm_jpeg_q_in(struct msm_jpeg_q *q_p, void *data)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_q_entry *q_entry_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	q_entry_p = kmalloc(sizeof(struct msm_jpeg_q_entry), GFP_ATOMIC);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:inline int msm_jpeg_q_in_buf(struct msm_jpeg_q *q_p,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	buf_p = kmemdup(buf, sizeof(struct msm_jpeg_core_buf), GFP_ATOMIC);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_in(q_p, buf_p);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:inline int msm_jpeg_q_wait(struct msm_jpeg_q *q_p)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:inline int msm_jpeg_q_wakeup(struct msm_jpeg_q *q_p)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:inline int msm_jpeg_q_unblock(struct msm_jpeg_q *q_p)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:inline void msm_jpeg_outbuf_q_cleanup(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_q *q_p)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		buf_p = msm_jpeg_q_out(q_p);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:			msm_jpeg_platform_p2v(pgmn_dev->iommu_hdl,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:inline void msm_jpeg_q_cleanup(struct msm_jpeg_q *q_p)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		data = msm_jpeg_q_out(q_p);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_framedone_irq(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_in)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_q_in_buf(&pgmn_dev->evt_q, buf_in);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_q_wakeup(&pgmn_dev->evt_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_evt_get(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_ctrl_cmd ctrl_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_wait(&pgmn_dev->evt_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	buf_p = msm_jpeg_q_out(&pgmn_dev->evt_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		msm_camera_update_bus_vector(pgmn_dev->bus_client, 0);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_evt_get_unblock(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_unblock(&pgmn_dev->evt_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static void msm_jpeg_reset_ack_irq(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static void msm_jpeg_err_irq(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf buf;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	rc = msm_jpeg_q_in_buf(&pgmn_dev->evt_q, &buf);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_q_wakeup(&pgmn_dev->evt_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_we_pingpong_irq(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_in)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_out;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_q_in_buf(&pgmn_dev->output_rtn_q, buf_in);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	buf_out = msm_jpeg_q_out(&pgmn_dev->output_buf_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_core_we_buf_update(pgmn_dev, buf_out);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		msm_jpeg_core_we_buf_reset(pgmn_dev, buf_in);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_q_wakeup(&pgmn_dev->output_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_output_get(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_buf buf_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_wait(&pgmn_dev->output_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	buf_p = msm_jpeg_q_out(&pgmn_dev->output_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_platform_p2v(pgmn_dev->iommu_hdl, buf_p->ion_fd);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_output_get_unblock(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_unblock(&pgmn_dev->output_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static inline int msm_jpeg_add_u32_check(uint32_t *p, uint32_t n, uint32_t *res)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_output_buf_enqueue(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_buf buf_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	memset(&buf_cmd, 0x0, sizeof(struct msm_jpeg_buf));
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	if (copy_from_user(&buf_cmd, arg, sizeof(struct msm_jpeg_buf))) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	if (msm_jpeg_add_u32_check(buf_len_params, n, &total_len) < 0) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	buf_p = kmalloc(sizeof(struct msm_jpeg_core_buf), GFP_ATOMIC);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	buf_p->y_buffer_addr = msm_jpeg_platform_v2p(pgmn_dev, buf_cmd.fd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_in(&pgmn_dev->output_buf_q, buf_p);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_fe_pingpong_irq(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_in)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_out;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_q_in_buf(&pgmn_dev->input_rtn_q, buf_in);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	buf_out = msm_jpeg_q_out(&pgmn_dev->input_buf_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_core_fe_buf_update(pgmn_dev, buf_out);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		msm_jpeg_core_fe_start(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_q_wakeup(&pgmn_dev->input_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_input_get(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_buf buf_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_wait(&pgmn_dev->input_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	buf_p = msm_jpeg_q_out(&pgmn_dev->input_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_platform_p2v(pgmn_dev->iommu_hdl, buf_p->ion_fd);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_input_get_unblock(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_unblock(&pgmn_dev->input_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_input_buf_enqueue(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_buf buf_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	memset(&buf_cmd, 0x0, sizeof(struct msm_jpeg_buf));
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	if (copy_from_user(&buf_cmd, arg, sizeof(struct msm_jpeg_buf))) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	if (msm_jpeg_add_u32_check(buf_len_params, n, &total_len) < 0) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	buf_p = kmalloc(sizeof(struct msm_jpeg_core_buf), GFP_ATOMIC);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	buf_p->y_buffer_addr = msm_jpeg_platform_v2p(pgmn_dev, buf_cmd.fd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_in(&pgmn_dev->input_buf_q, buf_p);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_irq(int event, void *context, void *data)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_device *pgmn_dev =
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		(struct msm_jpeg_device *) context;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		msm_jpeg_framedone_irq(pgmn_dev, data);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		msm_jpeg_we_pingpong_irq(pgmn_dev, data);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		msm_jpeg_fe_pingpong_irq(pgmn_dev, data);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		msm_jpeg_we_pingpong_irq(pgmn_dev, data);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		msm_jpeg_reset_ack_irq(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		msm_jpeg_err_irq(pgmn_dev, event);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:int __msm_jpeg_open(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_core_irq_install(msm_jpeg_irq);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		core_irq = msm_jpeg_core_irq;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		core_irq = msm_jpegdma_core_irq;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	rc = msm_jpeg_platform_init(core_irq, pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_cleanup(&pgmn_dev->evt_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_cleanup(&pgmn_dev->output_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_outbuf_q_cleanup(pgmn_dev, &pgmn_dev->output_buf_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_cleanup(&pgmn_dev->input_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_cleanup(&pgmn_dev->input_buf_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_core_init(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:int __msm_jpeg_release(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_core_release(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_cleanup(&pgmn_dev->evt_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_cleanup(&pgmn_dev->output_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_outbuf_q_cleanup(pgmn_dev, &pgmn_dev->output_buf_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_cleanup(&pgmn_dev->input_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_outbuf_q_cleanup(pgmn_dev, &pgmn_dev->input_buf_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_platform_release(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_ioctl_hw_cmd(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_hw_cmd hw_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		sizeof(struct msm_jpeg_hw_cmd))) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		is_copy_to_user = msm_jpeg_hw_exec_cmds(&hw_cmd, 1,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_ioctl_hw_cmds(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_hw_cmds *hw_cmds_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_hw_cmd *hw_cmd_p;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	if ((m == 0) || (m > ((UINT32_MAX - sizeof(struct msm_jpeg_hw_cmds)) /
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		sizeof(struct msm_jpeg_hw_cmd)))) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	len = sizeof(struct msm_jpeg_hw_cmds) +
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		sizeof(struct msm_jpeg_hw_cmd) * (m - 1);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	hw_cmd_p = (struct msm_jpeg_hw_cmd *) &(hw_cmds_p->hw_cmd);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	is_copy_to_user = msm_jpeg_hw_exec_cmds(hw_cmd_p, m,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_start(struct msm_jpeg_device *pgmn_dev, void __user *arg,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	int (*hw_ioctl)(struct msm_jpeg_device *, void __user *))
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_out;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_core_buf *buf_out_free[2] = {NULL, NULL};
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_platform_set_dt_config(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_camera_update_bus_vector(pgmn_dev->bus_client, 1);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		buf_out = msm_jpeg_q_out(&pgmn_dev->input_buf_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:			msm_jpeg_core_fe_buf_update(pgmn_dev, buf_out);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		buf_out_free[i] = msm_jpeg_q_out(&pgmn_dev->output_buf_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:			msm_jpeg_core_we_buf_update(pgmn_dev, buf_out_free[i]);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_ioctl_reset(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_ctrl_cmd ctrl_cmd, *p_ctrl_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_core_reset(pgmn_dev, pgmn_dev->op_mode,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_ioctl_test_dump_region(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_io_dump(pgmn_dev->base, JPEG_REG_SIZE);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_ioctl_set_clk_rate(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	rc = msm_jpeg_platform_set_clk_rate(pgmn_dev, clk_rate);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_get_ctrl_cmd32(struct msm_jpeg_ctrl_cmd *ctrl_cmd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_ctrl_cmd32 ctrl_cmd32;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		sizeof(struct msm_jpeg_ctrl_cmd32))) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_put_ctrl_cmd32(struct msm_jpeg_ctrl_cmd *ctrl_cmd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_ctrl_cmd32 ctrl_cmd32;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		sizeof(struct msm_jpeg_ctrl_cmd32))) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_get_jpeg_buf32(struct msm_jpeg_buf *jpeg_buf,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_buf32 jpeg_buf32;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	if (copy_from_user(&jpeg_buf32, arg, sizeof(struct msm_jpeg_buf32))) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_put_jpeg_buf32(struct msm_jpeg_buf *jpeg_buf,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_buf32 jpeg_buf32;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	if (copy_to_user(arg, &jpeg_buf32, sizeof(struct msm_jpeg_buf32))) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_put_hw_cmd32(void __user *arg,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_hw_cmd *phw_cmd, int copy)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_hw_cmd32 hw_cmd32;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_hw_cmd32 *phw_cmd32;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	phw_cmd32 = (struct msm_jpeg_hw_cmd32 *) arg;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_get_hw_cmd32(struct msm_jpeg_hw_cmd *phw_cmd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_hw_cmd32 hw_cmd32;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_hw_cmd32 *phw_cmd32;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		phw_cmd32 = (struct msm_jpeg_hw_cmd32 *) arg;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_ioctl_hw_cmds32(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_hw_cmds32 *phw_cmds32;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_hw_cmds   *phw_cmds;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	if ((m == 0) || (m > ((UINT32_MAX - sizeof(struct msm_jpeg_hw_cmds32)) /
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:			sizeof(struct msm_jpeg_hw_cmd32)))) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	len32 = sizeof(struct msm_jpeg_hw_cmds32) +
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:			sizeof(struct msm_jpeg_hw_cmd32) * (m - 1);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	len = sizeof(struct msm_jpeg_hw_cmds) +
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:			sizeof(struct msm_jpeg_hw_cmd) * (m - 1);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		struct msm_jpeg_hw_cmd32 *src;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		struct msm_jpeg_hw_cmd *dst;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		msm_jpeg_get_hw_cmd32(dst, (void __user *)src, 0);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	is_copy_to_user = msm_jpeg_hw_exec_cmds(phw_cmds->hw_cmd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:			struct msm_jpeg_hw_cmd *src;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:			struct msm_jpeg_hw_cmd32 *dst;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:			msm_jpeg_put_hw_cmd32((void __user *)dst, src, 0);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static int msm_jpeg_ioctl_hw_cmd32(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_hw_cmd hw_cmd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	if (msm_jpeg_get_hw_cmd32(&hw_cmd, (void __user *)arg, 1)) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	is_copy_to_user = msm_jpeg_hw_exec_cmds(&hw_cmd, 1,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		if (msm_jpeg_put_hw_cmd32((void __user *)arg, &hw_cmd, 1)) {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:long __msm_jpeg_compat_ioctl(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_ctrl_cmd *pctrl_cmd = NULL, ctrl_cmd = {0};
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_buf jpeg_buf = {0};
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_hw_cmd(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_hw_cmd32(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_reset(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_get_ctrl_cmd32(&ctrl_cmd,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_reset(pgmn_dev, (void __user *) &ctrl_cmd);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_hw_cmds(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_hw_cmds32(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_start(pgmn_dev, (void __user *) arg,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:			msm_jpeg_ioctl_hw_cmds);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_start(pgmn_dev, (void __user *) arg,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:				msm_jpeg_ioctl_hw_cmds32);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_input_buf_enqueue(pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_get_jpeg_buf32(&jpeg_buf, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_input_buf_enqueue(pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_input_get(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_input_get(pgmn_dev, (void __user *) &jpeg_buf);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_put_jpeg_buf32(&jpeg_buf, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_input_get_unblock(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_output_buf_enqueue(pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_get_jpeg_buf32(&jpeg_buf, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_output_buf_enqueue(pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_output_get(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_output_get(pgmn_dev, (void __user *) &jpeg_buf);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_put_jpeg_buf32(&jpeg_buf, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_output_get_unblock(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_evt_get(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_evt_get(pgmn_dev, (void __user *) &ctrl_cmd);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		msm_jpeg_put_ctrl_cmd32(&ctrl_cmd, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_evt_get_unblock(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_hw_cmd32(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_hw_cmd(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_hw_cmds32(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_hw_cmds(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_test_dump_region(pgmn_dev, arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_test_dump_region(pgmn_dev, arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_set_clk_rate(pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:long __msm_jpeg_compat_ioctl(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:long __msm_jpeg_ioctl(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_hw_cmd(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_reset(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_hw_cmds(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_start(pgmn_dev, (void __user *) arg,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:			msm_jpeg_ioctl_hw_cmds);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_input_buf_enqueue(pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_input_get(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_input_get_unblock(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_output_buf_enqueue(pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_output_get(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_output_get_unblock(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_evt_get(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_evt_get_unblock(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_hw_cmd(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_hw_cmds(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_test_dump_region(pgmn_dev, arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:		rc = msm_jpeg_ioctl_set_clk_rate(pgmn_dev, (void __user *) arg);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:static void msm_jpeg_iommu_fault_handler (struct iommu_domain *domain,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	struct msm_jpeg_device *pgmn_dev;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:int __msm_jpeg_init(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_init("evt_q", &pgmn_dev->evt_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_init("output_rtn_q", &pgmn_dev->output_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_init("output_buf_q", &pgmn_dev->output_buf_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_init("input_rtn_q", &pgmn_dev->input_rtn_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_q_init("input_buf_q", &pgmn_dev->input_buf_q);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:			msm_jpeg_iommu_fault_handler,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	rc = msm_jpeg_platform_setup(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:int __msm_jpeg_exit(struct msm_jpeg_device *pgmn_dev)
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.c:	msm_jpeg_platform_cleanup(pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:#include "msm_jpeg_hw.h"
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:enum msm_jpeg_state {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:enum msm_jpeg_core_type {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:struct msm_jpeg_q {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:struct msm_jpeg_q_entry {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:struct msm_jpeg_device {
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:	struct msm_cam_clk_info *jpeg_clk_info;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:	struct msm_cam_regulator *jpeg_vdd;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:	struct msm_jpeg_q evt_q;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:	struct msm_jpeg_q output_rtn_q;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:	struct msm_jpeg_q output_buf_q;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:	struct msm_jpeg_q input_rtn_q;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:	struct msm_jpeg_q input_buf_q;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:	struct class *msm_jpeg_class;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:	dev_t msm_jpeg_devno;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:	struct msm_jpeg_hw_pingpong fe_pingpong_buf;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:	struct msm_jpeg_hw_pingpong we_pingpong_buf;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:	enum msm_jpeg_state state;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:	enum msm_jpeg_core_type core_type;
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:int __msm_jpeg_open(struct msm_jpeg_device *pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:int __msm_jpeg_release(struct msm_jpeg_device *pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:long __msm_jpeg_ioctl(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:long __msm_jpeg_compat_ioctl(struct msm_jpeg_device *pgmn_dev,
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:int __msm_jpeg_init(struct msm_jpeg_device *pgmn_dev);
media/platform/msm/camera_v2/jpeg_10/msm_jpeg_sync.h:int __msm_jpeg_exit(struct msm_jpeg_device *pgmn_dev);
media/platform/msm/camera_v2/jpeg_dma/Makefile:ccflags-y += -Idrivers/media/video/msm
media/platform/msm/camera_v2/jpeg_dma/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/jpeg_dma/Makefile:obj-$(CONFIG_MSM_JPEGDMA) += msm_jpeg_dma_dev.o msm_jpeg_dma_hw.o
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:#include <linux/msm_ion.h>
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:#include <media/msm_jpeg_dma.h>
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:#include "msm_jpeg_dma_dev.h"
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:#include "msm_jpeg_dma_hw.h"
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:#define MSM_JPEGDMA_DRV_NAME "msm_jpegdma"
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static struct msm_jpegdma_format formats[] = {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_ctx_from_fh - Get dma context from v4l2 fh.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static inline struct jpegdma_ctx *msm_jpegdma_ctx_from_fh(struct v4l2_fh *fh)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_get_next_config_idx - get next configuration index.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static inline int msm_jpegdma_get_next_config_idx(struct jpegdma_ctx *ctx)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_schedule_next_config - Schedule next configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static inline void msm_jpegdma_schedule_next_config(struct jpegdma_ctx *ctx)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_cast_long_to_buff_ptr - Cast long to buffer pointer.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static inline void msm_jpegdma_cast_long_to_buff_ptr(unsigned long vaddr,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpeg_dma_buff __user **buff_ptr_head)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	*buff_ptr_head = (struct msm_jpeg_dma_buff *) vaddr;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_get_format_idx - Get jpeg dma format lookup index.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_get_format_idx(struct jpegdma_ctx *ctx,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_fill_size_from_ctx - Fill jpeg dma format lookup index.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static void msm_jpegdma_fill_size_from_ctx(struct jpegdma_ctx *ctx,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpegdma_size_config *size)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_align_format - Align jpeg dma format.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static void msm_jpegdma_align_format(struct v4l2_format *f, int format_idx)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_config_ok - Check if jpeg dma format is ok for processing.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_config_ok(struct jpegdma_ctx *ctx)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpegdma_size_config size;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	cap_idx = msm_jpegdma_get_format_idx(ctx, &ctx->format_cap);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	out_idx = msm_jpegdma_get_format_idx(ctx, &ctx->format_out);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_fill_size_from_ctx(ctx, &size);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	ret = msm_jpegdma_hw_check_config(ctx->jdma_device, &size);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_update_hw_config - Update dma hw configuration/
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_update_hw_config(struct jpegdma_ctx *ctx)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpegdma_size_config size;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	if (msm_jpegdma_config_ok(ctx)) {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		msm_jpegdma_fill_size_from_ctx(ctx, &size);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		idx = msm_jpegdma_get_next_config_idx(ctx);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		ret = msm_jpegdma_hw_set_config(ctx->jdma_device,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_queue_setup - vb2_ops queue_setup callback.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_queue_setup(struct vb2_queue *q,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_buf_queue - vb2_ops buf_queue callback.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static void msm_jpegdma_buf_queue(struct vb2_buffer *vb)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_start_streaming - vb2_ops start_streaming callback.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_start_streaming(struct vb2_queue *q, unsigned int count)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	ret = msm_jpegdma_hw_get(ctx->jdma_device);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		ret =  msm_jpegdma_update_hw_config(ctx);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_stop_streaming - vb2_ops stop_streaming callback.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static void msm_jpegdma_stop_streaming(struct vb2_queue *q)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		msm_jpegdma_hw_put(ctx->jdma_device);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static struct vb2_ops msm_jpegdma_vb2_q_ops = {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.queue_setup     = msm_jpegdma_queue_setup,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.buf_queue       = msm_jpegdma_buf_queue,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.start_streaming = msm_jpegdma_start_streaming,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.stop_streaming  = msm_jpegdma_stop_streaming,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_get_userptr - Map and get buffer handler for user pointer buffer.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static void *msm_jpegdma_get_userptr(struct device *alloc_ctx,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpegdma_device *dma = (void *)alloc_ctx;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpegdma_buf_handle *buf;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpeg_dma_buff __user *up_buff;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpeg_dma_buff kp_buff;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_cast_long_to_buff_ptr(vaddr, &up_buff);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		sizeof(struct msm_jpeg_dma_buff)) ||
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		sizeof(struct msm_jpeg_dma_buff)) ||
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	ret = msm_jpegdma_hw_map_buffer(dma, kp_buff.fd, buf);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_put_userptr - Unmap and free buffer handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static void msm_jpegdma_put_userptr(void *buf_priv)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_hw_unmap_buffer(buf_priv);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static struct vb2_mem_ops msm_jpegdma_vb2_mem_ops = {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.get_userptr = msm_jpegdma_get_userptr,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.put_userptr = msm_jpegdma_put_userptr,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_queue_init - m2m_ops queue_setup callback.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_queue_init(void *priv, struct vb2_queue *src_vq,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	src_vq->mem_ops = &msm_jpegdma_vb2_mem_ops;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	src_vq->ops = &msm_jpegdma_vb2_q_ops;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	dst_vq->mem_ops = &msm_jpegdma_vb2_mem_ops;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	dst_vq->ops = &msm_jpegdma_vb2_q_ops;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_open - Fd device open method.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_open(struct file *file)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpegdma_device *device = video_drvdata(file);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		ctx, msm_jpegdma_queue_init);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_release - Fd device release method.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_release(struct file *file)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(file->private_data);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		msm_jpegdma_hw_put(ctx->jdma_device);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_poll - Fd device pool method.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static unsigned int msm_jpegdma_poll(struct file *file,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(file->private_data);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.open           = msm_jpegdma_open,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.release        = msm_jpegdma_release,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.poll           = msm_jpegdma_poll,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_querycap - V4l2 ioctl query capability handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_querycap(struct file *file,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_enum_fmt_vid_cap - V4l2 ioctl enumerate output format handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_enum_fmt_vid_cap(struct file *file,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_enum_fmt_vid_out - V4l2 ioctl enumerate capture format handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_enum_fmt_vid_out(struct file *file,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_g_fmt_cap - V4l2 ioctl get capture format handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_g_fmt_cap(struct file *file, void *fh,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_g_fmt_out - V4l2 ioctl get output format handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_g_fmt_out(struct file *file, void *fh,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_try_fmt_vid_cap - V4l2 ioctl try capture format handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_try_fmt_vid_cap(struct file *file,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_align_format(f, ctx->format_idx);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_try_fmt_vid_out - V4l2 ioctl try output format handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_try_fmt_vid_out(struct file *file,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_align_format(f, ctx->format_idx);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_s_fmt_vid_cap - V4l2 ioctl set capture format handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_s_fmt_vid_cap(struct file *file,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	ret = msm_jpegdma_get_format_idx(ctx, f);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_align_format(f, ctx->format_idx);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_s_fmt_vid_out - V4l2 ioctl set output format handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_s_fmt_vid_out(struct file *file,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	ret = msm_jpegdma_get_format_idx(ctx, f);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_align_format(f, ctx->format_idx);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_reqbufs - V4l2 ioctl request buffers handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_reqbufs(struct file *file,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_qbuf - V4l2 ioctl queue buffer handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_qbuf(struct file *file, void *fh,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpeg_dma_buff __user *up_buff;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpeg_dma_buff kp_buff;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_cast_long_to_buff_ptr(buf->m.userptr, &up_buff);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		sizeof(struct msm_jpeg_dma_buff)) ||
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		sizeof(struct msm_jpeg_dma_buff)) ||
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		ret = msm_jpegdma_update_hw_config(ctx);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_dqbuf - V4l2 ioctl dequeue buffer handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_dqbuf(struct file *file,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_streamon - V4l2 ioctl stream on handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_streamon(struct file *file,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	if (!msm_jpegdma_config_ok(ctx)) {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_streamoff - V4l2 ioctl stream off handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_streamoff(struct file *file,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_cropcap - V4l2 ioctl crop capabilities.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_cropcap(struct file *file, void *fh,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_g_crop - V4l2 ioctl get crop.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_g_crop(struct file *file, void *fh,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_s_crop - V4l2 ioctl set crop.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_s_crop(struct file *file, void *fh,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		ret = msm_jpegdma_update_hw_config(ctx);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_g_crop - V4l2 ioctl get parm.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_g_parm(struct file *file, void *fh,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_s_crop - V4l2 ioctl set parm.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_s_parm(struct file *file, void *fh,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_fd_g_ctrl - V4l2 ioctl get control.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_g_ctrl(struct file *file, void *fh,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		a->value = msm_jpegdma_hw_get_max_downscale(ctx->jdma_device);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_querycap          = msm_jpegdma_querycap,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_enum_fmt_vid_out  = msm_jpegdma_enum_fmt_vid_out,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_enum_fmt_vid_cap  = msm_jpegdma_enum_fmt_vid_cap,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_g_fmt_vid_out     = msm_jpegdma_g_fmt_out,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_g_fmt_vid_cap     = msm_jpegdma_g_fmt_cap,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_try_fmt_vid_out   = msm_jpegdma_try_fmt_vid_out,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_try_fmt_vid_cap   = msm_jpegdma_try_fmt_vid_cap,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_s_fmt_vid_out     = msm_jpegdma_s_fmt_vid_out,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_s_fmt_vid_cap     = msm_jpegdma_s_fmt_vid_cap,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_reqbufs           = msm_jpegdma_reqbufs,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_qbuf              = msm_jpegdma_qbuf,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_dqbuf             = msm_jpegdma_dqbuf,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_streamon          = msm_jpegdma_streamon,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_streamoff         = msm_jpegdma_streamoff,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_cropcap           = msm_jpegdma_cropcap,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_g_crop            = msm_jpegdma_g_crop,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_s_crop            = msm_jpegdma_s_crop,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_g_parm            = msm_jpegdma_g_parm,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_s_parm            = msm_jpegdma_s_parm,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.vidioc_g_ctrl            = msm_jpegdma_g_ctrl,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_process_buffers - Start dma processing.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static void msm_jpegdma_process_buffers(struct jpegdma_ctx *ctx,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpegdma_buf_handle *buf_handle;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpegdma_addr addr;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_hw_start(ctx->jdma_device, &addr,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_device_run - Dma device run.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static void msm_jpegdma_device_run(void *priv)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		msm_jpegdma_schedule_next_config(ctx);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_process_buffers(ctx, src_buf, dst_buf);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_job_abort - Dma abort job.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static void msm_jpegdma_job_abort(void *priv)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_hw_abort(ctx->jdma_device);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_job_ready - Dma check if job is ready
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int msm_jpegdma_job_ready(void *priv)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static struct v4l2_m2m_ops msm_jpegdma_m2m_ops = {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.device_run = msm_jpegdma_device_run,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.job_abort = msm_jpegdma_job_abort,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	.job_ready = msm_jpegdma_job_ready,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c: * msm_jpegdma_isr_processing_done - Invoked by dma_hw when processing is done.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:void msm_jpegdma_isr_processing_done(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:			msm_jpegdma_process_buffers(ctx, src_buf, dst_buf);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpegdma_device *jpegdma;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	jpegdma = kzalloc(sizeof(struct msm_jpegdma_device), GFP_KERNEL);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	ret = msm_jpegdma_hw_get_mem_resources(pdev, jpegdma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	ret = msm_camera_get_regulator_info(pdev, &jpegdma->dma_vdd,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	ret = msm_camera_get_clk_info(pdev, &jpegdma->jpeg_clk_info,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:			msm_camera_set_clk_flags(jpegdma->clk[i],
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:			msm_camera_set_clk_flags(jpegdma->clk[i],
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	ret = msm_jpegdma_hw_get_qos(jpegdma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	ret = msm_jpegdma_hw_get_vbif(jpegdma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	ret = msm_jpegdma_hw_get_prefetch(jpegdma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	jpegdma->irq = msm_camera_get_irq(pdev, "jpeg");
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	ret = msm_camera_register_bus_client(pdev,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	ret = msm_jpegdma_hw_get_capabilities(jpegdma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	jpegdma->m2m_dev = v4l2_m2m_init(&msm_jpegdma_m2m_ops);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_camera_unregister_bus_client(jpegdma->bus_client);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_hw_put_prefetch(jpegdma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_hw_put_vbif(jpegdma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_hw_put_qos(jpegdma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_camera_put_clk_info(pdev, &jpegdma->jpeg_clk_info,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_camera_put_regulators(pdev, &jpegdma->dma_vdd,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_hw_release_mem_resources(jpegdma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	struct msm_jpegdma_device *dma;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_camera_unregister_bus_client(dma->bus_client);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_camera_put_regulators(dma->pdev, &dma->dma_vdd,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_camera_put_clk_info(dma->pdev, &dma->jpeg_clk_info,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:	msm_jpegdma_hw_release_mem_resources(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static const struct of_device_id msm_jpegdma_dt_match[] = {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:		.of_match_table = msm_jpegdma_dt_match,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static int __init msm_jpegdma_init_module(void)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:static void __exit msm_jpegdma_exit_module(void)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:module_init(msm_jpegdma_init_module);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c:module_exit(msm_jpegdma_exit_module);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:#include <linux/msm-bus.h>
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * enum msm_jpegdma_plane_type - Dma format.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:enum msm_jpegdma_plane_type {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * struct msm_jpegdma_format - Dma format.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:struct msm_jpegdma_format {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	enum msm_jpegdma_plane_type planes[MSM_JPEGDMA_MAX_PLANES];
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * struct msm_jpegdma_size - Dma size.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:struct msm_jpegdma_size {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * struct msm_jpegdma_size_config - Dma engine size configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:struct msm_jpegdma_size_config {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_jpegdma_size in_size;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_jpegdma_size out_size;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_jpegdma_format format;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * struct msm_jpegdma_block - Dma hw block.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:struct msm_jpegdma_block {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * struct msm_jpegdma_block_config - Dma hw block configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:struct msm_jpegdma_block_config {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_jpegdma_block block;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * msm_jpegdma_scale - Dma hw scale configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:struct msm_jpegdma_scale {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * struct msm_jpegdma_config - Dma hw configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:struct msm_jpegdma_config {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_jpegdma_size_config size_cfg;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_jpegdma_scale scale_cfg;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_jpegdma_block_config block_cfg;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * struct msm_jpegdma_plane_config - Contain input output address.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:struct msm_jpegdma_speed {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * struct msm_jpegdma_plane_config - Contain input output address.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:struct msm_jpegdma_plane {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_jpegdma_config config[MSM_JPEGDMA_MAX_PIPES];
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	enum msm_jpegdma_plane_type type;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * struct msm_jpegdma_plane_config - Contain input output address.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:struct msm_jpegdma_plane_config {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_jpegdma_plane plane[MSM_JPEGDMA_MAX_PLANES];
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_jpegdma_speed speed;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * struct msm_jpegdma_addr - Contain input output address.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:struct msm_jpegdma_addr {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * struct msm_jpegdma_buf_handle - Structure contain dma buffer information.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:struct msm_jpegdma_buf_handle {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_jpegdma_device *dma;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_jpegdma_device *jdma_device;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_jpegdma_plane_config plane_config[MSM_JPEGDMA_MAX_CONFIGS];
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * enum msm_jpegdma_mem_resources - jpegdma device iomem resources.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:enum msm_jpegdma_mem_resources {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h: * struct msm_jpegdma_device - FD device structure.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:struct msm_jpegdma_device {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_cam_regulator *dma_vdd;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_cam_clk_info *jpeg_clk_info;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_bus_vectors bus_vectors;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_bus_paths bus_paths;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:	struct msm_bus_scale_pdata bus_scale_data;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.h:void msm_jpegdma_isr_processing_done(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:#include <linux/msm_ion.h>
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:#include <linux/msm-bus.h>
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:#include <linux/msm-bus-board.h>
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:#include "msm_jpeg_dma_dev.h"
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:#include "msm_jpeg_dma_hw.h"
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:#include "msm_jpeg_dma_regs.h"
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:#define MSM_JPEGDMA_BUS_CLIENT_NAME "msm_jpeg_dma"
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static const struct msm_jpegdma_block msm_jpegdma_block_sel[] = {
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_read_reg - dma read from register.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static inline u32 msm_jpegdma_hw_read_reg(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	enum msm_jpegdma_mem_resources base_idx, u32 reg)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	return msm_camera_io_r(dma->iomem_base[base_idx] + reg);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_write_reg - dma write to register.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static inline void msm_jpegdma_hw_write_reg(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	enum msm_jpegdma_mem_resources base_idx, u32 reg, u32 value)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_camera_io_w(value, dma->iomem_base[base_idx] + reg);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_enable_irq - Enable dma interrupts.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static void msm_jpegdma_hw_enable_irq(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_disable_irq - Disable dma interrupts.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static void msm_jpegdma_hw_disable_irq(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_clear_irq - Clear dma interrupts.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static void msm_jpegdma_hw_clear_irq(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_get_irq_status - Get dma irq status
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static u32 msm_jpegdma_hw_get_irq_status(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	return msm_jpegdma_hw_read_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_get_num_pipes - Get number of dma pipes
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_get_num_pipes(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	reg = msm_jpegdma_hw_read_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_get_clock_index - Get clock index by name
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_get_clock_index(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_reset - Reset jpeg dma core.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_reset(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_halt - Halt jpeg dma core.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_halt(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_run - Enable dma processing.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_run(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_core_config - Set jpeg dma core configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_core_config(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_fe_0_block - Fetch engine 0 block configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_fe_0_block(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_block_config *block_config,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	enum msm_jpegdma_plane_type plane_type)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_fe_1_block - Fetch engine 1 block configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_fe_1_block(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_block_config *block_config,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	enum msm_jpegdma_plane_type plane_type)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_fe_0_phase - Fetch engine 0 phase configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_fe_0_phase(struct msm_jpegdma_device *dma, int phase)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_fe_1_phase - Fetch engine 1 phase configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_fe_1_phase(struct msm_jpegdma_device *dma, int phase)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_fe_0_size - Fetch engine 0 size configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_fe_0_size(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_size *size, enum msm_jpegdma_plane_type plane_type)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_fe_1_size - Fetch engine 1 size configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_fe_1_size(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_size *size, enum msm_jpegdma_plane_type plane_type)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_fe_0_addr - Set fetch engine 0 address.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_fe_0_addr(struct msm_jpegdma_device *dma, u32 addr)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_fe_1_addr - Set fetch engine 1 address.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_fe_1_addr(struct msm_jpegdma_device *dma, u32 addr)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_fe_0_block - Write engine 0 block configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_we_0_block(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_block_config *block,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	enum msm_jpegdma_plane_type plane_type)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_we_1_block - Write engine 1 block configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_we_1_block(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_block_config *block,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	enum msm_jpegdma_plane_type plane_type)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_we_0_size - Write engine 0 size configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_we_0_size(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_size *size)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_we_1_size - Write engine 1 size configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_we_1_size(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_size *size)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_we_0_addr - Set write engine 0 address.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_we_0_addr(struct msm_jpegdma_device *dma, u32 addr)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_we_1_addr - Set write engine 1 address.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_we_1_addr(struct msm_jpegdma_device *dma, u32 addr)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_scale_0_config - Scale configuration for 0 pipeline.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_scale_0_config(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_scale *scale)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_scale_1_config - Scale configuration for 1 pipeline.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_scale_1_config(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_scale *scale)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_config_qos - Configure qos registers.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static void msm_jpegdma_hw_config_qos(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_config_vbif - Configure and vbif interface.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static void msm_jpegdma_hw_config_vbif(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_VBIF,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_config_mmu_prefetch - Configure mmu prefetch registers.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static void msm_jpegdma_hw_config_mmu_prefetch(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_addr *min_addr,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_addr *max_addr)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_VBIF,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_write_reg(dma, MSM_JPEGDMA_IOMEM_CORE,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_calc_speed - Calculate speed based on framerate and size.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_calc_speed(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_size_config *size,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_speed *speed)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	core_clk_idx = msm_jpegdma_hw_get_clock_index(dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_set_speed - Configure clock and bus bandwidth based on
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_set_speed(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_size_config *size,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_speed *speed)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_speed new_sp;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_size_config new_size;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		ret = msm_jpegdma_hw_calc_speed(dma, &new_size, &new_sp);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	core_clk_idx = msm_jpegdma_hw_get_clock_index(dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	ret = msm_bus_scale_client_update_request(dma->bus_client, 0);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_add_plane_offset - Add plane offset to all pipelines.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_add_plane_offset(struct msm_jpegdma_plane *plane,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_calc_config - Calculate plane configuration.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_calc_config(struct msm_jpegdma_size_config *size_cfg,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_plane *plane)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_config *config;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	for (i = 0; ARRAY_SIZE(msm_jpegdma_block_sel); i++)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		if (scale_hor <= msm_jpegdma_block_sel[i].div)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	if (i == ARRAY_SIZE(msm_jpegdma_block_sel))
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	config->block_cfg.block = msm_jpegdma_block_sel[i];
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_check_config - Check configuration based on size is possible.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:int msm_jpegdma_hw_check_config(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_size_config *size_cfg)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_set_config - Set dma configuration based on size.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:int msm_jpegdma_hw_set_config(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_size_config *size_cfg,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_plane_config *plane_cfg)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_size_config plane_size;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	ret = msm_jpegdma_hw_calc_speed(dma, size_cfg, &plane_cfg->speed);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_calc_config(size_cfg, &plane_cfg->plane[0]);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_add_plane_offset(&plane_cfg->plane[0],
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_calc_config(&plane_size,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_add_plane_offset(&plane_cfg->plane[i],
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_start - Start dma processing.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:int msm_jpegdma_hw_start(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_addr *addr,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_plane *plane,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_speed *speed)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_config *cfg;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_addr prefetch_max_addr;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	ret = msm_jpegdma_hw_set_speed(dma, &plane->config[0].size_cfg, speed);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_core_config(dma, plane->active_pipes,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_scale_0_config(dma, &cfg->scale_cfg);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_fe_0_block(dma, &cfg->block_cfg, plane->type);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_fe_0_phase(dma, cfg->phase);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_fe_0_size(dma, &cfg->size_cfg.in_size, plane->type);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_fe_0_addr(dma, addr->in_addr + cfg->in_offset);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_we_0_block(dma, &cfg->block_cfg, plane->type);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_we_0_size(dma, &cfg->size_cfg.out_size);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_we_0_addr(dma, addr->out_addr + cfg->out_offset);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_scale_1_config(dma, &cfg->scale_cfg);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_fe_1_block(dma, &cfg->block_cfg, plane->type);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_fe_1_phase(dma, cfg->phase);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_fe_1_size(dma, &cfg->size_cfg.in_size,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_fe_1_addr(dma, addr->in_addr + cfg->in_offset);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_we_1_block(dma, &cfg->block_cfg, plane->type);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_we_1_size(dma, &cfg->size_cfg.out_size);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_we_1_addr(dma, addr->out_addr + cfg->out_offset);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_config_mmu_prefetch(dma, addr,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_run(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_abort - abort dma processing.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:int msm_jpegdma_hw_abort(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	ret = msm_jpegdma_hw_halt(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	ret = msm_jpegdma_hw_reset(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_irq - Dma irq handler.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static irqreturn_t msm_jpegdma_hw_irq(int irq, void *dev_id)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_device *dma = dev_id;
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	irq_status = msm_jpegdma_hw_get_irq_status(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_clear_irq(dma, irq_status);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_isr_processing_done(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_request_irq - Request dma irq.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:int msm_jpegdma_hw_request_irq(struct platform_device *pdev,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_irq, IRQF_ONESHOT | IRQF_TRIGGER_RISING,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_release_mem_resources - Releases memory resources.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:void msm_jpegdma_hw_release_mem_resources(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_camera_put_reg_base(dma->pdev, dma->iomem_base[i], dev_name,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_get_mem_resources - Get memory resources.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:int msm_jpegdma_hw_get_mem_resources(struct platform_device *pdev,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:			msm_camera_get_reg_base(pdev, dev_name,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_release_mem_resources(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_get_max_downscale - Get max downscale factor from dtsi.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:int msm_jpegdma_hw_get_max_downscale(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_get_qos - Get dma qos settings from device-tree.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:int msm_jpegdma_hw_get_qos(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_put_qos - Free dma qos settings.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:void msm_jpegdma_hw_put_qos(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_get_vbif - Get dma vbif settings from device-tree.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:int msm_jpegdma_hw_get_vbif(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_put_vbif - Put dma clocks.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:void msm_jpegdma_hw_put_vbif(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_get_prefetch - Get dma prefetch settings from device-tree.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:int msm_jpegdma_hw_get_prefetch(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_put_prefetch - free prefetch settings.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:void msm_jpegdma_hw_put_prefetch(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_get_capabilities - Get dma hw for performing any hw operation.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:int msm_jpegdma_hw_get_capabilities(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	ret = msm_camera_regulator_enable(dma->dma_vdd,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	ret = msm_camera_clk_enable(&dma->pdev->dev,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	dma->hw_num_pipes = msm_jpegdma_hw_get_num_pipes(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_camera_clk_enable(&dma->pdev->dev,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_camera_regulator_enable(dma->dma_vdd, dma->num_reg, false);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_camera_regulator_enable(dma->dma_vdd, dma->num_reg, false);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_get - Get dma hw for performing any hw operation.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:int msm_jpegdma_hw_get(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		ret = msm_camera_regulator_enable(dma->dma_vdd,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		ret = msm_camera_clk_enable(&dma->pdev->dev,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_camera_update_bus_vector(dma->bus_client, 1);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_config_qos(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_config_vbif(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_camera_register_threaded_irq(dma->pdev, dma->irq, NULL,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:			msm_jpegdma_hw_irq, IRQF_ONESHOT | IRQF_TRIGGER_RISING,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_enable_irq(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		ret = msm_jpegdma_hw_reset(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_config_qos(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_config_mmu_prefetch(dma, NULL, NULL);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_enable_irq(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_disable_irq(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_camera_clk_enable(&dma->pdev->dev, dma->jpeg_clk_info,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_camera_regulator_enable(dma->dma_vdd, dma->num_reg, false);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_put - Put dma hw.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:void msm_jpegdma_hw_put(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_halt(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_disable_irq(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_camera_unregister_irq(dma->pdev,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_camera_update_bus_vector(dma->bus_client, 0);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_camera_clk_enable(&dma->pdev->dev, dma->jpeg_clk_info,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_camera_regulator_enable(dma->dma_vdd, dma->num_reg, false);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_attach_iommu - Attach iommu to jpeg dma engine.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static int msm_jpegdma_hw_attach_iommu(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_detach_iommu - Detach iommu from jpeg dma engine.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:static void msm_jpegdma_hw_detach_iommu(struct msm_jpegdma_device *dma)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_map_buffer - Map buffer to dma hw mmu.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:int msm_jpegdma_hw_map_buffer(struct msm_jpegdma_device *dma, int fd,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	struct msm_jpegdma_buf_handle *buf)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	ret = msm_jpegdma_hw_attach_iommu(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:	msm_jpegdma_hw_detach_iommu(dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c: * msm_jpegdma_hw_unmap_buffer - Unmap buffer from dma hw mmu.
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:void msm_jpegdma_hw_unmap_buffer(struct msm_jpegdma_buf_handle *buf)
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.c:		msm_jpegdma_hw_detach_iommu(buf->dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:#include "msm_jpeg_dma_dev.h"
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_check_config(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:	struct msm_jpegdma_size_config *size_cfg);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_set_config(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:	struct msm_jpegdma_size_config *size_cfg,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:	struct msm_jpegdma_plane_config *plane_cfg);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_start(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:	struct msm_jpegdma_addr *addr,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:	struct msm_jpegdma_plane *plane,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:	struct msm_jpegdma_speed *speed);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_abort(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_update_bus_data(struct msm_jpegdma_device *dma,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_handle_irq(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_request_irq(struct platform_device *pdev,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:	struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:void msm_jpegdma_hw_release_irq(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:void msm_jpegdma_hw_release_mem_resources(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_get_mem_resources(struct platform_device *pdev,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:	struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_get_regulators(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:void msm_jpegdma_hw_put_regulators(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_get_clocks(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_put_clocks(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_get_max_downscale(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_get_qos(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:void msm_jpegdma_hw_put_qos(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_get_vbif(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:void msm_jpegdma_hw_put_vbif(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_get_prefetch(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:void msm_jpegdma_hw_put_prefetch(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_get_capabilities(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_get(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:void msm_jpegdma_hw_put(struct msm_jpegdma_device *dma);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:int msm_jpegdma_hw_map_buffer(struct msm_jpegdma_device *dma, int fd,
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:	struct msm_jpegdma_buf_handle *buf);
media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_hw.h:void msm_jpegdma_hw_unmap_buffer(struct msm_jpegdma_buf_handle *buf);
media/platform/msm/camera_v2/msm.c:#include <linux/msm_ion.h>
media/platform/msm/camera_v2/msm.c:#include "msm.h"
media/platform/msm/camera_v2/msm.c:#include "msm_vb2.h"
media/platform/msm/camera_v2/msm.c:#include "msm_sd.h"
media/platform/msm/camera_v2/msm.c:#include <media/msmb_generic_buf_mgr.h>
media/platform/msm/camera_v2/msm.c:static struct v4l2_device *msm_v4l2_dev;
media/platform/msm/camera_v2/msm.c:static struct pm_qos_request msm_v4l2_pm_qos_request;
media/platform/msm/camera_v2/msm.c:static struct msm_queue_head *msm_session_q;
media/platform/msm/camera_v2/msm.c:static struct v4l2_fh  *msm_eventq;
media/platform/msm/camera_v2/msm.c:static spinlock_t msm_eventq_lock;
media/platform/msm/camera_v2/msm.c:static struct pid *msm_pid;
media/platform/msm/camera_v2/msm.c:static spinlock_t msm_pid_lock;
media/platform/msm/camera_v2/msm.c:#define msm_dequeue(queue, type, member) ({				\
media/platform/msm/camera_v2/msm.c:	struct msm_queue_head *__q = (queue);			\
media/platform/msm/camera_v2/msm.c:#define msm_delete_sd_entry(queue, type, member, q_node) ({		\
media/platform/msm/camera_v2/msm.c:	struct msm_queue_head *__q = (queue);			\
media/platform/msm/camera_v2/msm.c:#define msm_delete_entry(queue, type, member, q_node) ({		\
media/platform/msm/camera_v2/msm.c:	struct msm_queue_head *__q = (queue);			\
media/platform/msm/camera_v2/msm.c:#define msm_queue_drain(queue, type, member) do {			\
media/platform/msm/camera_v2/msm.c:	struct msm_queue_head *__q = (queue);			\
media/platform/msm/camera_v2/msm.c:typedef int (*msm_queue_func)(void *d1, void *d2);
media/platform/msm/camera_v2/msm.c:#define msm_queue_traverse_action(queue, type, member, func, data) do {\
media/platform/msm/camera_v2/msm.c:	struct msm_queue_head *__q = (queue);			\
media/platform/msm/camera_v2/msm.c:	msm_queue_func __f = (func); \
media/platform/msm/camera_v2/msm.c:typedef int (*msm_queue_find_func)(void *d1, void *d2);
media/platform/msm/camera_v2/msm.c:#define msm_queue_find(queue, type, member, func, data) ({\
media/platform/msm/camera_v2/msm.c:	struct msm_queue_head *__q = (queue);			\
media/platform/msm/camera_v2/msm.c:	msm_queue_find_func __f = (func); \
media/platform/msm/camera_v2/msm.c:static void msm_init_queue(struct msm_queue_head *qhead)
media/platform/msm/camera_v2/msm.c:static void msm_enqueue(struct msm_queue_head *qhead,
media/platform/msm/camera_v2/msm.c:void msm_cam_copy_v4l2_subdev_fops(struct v4l2_file_operations *d1)
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_cam_copy_v4l2_subdev_fops);
media/platform/msm/camera_v2/msm.c:static const struct v4l2_file_operations *msm_cam_get_v4l2_subdev_fops_ptr(
media/platform/msm/camera_v2/msm.c:static inline int __msm_queue_find_session(void *d1, void *d2)
media/platform/msm/camera_v2/msm.c:	struct msm_session *session = d1;
media/platform/msm/camera_v2/msm.c:static inline int __msm_queue_find_stream(void *d1, void *d2)
media/platform/msm/camera_v2/msm.c:	struct msm_stream *stream = d1;
media/platform/msm/camera_v2/msm.c:static inline int __msm_queue_find_command_ack_q(void *d1, void *d2)
media/platform/msm/camera_v2/msm.c:	struct msm_command_ack *ack = d1;
media/platform/msm/camera_v2/msm.c:static inline void msm_pm_qos_add_request(void)
media/platform/msm/camera_v2/msm.c:	pm_qos_add_request(&msm_v4l2_pm_qos_request, PM_QOS_CPU_DMA_LATENCY,
media/platform/msm/camera_v2/msm.c:static void msm_pm_qos_remove_request(void)
media/platform/msm/camera_v2/msm.c:	pm_qos_remove_request(&msm_v4l2_pm_qos_request);
media/platform/msm/camera_v2/msm.c:void msm_pm_qos_update_request(int val)
media/platform/msm/camera_v2/msm.c:	msm_pm_qos_add_request();
media/platform/msm/camera_v2/msm.c:	pm_qos_update_request(&msm_v4l2_pm_qos_request, val);
media/platform/msm/camera_v2/msm.c:struct msm_session *msm_session_find(unsigned int session_id)
media/platform/msm/camera_v2/msm.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm.c:	session = msm_queue_find(msm_session_q, struct msm_session,
media/platform/msm/camera_v2/msm.c:		list, __msm_queue_find_session, &session_id);
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_session_find);
media/platform/msm/camera_v2/msm.c:int msm_create_stream(unsigned int session_id,
media/platform/msm/camera_v2/msm.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm.c:	struct msm_stream  *stream;
media/platform/msm/camera_v2/msm.c:	session = msm_queue_find(msm_session_q, struct msm_session,
media/platform/msm/camera_v2/msm.c:		list, __msm_queue_find_session, &session_id);
media/platform/msm/camera_v2/msm.c:	msm_enqueue(&session->stream_q, &stream->list);
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_create_stream);
media/platform/msm/camera_v2/msm.c:void msm_delete_stream(unsigned int session_id, unsigned int stream_id)
media/platform/msm/camera_v2/msm.c:	struct msm_session *session = NULL;
media/platform/msm/camera_v2/msm.c:	struct msm_stream  *stream = NULL;
media/platform/msm/camera_v2/msm.c:	session = msm_queue_find(msm_session_q, struct msm_session,
media/platform/msm/camera_v2/msm.c:		list, __msm_queue_find_session, &session_id);
media/platform/msm/camera_v2/msm.c:		stream = msm_queue_find(&session->stream_q, struct msm_stream,
media/platform/msm/camera_v2/msm.c:			list, __msm_queue_find_stream, &stream_id);
media/platform/msm/camera_v2/msm.c:		if (msm_vb2_get_stream_state(stream) != 1) {
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_delete_stream);
media/platform/msm/camera_v2/msm.c:static void msm_sd_unregister_subdev(struct video_device *vdev)
media/platform/msm/camera_v2/msm.c:static inline int __msm_sd_register_subdev(struct v4l2_subdev *sd)
media/platform/msm/camera_v2/msm.c:	if (!msm_v4l2_dev || !sd || !sd->name[0])
media/platform/msm/camera_v2/msm.c:	rc = v4l2_device_register_subdev(msm_v4l2_dev, sd);
media/platform/msm/camera_v2/msm.c:	vdev->v4l2_dev = msm_v4l2_dev;
media/platform/msm/camera_v2/msm.c:	vdev->fops = msm_cam_get_v4l2_subdev_fops_ptr();
media/platform/msm/camera_v2/msm.c:	vdev->release = msm_sd_unregister_subdev;
media/platform/msm/camera_v2/msm.c:static void msm_add_sd_in_position(struct msm_sd_subdev *msm_subdev,
media/platform/msm/camera_v2/msm.c:	struct msm_sd_subdev *temp_sd;
media/platform/msm/camera_v2/msm.c:		if (temp_sd == msm_subdev) {
media/platform/msm/camera_v2/msm.c:		if (msm_subdev->close_seq < temp_sd->close_seq) {
media/platform/msm/camera_v2/msm.c:			list_add_tail(&msm_subdev->list, &temp_sd->list);
media/platform/msm/camera_v2/msm.c:	list_add_tail(&msm_subdev->list, sd_list);
media/platform/msm/camera_v2/msm.c:int msm_sd_register(struct msm_sd_subdev *msm_subdev)
media/platform/msm/camera_v2/msm.c:	if (WARN_ON(!msm_subdev))
media/platform/msm/camera_v2/msm.c:	if (WARN_ON(!msm_v4l2_dev) || WARN_ON(!msm_v4l2_dev->dev))
media/platform/msm/camera_v2/msm.c:	msm_add_sd_in_position(msm_subdev, &ordered_sd_list);
media/platform/msm/camera_v2/msm.c:	return __msm_sd_register_subdev(&msm_subdev->sd);
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_sd_register);
media/platform/msm/camera_v2/msm.c:int msm_sd_unregister(struct msm_sd_subdev *msm_subdev)
media/platform/msm/camera_v2/msm.c:	if (WARN_ON(!msm_subdev))
media/platform/msm/camera_v2/msm.c:	v4l2_device_unregister_subdev(&msm_subdev->sd);
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_sd_unregister);
media/platform/msm/camera_v2/msm.c:static struct v4l2_subdev *msm_sd_find(const char *name)
media/platform/msm/camera_v2/msm.c:	spin_lock_irqsave(&msm_v4l2_dev->lock, flags);
media/platform/msm/camera_v2/msm.c:	if (!list_empty(&msm_v4l2_dev->subdevs)) {
media/platform/msm/camera_v2/msm.c:		list_for_each_entry(subdev, &msm_v4l2_dev->subdevs, list)
media/platform/msm/camera_v2/msm.c:	spin_unlock_irqrestore(&msm_v4l2_dev->lock, flags);
media/platform/msm/camera_v2/msm.c:int msm_create_session(unsigned int session_id, struct video_device *vdev)
media/platform/msm/camera_v2/msm.c:	struct msm_session *session = NULL;
media/platform/msm/camera_v2/msm.c:	if (!msm_session_q) {
media/platform/msm/camera_v2/msm.c:	session = msm_queue_find(msm_session_q, struct msm_session,
media/platform/msm/camera_v2/msm.c:		list, __msm_queue_find_session, &session_id);
media/platform/msm/camera_v2/msm.c:	msm_init_queue(&session->command_ack_q);
media/platform/msm/camera_v2/msm.c:	msm_init_queue(&session->stream_q);
media/platform/msm/camera_v2/msm.c:	msm_enqueue(msm_session_q, &session->list);
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_create_session);
media/platform/msm/camera_v2/msm.c:int msm_create_command_ack_q(unsigned int session_id, unsigned int stream_id)
media/platform/msm/camera_v2/msm.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm.c:	struct msm_command_ack *cmd_ack;
media/platform/msm/camera_v2/msm.c:	if (!msm_session_q) {
media/platform/msm/camera_v2/msm.c:	session = msm_queue_find(msm_session_q, struct msm_session,
media/platform/msm/camera_v2/msm.c:		list, __msm_queue_find_session, &session_id);
media/platform/msm/camera_v2/msm.c:	msm_init_queue(&cmd_ack->command_q);
media/platform/msm/camera_v2/msm.c:	msm_enqueue(&session->command_ack_q, &cmd_ack->list);
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_create_command_ack_q);
media/platform/msm/camera_v2/msm.c:void msm_delete_command_ack_q(unsigned int session_id, unsigned int stream_id)
media/platform/msm/camera_v2/msm.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm.c:	struct msm_command_ack *cmd_ack;
media/platform/msm/camera_v2/msm.c:	session = msm_queue_find(msm_session_q, struct msm_session,
media/platform/msm/camera_v2/msm.c:		list, __msm_queue_find_session, &session_id);
media/platform/msm/camera_v2/msm.c:	cmd_ack = msm_queue_find(&session->command_ack_q,
media/platform/msm/camera_v2/msm.c:		struct msm_command_ack,	list, __msm_queue_find_command_ack_q,
media/platform/msm/camera_v2/msm.c:	msm_queue_drain(&cmd_ack->command_q, struct msm_command, list);
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_delete_command_ack_q);
media/platform/msm/camera_v2/msm.c:static inline int __msm_sd_close_subdevs(struct msm_sd_subdev *msm_sd,
media/platform/msm/camera_v2/msm.c:	struct msm_sd_close_ioctl *sd_close)
media/platform/msm/camera_v2/msm.c:	sd = &msm_sd->sd;
media/platform/msm/camera_v2/msm.c:static inline int __msm_sd_notify_freeze_subdevs(struct msm_sd_subdev *msm_sd,
media/platform/msm/camera_v2/msm.c:	sd = &msm_sd->sd;
media/platform/msm/camera_v2/msm.c:static inline int __msm_destroy_session_streams(void *d1, void *d2)
media/platform/msm/camera_v2/msm.c:	struct msm_stream *stream = d1;
media/platform/msm/camera_v2/msm.c:static void msm_destroy_session_streams(struct msm_session *session)
media/platform/msm/camera_v2/msm.c:	msm_queue_traverse_action(&session->stream_q, struct msm_stream, list,
media/platform/msm/camera_v2/msm.c:		__msm_destroy_session_streams, NULL);
media/platform/msm/camera_v2/msm.c:	msm_queue_drain(&session->stream_q, struct msm_stream, list);
media/platform/msm/camera_v2/msm.c:static inline int __msm_remove_session_cmd_ack_q(void *d1, void *d2)
media/platform/msm/camera_v2/msm.c:	struct msm_command_ack *cmd_ack = d1;
media/platform/msm/camera_v2/msm.c:	msm_queue_drain(&cmd_ack->command_q, struct msm_command, list);
media/platform/msm/camera_v2/msm.c:static void msm_remove_session_cmd_ack_q(struct msm_session *session)
media/platform/msm/camera_v2/msm.c:	msm_queue_traverse_action(&session->command_ack_q,
media/platform/msm/camera_v2/msm.c:		struct msm_command_ack,	list,
media/platform/msm/camera_v2/msm.c:		__msm_remove_session_cmd_ack_q, NULL);
media/platform/msm/camera_v2/msm.c:	msm_queue_drain(&session->command_ack_q, struct msm_command_ack, list);
media/platform/msm/camera_v2/msm.c:int msm_destroy_session(unsigned int session_id)
media/platform/msm/camera_v2/msm.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm.c:	struct msm_sd_close_ioctl session_info;
media/platform/msm/camera_v2/msm.c:	session = msm_queue_find(msm_session_q, struct msm_session,
media/platform/msm/camera_v2/msm.c:		list, __msm_queue_find_session, &session_id);
media/platform/msm/camera_v2/msm.c:	msm_destroy_session_streams(session);
media/platform/msm/camera_v2/msm.c:	msm_remove_session_cmd_ack_q(session);
media/platform/msm/camera_v2/msm.c:	msm_delete_entry(msm_session_q, struct msm_session,
media/platform/msm/camera_v2/msm.c:	buf_mgr_subdev = msm_sd_find("msm_buf_mngr");
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_destroy_session);
media/platform/msm/camera_v2/msm.c:static int __msm_close_destry_session_notify_apps(void *d1, void *d2)
media/platform/msm/camera_v2/msm.c:	struct msm_v4l2_event_data *event_data =
media/platform/msm/camera_v2/msm.c:		(struct msm_v4l2_event_data *)&event.u.data[0];
media/platform/msm/camera_v2/msm.c:	struct msm_session *session = d1;
media/platform/msm/camera_v2/msm.c:static int __msm_wakeup_all_cmdack_session_stream(void *d1, void *d2)
media/platform/msm/camera_v2/msm.c:	struct msm_stream *stream = d1;
media/platform/msm/camera_v2/msm.c:	struct msm_session *session = d2;
media/platform/msm/camera_v2/msm.c:	struct msm_command_ack *cmd_ack = NULL;
media/platform/msm/camera_v2/msm.c:	cmd_ack = msm_queue_find(&session->command_ack_q,
media/platform/msm/camera_v2/msm.c:		struct msm_command_ack, list,
media/platform/msm/camera_v2/msm.c:		__msm_queue_find_command_ack_q,
media/platform/msm/camera_v2/msm.c:static int __msm_close_wakeup_all_cmdack_session(void *d1, void *d2)
media/platform/msm/camera_v2/msm.c:	struct msm_stream  *stream = NULL;
media/platform/msm/camera_v2/msm.c:	struct msm_session *session = d1;
media/platform/msm/camera_v2/msm.c:	stream = msm_queue_find(&session->stream_q, struct msm_stream,
media/platform/msm/camera_v2/msm.c:		list, __msm_wakeup_all_cmdack_session_stream, d1);
media/platform/msm/camera_v2/msm.c:static long msm_private_ioctl(struct file *file, void *fh,
media/platform/msm/camera_v2/msm.c:	struct msm_v4l2_event_data *event_data = arg;
media/platform/msm/camera_v2/msm.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm.c:	struct msm_sd_subdev *msm_sd;
media/platform/msm/camera_v2/msm.c:	session = msm_queue_find(msm_session_q, struct msm_session,
media/platform/msm/camera_v2/msm.c:		list, __msm_queue_find_session, &session_id);
media/platform/msm/camera_v2/msm.c:			sizeof(struct msm_v4l2_event_data));
media/platform/msm/camera_v2/msm.c:		struct msm_command_ack *cmd_ack;
media/platform/msm/camera_v2/msm.c:		struct msm_command *ret_cmd;
media/platform/msm/camera_v2/msm.c:		cmd_ack = msm_queue_find(&session->command_ack_q,
media/platform/msm/camera_v2/msm.c:			struct msm_command_ack, list,
media/platform/msm/camera_v2/msm.c:			__msm_queue_find_command_ack_q,
media/platform/msm/camera_v2/msm.c:			sizeof(struct msm_v4l2_event_data));
media/platform/msm/camera_v2/msm.c:		msm_enqueue(&cmd_ack->command_q, &ret_cmd->list);
media/platform/msm/camera_v2/msm.c:		if (!list_empty(&msm_v4l2_dev->subdevs)) {
media/platform/msm/camera_v2/msm.c:			list_for_each_entry(msm_sd, &ordered_sd_list, list)
media/platform/msm/camera_v2/msm.c:				__msm_sd_notify_freeze_subdevs(msm_sd,
media/platform/msm/camera_v2/msm.c:		msm_queue_traverse_action(msm_session_q,
media/platform/msm/camera_v2/msm.c:			struct msm_session, list,
media/platform/msm/camera_v2/msm.c:			__msm_close_destry_session_notify_apps, NULL);
media/platform/msm/camera_v2/msm.c:static int msm_unsubscribe_event(struct v4l2_fh *fh,
media/platform/msm/camera_v2/msm.c:static int msm_subscribe_event(struct v4l2_fh *fh,
media/platform/msm/camera_v2/msm.c:static const struct v4l2_ioctl_ops g_msm_ioctl_ops = {
media/platform/msm/camera_v2/msm.c:	.vidioc_subscribe_event = msm_subscribe_event,
media/platform/msm/camera_v2/msm.c:	.vidioc_unsubscribe_event = msm_unsubscribe_event,
media/platform/msm/camera_v2/msm.c:	.vidioc_default = msm_private_ioctl,
media/platform/msm/camera_v2/msm.c:static unsigned int msm_poll(struct file *f,
media/platform/msm/camera_v2/msm.c:static void msm_print_event_error(struct v4l2_event *event)
media/platform/msm/camera_v2/msm.c:	struct msm_v4l2_event_data *event_data =
media/platform/msm/camera_v2/msm.c:		(struct msm_v4l2_event_data *)&event->u.data[0];
media/platform/msm/camera_v2/msm.c:/* something seriously wrong if msm_close is triggered
media/platform/msm/camera_v2/msm.c:int msm_post_event(struct v4l2_event *event, int timeout)
media/platform/msm/camera_v2/msm.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm.c:	struct msm_v4l2_event_data *event_data =
media/platform/msm/camera_v2/msm.c:		(struct msm_v4l2_event_data *)&event->u.data[0];
media/platform/msm/camera_v2/msm.c:	struct msm_command_ack *cmd_ack;
media/platform/msm/camera_v2/msm.c:	struct msm_command *cmd;
media/platform/msm/camera_v2/msm.c:	spin_lock_irqsave(&msm_eventq_lock, flags);
media/platform/msm/camera_v2/msm.c:	if (!msm_eventq) {
media/platform/msm/camera_v2/msm.c:		spin_unlock_irqrestore(&msm_eventq_lock, flags);
media/platform/msm/camera_v2/msm.c:		pr_err("%s : msm event queue not available Line %d\n",
media/platform/msm/camera_v2/msm.c:	spin_unlock_irqrestore(&msm_eventq_lock, flags);
media/platform/msm/camera_v2/msm.c:	vdev = msm_eventq->vdev;
media/platform/msm/camera_v2/msm.c:	session = msm_queue_find(msm_session_q, struct msm_session,
media/platform/msm/camera_v2/msm.c:		list, __msm_queue_find_session, &session_id);
media/platform/msm/camera_v2/msm.c:	cmd_ack = msm_queue_find(&session->command_ack_q,
media/platform/msm/camera_v2/msm.c:		struct msm_command_ack, list,
media/platform/msm/camera_v2/msm.c:		__msm_queue_find_command_ack_q, &stream_id);
media/platform/msm/camera_v2/msm.c:			msm_print_event_error(event);
media/platform/msm/camera_v2/msm.c:		msm_print_event_error(event);
media/platform/msm/camera_v2/msm.c:	cmd = msm_dequeue(&cmd_ack->command_q,
media/platform/msm/camera_v2/msm.c:		struct msm_command, list);
media/platform/msm/camera_v2/msm.c:	event_data = (struct msm_v4l2_event_data *)cmd->event.u.data;
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_post_event);
media/platform/msm/camera_v2/msm.c:static int msm_close(struct file *filep)
media/platform/msm/camera_v2/msm.c:	struct msm_video_device *pvdev = video_drvdata(filep);
media/platform/msm/camera_v2/msm.c:	struct msm_sd_close_ioctl sd_close;
media/platform/msm/camera_v2/msm.c:	struct msm_sd_subdev *msm_sd;
media/platform/msm/camera_v2/msm.c:	if (!list_empty(&msm_v4l2_dev->subdevs))
media/platform/msm/camera_v2/msm.c:		list_for_each_entry(msm_sd, &ordered_sd_list, list)
media/platform/msm/camera_v2/msm.c:			__msm_sd_close_subdevs(msm_sd, &sd_close);
media/platform/msm/camera_v2/msm.c:	/* remove msm_v4l2_pm_qos_request */
media/platform/msm/camera_v2/msm.c:	msm_pm_qos_remove_request();
media/platform/msm/camera_v2/msm.c:	msm_queue_traverse_action(msm_session_q, struct msm_session, list,
media/platform/msm/camera_v2/msm.c:		__msm_close_destry_session_notify_apps, NULL);
media/platform/msm/camera_v2/msm.c:	msm_queue_traverse_action(msm_session_q, struct msm_session, list,
media/platform/msm/camera_v2/msm.c:		__msm_close_wakeup_all_cmdack_session, NULL);
media/platform/msm/camera_v2/msm.c:	spin_lock_irqsave(&msm_eventq_lock, flags);
media/platform/msm/camera_v2/msm.c:	msm_eventq = NULL;
media/platform/msm/camera_v2/msm.c:	spin_unlock_irqrestore(&msm_eventq_lock, flags);
media/platform/msm/camera_v2/msm.c:	spin_lock_irqsave(&msm_pid_lock, flags);
media/platform/msm/camera_v2/msm.c:	put_pid(msm_pid);
media/platform/msm/camera_v2/msm.c:	msm_pid = NULL;
media/platform/msm/camera_v2/msm.c:	spin_unlock_irqrestore(&msm_pid_lock, flags);
media/platform/msm/camera_v2/msm.c:static inline void msm_list_switch(struct list_head *l1,
media/platform/msm/camera_v2/msm.c:static int msm_open(struct file *filep)
media/platform/msm/camera_v2/msm.c:	struct msm_video_device *pvdev = video_drvdata(filep);
media/platform/msm/camera_v2/msm.c:	spin_lock_irqsave(&msm_pid_lock, flags);
media/platform/msm/camera_v2/msm.c:	msm_pid = get_pid(task_pid(current));
media/platform/msm/camera_v2/msm.c:	spin_unlock_irqrestore(&msm_pid_lock, flags);
media/platform/msm/camera_v2/msm.c:	spin_lock_irqsave(&msm_eventq_lock, flags);
media/platform/msm/camera_v2/msm.c:	msm_eventq = filep->private_data;
media/platform/msm/camera_v2/msm.c:	spin_unlock_irqrestore(&msm_eventq_lock, flags);
media/platform/msm/camera_v2/msm.c:	/* register msm_v4l2_pm_qos_request */
media/platform/msm/camera_v2/msm.c:	msm_pm_qos_add_request();
media/platform/msm/camera_v2/msm.c:static struct v4l2_file_operations msm_fops = {
media/platform/msm/camera_v2/msm.c:	.open   = msm_open,
media/platform/msm/camera_v2/msm.c:	.poll   = msm_poll,
media/platform/msm/camera_v2/msm.c:	.release = msm_close,
media/platform/msm/camera_v2/msm.c:struct msm_session *msm_get_session(unsigned int session_id)
media/platform/msm/camera_v2/msm.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm.c:	session = msm_queue_find(msm_session_q, struct msm_session,
media/platform/msm/camera_v2/msm.c:		list, __msm_queue_find_session, &session_id);
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_get_session);
media/platform/msm/camera_v2/msm.c:struct msm_stream *msm_get_stream(struct msm_session *session,
media/platform/msm/camera_v2/msm.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm.c:	stream = msm_queue_find(&session->stream_q, struct msm_stream,
media/platform/msm/camera_v2/msm.c:		list, __msm_queue_find_stream, &stream_id);
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_get_stream);
media/platform/msm/camera_v2/msm.c:struct vb2_queue *msm_get_stream_vb2q(unsigned int session_id,
media/platform/msm/camera_v2/msm.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm.c:	session = msm_queue_find(msm_session_q, struct msm_session,
media/platform/msm/camera_v2/msm.c:		list, __msm_queue_find_session, &session_id);
media/platform/msm/camera_v2/msm.c:	stream = msm_queue_find(&session->stream_q, struct msm_stream,
media/platform/msm/camera_v2/msm.c:		list, __msm_queue_find_stream, &stream_id);
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_get_stream_vb2q);
media/platform/msm/camera_v2/msm.c:struct msm_stream *msm_get_stream_from_vb2q(struct vb2_queue *q)
media/platform/msm/camera_v2/msm.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm.c:	spin_lock_irqsave(&msm_session_q->lock, flags1);
media/platform/msm/camera_v2/msm.c:	list_for_each_entry(session, &(msm_session_q->list), list) {
media/platform/msm/camera_v2/msm.c:					(&msm_session_q->lock, flags1);
media/platform/msm/camera_v2/msm.c:	spin_unlock_irqrestore(&msm_session_q->lock, flags1);
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_get_stream_from_vb2q);
media/platform/msm/camera_v2/msm.c:struct msm_session *msm_get_session_from_vb2q(struct vb2_queue *q)
media/platform/msm/camera_v2/msm.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm.c:	spin_lock_irqsave(&msm_session_q->lock, flags1);
media/platform/msm/camera_v2/msm.c:	list_for_each_entry(session, &(msm_session_q->list), list) {
media/platform/msm/camera_v2/msm.c:					(&msm_session_q->lock, flags1);
media/platform/msm/camera_v2/msm.c:	spin_unlock_irqrestore(&msm_session_q->lock, flags1);
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_get_session_from_vb2q);
media/platform/msm/camera_v2/msm.c:long msm_copy_camera_private_ioctl_args(unsigned long arg,
media/platform/msm/camera_v2/msm.c:	struct msm_camera_private_ioctl_arg *k_ioctl,
media/platform/msm/camera_v2/msm.c:	struct msm_camera_private_ioctl_arg up_ioctl;
media/platform/msm/camera_v2/msm.c:		sizeof(struct msm_camera_private_ioctl_arg)))
media/platform/msm/camera_v2/msm.c:EXPORT_SYMBOL(msm_copy_camera_private_ioctl_args);
media/platform/msm/camera_v2/msm.c:static void msm_sd_notify(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/msm.c:	if (!msm_sd_find(sd->name))
media/platform/msm/camera_v2/msm.c:		struct msm_sd_req_sd *get_sd = arg;
media/platform/msm/camera_v2/msm.c:		get_sd->subdev = msm_sd_find(get_sd->name);
media/platform/msm/camera_v2/msm.c:		struct msm_sd_req_sd *put_sd = arg;
media/platform/msm/camera_v2/msm.c:		subdev = msm_sd_find(put_sd->name);
media/platform/msm/camera_v2/msm.c:		struct msm_sd_req_vb2_q *req_sd = arg;
media/platform/msm/camera_v2/msm.c:		rc = msm_vb2_request_cb(req_sd);
media/platform/msm/camera_v2/msm.c:static int msm_probe(struct platform_device *pdev)
media/platform/msm/camera_v2/msm.c:	struct msm_video_device *pvdev = NULL;
media/platform/msm/camera_v2/msm.c:	msm_v4l2_dev = kzalloc(sizeof(*msm_v4l2_dev),
media/platform/msm/camera_v2/msm.c:	if (WARN_ON(!msm_v4l2_dev)) {
media/platform/msm/camera_v2/msm.c:	pvdev = kzalloc(sizeof(struct msm_video_device),
media/platform/msm/camera_v2/msm.c:	msm_v4l2_dev->mdev = kzalloc(sizeof(struct media_device),
media/platform/msm/camera_v2/msm.c:	if (!msm_v4l2_dev->mdev) {
media/platform/msm/camera_v2/msm.c:	media_device_init(msm_v4l2_dev->mdev);
media/platform/msm/camera_v2/msm.c:	strlcpy(msm_v4l2_dev->mdev->model, MSM_CONFIGURATION_NAME,
media/platform/msm/camera_v2/msm.c:			sizeof(msm_v4l2_dev->mdev->model));
media/platform/msm/camera_v2/msm.c:	msm_v4l2_dev->mdev->dev = &(pdev->dev);
media/platform/msm/camera_v2/msm.c:	rc = media_device_register(msm_v4l2_dev->mdev);
media/platform/msm/camera_v2/msm.c:	msm_v4l2_dev->notify = msm_sd_notify;
media/platform/msm/camera_v2/msm.c:	pvdev->vdev->v4l2_dev = msm_v4l2_dev;
media/platform/msm/camera_v2/msm.c:	strlcpy(pvdev->vdev->name, "msm-config", sizeof(pvdev->vdev->name));
media/platform/msm/camera_v2/msm.c:	pvdev->vdev->fops     = &msm_fops;
media/platform/msm/camera_v2/msm.c:	pvdev->vdev->ioctl_ops = &g_msm_ioctl_ops;
media/platform/msm/camera_v2/msm.c:	msm_session_q = kzalloc(sizeof(*msm_session_q), GFP_KERNEL);
media/platform/msm/camera_v2/msm.c:	if (WARN_ON(!msm_session_q))
media/platform/msm/camera_v2/msm.c:	msm_init_queue(msm_session_q);
media/platform/msm/camera_v2/msm.c:	spin_lock_init(&msm_eventq_lock);
media/platform/msm/camera_v2/msm.c:	spin_lock_init(&msm_pid_lock);
media/platform/msm/camera_v2/msm.c:	media_device_unregister(msm_v4l2_dev->mdev);
media/platform/msm/camera_v2/msm.c:	kzfree(msm_v4l2_dev->mdev);
media/platform/msm/camera_v2/msm.c:	kzfree(msm_v4l2_dev);
media/platform/msm/camera_v2/msm.c:static const struct of_device_id msm_dt_match[] = {
media/platform/msm/camera_v2/msm.c:	{.compatible = "qcom,msm-cam"},
media/platform/msm/camera_v2/msm.c:MODULE_DEVICE_TABLE(of, msm_dt_match);
media/platform/msm/camera_v2/msm.c:static struct platform_driver msm_driver = {
media/platform/msm/camera_v2/msm.c:	.probe = msm_probe,
media/platform/msm/camera_v2/msm.c:		.name = "msm",
media/platform/msm/camera_v2/msm.c:		.of_match_table = msm_dt_match,
media/platform/msm/camera_v2/msm.c:static int __init msm_init(void)
media/platform/msm/camera_v2/msm.c:	return platform_driver_register(&msm_driver);
media/platform/msm/camera_v2/msm.c:static void __exit msm_exit(void)
media/platform/msm/camera_v2/msm.c:	platform_driver_unregister(&msm_driver);
media/platform/msm/camera_v2/msm.c:module_init(msm_init);
media/platform/msm/camera_v2/msm.c:module_exit(msm_exit);
media/platform/msm/camera_v2/msm.h:#include <linux/msm_ion.h>
media/platform/msm/camera_v2/msm.h:#include <linux/msm_kgsl.h>
media/platform/msm/camera_v2/msm.h:#include <media/msmb_camera.h>
media/platform/msm/camera_v2/msm.h:struct msm_video_device {
media/platform/msm/camera_v2/msm.h:struct msm_queue_head {
media/platform/msm/camera_v2/msm.h:/** msm_event:
media/platform/msm/camera_v2/msm.h:struct msm_event {
media/platform/msm/camera_v2/msm.h:struct msm_command {
media/platform/msm/camera_v2/msm.h:/** struct msm_command_ack
media/platform/msm/camera_v2/msm.h: *  contains struct msm_command
media/platform/msm/camera_v2/msm.h:struct msm_command_ack {
media/platform/msm/camera_v2/msm.h:	struct msm_queue_head command_q;
media/platform/msm/camera_v2/msm.h:struct msm_v4l2_subdev {
media/platform/msm/camera_v2/msm.h:struct msm_session {
media/platform/msm/camera_v2/msm.h:	struct msm_event event_q;
media/platform/msm/camera_v2/msm.h:	 * struct msm_command_ack per open,
media/platform/msm/camera_v2/msm.h:	struct msm_queue_head command_ack_q;
media/platform/msm/camera_v2/msm.h:	 * session struct msm_stream
media/platform/msm/camera_v2/msm.h:	struct msm_queue_head stream_q;
media/platform/msm/camera_v2/msm.h:static inline bool msm_is_daemon_present(void)
media/platform/msm/camera_v2/msm.h:void msm_pm_qos_update_request(int val);
media/platform/msm/camera_v2/msm.h:int msm_post_event(struct v4l2_event *event, int timeout);
media/platform/msm/camera_v2/msm.h:int  msm_create_session(unsigned int session, struct video_device *vdev);
media/platform/msm/camera_v2/msm.h:int msm_destroy_session(unsigned int session_id);
media/platform/msm/camera_v2/msm.h:int msm_create_stream(unsigned int session_id,
media/platform/msm/camera_v2/msm.h:void msm_delete_stream(unsigned int session_id, unsigned int stream_id);
media/platform/msm/camera_v2/msm.h:int  msm_create_command_ack_q(unsigned int session_id, unsigned int stream_id);
media/platform/msm/camera_v2/msm.h:void msm_delete_command_ack_q(unsigned int session_id, unsigned int stream_id);
media/platform/msm/camera_v2/msm.h:struct msm_session *msm_get_session(unsigned int session_id);
media/platform/msm/camera_v2/msm.h:struct msm_stream *msm_get_stream(struct msm_session *session,
media/platform/msm/camera_v2/msm.h:struct vb2_queue *msm_get_stream_vb2q(unsigned int session_id,
media/platform/msm/camera_v2/msm.h:struct msm_stream *msm_get_stream_from_vb2q(struct vb2_queue *q);
media/platform/msm/camera_v2/msm.h:struct msm_session *msm_get_session_from_vb2q(struct vb2_queue *q);
media/platform/msm/camera_v2/msm.h:struct msm_session *msm_session_find(unsigned int session_id);
media/platform/msm/camera_v2/msm.h:long msm_copy_camera_private_ioctl_args(unsigned long arg,
media/platform/msm/camera_v2/msm.h:	struct msm_camera_private_ioctl_arg *k_ioctl,
media/platform/msm/camera_v2/msm_buf_mgr/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/msm_buf_mgr/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_generic_buf_mgr.o
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:#include "msm_generic_buf_mgr.h"
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static struct msm_buf_mngr_device *msm_buf_mngr_dev;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:struct v4l2_subdev *msm_buf_mngr_get_subdev(void)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	return &msm_buf_mngr_dev->subdev.sd;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static int32_t msm_buf_mngr_hdl_cont_get_buf(struct msm_buf_mngr_device *dev,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_info *buf_info)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_user_buf_cont_info *cbuf, *cont_save;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static int32_t msm_buf_mngr_get_buf(struct msm_buf_mngr_device *dev,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_info *buf_info =
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		(struct msm_buf_mngr_info *)argp;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_get_bufs *new_entry =
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		kzalloc(sizeof(struct msm_get_bufs), GFP_KERNEL);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			rc = msm_buf_mngr_hdl_cont_get_buf(dev, buf_info);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static int32_t msm_buf_mngr_get_buf_by_idx(struct msm_buf_mngr_device *dev,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_info *buf_info =
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		(struct msm_buf_mngr_info *)argp;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_get_bufs *new_entry =
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		kzalloc(sizeof(struct msm_get_bufs), GFP_KERNEL);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			rc = msm_buf_mngr_hdl_cont_get_buf(dev, buf_info);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static int32_t msm_buf_mngr_buf_done(struct msm_buf_mngr_device *buf_mngr_dev,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_info *buf_info)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_get_bufs *bufs, *save;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static int32_t msm_buf_mngr_buf_error(struct msm_buf_mngr_device *buf_mngr_dev,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_info *buf_info)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_get_bufs *bufs, *save;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static int32_t msm_buf_mngr_put_buf(struct msm_buf_mngr_device *buf_mngr_dev,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_info *buf_info)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_get_bufs *bufs, *save;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static int32_t msm_generic_buf_mngr_flush(
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_device *buf_mngr_dev,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_info *buf_info)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_get_bufs *bufs, *save;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static int32_t msm_buf_mngr_find_cont_stream(struct msm_buf_mngr_device *dev,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:					     struct msm_sd_close_ioctl *session)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_user_buf_cont_info *cont_bufs, *cont_save;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static void msm_buf_mngr_contq_listdel(struct msm_buf_mngr_device *dev,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_user_buf_cont_info *cont_bufs, *cont_save;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static void msm_buf_mngr_contq_cleanup(struct msm_buf_mngr_device *dev,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:				     struct msm_sd_close_ioctl *session)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		found = msm_buf_mngr_find_cont_stream(dev, &cnt,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		msm_buf_mngr_contq_listdel(dev, session->session,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static void msm_buf_mngr_sd_shutdown(struct msm_buf_mngr_device *dev,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:				     struct msm_sd_close_ioctl *session)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_get_bufs *bufs, *save;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		msm_buf_mngr_contq_cleanup(dev, session);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static int msm_buf_mngr_handle_cont_cmd(struct msm_buf_mngr_device *dev,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:					struct msm_buf_mngr_main_cont_info
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_camera_user_buf_cont_t *iaddr, *temp_addr;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_user_buf_cont_info *new_entry, *bufs, *save;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			(sizeof(struct msm_camera_user_buf_cont_t) *
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:				struct msm_buf_mngr_user_buf_cont_info),
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			msm_buf_mngr_contq_listdel(dev, cont_cmd->session_id,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			msm_buf_mngr_contq_listdel(dev, cont_cmd->session_id,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static int msm_generic_buf_mngr_open(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_device *buf_mngr_dev = v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static int msm_generic_buf_mngr_close(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_device *buf_mngr_dev = v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static int msm_cam_buf_mgr_ops(unsigned int cmd, void *argp)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	if (!msm_buf_mngr_dev)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		rc = msm_buf_mngr_get_buf(msm_buf_mngr_dev, argp);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		rc = msm_buf_mngr_buf_done(msm_buf_mngr_dev, argp);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		rc = msm_buf_mngr_buf_error(msm_buf_mngr_dev, argp);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		rc = msm_buf_mngr_put_buf(msm_buf_mngr_dev, argp);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		struct msm_camera_private_ioctl_arg *k_ioctl = argp;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			struct msm_buf_mngr_info *tmp = NULL;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			if (k_ioctl->size != sizeof(struct msm_buf_mngr_info))
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			rc = msm_buf_mngr_get_buf_by_idx(msm_buf_mngr_dev,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:int msm_cam_buf_mgr_register_ops(struct msm_cam_buf_mgr_req_ops *cb_struct)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	if (!msm_buf_mngr_dev)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	cb_struct->msm_cam_buf_mgr_ops = msm_cam_buf_mgr_ops;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static long msm_buf_mngr_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_buf_mngr_device *buf_mngr_dev = v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		struct msm_camera_private_ioctl_arg k_ioctl, *ptr;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			struct msm_buf_mngr_info buf_info, *tmp = NULL;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			if (k_ioctl.size != sizeof(struct msm_buf_mngr_info))
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:					sizeof(struct msm_buf_mngr_info))) {
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			rc = msm_cam_buf_mgr_ops(cmd, argp);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		rc = msm_cam_buf_mgr_ops(cmd, argp);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		rc = msm_generic_buf_mngr_open(sd, NULL);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		rc = msm_generic_buf_mngr_close(sd, NULL);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		rc = msm_generic_buf_mngr_flush(buf_mngr_dev, argp);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		msm_buf_mngr_sd_shutdown(buf_mngr_dev, argp);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		rc = msm_buf_mngr_handle_cont_cmd(buf_mngr_dev, argp);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static long msm_camera_buf_mgr_fetch_buf_info(
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		struct msm_buf_mngr_info32_t *buf_info32,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		struct msm_buf_mngr_info *buf_info, unsigned long arg)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:				sizeof(struct msm_buf_mngr_info32_t)))
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static long msm_camera_buf_mgr_update_buf_info(
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		struct msm_buf_mngr_info32_t *buf_info32,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		struct msm_buf_mngr_info *buf_info, unsigned long arg)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			sizeof(struct msm_buf_mngr_info32_t)))
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static long msm_camera_buf_mgr_internal_compat_ioctl(struct file *file,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	struct msm_camera_private_ioctl_arg k_ioctl;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	rc = msm_copy_camera_private_ioctl_args(arg,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		struct msm_buf_mngr_info32_t buf_info32;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		struct msm_buf_mngr_info buf_info;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		if (k_ioctl.size != sizeof(struct msm_buf_mngr_info32_t)) {
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		k_ioctl.size = sizeof(struct msm_buf_mngr_info);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		rc = msm_camera_buf_mgr_fetch_buf_info(&buf_info32, &buf_info,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static long msm_bmgr_subdev_fops_compat_ioctl(struct file *file,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		struct msm_buf_mngr_info32_t buf_info32;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		struct msm_buf_mngr_info buf_info;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		rc = msm_camera_buf_mgr_fetch_buf_info(&buf_info32, &buf_info,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		rc = msm_camera_buf_mgr_update_buf_info(&buf_info32, &buf_info,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		rc = msm_camera_buf_mgr_internal_compat_ioctl(file, cmd, arg);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		struct msm_buf_mngr_main_cont_info cont_cmd;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			sizeof(struct msm_buf_mngr_main_cont_info)))
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static struct v4l2_subdev_core_ops msm_buf_mngr_subdev_core_ops = {
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	.ioctl = msm_buf_mngr_subdev_ioctl,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	msm_generic_buf_mngr_subdev_internal_ops = {
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	.open  = msm_generic_buf_mngr_open,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	.close = msm_generic_buf_mngr_close,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static const struct v4l2_subdev_ops msm_buf_mngr_subdev_ops = {
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	.core = &msm_buf_mngr_subdev_core_ops,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static const struct of_device_id msm_buf_mngr_dt_match[] = {
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static struct v4l2_file_operations msm_buf_v4l2_subdev_fops;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static long msm_bmgr_subdev_do_ioctl(
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static long msm_buf_subdev_fops_ioctl(struct file *file,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	return video_usercopy(file, cmd, arg, msm_bmgr_subdev_do_ioctl);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static int32_t __init msm_buf_mngr_init(void)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	msm_buf_mngr_dev = kzalloc(sizeof(*msm_buf_mngr_dev),
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	if (WARN_ON(!msm_buf_mngr_dev)) {
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	v4l2_subdev_init(&msm_buf_mngr_dev->subdev.sd,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		&msm_buf_mngr_subdev_ops);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	msm_cam_copy_v4l2_subdev_fops(&msm_buf_v4l2_subdev_fops);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	msm_buf_v4l2_subdev_fops.unlocked_ioctl = msm_buf_subdev_fops_ioctl;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	msm_buf_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:			msm_bmgr_subdev_fops_compat_ioctl;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	snprintf(msm_buf_mngr_dev->subdev.sd.name,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		ARRAY_SIZE(msm_buf_mngr_dev->subdev.sd.name), "msm_buf_mngr");
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	msm_buf_mngr_dev->subdev.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	v4l2_set_subdevdata(&msm_buf_mngr_dev->subdev.sd, msm_buf_mngr_dev);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	media_entity_pads_init(&msm_buf_mngr_dev->subdev.sd.entity, 0, NULL);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	msm_buf_mngr_dev->subdev.sd.entity.function =
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	msm_buf_mngr_dev->subdev.sd.internal_ops =
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		&msm_generic_buf_mngr_subdev_internal_ops;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	msm_buf_mngr_dev->subdev.close_seq = MSM_SD_CLOSE_4TH_CATEGORY;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	rc = msm_sd_register(&msm_buf_mngr_dev->subdev);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		pr_err("%s: msm_sd_register error = %d\n", __func__, rc);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	msm_buf_mngr_dev->subdev.sd.devnode->fops = &msm_buf_v4l2_subdev_fops;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	v4l2_subdev_notify(&msm_buf_mngr_dev->subdev.sd, MSM_SD_NOTIFY_REQ_CB,
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:		&msm_buf_mngr_dev->vb2_ops);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	INIT_LIST_HEAD(&msm_buf_mngr_dev->buf_qhead);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	spin_lock_init(&msm_buf_mngr_dev->buf_q_spinlock);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	mutex_init(&msm_buf_mngr_dev->cont_mutex);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	INIT_LIST_HEAD(&msm_buf_mngr_dev->cont_qhead);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:static void __exit msm_buf_mngr_exit(void)
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	msm_sd_unregister(&msm_buf_mngr_dev->subdev);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	mutex_destroy(&msm_buf_mngr_dev->cont_mutex);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:	kfree(msm_buf_mngr_dev);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:module_init(msm_buf_mngr_init);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c:module_exit(msm_buf_mngr_exit);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.h:#include <media/msmb_camera.h>
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.h:#include <media/msmb_generic_buf_mgr.h>
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.h:#include "msm.h"
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.h:#include "msm_sd.h"
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.h:struct msm_get_bufs {
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.h:struct msm_buf_mngr_device {
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.h:	struct msm_sd_subdev subdev;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.h:	struct msm_sd_req_vb2_q vb2_ops;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.h:struct msm_buf_mngr_user_buf_cont_info {
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.h:	struct msm_camera_user_buf_cont_t *paddr;
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.h:struct msm_cam_buf_mgr_req_ops {
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.h:	int (*msm_cam_buf_mgr_ops)(unsigned int cmd, void *argp);
media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.h:int msm_cam_buf_mgr_register_ops(struct msm_cam_buf_mgr_req_ops *cb_struct);
media/platform/msm/camera_v2/msm_sd.h:#include <media/msmb_camera.h>
media/platform/msm/camera_v2/msm_sd.h:struct msm_sd_close_ioctl {
media/platform/msm/camera_v2/msm_sd.h:	_IOWR('V', BASE_VIDIOC_PRIVATE + 26, struct msm_sd_close_ioctl)
media/platform/msm/camera_v2/msm_sd.h:	_IOWR('V', BASE_VIDIOC_PRIVATE + 27, struct msm_sd_close_ioctl)
media/platform/msm/camera_v2/msm_sd.h:	_IOWR('V', BASE_VIDIOC_PRIVATE + 28, struct msm_sd_close_ioctl)
media/platform/msm/camera_v2/msm_sd.h:	_IOWR('V', BASE_VIDIOC_PRIVATE + 29, struct msm_sd_close_ioctl)
media/platform/msm/camera_v2/msm_sd.h:	_IOWR('V', BASE_VIDIOC_PRIVATE + 30, struct msm_sd_close_ioctl)
media/platform/msm/camera_v2/msm_sd.h:	_IOWR('V', BASE_VIDIOC_PRIVATE + 31, struct msm_sd_close_ioctl)
media/platform/msm/camera_v2/msm_sd.h: * This is used to install Sequence in msm_sd_register.
media/platform/msm/camera_v2/msm_sd.h: * During msm_close, proper close sequence will be triggered.
media/platform/msm/camera_v2/msm_sd.h:struct msm_sd_subdev {
media/platform/msm/camera_v2/msm_sd.h:struct msm_sd_req_sd {
media/platform/msm/camera_v2/msm_sd.h:struct msm_sd_req_vb2_q {
media/platform/msm/camera_v2/msm_sd.h:int msm_sd_register(struct msm_sd_subdev *msm_subdev);
media/platform/msm/camera_v2/msm_sd.h:int msm_sd_unregister(struct msm_sd_subdev *sd);
media/platform/msm/camera_v2/msm_sd.h:struct v4l2_subdev *msm_sd_get_subdev(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/msm_sd.h:void msm_sd_put_subdev(struct v4l2_subdev *sd, struct v4l2_subdev *put);
media/platform/msm/camera_v2/msm_sd.h:void msm_cam_copy_v4l2_subdev_fops(struct v4l2_file_operations *d1);
media/platform/msm/camera_v2/msm_vb2/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/msm_vb2/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/msm_vb2
media/platform/msm/camera_v2/msm_vb2/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_vb2.o
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:#include "msm_vb2.h"
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static int msm_vb2_queue_setup(struct vb2_queue *q,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_v4l2_format_data *data = NULL;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static int msm_vb2_buf_init(struct vb2_buffer *vb)
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_buffer *msm_vb2_buf;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	session = msm_get_session_from_vb2q(vb->vb2_queue);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	stream = msm_get_stream_from_vb2q(vb->vb2_queue);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	msm_vb2_buf = container_of(vbuf, struct msm_vb2_buffer, vb2_v4l2_buf);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	msm_vb2_buf->in_freeq = 0;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static void msm_vb2_buf_queue(struct vb2_buffer *vb)
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_buffer *msm_vb2;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	msm_vb2 = container_of(vbuf, struct msm_vb2_buffer, vb2_v4l2_buf);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	if (!msm_vb2) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	session = msm_get_session_from_vb2q(vb->vb2_queue);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	stream = msm_get_stream_from_vb2q(vb->vb2_queue);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	list_add_tail(&msm_vb2->list, &stream->queued_list);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static void msm_vb2_buf_finish(struct vb2_buffer *vb)
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_buffer *msm_vb2;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_buffer *msm_vb2_entry, *temp;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	msm_vb2 = container_of(vbuf, struct msm_vb2_buffer, vb2_v4l2_buf);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	if (!msm_vb2) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	session = msm_get_session_from_vb2q(vb->vb2_queue);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	stream = msm_get_stream_from_vb2q(vb->vb2_queue);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	list_for_each_entry_safe(msm_vb2_entry, temp, &(stream->queued_list),
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		if (msm_vb2_entry == msm_vb2) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:			list_del_init(&msm_vb2_entry->list);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static void msm_vb2_stop_stream(struct vb2_queue *q)
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_buffer *msm_vb2, *temp;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	session = msm_get_session_from_vb2q(q);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	stream = msm_get_stream_from_vb2q(q);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	list_for_each_entry_safe(msm_vb2, temp, &(stream->queued_list),
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		vb2_v4l2_buf = &(msm_vb2->vb2_v4l2_buf);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		msm_vb2->in_freeq = 0;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:int msm_vb2_get_stream_state(struct msm_stream *stream)
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_buffer *msm_vb2, *temp;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	list_for_each_entry_safe(msm_vb2, temp, &(stream->queued_list), list) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		if (msm_vb2->in_freeq != 0) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:EXPORT_SYMBOL(msm_vb2_get_stream_state);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static struct vb2_ops msm_vb2_get_q_op = {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	.queue_setup	= msm_vb2_queue_setup,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	.buf_init	= msm_vb2_buf_init,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	.buf_queue	= msm_vb2_buf_queue,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	.buf_finish	= msm_vb2_buf_finish,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	.stop_streaming = msm_vb2_stop_stream,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:struct vb2_ops *msm_vb2_get_q_ops(void)
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	return &msm_vb2_get_q_op;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static void *msm_vb2_dma_contig_get_userptr(struct device *alloc_ctx,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_private_data *priv;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static void msm_vb2_dma_contig_put_userptr(void *buf_priv)
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static struct vb2_mem_ops msm_vb2_get_q_mem_op = {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	.get_userptr		= msm_vb2_dma_contig_get_userptr,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	.put_userptr		= msm_vb2_dma_contig_put_userptr,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:struct vb2_mem_ops *msm_vb2_get_q_mem_ops(void)
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	return &msm_vb2_get_q_mem_op;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static struct vb2_queue *msm_vb2_get_queue(int session_id,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	return msm_get_stream_vb2q(session_id, stream_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static struct vb2_v4l2_buffer *msm_vb2_get_buf(int session_id,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_buffer *msm_vb2 = NULL;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	session = msm_get_session(session_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	stream = msm_get_stream(session, stream_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	list_for_each_entry(msm_vb2, &(stream->queued_list), list) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		vb2_v4l2_buf = &(msm_vb2->vb2_v4l2_buf);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		if (msm_vb2->in_freeq)
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		msm_vb2->in_freeq = 1;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	msm_vb2 = NULL;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static struct vb2_v4l2_buffer *msm_vb2_get_buf_by_idx(int session_id,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_buffer *msm_vb2 = NULL;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	session = msm_get_session(session_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	stream = msm_get_stream(session, stream_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	list_for_each_entry(msm_vb2, &(stream->queued_list), list) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		vb2_v4l2_buf = &(msm_vb2->vb2_v4l2_buf);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		if ((vb2_v4l2_buf->vb2_buf.index != index) || msm_vb2->in_freeq
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		msm_vb2->in_freeq = 1;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	msm_vb2 = NULL;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static int msm_vb2_put_buf(struct vb2_v4l2_buffer *vb, int session_id,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_buffer *msm_vb2;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	session = msm_get_session(session_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	stream = msm_get_stream(session, stream_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		list_for_each_entry(msm_vb2, &(stream->queued_list), list) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:			vb2_v4l2_buf = &(msm_vb2->vb2_v4l2_buf);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		msm_vb2 =
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:			container_of(vb2_v4l2_buf, struct msm_vb2_buffer,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		if (msm_vb2->in_freeq) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:			msm_vb2->in_freeq = 0;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static int msm_vb2_buf_done(struct vb2_v4l2_buffer *vb, int session_id,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_buffer *msm_vb2;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	session = msm_get_session(session_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	stream = msm_get_stream(session, stream_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		list_for_each_entry(msm_vb2, &(stream->queued_list), list) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:			vb2_v4l2_buf = &(msm_vb2->vb2_v4l2_buf);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		msm_vb2 =
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:			container_of(vb2_v4l2_buf, struct msm_vb2_buffer,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		if (msm_vb2->in_freeq) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:			msm_vb2->in_freeq = 0;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static int msm_vb2_buf_error(struct vb2_v4l2_buffer *vb, int session_id,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_buffer *msm_vb2;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	session = msm_get_session(session_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	stream = msm_get_stream(session, stream_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		list_for_each_entry(msm_vb2, &(stream->queued_list), list) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:			vb2_v4l2_buf = &(msm_vb2->vb2_v4l2_buf);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		msm_vb2 =
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:			container_of(vb2_v4l2_buf, struct msm_vb2_buffer,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		if (msm_vb2->in_freeq) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:			msm_vb2->in_freeq = 0;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:long msm_vb2_return_buf_by_idx(int session_id, unsigned int stream_id,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_buffer *msm_vb2 = NULL;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	session = msm_get_session(session_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	stream = msm_get_stream(session, stream_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	list_for_each_entry(msm_vb2, &(stream->queued_list), list) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		vb2_v4l2_buf = &(msm_vb2->vb2_v4l2_buf);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		if (!msm_vb2->in_freeq) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:EXPORT_SYMBOL(msm_vb2_return_buf_by_idx);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:static int msm_vb2_flush_buf(int session_id, unsigned int stream_id)
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_vb2_buffer *msm_vb2;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_stream *stream;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	struct msm_session *session;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	session = msm_get_session(session_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	stream = msm_get_stream(session, stream_id);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	list_for_each_entry(msm_vb2, &(stream->queued_list), list) {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		vb2_v4l2_buf = &(msm_vb2->vb2_v4l2_buf);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:		msm_vb2->in_freeq = 0;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:int msm_vb2_request_cb(struct msm_sd_req_vb2_q *req)
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	req->get_buf = msm_vb2_get_buf;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	req->get_buf_by_idx = msm_vb2_get_buf_by_idx;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	req->get_vb2_queue = msm_vb2_get_queue;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	req->put_buf = msm_vb2_put_buf;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	req->buf_done = msm_vb2_buf_done;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	req->flush_buf = msm_vb2_flush_buf;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.c:	req->buf_error = msm_vb2_buf_error;
media/platform/msm/camera_v2/msm_vb2/msm_vb2.h:#include <linux/msm_ion.h>
media/platform/msm/camera_v2/msm_vb2/msm_vb2.h:#include <media/msmb_camera.h>
media/platform/msm/camera_v2/msm_vb2/msm_vb2.h:#include "msm.h"
media/platform/msm/camera_v2/msm_vb2/msm_vb2.h:#include "msm_sd.h"
media/platform/msm/camera_v2/msm_vb2/msm_vb2.h:struct msm_vb2_buffer {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.h:	 * cast msm_vb2_buffer to a vb2_buf.
media/platform/msm/camera_v2/msm_vb2/msm_vb2.h:struct msm_vb2_private_data {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.h:struct msm_stream {
media/platform/msm/camera_v2/msm_vb2/msm_vb2.h:struct vb2_ops *msm_vb2_get_q_ops(void);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.h:struct vb2_mem_ops *msm_vb2_get_q_mem_ops(void);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.h:int msm_vb2_request_cb(struct msm_sd_req_vb2_q *req_sd);
media/platform/msm/camera_v2/msm_vb2/msm_vb2.h:long msm_vb2_return_buf_by_idx(int session_id, unsigned int stream_id,
media/platform/msm/camera_v2/msm_vb2/msm_vb2.h:int msm_vb2_get_stream_state(struct msm_stream *stream);
media/platform/msm/camera_v2/pproc/cpp/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/pproc/cpp/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/isp/
media/platform/msm/camera_v2/pproc/cpp/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/pproc/cpp/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/pproc/cpp/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/msm_buf_mgr/
media/platform/msm/camera_v2/pproc/cpp/Makefile:obj-$(CONFIG_MSM_CPP) += msm_cpp_soc.o msm_cpp.o
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:#include <linux/msm_ion.h>
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:#include <media/msmb_camera.h>
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:#include <media/msmb_generic_buf_mgr.h>
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:#include <media/msmb_pproc.h>
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:#include "msm_cpp.h"
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:#include "msm_isp_util.h"
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:#include "msm_cam_cx_ipeak.h"
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:#define MSM_CPP_DRV_NAME "msm_cpp"
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static struct msm_cpp_vbif_data cpp_vbif;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_buffer_ops(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_send_frame_to_hardware(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_queue_cmd *frame_qcmd);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_send_command_to_hardware(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static  int msm_cpp_update_gdscr_status(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_buffer_private_ops(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_set_micro_irq_mask(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_flush_queue_and_release_buffer(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_dump_frame_cmd(struct msm_cpp_frame_info_t *frame_info);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_dump_addr(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *frame_info);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int32_t msm_cpp_reset_vbif_and_load_fw(struct cpp_device *cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:#define msm_dequeue(queue, member, pop_dir) ({	   \
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_device_queue *__q = (queue);	 \
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_queue_cmd *qcmd = NULL;	   \
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			struct msm_queue_cmd, member) :    \
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			struct msm_queue_cmd, member);    \
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:struct msm_cpp_timer_data_t {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *processed_frame[MAX_CPP_PROCESSING_FRAME];
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:struct msm_cpp_timer_t {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_timer_data_t data;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static struct msm_cpp_timer_t cpp_timer;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_set_vbif_reg_values(struct cpp_device *cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:void msm_cpp_vbif_register_error_handler(void *dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_init_bandwidth_mgr(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_camera_register_bus_client(cpp_dev->pdev, CAM_BUS_CLIENT_CPP);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_camera_update_bus_bw(CAM_BUS_CLIENT_CPP, 0, 0);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_unregister_bus_client(CAM_BUS_CLIENT_CPP);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_update_bandwidth(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_camera_update_bus_bw(CAM_BUS_CLIENT_CPP, ab, ib);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_deinit_bandwidth_mgr(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_camera_unregister_bus_client(CAM_BUS_CLIENT_CPP);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int  msm_cpp_update_bandwidth_setting(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_update_bandwidth(cpp_dev, ab, ib);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_isp_update_bandwidth(ISP_CPP, ab, ib);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_queue_init(struct msm_device_queue *queue, const char *name)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_enqueue(struct msm_device_queue *queue,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:#define msm_cpp_empty_list(queue, member) { \
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_queue_cmd *qcmd = NULL; \
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				struct msm_queue_cmd, member); \
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_notify_frame_done(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_enable_debugfs(struct cpp_device *cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_write(u32 data, void __iomem *cpp_base)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w((data), cpp_base + MSM_CPP_MICRO_FIFO_RX_DATA);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_clear_timer(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_timer_queue_update(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_clear_timer(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static uint32_t msm_cpp_read(void __iomem *cpp_base)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		tmp = msm_camera_io_r(cpp_base + MSM_CPP_MICRO_FIFO_TX_STAT);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		tmp = msm_camera_io_r(cpp_base + MSM_CPP_MICRO_FIFO_TX_DATA);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static struct msm_cpp_buff_queue_info_t *msm_cpp_get_buff_queue_entry(
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buff_queue_info_t *buff_queue_info = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static unsigned long msm_cpp_get_phy_addr(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buff_queue_info_t *buff_queue_info, uint32_t buff_index,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buffer_map_list_t *buff, *save;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static unsigned long msm_cpp_queue_buffer_info(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buff_queue_info_t *buff_queue,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buffer_info_t *buffer_info)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buffer_map_list_t *buff, *save;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		sizeof(struct msm_cpp_buffer_map_list_t), GFP_KERNEL);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_dequeue_buffer_info(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buff_queue_info_t *buff_queue,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buffer_map_list_t *buff)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static unsigned long msm_cpp_fetch_buffer_info(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buffer_info_t *buffer_info, uint32_t session_id,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buff_queue_info_t *buff_queue_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	buff_queue_info = msm_cpp_get_buff_queue_entry(cpp_dev, session_id,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	phy_addr = msm_cpp_get_phy_addr(cpp_dev, buff_queue_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		phy_addr = msm_cpp_queue_buffer_info(cpp_dev, buff_queue_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int32_t msm_cpp_dequeue_buff_info_list(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buff_queue_info_t *buff_queue_info)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buffer_map_list_t *buff, *save;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_dequeue_buffer_info(cpp_dev, buff_queue_info, buff);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_dequeue_buffer_info(cpp_dev, buff_queue_info, buff);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int32_t msm_cpp_dequeue_buff(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buff_queue_info_t *buff_queue_info, uint32_t buff_index,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buffer_map_list_t *buff, *save;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_dequeue_buffer_info(cpp_dev, buff_queue_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int32_t msm_cpp_add_buff_queue_entry(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buff_queue_info_t *buff_queue_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int32_t msm_cpp_free_buff_queue_entry(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buff_queue_info_t *buff_queue_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	buff_queue_info = msm_cpp_get_buff_queue_entry(cpp_dev, session_id,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int32_t msm_cpp_create_buff_queue(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_buff_queue_info_t *buff_queue;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		sizeof(struct msm_cpp_buff_queue_info_t), num_buffq,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_delete_buff_queue(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_dequeue_buff_info_list
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_free_buff_queue_entry(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int32_t msm_cpp_poll(void __iomem *cpp_base, u32 val)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		tmp = msm_cpp_read(cpp_base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int32_t msm_cpp_poll_rx_empty(void __iomem *cpp_base)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	tmp = msm_camera_io_r(cpp_base + MSM_CPP_MICRO_FIFO_RX_STAT);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		tmp = msm_camera_io_r(cpp_base + MSM_CPP_MICRO_FIFO_RX_STAT);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_dump_addr(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *frame_info)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_iommu_fault_reset_handler(
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w(0xB, cpp_dev->cpp_hw_base + 0xC);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w(0x1, cpp_dev->cpp_hw_base + 0x16C);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_iommu_fault_handler(struct iommu_domain *domain,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *processed_frame[MAX_CPP_PROCESSING_FRAME];
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_device_queue *queue = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x10));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			result = msm_camera_io_r(cpp_dev->cpp_hw_base + 0x10);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x10));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_io_w(0x3FFFF, cpp_dev->cpp_hw_base + 0x8);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			result = msm_camera_io_r(cpp_dev->cpp_hw_base + 0x10);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x10));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_io_w(0x0, cpp_dev->cpp_hw_base + 0x16C);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				msm_cpp_dump_addr(cpp_dev, processed_frame[i]);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				msm_cpp_dump_frame_cmd(processed_frame[i]);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_flush_queue_and_release_buffer(cpp_dev, queue_len);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_iommu_fault_handler,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_iommu_fault_reset_handler,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static irqreturn_t msm_cpp_irq(int irq_num, void *data)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_tasklet_queue_cmd *queue_cmd;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	irq_status = msm_camera_io_r(cpp_dev->base + MSM_CPP_MICRO_IRQGEN_STAT);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		tx_level = msm_camera_io_r(cpp_dev->base +
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				tx_fifo[i] = msm_camera_io_r(cpp_dev->base +
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x40));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x44));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x48));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x4C));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x50));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x54));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x60));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x64));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x70));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x74));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x80));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x84));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x88));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->base + 0x8C));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w(irq_status, cpp_dev->base + MSM_CPP_MICRO_IRQGEN_CLR);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_do_tasklet(unsigned long data)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_tasklet_queue_cmd *queue_cmd;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_tasklet_queue_cmd, list);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:					msm_cpp_timer_queue_update(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:					msm_cpp_notify_frame_done(cpp_dev, 0);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:					msm_cpp_timer_queue_update(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:					msm_cpp_notify_frame_done(cpp_dev, 0);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_camera_regulator_enable(cpp_dev->cpp_vdd,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_set_micro_clk(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_update_bandwidth(cpp_dev, 0x1000, 0x1000);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_camera_clk_enable(&cpp_dev->pdev->dev, cpp_dev->clk_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_camera_register_irq(cpp_dev->pdev, cpp_dev->irq,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_irq, IRQF_TRIGGER_RISING, "cpp", cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cam_buf_mgr_register_ops(&cpp_dev->buf_mgr_ops);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_unregister_irq(cpp_dev->pdev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_io_r(cpp_dev->cpp_hw_base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		vbif_version = msm_camera_io_r(cpp_dev->vbif_base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_io_r(cpp_dev->cpp_hw_base + 0x4);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_update_freq_tbl(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w(0x1, cpp_dev->vbif_base + 0x4);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_create_buff_queue(cpp_dev, MSM_CPP_MAX_BUFF_QUEUE);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_enable_irq(cpp_dev->irq, false);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_reset_vbif_and_load_fw(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				msm_camera_enable_irq(cpp_dev->irq, true);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_enable_irq(cpp_dev->irq, true);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_io_w_mb(0x7C8, cpp_dev->base +
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_io_w_mb(0xFFFF, cpp_dev->base +
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_set_vbif_reg_values(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_update_gdscr_status(cpp_dev, false);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_unregister_irq(cpp_dev->pdev, cpp_dev->irq, cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_clk_enable(&cpp_dev->pdev->dev, cpp_dev->clk_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_regulator_disable(cpp_dev->cpp_vdd, cpp_dev->num_reg, true);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_unregister_irq(cpp_dev->pdev, cpp_dev->irq, cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_delete_buff_queue(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_update_gdscr_status(cpp_dev, false);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_clk_enable(&cpp_dev->pdev->dev, cpp_dev->clk_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_regulator_disable(cpp_dev->cpp_vdd, cpp_dev->num_reg, true);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_update_bandwidth_setting(cpp_dev, 0, 0);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w(0x1, cpp_dev->base + MSM_CPP_MICRO_CLKEN_CTL);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w(0x1, cpp_dev->base +
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll(cpp_dev->base, MSM_CPP_MSG_ID_CMD);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w(0xFFFFFFFF, cpp_dev->base +
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_write(MSM_CPP_CMD_FW_LOAD, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_write(cpp_dev->fw->size, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_write(MSM_CPP_START_ADDRESS, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_write(*ptr_bin, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w_mb(0x00, cpp_dev->cpp_hw_base + 0xC);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_update_gdscr_status(cpp_dev, true);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll(cpp_dev->base, MSM_CPP_MSG_ID_OK);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll(cpp_dev->base, MSM_CPP_MSG_ID_CMD);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_write(MSM_CPP_CMD_EXEC_JUMP, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_write(MSM_CPP_JUMP_ADDRESS, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll(cpp_dev->base, MSM_CPP_MSG_ID_CMD);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll(cpp_dev->base, 0x1);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll(cpp_dev->base, MSM_CPP_MSG_ID_JUMP_ACK);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll(cpp_dev->base, MSM_CPP_MSG_ID_TRAILER);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int32_t msm_cpp_reset_vbif_clients(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int32_t msm_cpp_reset_vbif_and_load_fw(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_reset_vbif_clients(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		__func__, msm_camera_io_r(cpp_dev->cpp_hw_base + 0x10));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w(0x3DF77, cpp_dev->cpp_hw_base + 0x8);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		__func__, msm_camera_io_r(cpp_dev->cpp_hw_base + 0x10));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_vbif_register_error_handler(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_device_queue *processing_q = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_device_queue *eventData_q = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x4));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x40));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x44));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x48));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x4C));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x50));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x54));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x60));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x64));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x70));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x74));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x80));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x84));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x88));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_io_r(cpp_dev->cpp_hw_base + 0x8C));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_io_w(0xB, cpp_dev->cpp_hw_base + 0xC);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_io_w(0xFFFFF, cpp_dev->cpp_hw_base + 0x14);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_io_w(0x1, cpp_dev->cpp_hw_base + 0x16C);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			result = msm_camera_io_r(cpp_dev->cpp_hw_base + 0x10);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_io_w(0xFFFFF, cpp_dev->cpp_hw_base + 0x14);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_io_w(0x3DF77, cpp_dev->cpp_hw_base + 0x8);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			result = msm_camera_io_r(cpp_dev->cpp_hw_base + 0x10);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_io_w(0x0, cpp_dev->base + MSM_CPP_MICRO_CLKEN_CTL);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_clear_timer(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_empty_list(processing_q, list_frame);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_empty_list(eventData_q, list_eventdata);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_vbif_register_error_handler(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static const struct v4l2_subdev_internal_ops msm_cpp_internal_ops = {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_buffer_ops(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_buffer_private_ops(cpp_dev, buff_mgr_ops,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_buf_mngr_info *buff_mgr_info =
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			(struct msm_buf_mngr_info *)arg;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = cpp_dev->buf_mgr_ops.msm_cam_buf_mgr_ops(buff_mgr_ops,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_notify_frame_done(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_queue_cmd *frame_qcmd = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_queue_cmd *event_qcmd = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *processed_frame = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_device_queue *queue = &cpp_dev->processing_q;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_buf_mngr_info buff_mgr_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	frame_qcmd = msm_dequeue(queue, list_frame, POP_FRONT);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		event_qcmd = kzalloc(sizeof(struct msm_queue_cmd), GFP_ATOMIC);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_enqueue(&cpp_dev->eventData_q, &event_qcmd->list_eventdata);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				sizeof(struct msm_buf_mngr_info));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				rc = msm_cpp_buffer_ops(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				rc = msm_cpp_buffer_ops(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				sizeof(struct msm_buf_mngr_info));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				rc = msm_cpp_buffer_ops(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				rc = msm_cpp_buffer_ops(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		v4l2_event_queue(cpp_dev->msm_sd.sd.devnode, &v4l2_evt);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_dump_frame_cmd(struct msm_cpp_frame_info_t *frame_info)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_dump_frame_cmd(struct msm_cpp_frame_info_t *frame_info)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_flush_queue_and_release_buffer(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_notify_frame_done(cpp_dev, 1);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_set_micro_irq_mask(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w_mb(irq_mask, cpp_dev->base +
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w_mb(0xFFFF, cpp_dev->base +
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_do_timeout_work(struct work_struct *work)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_device_queue *queue = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *processed_frame[MAX_CPP_PROCESSING_FRAME];
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_enable_irq(cpp_timer.data.cpp_dev->irq, false);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_set_micro_irq_mask(cpp_dev, 1, 0x8);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_reset_vbif_and_load_fw(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_set_micro_irq_mask(cpp_dev, 1, 0x8);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_flush_queue_and_release_buffer(cpp_dev, queue_len);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_set_micro_irq_mask(cpp_dev, 1, 0x8);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_flush_queue_and_release_buffer(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_set_micro_irq_mask(cpp_dev, 1, 0x8);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_set_micro_irq_mask(cpp_dev, 1, 0x8);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_write(0x6, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_write(processed_frame[i]->cpp_cmd_msg[j],
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_write(processed_frame[i]->cpp_cmd_msg[j+i1],
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_write(0xabcdefaa, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_flush_queue_and_release_buffer(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_set_micro_irq_mask(cpp_dev, 0, 0x0);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_work_t *work =
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_send_frame_to_hardware(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_queue_cmd *frame_qcmd)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *process_frame;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_queue_cmd *qcmd = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_dump_frame_cmd(process_frame);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_enqueue(&cpp_dev->processing_q,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_write(0x6, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_write(process_frame->cpp_cmd_msg[i],
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_write(process_frame->cpp_cmd_msg[i+i1],
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_write(MSM_CPP_MSG_ID_TRAILER, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		qcmd = msm_dequeue(&cpp_dev->processing_q, list_frame,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_send_command_to_hardware(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_write(cmd_msg[i], cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_flush_frames(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static struct msm_cpp_frame_info_t *msm_cpp_get_frame(
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_camera_v4l2_ioctl_t *ioctl_ptr)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *new_frame = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	new_frame = kzalloc(sizeof(struct msm_cpp_frame_info_t), GFP_KERNEL);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			sizeof(struct msm_cpp_frame_info_t)) ? -EFAULT : 0);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_check_buf_type(struct msm_buf_mngr_info *buff_mgr_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *new_frame)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_update_frame_msg_phy_address(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *new_frame, unsigned long in_phyaddr,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int32_t msm_cpp_set_group_buffer_duplicate(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *new_frame, unsigned long out_phyaddr,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			out_phyaddr1 = msm_cpp_fetch_buffer_info(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_send_command_to_hardware(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int32_t msm_cpp_set_group_buffer(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *new_frame, unsigned long out_phyaddr,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		return msm_cpp_set_group_buffer_duplicate(cpp_dev, new_frame,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_fetch_buffer_info(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_send_command_to_hardware(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_cfg_frame(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *new_frame)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_queue_cmd *frame_qcmd = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_buf_mngr_info buff_mgr_info, dup_buff_mgr_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	enum msm_camera_buf_mngr_buf_type buf_type =
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	in_phyaddr = msm_cpp_fetch_buffer_info(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				sizeof(struct msm_buf_mngr_info));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_buffer_ops(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				msm_cpp_check_buf_type(&buff_mgr_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		out_phyaddr0 = msm_cpp_fetch_buffer_info(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		memset(&dup_buff_mgr_info, 0, sizeof(struct msm_buf_mngr_info));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_buffer_ops(cpp_dev, ioctl_cmd, idx,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		out_phyaddr1 = msm_cpp_fetch_buffer_info(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_buffer_ops(cpp_dev, VIDIOC_MSM_BUF_MNGR_PUT_BUF,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		tnr_scratch_buffer0 = msm_cpp_fetch_buffer_info(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		tnr_scratch_buffer1 = msm_cpp_fetch_buffer_info(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_update_frame_msg_phy_address(cpp_dev, new_frame,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_set_group_buffer(cpp_dev, new_frame, out_phyaddr0,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	frame_qcmd = kzalloc(sizeof(struct msm_queue_cmd), GFP_KERNEL);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_send_frame_to_hardware(cpp_dev, frame_qcmd);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_buffer_ops(cpp_dev, VIDIOC_MSM_BUF_MNGR_PUT_BUF,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_cfg(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_camera_v4l2_ioctl_t *ioctl_ptr)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *frame = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t k_frame_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				sizeof(struct msm_cpp_buffer_info_t);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	frame = msm_cpp_get_frame(ioctl_ptr);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_cfg_frame(cpp_dev, frame);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_clean_queue(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_queue_cmd *frame_qcmd = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *processed_frame = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_device_queue *queue = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		frame_qcmd = msm_dequeue(queue, list_frame, POP_FRONT);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_copy_from_ioctl_ptr(void *dst_ptr,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_camera_v4l2_ioctl_t *ioctl_ptr)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_copy_from_ioctl_ptr(void *dst_ptr,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_camera_v4l2_ioctl_t *ioctl_ptr)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int32_t msm_cpp_fw_version(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll_rx_empty(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_write(MSM_CPP_CMD_GET_FW_VER, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_write(MSM_CPP_MSG_ID_CMD, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_write(0x1, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_write(MSM_CPP_CMD_GET_FW_VER, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_write(MSM_CPP_MSG_ID_TRAILER, cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll(cpp_dev->base, MSM_CPP_MSG_ID_CMD);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll(cpp_dev->base, 0x2);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll(cpp_dev->base, MSM_CPP_MSG_ID_FW_VER);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	cpp_dev->fw_version = msm_cpp_read(cpp_dev->base);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_poll(cpp_dev->base, MSM_CPP_MSG_ID_TRAILER);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_validate_input(unsigned int cmd, void *arg,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_camera_v4l2_ioctl_t **ioctl_ptr)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		clock_rate = msm_cpp_set_core_clk(cpp_dev, clock, idx);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		clock_rate = msm_cpp_set_core_clk(cpp_dev, clock, idx);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static long msm_cpp_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_camera_v4l2_ioctl_t *ioctl_ptr = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_validate_input(cmd, arg, &ioctl_ptr);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_enable_irq(cpp_dev->irq, false);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				rc = msm_cpp_reset_vbif_and_load_fw(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_fw_version(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_enable_irq(cpp_dev->irq, true);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_cfg(cpp_dev, ioctl_ptr);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_flush_frames(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_stream_buff_info_t *u_stream_buff_info = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_stream_buff_info_t k_stream_buff_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_buff_queue_info_t *buff_queue_info = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		if (sizeof(struct msm_cpp_stream_buff_info_t) !=
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_copy_from_ioctl_ptr(u_stream_buff_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				sizeof(struct msm_cpp_buffer_info_t),
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				sizeof(struct msm_cpp_buffer_info_t)) ?
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		buff_queue_info = msm_cpp_get_buff_queue_entry(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_add_buff_queue_entry(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				msm_cpp_clear_timer(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				msm_cpp_clean_queue(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		buff_queue_info = msm_cpp_get_buff_queue_entry(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				msm_cpp_dequeue_buff(cpp_dev, buff_queue_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				msm_cpp_queue_buffer_info(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_buff_queue_info_t *buff_queue_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_copy_from_ioctl_ptr(&identity, ioctl_ptr);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		buff_queue_info = msm_cpp_get_buff_queue_entry(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_dequeue_buff_info_list(cpp_dev, buff_queue_info);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_free_buff_queue_entry(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				rc = msm_cpp_update_bandwidth_setting(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				msm_cpp_clear_timer(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				msm_cpp_clean_queue(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_device_queue *queue = &cpp_dev->eventData_q;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_queue_cmd *event_qcmd;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_frame_info_t *process_frame;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		event_qcmd = msm_dequeue(queue, list_eventdata, POP_FRONT);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			sizeof(struct msm_cpp_frame_info_t))) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		int msm_cpp_core_clk_idx;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_clock_settings_t clock_settings;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		if (ioctl_ptr->len != sizeof(struct msm_cpp_clock_settings_t)) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_copy_from_ioctl_ptr(&clock_settings, ioctl_ptr);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_cpp_core_clk_idx = msm_cpp_get_clock_index(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			if (msm_cpp_core_clk_idx < 0) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_update_bandwidth_setting(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				rc = msm_cpp_update_bandwidth_setting(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:					msm_cpp_core_clk_idx);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				clock_rate = msm_cpp_set_core_clk(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:					msm_cpp_core_clk_idx);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_isp_util_update_clk_rate(clock_settings.clock_rate);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_pproc_queue_buf_info queue_buf_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		if (ioctl_ptr->len != sizeof(struct msm_pproc_queue_buf_info)) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_copy_from_ioctl_ptr(&queue_buf_info, ioctl_ptr);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_buffer_ops(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_buffer_ops(cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_buf_mngr_info buff_mgr_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_frame_info_t frame_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			sizeof(struct msm_cpp_frame_info_t))) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_copy_from_ioctl_ptr(&frame_info, ioctl_ptr);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		memset(&buff_mgr_info, 0, sizeof(struct msm_buf_mngr_info));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_buffer_ops(cpp_dev, ioctl_cmd, idx,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_buffer_ops(cpp_dev, VIDIOC_MSM_BUF_MNGR_BUF_ERROR,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			struct msm_camera_smmu_attach_type cpp_attach_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				sizeof(struct msm_camera_smmu_attach_type)) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_copy_from_ioctl_ptr(&cpp_attach_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			struct msm_camera_smmu_attach_type cpp_attach_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				sizeof(struct msm_camera_smmu_attach_type)) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_copy_from_ioctl_ptr(&cpp_attach_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_unsubscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static struct v4l2_subdev_core_ops msm_cpp_subdev_core_ops = {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	.ioctl = msm_cpp_subdev_ioctl,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	.subscribe_event = msm_cpp_subscribe_event,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	.unsubscribe_event = msm_cpp_unsubscribe_event,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static const struct v4l2_subdev_ops msm_cpp_subdev_ops = {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	.core = &msm_cpp_subdev_core_ops,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static long msm_cpp_subdev_do_ioctl(
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_camera_v4l2_ioctl_t *ioctl_ptr = arg;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_frame_info_t inst_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		memset(&inst_info, 0, sizeof(struct msm_cpp_frame_info_t));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				sizeof(struct msm_cpp_frame_info_t))) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static long msm_cpp_subdev_fops_ioctl(struct file *file, unsigned int cmd,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	return video_usercopy(file, cmd, arg, msm_cpp_subdev_do_ioctl);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static struct msm_cpp_frame_info_t *get_64bit_cpp_frame_from_compat(
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_camera_v4l2_ioctl_t *kp_ioctl)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info32_t *new_frame32 = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t *new_frame = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	new_frame32 = kzalloc(sizeof(struct msm_cpp_frame_info32_t),
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	new_frame = kzalloc(sizeof(struct msm_cpp_frame_info_t), GFP_KERNEL);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			sizeof(struct msm_cpp_frame_info32_t)) ? -EFAULT : 0);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void get_compat_frame_from_64bit(struct msm_cpp_frame_info_t *frame,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info32_t *k32_frame)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static long msm_cpp_subdev_fops_compat_ioctl(struct file *file,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_camera_v4l2_ioctl_t kp_ioctl;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_camera_v4l2_ioctl32_t up32_ioctl;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_clock_settings_t clock_settings;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_pproc_queue_buf_info k_queue_buf;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_stream_buff_info_t k_cpp_buff_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info32_t k32_frame_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_cpp_frame_info_t k64_frame_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	struct msm_camera_smmu_attach_type kb_cpp_smmu_attach_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_frame_info32_t k32_frame_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_frame_info_t *cpp_frame = NULL;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = msm_cpp_cfg_frame(cpp_dev, cpp_frame);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_frame_info32_t inst_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		memset(&inst_info, 0, sizeof(struct msm_cpp_frame_info32_t));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			&inst_info, sizeof(struct msm_cpp_frame_info32_t))) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_stream_buff_info32_t __user *u32_cpp_buff_info =
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			(struct msm_cpp_stream_buff_info32_t __user *)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			(struct msm_cpp_buffer_info_t *)compat_ptr(p);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				struct msm_cpp_stream_buff_info32_t)) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				sizeof(struct msm_cpp_stream_buff_info_t);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_device_queue *queue = &cpp_dev->eventData_q;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_queue_cmd *event_qcmd;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_frame_info_t *process_frame;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_frame_info32_t k32_process_frame;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		event_qcmd = msm_dequeue(queue, list_eventdata, POP_FRONT);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			sizeof(struct msm_cpp_frame_info32_t))) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_cpp_clock_settings32_t __user *clock_settings32 =
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			(struct msm_cpp_clock_settings32_t __user *)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				struct msm_cpp_clock_settings32_t)) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				sizeof(struct msm_cpp_clock_settings_t);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_pproc_queue_buf_info32_t __user *u32_queue_buf =
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			(struct msm_pproc_queue_buf_info32_t __user *)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		kp_ioctl.len = sizeof(struct msm_pproc_queue_buf_info);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		if (kp_ioctl.len != sizeof(struct msm_cpp_frame_info32_t)) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		kp_ioctl.len = sizeof(struct msm_cpp_frame_info_t);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		if ((kp_ioctl.len != sizeof(struct msm_camera_smmu_attach_type))
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static struct v4l2_file_operations msm_cpp_v4l2_subdev_fops = {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	.unlocked_ioctl = msm_cpp_subdev_fops_ioctl,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	.compat_ioctl32 = msm_cpp_subdev_fops_compat_ioctl,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static  int msm_cpp_update_gdscr_status(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	int msm_cpp_reg_idx;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_reg_idx = msm_cpp_get_regulator_index(cpp_dev, "vdd");
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	if (msm_cpp_reg_idx < 0) {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_camera_regulator_set_mode(cpp_dev->cpp_vdd +
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_reg_idx, 1, status);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void msm_cpp_set_vbif_reg_values(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:					 __func__, msm_camera_io_r(
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:				msm_camera_io_w(val, cpp_dev->vbif_base + reg);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:					 __func__, msm_camera_io_r(
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_buffer_private_ops(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_camera_private_ioctl_arg ioctl_arg;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		struct msm_buf_mngr_info *buff_mgr_info =
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			(struct msm_buf_mngr_info *)arg;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		ioctl_arg.size = sizeof(struct msm_buf_mngr_info);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = cpp_dev->buf_mgr_ops.msm_cam_buf_mgr_ops(buff_mgr_ops,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			rc = cpp_dev->buf_mgr_ops.msm_cam_buf_mgr_ops(
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	v4l2_subdev_init(&cpp_dev->msm_sd.sd, &msm_cpp_subdev_ops);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	cpp_dev->msm_sd.sd.internal_ops = &msm_cpp_internal_ops;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	snprintf(cpp_dev->msm_sd.sd.name, ARRAY_SIZE(cpp_dev->msm_sd.sd.name),
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	cpp_dev->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	cpp_dev->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_EVENTS;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	v4l2_set_subdevdata(&cpp_dev->msm_sd.sd, cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	platform_set_drvdata(pdev, &cpp_dev->msm_sd.sd);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	memset(&cpp_vbif, 0, sizeof(struct msm_cpp_vbif_data));
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_get_reg_base(pdev, "cpp", true);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_get_reg_base(pdev, "cpp_vbif", false);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_camera_get_reg_base(pdev, "cpp_hw", true);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	cpp_dev->irq = msm_camera_get_irq(pdev, "cpp");
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_camera_get_clk_info(pdev, &cpp_dev->clk_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_set_clk_flags(cpp_dev->cpp_clk[i],
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:			msm_camera_set_clk_flags(cpp_dev->cpp_clk[i],
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_camera_get_reset_info(pdev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_camera_get_regulator_info(pdev, &cpp_dev->cpp_vdd,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_fetch_dt_params(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	rc = msm_cpp_read_payload_params_from_dt(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_cpp_init_bandwidth_mgr(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		rc = msm_isp_init_bandwidth_mgr(NULL, ISP_CPP);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	media_entity_pads_init(&cpp_dev->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	cpp_dev->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_CPP;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	cpp_dev->msm_sd.sd.entity.name = pdev->name;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	cpp_dev->msm_sd.close_seq = MSM_SD_CLOSE_3RD_CATEGORY;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_sd_register(&cpp_dev->msm_sd);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cam_copy_v4l2_subdev_fops(&msm_cpp_v4l2_subdev_fops);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_v4l2_subdev_fops.unlocked_ioctl = msm_cpp_subdev_fops_ioctl;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_subdev_fops_compat_ioctl;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	cpp_dev->msm_sd.sd.devnode->fops = &msm_cpp_v4l2_subdev_fops;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w(0x0, cpp_dev->base +
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w(0xFFFF, cpp_dev->base +
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_io_w(0x80000000, cpp_dev->base + 0xF0);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_enable_debugfs(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_queue_init(&cpp_dev->eventData_q, "eventdata");
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_queue_init(&cpp_dev->processing_q, "frame");
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	tasklet_init(&cpp_dev->cpp_tasklet, msm_cpp_do_tasklet,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	cpp_dev->timer_wq = create_workqueue("msm_cpp_workqueue");
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	cpp_dev->work = kmalloc(sizeof(struct msm_cpp_work_t),
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	INIT_WORK((struct work_struct *)cpp_dev->work, msm_cpp_do_timeout_work);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_deinit_bandwidth_mgr(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_isp_deinit_bandwidth_mgr(ISP_CPP);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	media_entity_cleanup(&cpp_dev->msm_sd.sd.entity);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_sd_unregister(&cpp_dev->msm_sd);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_put_clk_info(pdev, &cpp_dev->clk_info, &cpp_dev->cpp_clk,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_put_reg_base(pdev, cpp_dev->cpp_hw_base, "cpp_hw", true);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_put_reg_base(pdev, cpp_dev->vbif_base, "cpp_vbif", false);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_put_reg_base(pdev, cpp_dev->base, "cpp", true);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_put_reg_base(pdev, cpp_dev->camss_cpp_base,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static const struct of_device_id msm_cpp_dt_match[] = {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_cpp_deinit_bandwidth_mgr(cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		msm_isp_deinit_bandwidth_mgr(ISP_CPP);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_sd_unregister(&cpp_dev->msm_sd);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_put_reg_base(dev, cpp_dev->camss_cpp_base,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_put_reg_base(dev, cpp_dev->base, "cpp", true);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_put_reg_base(dev, cpp_dev->vbif_base, "cpp_vbif", false);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_put_reg_base(dev, cpp_dev->cpp_hw_base, "cpp_hw", true);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_put_regulators(dev, &cpp_dev->cpp_vdd,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_put_clk_info(dev, &cpp_dev->clk_info,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_camera_unregister_bus_client(CAM_BUS_CLIENT_CPP);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:		.of_match_table = msm_cpp_dt_match,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int __init msm_cpp_init_module(void)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static void __exit msm_cpp_exit_module(void)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_debugfs_error_s(void *data, u64 val)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	msm_cpp_debugfs_error_s, "%llu\n");
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:static int msm_cpp_enable_debugfs(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:	debugfs_base = debugfs_create_dir("msm_cpp", NULL);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:module_init(msm_cpp_init_module);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c:module_exit(msm_cpp_exit_module);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:#include "msm_generic_buf_mgr.h"
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:#include "msm_sd.h"
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:#include <media/msmb_pproc.h>
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:struct msm_cpp_vbif_data {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:enum msm_queue {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:struct msm_queue_cmd {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	enum msm_queue type;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:struct msm_device_queue {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:struct msm_cpp_tasklet_queue_cmd {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:struct msm_cpp_buffer_map_info_t {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	struct msm_cpp_buffer_info_t buff_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:struct msm_cpp_buffer_map_list_t {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	struct msm_cpp_buffer_map_info_t map_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:struct msm_cpp_buff_queue_info_t {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:struct msm_cpp_work_t {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:struct msm_cpp_payload_params {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	struct msm_cam_clk_info *clk_info;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	struct msm_cam_regulator *cpp_vdd;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	struct msm_cpp_work_t *work;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	/* Reusing proven tasklet from msm isp */
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	struct msm_cpp_tasklet_queue_cmd
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	struct msm_device_queue eventData_q; /* V4L2 Event Payload Queue */
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	struct msm_device_queue processing_q;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	struct msm_cpp_buff_queue_info_t *buff_queue;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	struct msm_cam_buf_mgr_req_ops buf_mgr_ops;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	struct msm_cpp_payload_params payload_params;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:	struct msm_cpp_vbif_data *vbif_data;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:int msm_cpp_set_micro_clk(struct cpp_device *cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:int msm_update_freq_tbl(struct cpp_device *cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:int msm_cpp_get_clock_index(struct cpp_device *cpp_dev, const char *clk_name);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:int msm_cpp_get_regulator_index(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:long msm_cpp_set_core_clk(struct cpp_device *cpp_dev, long rate, int idx);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:void msm_cpp_fetch_dt_params(struct cpp_device *cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:int msm_cpp_read_payload_params_from_dt(struct cpp_device *cpp_dev);
media/platform/msm/camera_v2/pproc/cpp/msm_cpp.h:void msm_cpp_vbif_register_error_handler(void *dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c://#include <linux/clk/msm-clk-provider.h>
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:#include <media/msmb_pproc.h>
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:#include "msm_cpp.h"
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:void msm_cpp_fetch_dt_params(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:int msm_cpp_get_clock_index(struct cpp_device *cpp_dev, const char *clk_name)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:int msm_cpp_get_regulator_index(struct cpp_device *cpp_dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:int msm_cpp_set_micro_clk(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:int msm_update_freq_tbl(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:	int msm_cpp_core_clk_idx;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:	msm_cpp_core_clk_idx = msm_cpp_get_clock_index(cpp_dev, "cpp_core_clk");
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:	if (msm_cpp_core_clk_idx < 0)  {
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:		rc = msm_cpp_core_clk_idx;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:long msm_cpp_set_core_clk(struct cpp_device *cpp_dev, long rate, int idx)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:	rc = msm_camera_clk_set_rate(&cpp_dev->pdev->dev,
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:int msm_cpp_read_payload_params_from_dt(struct cpp_device *cpp_dev)
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:	struct msm_cpp_payload_params *payload_params;
media/platform/msm/camera_v2/pproc/cpp/msm_cpp_soc.c:	memset(payload_params, 0x0, sizeof(struct msm_cpp_payload_params));
media/platform/msm/camera_v2/pproc/vpe/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/pproc/vpe/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/pproc/vpe/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_vpe.o
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:#include <linux/msm_ion.h>
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:#include <linux/msm_iommu_domains.h>
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:#include <media/msmb_generic_buf_mgr.h>
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:#include <media/msmb_pproc.h>
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:#include "msm_vpe.h"
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:#define MSM_VPE_DRV_NAME "msm_vpe"
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:#define msm_dequeue(queue, member) ({					\
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:			struct msm_device_queue *__q = (queue);		\
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:			struct msm_queue_cmd *qcmd = 0;			\
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:							struct msm_queue_cmd, \
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static void msm_queue_init(struct msm_device_queue *queue, const char *name)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static struct msm_cam_clk_info vpe_clk_info[] = {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static int msm_vpe_notify_frame_done(struct vpe_device *vpe_dev);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static void msm_enqueue(struct msm_device_queue *queue,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static struct msm_vpe_buff_queue_info_t *msm_vpe_get_buff_queue_entry(
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buff_queue_info_t *buff_queue_info = NULL;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static unsigned long msm_vpe_get_phy_addr(struct vpe_device *vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buff_queue_info_t *buff_queue_info, uint32_t buff_index,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buffer_map_list_t *buff, *save;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static unsigned long msm_vpe_queue_buffer_info(struct vpe_device *vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buff_queue_info_t *buff_queue,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buffer_info_t *buffer_info)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buffer_map_list_t *buff, *save;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		sizeof(struct msm_vpe_buffer_map_list_t), GFP_KERNEL);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	if (msm_map_dma_buf(buff->map_info.dbuf, buff->map_info.table,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static void msm_vpe_dequeue_buffer_info(struct vpe_device *vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buffer_map_list_t *buff)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_unmap_dma_buf(buff->map_info.table, vpe_dev->domain_num, 0);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static unsigned long msm_vpe_fetch_buffer_info(struct vpe_device *vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buffer_info_t *buffer_info, uint32_t session_id,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buff_queue_info_t *buff_queue_info;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	buff_queue_info = msm_vpe_get_buff_queue_entry(vpe_dev, session_id,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	phy_addr = msm_vpe_get_phy_addr(vpe_dev, buff_queue_info,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		phy_addr = msm_vpe_queue_buffer_info(vpe_dev, buff_queue_info,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static int32_t msm_vpe_enqueue_buff_info_list(struct vpe_device *vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_stream_buff_info_t *stream_buff_info)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buff_queue_info_t *buff_queue_info;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	buff_queue_info = msm_vpe_get_buff_queue_entry(vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		msm_vpe_queue_buffer_info(vpe_dev, buff_queue_info,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static int32_t msm_vpe_dequeue_buff_info_list(struct vpe_device *vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buff_queue_info_t *buff_queue_info)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buffer_map_list_t *buff, *save;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		msm_vpe_dequeue_buffer_info(vpe_dev, buff);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		msm_vpe_dequeue_buffer_info(vpe_dev, buff);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static int32_t msm_vpe_add_buff_queue_entry(struct vpe_device *vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buff_queue_info_t *buff_queue_info;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static int32_t msm_vpe_free_buff_queue_entry(struct vpe_device *vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buff_queue_info_t *buff_queue_info;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	buff_queue_info = msm_vpe_get_buff_queue_entry(vpe_dev, session_id,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static int32_t msm_vpe_create_buff_queue(struct vpe_device *vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_buff_queue_info_t *buff_queue;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		sizeof(struct msm_vpe_buff_queue_info_t), num_buffq,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static void msm_vpe_delete_buff_queue(struct vpe_device *vpe_dev)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:			msm_vpe_free_buff_queue_entry(vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	vpe_dev->client = msm_ion_client_create("vpe");
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static irqreturn_t msm_vpe_irq(int irq_num, void *data)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_tasklet_queue_cmd *queue_cmd;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	irq_status = msm_camera_io_r_mb(vpe_dev->base +
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w_mb(irq_status, vpe_dev->base + VPE_INTR_CLEAR_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(0, vpe_dev->base + VPE_INTR_ENABLE_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static void msm_vpe_do_tasklet(unsigned long data)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_tasklet_queue_cmd *queue_cmd;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:					struct msm_vpe_tasklet_queue_cmd, list);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		msm_vpe_notify_frame_done(vpe_dev);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	rc = msm_cam_clk_enable(&vpe_dev->pdev->dev, vpe_clk_info,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		rc = request_irq(vpe_dev->irq->start, msm_vpe_irq,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	vpe_dev->buf_mgr_subdev = msm_buf_mngr_get_subdev();
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_vpe_create_buff_queue(vpe_dev, MSM_VPE_MAX_BUFF_QUEUE);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_vpe_delete_buff_queue(vpe_dev);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_cam_clk_enable(&vpe_dev->pdev->dev, vpe_clk_info,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static const struct v4l2_subdev_internal_ops msm_vpe_internal_ops = {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static int msm_vpe_buffer_ops(struct vpe_device *vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	uint32_t buff_mgr_ops, struct msm_buf_mngr_info *buff_mgr_info)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static int msm_vpe_notify_frame_done(struct vpe_device *vpe_dev)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_queue_cmd *frame_qcmd;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_queue_cmd *event_qcmd;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_frame_info_t *processed_frame;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_device_queue *queue = &vpe_dev->processing_q;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_buf_mngr_info buff_mgr_info;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		frame_qcmd = msm_dequeue(queue, list_frame);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		event_qcmd = kzalloc(sizeof(struct msm_queue_cmd), GFP_ATOMIC);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		msm_enqueue(&vpe_dev->eventData_q, &event_qcmd->list_eventdata);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:			rc = msm_vpe_buffer_ops(vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		v4l2_event_queue(vpe_dev->msm_sd.sd.devnode, &v4l2_evt);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:			struct msm_vpe_frame_strip_info strip_info)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	temp = msm_camera_io_r(vpe_dev->base + VPE_OP_MODE_OFFSET) | 0x3;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(temp, vpe_dev->base + VPE_OP_MODE_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(src_roi, vpe_dev->base + VPE_SRC_SIZE_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(src_xy, vpe_dev->base +
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(strip_info.phase_step_x, vpe_dev->base +
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(strip_info.phase_step_y, vpe_dev->base +
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(strip_info.phase_init_x, vpe_dev->base +
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(strip_info.phase_init_y, vpe_dev->base +
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(srcP0, vpe_dev->base + VPE_SRCP0_ADDR_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(srcP1, vpe_dev->base + VPE_SRCP1_ADDR_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(outP0, vpe_dev->base + VPE_OUTP0_ADDR_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(outP1, vpe_dev->base + VPE_OUTP1_ADDR_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w_mb(1, vpe_dev->base + VPE_INTR_ENABLE_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_dump(vpe_dev->base, 0x120, CONFIG_MSM_VPE_DBG);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_dump(vpe_dev->base + 0x00400, 0x18, CONFIG_MSM_VPE_DBG);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_dump(vpe_dev->base + 0x10000, 0x250, CONFIG_MSM_VPE_DBG);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_dump(vpe_dev->base + 0x30000, 0x20, CONFIG_MSM_VPE_DBG);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_dump(vpe_dev->base + 0x50000, 0x30, CONFIG_MSM_VPE_DBG);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_dump(vpe_dev->base + 0x50400, 0x10, CONFIG_MSM_VPE_DBG);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	 * msm_vpe_irq will fire.
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w_mb(1, vpe_dev->base + VPE_DL0_START_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(0x25, vpe_dev->base + VPE_AXI_ARB_2_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	vpe_version = msm_camera_io_r(
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(0, vpe_dev->base + VPE_INTR_ENABLE_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(0x1fffff, vpe_dev->base + VPE_INTR_CLEAR_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(0x10, vpe_dev->base + VPE_SW_RESET_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		rc = msm_camera_io_r(
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(VPE_AXI_RD_ARB_CONFIG_VALUE,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(VPE_CGC_ENABLE_VALUE,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(1, vpe_dev->base + VPE_CMD_MODE_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(VPE_DEFAULT_OP_MODE_VALUE,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(VPE_DEFAULT_SCALE_CONFIG,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		msm_camera_io_w(*(++p),
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		msm_camera_io_w(*(++p),
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(*p, vpe_dev->base + VPE_SRC_FORMAT_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(*(++p),
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(*(++p), vpe_dev->base + VPE_SRC_IMAGE_SIZE_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(*(++p), vpe_dev->base + VPE_SRC_YSTRIDE1_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(*(++p), vpe_dev->base + VPE_SRC_SIZE_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(*(++p), vpe_dev->base + VPE_SRC_XY_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(*p, vpe_dev->base + VPE_OUT_FORMAT_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(*(++p),
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(*(++p), vpe_dev->base + VPE_OUT_YSTRIDE1_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(*(++p), vpe_dev->base + VPE_OUT_SIZE_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(*(++p), vpe_dev->base + VPE_OUT_XY_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_camera_io_w(*p, vpe_dev->base + VPE_OP_MODE_OFFSET);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c: * msm_vpe_transaction_setup() - send setup for one frame to VPE
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c: * See msm_vpe.h for the expected format of `data'
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static void msm_vpe_transaction_setup(struct vpe_device *vpe_dev, void *data)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static int msm_vpe_send_frame_to_hardware(struct vpe_device *vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_queue_cmd *frame_qcmd)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_frame_info_t *process_frame;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		msm_enqueue(&vpe_dev->processing_q,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static int msm_vpe_cfg(struct vpe_device *vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_camera_v4l2_ioctl_t *ioctl_ptr)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_queue_cmd *frame_qcmd = NULL;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_vpe_frame_info_t *new_frame =
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		kzalloc(sizeof(struct msm_vpe_frame_info_t), GFP_KERNEL);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_buf_mngr_info buff_mgr_info;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:			sizeof(struct msm_vpe_frame_info_t));
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	in_phyaddr = msm_vpe_fetch_buffer_info(vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		sizeof(struct msm_vpe_buffer_info_t));
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	memset(&buff_mgr_info, 0, sizeof(struct msm_buf_mngr_info));
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	rc = msm_vpe_buffer_ops(vpe_dev, VIDIOC_MSM_BUF_MNGR_GET_BUF,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	out_phyaddr = msm_vpe_fetch_buffer_info(vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	frame_qcmd = kzalloc(sizeof(struct msm_queue_cmd), GFP_KERNEL);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	rc = msm_vpe_send_frame_to_hardware(vpe_dev, frame_qcmd);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_vpe_buffer_ops(vpe_dev, VIDIOC_MSM_BUF_MNGR_PUT_BUF,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static long msm_vpe_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_camera_v4l2_ioctl_t *ioctl_ptr = arg;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		struct msm_vpe_transaction_setup_cfg *cfg;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		msm_vpe_transaction_setup(vpe_dev, (void *)cfg);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		rc = msm_vpe_cfg(vpe_dev, ioctl_ptr);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		struct msm_vpe_stream_buff_info_t *u_stream_buff_info;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		struct msm_vpe_stream_buff_info_t k_stream_buff_info;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		if (sizeof(struct msm_vpe_stream_buff_info_t) !=
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:			sizeof(struct msm_vpe_buffer_info_t), GFP_KERNEL);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:				sizeof(struct msm_vpe_buffer_info_t)) ?
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		rc = msm_vpe_add_buff_queue_entry(vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:			rc = msm_vpe_enqueue_buff_info_list(vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		struct msm_vpe_buff_queue_info_t *buff_queue_info;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		buff_queue_info = msm_vpe_get_buff_queue_entry(vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		msm_vpe_dequeue_buff_info_list(vpe_dev, buff_queue_info);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		rc = msm_vpe_free_buff_queue_entry(vpe_dev,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		struct msm_device_queue *queue = &vpe_dev->eventData_q;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		struct msm_queue_cmd *event_qcmd;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		struct msm_vpe_frame_info_t *process_frame;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		event_qcmd = msm_dequeue(queue, list_eventdata);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:			sizeof(struct msm_vpe_frame_info_t))) {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static int msm_vpe_subscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static int msm_vpe_unsubscribe_event(struct v4l2_subdev *sd, struct v4l2_fh *fh,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static struct v4l2_subdev_core_ops msm_vpe_subdev_core_ops = {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	.ioctl = msm_vpe_subdev_ioctl,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	.subscribe_event = msm_vpe_subscribe_event,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	.unsubscribe_event = msm_vpe_unsubscribe_event,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static const struct v4l2_subdev_ops msm_vpe_subdev_ops = {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	.core = &msm_vpe_subdev_core_ops,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static struct v4l2_file_operations msm_vpe_v4l2_subdev_fops;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static long msm_vpe_subdev_do_ioctl(
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		struct msm_camera_v4l2_ioctl_t *ioctl_ptr = arg;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		struct msm_vpe_frame_info_t inst_info;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		memset(&inst_info, 0, sizeof(struct msm_vpe_frame_info_t));
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:				sizeof(struct msm_vpe_frame_info_t))) {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static long msm_vpe_subdev_fops_ioctl(struct file *file, unsigned int cmd,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	return video_usercopy(file, cmd, arg, msm_vpe_subdev_do_ioctl);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_iova_partition vpe_iommu_partition = {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	struct msm_iova_layout vpe_iommu_layout = {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	return msm_register_domain(&vpe_iommu_layout);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	v4l2_subdev_init(&vpe_dev->msm_sd.sd, &msm_vpe_subdev_ops);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	vpe_dev->msm_sd.sd.internal_ops = &msm_vpe_internal_ops;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	snprintf(vpe_dev->msm_sd.sd.name, ARRAY_SIZE(vpe_dev->msm_sd.sd.name),
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	vpe_dev->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	vpe_dev->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_EVENTS;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	v4l2_set_subdevdata(&vpe_dev->msm_sd.sd, vpe_dev);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	platform_set_drvdata(pdev, &vpe_dev->msm_sd.sd);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:		msm_get_iommu_domain(vpe_dev->domain_num);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	vpe_dev->iommu_ctx_src = msm_iommu_get_ctx("vpe_src");
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	vpe_dev->iommu_ctx_dst = msm_iommu_get_ctx("vpe_dst");
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	media_entity_init(&vpe_dev->msm_sd.sd.entity, 0, NULL, 0);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	vpe_dev->msm_sd.sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	vpe_dev->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_VPE;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	vpe_dev->msm_sd.sd.entity.name = pdev->name;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_sd_register(&vpe_dev->msm_sd);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_cam_copy_v4l2_subdev_fops(&msm_vpe_v4l2_subdev_fops);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	vpe_dev->msm_sd.sd.devnode->fops = &msm_vpe_v4l2_subdev_fops;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	vpe_dev->msm_sd.sd.entity.revision = vpe_dev->msm_sd.sd.devnode->num;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_queue_init(&vpe_dev->eventData_q, "vpe-eventdata");
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_queue_init(&vpe_dev->processing_q, "vpe-frame");
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	tasklet_init(&vpe_dev->vpe_tasklet, msm_vpe_do_tasklet,
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_sd_unregister(&vpe_dev->msm_sd);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:	msm_sd_unregister(&vpe_dev->msm_sd);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static int __init msm_vpe_init_module(void)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:static void __exit msm_vpe_exit_module(void)
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:module_init(msm_vpe_init_module);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.c:module_exit(msm_vpe_exit_module);
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:#include "msm_sd.h"
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h: * The format of the msm_vpe_transaction_setup_cfg is as follows:
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:struct msm_vpe_transaction_setup_cfg {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:struct msm_queue_cmd {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:struct msm_device_queue {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:struct msm_vpe_tasklet_queue_cmd {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:struct msm_vpe_buffer_map_info_t {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:	struct msm_vpe_buffer_info_t buff_info;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:struct msm_vpe_buffer_map_list_t {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:	struct msm_vpe_buffer_map_info_t map_info;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:struct msm_vpe_buff_queue_info_t {
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:	/* Reusing proven tasklet from msm isp */
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:	struct msm_vpe_tasklet_queue_cmd
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:	struct msm_device_queue eventData_q; /* V4L2 Event Payload Queue */
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:	struct msm_device_queue processing_q;
media/platform/msm/camera_v2/pproc/vpe/msm_vpe.h:	struct msm_vpe_buff_queue_info_t *buff_queue;
media/platform/msm/camera_v2/sensor/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/sensor/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/sensor/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/msm_vb2
media/platform/msm/camera_v2/sensor/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/camera
media/platform/msm/camera_v2/sensor/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/sensor/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
media/platform/msm/camera_v2/sensor/Makefile:obj-$(CONFIG_MSM_CAMERA_SENSOR) += msm_sensor_init.o msm_sensor_driver.o msm_sensor.o
media/platform/msm/camera_v2/sensor/actuator/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/sensor/actuator/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/sensor/actuator/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/sensor/actuator/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
media/platform/msm/camera_v2/sensor/actuator/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_actuator.o
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:#include "msm_actuator.h"
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:#include "msm_cci.h"
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:DEFINE_MSM_MUTEX(msm_actuator_mutex);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct v4l2_file_operations msm_actuator_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_power_up(struct msm_actuator_ctrl_t *a_ctrl);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_power_down(struct msm_actuator_ctrl_t *a_ctrl);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct msm_actuator msm_vcm_actuator_table;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct msm_actuator msm_piezo_actuator_table;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct msm_actuator msm_hvcm_actuator_table;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct msm_actuator msm_bivcm_actuator_table;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct i2c_driver msm_actuator_i2c_driver;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct msm_actuator *actuators[] = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	&msm_vcm_actuator_table,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	&msm_piezo_actuator_table,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	&msm_hvcm_actuator_table,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	&msm_bivcm_actuator_table,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_piezo_set_default_focus(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_move_params_t *move_params)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_camera_i2c_reg_setting reg_setting;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static void msm_actuator_parse_i2c_params(struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_reg_params_t *write_arr = NULL;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_camera_i2c_reg_array *i2c_tbl = NULL;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int msm_actuator_bivcm_handle_i2c_ops(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_reg_params_t *write_arr = a_ctrl->reg_tbl;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_camera_i2c_reg_array i2c_tbl;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_camera_i2c_reg_setting reg_setting;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	enum msm_camera_i2c_reg_addr_type save_addr_type =
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_init_focus(struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	enum msm_camera_i2c_reg_addr_type save_addr_type;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static void msm_actuator_write_focus(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int msm_actuator_bivcm_write_focus(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		rc = msm_actuator_bivcm_handle_i2c_ops(a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:			pr_err("%s:%d msm_actuator_bivcm_handle_i2c_ops failed\n",
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		rc = msm_actuator_bivcm_handle_i2c_ops(a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:			pr_err("%s:%d msm_actuator_bivcm_handle_i2c_ops failed\n",
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_piezo_move_focus(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_move_params_t *move_params)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_camera_i2c_reg_setting reg_setting;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_move_focus(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_move_params_t *move_params)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_camera_i2c_reg_setting reg_setting;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_bivcm_move_focus(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_move_params_t *move_params)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:			rc = msm_actuator_bivcm_write_focus(a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:			rc = msm_actuator_bivcm_write_focus(a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_park_lens(struct msm_actuator_ctrl_t *a_ctrl)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_camera_i2c_reg_setting reg_setting;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_bivcm_init_step_table(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_set_info_t *set_info)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_init_step_table(struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_set_info_t *set_info)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_set_default_focus(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_move_params_t *move_params)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_vreg_control(struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_vreg *vreg_cfg;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:			rc = msm_camera_config_single_vreg(&(a_ctrl->pdev->dev),
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:			rc = msm_camera_config_single_vreg(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_power_down(struct msm_actuator_ctrl_t *a_ctrl)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	enum msm_sensor_power_seq_gpio_t gpio;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		rc = msm_actuator_vreg_control(a_ctrl, 0);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:				rc = msm_camera_request_gpio_table(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_set_position(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_set_position_t *set_pos)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_camera_i2c_reg_setting reg_setting;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_bivcm_set_position(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_set_position_t *set_pos)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		rc = msm_actuator_bivcm_handle_i2c_ops(a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_set_param(struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_set_info_t *set_info)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_camera_cci_client *cci_client = NULL;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		kmalloc(sizeof(struct msm_camera_i2c_reg_array) *
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		sizeof(struct msm_actuator_reg_params_t))) {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int msm_actuator_init(struct msm_actuator_ctrl_t *a_ctrl)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_config(struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_cfg_data *cdata =
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		(struct msm_actuator_cfg_data *)argp;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		rc = msm_actuator_init(a_ctrl);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:			pr_err("msm_actuator_init failed %d\n", rc);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		rc = msm_actuator_set_param(a_ctrl, &cdata->cfg.set_info);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		rc = msm_actuator_power_down(a_ctrl);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:			pr_err("msm_actuator_power_down failed %d\n", rc);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		rc = msm_actuator_power_up(a_ctrl);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_get_subdev_id(struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct msm_camera_i2c_fn_t msm_sensor_cci_func_tbl = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.i2c_read = msm_camera_cci_i2c_read,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.i2c_read_seq = msm_camera_cci_i2c_read_seq,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.i2c_write = msm_camera_cci_i2c_write,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.i2c_write_table = msm_camera_cci_i2c_write_table,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.i2c_write_seq_table = msm_camera_cci_i2c_write_seq_table,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		msm_camera_cci_i2c_write_table_w_microdelay,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.i2c_util = msm_sensor_cci_i2c_util,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.i2c_poll =  msm_camera_cci_i2c_poll,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct msm_camera_i2c_fn_t msm_sensor_qup_func_tbl = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.i2c_read = msm_camera_qup_i2c_read,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.i2c_read_seq = msm_camera_qup_i2c_read_seq,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.i2c_write = msm_camera_qup_i2c_write,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.i2c_write_table = msm_camera_qup_i2c_write_table,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.i2c_write_seq_table = msm_camera_qup_i2c_write_seq_table,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		msm_camera_qup_i2c_write_table_w_microdelay,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.i2c_poll = msm_camera_qup_i2c_poll,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int msm_actuator_close(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *a_ctrl =  v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		rc = msm_actuator_power_down(a_ctrl);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static const struct v4l2_subdev_internal_ops msm_actuator_internal_ops = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.close = msm_actuator_close,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static long msm_actuator_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *a_ctrl = v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		return msm_actuator_get_subdev_id(a_ctrl, argp);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		return msm_actuator_config(a_ctrl, argp);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		rc = msm_actuator_power_down(a_ctrl);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		return msm_actuator_close(sd, NULL);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static long msm_actuator_subdev_do_ioctl(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_cfg_data32 *u32 =
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		(struct msm_actuator_cfg_data32 *)arg;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_cfg_data actuator_data;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:				sizeof(struct msm_actuator_set_position_t));
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	rc = msm_actuator_subdev_ioctl(sd, cmd, parg);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static long msm_actuator_subdev_fops_ioctl(struct file *file, unsigned int cmd,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	return video_usercopy(file, cmd, arg, msm_actuator_subdev_do_ioctl);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_power_up(struct msm_actuator_ctrl_t *a_ctrl)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	enum msm_sensor_power_seq_gpio_t gpio;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	rc = msm_actuator_vreg_control(a_ctrl, 1);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:			rc = msm_camera_request_gpio_table(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct v4l2_subdev_core_ops msm_actuator_subdev_core_ops = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.ioctl = msm_actuator_subdev_ioctl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct v4l2_subdev_ops msm_actuator_subdev_ops = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.core = &msm_actuator_subdev_core_ops,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static const struct i2c_device_id msm_actuator_i2c_id[] = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_i2c_probe(struct i2c_client *client,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *act_ctrl_t = NULL;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_vreg *vreg_cfg = NULL;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	act_ctrl_t = kzalloc(sizeof(struct msm_actuator_ctrl_t),
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		rc = msm_camera_get_dt_vreg_data(client->dev.of_node,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	act_ctrl_t->i2c_driver = &msm_actuator_i2c_driver;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	act_ctrl_t->i2c_client.i2c_func_tbl = &msm_sensor_qup_func_tbl;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	act_ctrl_t->act_v4l2_subdev_ops = &msm_actuator_subdev_ops;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	act_ctrl_t->actuator_mutex = &msm_actuator_mutex;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	snprintf(act_ctrl_t->msm_sd.sd.name, sizeof(act_ctrl_t->msm_sd.sd.name),
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	v4l2_i2c_subdev_init(&act_ctrl_t->msm_sd.sd,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	v4l2_set_subdevdata(&act_ctrl_t->msm_sd.sd, act_ctrl_t);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	act_ctrl_t->msm_sd.sd.internal_ops = &msm_actuator_internal_ops;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	act_ctrl_t->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	media_entity_pads_init(&act_ctrl_t->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	act_ctrl_t->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_ACTUATOR;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	act_ctrl_t->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x2;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_sd_register(&act_ctrl_t->msm_sd);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_cam_copy_v4l2_subdev_fops(&msm_actuator_v4l2_subdev_fops);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		msm_actuator_subdev_fops_ioctl;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	act_ctrl_t->msm_sd.sd.devnode->fops =
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		&msm_actuator_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int32_t msm_actuator_platform_probe(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_camera_cci_client *cci_client = NULL;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_ctrl_t *msm_actuator_t = NULL;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	struct msm_actuator_vreg *vreg_cfg;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t = kzalloc(sizeof(struct msm_actuator_ctrl_t),
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	if (!msm_actuator_t)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		kfree(msm_actuator_t);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		&msm_actuator_t->cci_master);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	CDBG("qcom,cci-master %d, rc %d\n", msm_actuator_t->cci_master, rc);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	if (rc < 0 || msm_actuator_t->cci_master >= MASTER_MAX) {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		kfree(msm_actuator_t);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		vreg_cfg = &msm_actuator_t->vreg_cfg;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		rc = msm_camera_get_dt_vreg_data((&pdev->dev)->of_node,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:			kfree(msm_actuator_t);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	rc = msm_sensor_driver_get_gpio_data(&(msm_actuator_t->gconf),
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		msm_actuator_t->cam_pinctrl_status = 1;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		rc = msm_camera_pinctrl_init(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:			&(msm_actuator_t->pinctrl_info), &(pdev->dev));
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:			msm_actuator_t->cam_pinctrl_status = 0;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t->act_v4l2_subdev_ops = &msm_actuator_subdev_ops;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t->actuator_mutex = &msm_actuator_mutex;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t->cam_name = pdev->id;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t->pdev = pdev;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t->act_device_type = MSM_CAMERA_PLATFORM_DEVICE;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t->i2c_client.i2c_func_tbl = &msm_sensor_cci_func_tbl;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t->i2c_client.cci_client = kzalloc(sizeof(
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		struct msm_camera_cci_client), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	if (!msm_actuator_t->i2c_client.cci_client) {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		kfree(msm_actuator_t->vreg_cfg.cam_vreg);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		kfree(msm_actuator_t->gconf);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		kfree(msm_actuator_t);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	cci_client = msm_actuator_t->i2c_client.cci_client;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	cci_client->cci_subdev = msm_cci_get_subdev();
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	cci_client->cci_i2c_master = msm_actuator_t->cci_master;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	v4l2_subdev_init(&msm_actuator_t->msm_sd.sd,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		msm_actuator_t->act_v4l2_subdev_ops);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	v4l2_set_subdevdata(&msm_actuator_t->msm_sd.sd, msm_actuator_t);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t->msm_sd.sd.internal_ops = &msm_actuator_internal_ops;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	snprintf(msm_actuator_t->msm_sd.sd.name,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		ARRAY_SIZE(msm_actuator_t->msm_sd.sd.name), "msm_actuator");
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	media_entity_pads_init(&msm_actuator_t->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_ACTUATOR;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x2;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_sd_register(&msm_actuator_t->msm_sd);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t->actuator_state = ACT_DISABLE_STATE;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_cam_copy_v4l2_subdev_fops(&msm_actuator_v4l2_subdev_fops);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		msm_actuator_subdev_fops_ioctl;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	msm_actuator_t->msm_sd.sd.devnode->fops =
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		&msm_actuator_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static const struct of_device_id msm_actuator_i2c_dt_match[] = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:MODULE_DEVICE_TABLE(of, msm_actuator_i2c_dt_match);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct i2c_driver msm_actuator_i2c_driver = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.id_table = msm_actuator_i2c_id,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.probe  = msm_actuator_i2c_probe,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.remove = __exit_p(msm_actuator_i2c_remove),
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.of_match_table = msm_actuator_i2c_dt_match,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static const struct of_device_id msm_actuator_dt_match[] = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:MODULE_DEVICE_TABLE(of, msm_actuator_dt_match);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct platform_driver msm_actuator_platform_driver = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	.probe = msm_actuator_platform_probe,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.of_match_table = msm_actuator_dt_match,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static int __init msm_actuator_init_module(void)
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	platform_driver_register(&msm_actuator_platform_driver);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:	return i2c_add_driver(&msm_actuator_i2c_driver);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct msm_actuator msm_vcm_actuator_table = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_init_step_table = msm_actuator_init_step_table,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_move_focus = msm_actuator_move_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_write_focus = msm_actuator_write_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_set_default_focus = msm_actuator_set_default_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_init_focus = msm_actuator_init_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_parse_i2c_params = msm_actuator_parse_i2c_params,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_set_position = msm_actuator_set_position,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_park_lens = msm_actuator_park_lens,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct msm_actuator msm_piezo_actuator_table = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_move_focus = msm_actuator_piezo_move_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:			msm_actuator_piezo_set_default_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_init_focus = msm_actuator_init_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_parse_i2c_params = msm_actuator_parse_i2c_params,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct msm_actuator msm_hvcm_actuator_table = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_init_step_table = msm_actuator_init_step_table,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_move_focus = msm_actuator_move_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_write_focus = msm_actuator_write_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_set_default_focus = msm_actuator_set_default_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_init_focus = msm_actuator_init_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_parse_i2c_params = msm_actuator_parse_i2c_params,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_set_position = msm_actuator_set_position,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_park_lens = msm_actuator_park_lens,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:static struct msm_actuator msm_bivcm_actuator_table = {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_init_step_table = msm_actuator_bivcm_init_step_table,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_move_focus = msm_actuator_bivcm_move_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_set_default_focus = msm_actuator_set_default_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_init_focus = msm_actuator_init_focus,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:		.actuator_set_position = msm_actuator_bivcm_set_position,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.c:module_init(msm_actuator_init_module);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:#include <media/msmb_camera.h>
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:#include "msm_camera_i2c.h"
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:struct msm_actuator_ctrl_t;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:enum msm_actuator_state_t {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:struct msm_actuator_func_tbl {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	int32_t (*actuator_init_step_table)(struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:		struct msm_actuator_set_info_t *set_info);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	int32_t (*actuator_init_focus)(struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:			struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:			struct msm_actuator_move_params_t *move_params);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	int32_t (*actuator_move_focus)(struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:			struct msm_actuator_move_params_t *move_params);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:			struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	void (*actuator_write_focus)(struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	int32_t (*actuator_set_position)(struct msm_actuator_ctrl_t *a_ctrl,
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:		struct msm_actuator_set_position_t *set_pos);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	int32_t (*actuator_park_lens)(struct msm_actuator_ctrl_t *a_ctrl);
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:struct msm_actuator {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	struct msm_actuator_func_tbl func_tbl;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:struct msm_actuator_vreg {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:struct msm_actuator_ctrl_t {
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	struct msm_camera_i2c_client i2c_client;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	enum msm_camera_device_type_t act_device_type;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	struct msm_actuator_func_tbl *func_tbl;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	enum msm_camera_i2c_data_type i2c_data_type;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	struct msm_actuator_reg_params_t reg_tbl[MAX_ACTUATOR_REG_TBL_SIZE];
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	struct msm_camera_i2c_reg_array *i2c_reg_tbl;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	enum msm_actuator_state_t actuator_state;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	struct msm_actuator_vreg vreg_cfg;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	struct msm_camera_gpio_conf *gconf;
media/platform/msm/camera_v2/sensor/actuator/msm_actuator.h:	struct msm_pinctrl_info pinctrl_info;
media/platform/msm/camera_v2/sensor/cci/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/sensor/cci/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/sensor/cci/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/sensor/cci/Makefile:obj-$(CONFIG_MSM_CCI) += msm_cci.o
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:#include "msm_cci.h"
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:#include "msm_cam_cci_hwreg.h"
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:#define MSM_CCI_DRV_NAME "msm_cci"
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static void msm_cci_dump_registers(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		read_val = msm_camera_io_r_mb(cci_dev->base + reg_offset);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		read_val = msm_camera_io_r_mb(cci_dev->base + reg_offset);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		read_val = msm_camera_io_r_mb(cci_dev->base + reg_offset);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		read_val = msm_camera_io_r_mb(cci_dev->base + reg_offset);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_set_clk_param(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_ctrl *c_ctrl)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_cci_clk_params_t *clk_params = NULL;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(clk_params->hw_thigh << 16 |
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(clk_params->hw_tsu_sto << 16 |
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(clk_params->hw_thd_dat << 16 |
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(clk_params->hw_tbuf,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(clk_params->hw_scl_stretch_en << 8 |
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(clk_params->hw_thigh << 16 |
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(clk_params->hw_tsu_sto << 16 |
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(clk_params->hw_thd_dat << 16 |
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(clk_params->hw_tbuf,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(clk_params->hw_scl_stretch_en << 8 |
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static void msm_cci_flush_queue(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(1 << master, cci_dev->base + CCI_HALT_REQ_ADDR);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:			msm_camera_io_w_mb(CCI_M0_RESET_RMSK,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:			msm_camera_io_w_mb(CCI_M1_RESET_RMSK,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_validate_queue(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	read_val = msm_camera_io_r_mb(cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(report_val,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(read_val, cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(reg_val, cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:			msm_cci_flush_queue(cci_dev, master);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_write_i2c_queue(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_validate_queue(cci_dev, 1, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(val, cci_dev->base + CCI_I2C_M0_Q0_LOAD_DATA_ADDR +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static uint32_t msm_cci_wait(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:			msm_cci_dump_registers(cci_dev, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_cci_flush_queue(cci_dev, master);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_addr_to_num_bytes(
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	enum msm_camera_i2c_reg_addr_type addr_type)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_data_to_num_bytes(
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_calc_cmd_len(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_ctrl *c_ctrl, uint32_t cmd_size,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	 struct msm_camera_i2c_reg_array *i2c_cmd, uint32_t *pack)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_i2c_reg_setting *msg;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_i2c_reg_array *cmd = i2c_cmd;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		addr_len = msm_cci_addr_to_num_bytes(msg->addr_type);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		addr_len = msm_cci_addr_to_num_bytes(msg->addr_type);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		data_len = msm_cci_data_to_num_bytes(msg->data_type);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static void msm_cci_load_report_cmd(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	uint32_t read_val = msm_camera_io_r_mb(cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(report_val,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(read_val, cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_wait_report_cmd(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_cci_load_report_cmd(cci_dev, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(reg_val, cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	return msm_cci_wait(cci_dev, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static void msm_cci_process_half_q(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_cci_load_report_cmd(cci_dev, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(reg_val, cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_process_full_q(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_wait(cci_dev, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_wait_report_cmd(cci_dev, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_lock_queue(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	return msm_cci_write_i2c_queue(cci_dev, val, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_transfer_end(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_lock_queue(cci_dev, master, queue, 0);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_wait_report_cmd(cci_dev, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_wait(cci_dev, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_lock_queue(cci_dev, master, queue, 0);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_wait_report_cmd(cci_dev, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_get_queue_free_size(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	read_val = msm_camera_io_r_mb(cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_data_queue(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_ctrl *c_ctrl, enum cci_i2c_queue_t queue,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_i2c_reg_setting *i2c_msg =
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_i2c_reg_array *i2c_cmd = i2c_msg->reg_setting;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(cci_dev->cci_wait_sync_cfg.cid,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(val, cci_dev->base + CCI_I2C_M0_Q0_LOAD_DATA_ADDR +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(val,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_lock_queue(cci_dev, master, queue, 1);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		len = msm_cci_calc_cmd_len(cci_dev, c_ctrl, cmd_size,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		read_val = msm_camera_io_r_mb(cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:				rc = msm_cci_process_full_q(cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:			msm_cci_process_half_q(cci_dev,	master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		free_size = msm_cci_get_queue_free_size(cci_dev, master,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		read_val = msm_camera_io_r_mb(cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:			msm_camera_io_w_mb(cmd, cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:			msm_camera_io_w_mb(read_val, cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:			msm_camera_io_w_mb(cmd, cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:			msm_camera_io_w_mb(read_val, cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_transfer_end(cci_dev, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_i2c_read(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_ctrl *c_ctrl)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_i2c_read_cfg *read_cfg = NULL;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_set_clk_param(cci_dev, c_ctrl);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		pr_err("%s:%d msm_cci_set_clk_param failed rc = %d\n",
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_validate_queue(cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_write_i2c_queue(cci_dev, val, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_write_i2c_queue(cci_dev, val, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_write_i2c_queue(cci_dev, val, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_write_i2c_queue(cci_dev, val, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_write_i2c_queue(cci_dev, val, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	val = msm_camera_io_r_mb(cci_dev->base + CCI_I2C_M0_Q0_CUR_WORD_CNT_ADDR
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(val, cci_dev->base + CCI_I2C_M0_Q0_EXEC_WORD_CNT_ADDR
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(val, cci_dev->base + CCI_QUEUE_START_ADDR);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:			msm_cci_dump_registers(cci_dev, master, queue);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_cci_flush_queue(cci_dev, master);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	read_words = msm_camera_io_r_mb(cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		val = msm_camera_io_r_mb(cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_i2c_read_bytes(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_ctrl *c_ctrl)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_i2c_read_cfg *read_cfg = NULL;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_i2c_read(sd, c_ctrl);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_i2c_write(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_ctrl *c_ctrl, enum cci_i2c_queue_t queue,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_set_clk_param(cci_dev, c_ctrl);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		pr_err("%s:%d msm_cci_set_clk_param failed rc = %d\n",
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_validate_queue(cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_data_queue(cci_dev, c_ctrl, queue, sync_en);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static void msm_cci_write_async_helper(struct work_struct *work)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_i2c_reg_setting *i2c_msg;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_master_info *cci_master_info;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_cci_i2c_write(&cci_dev->msm_sd.sd,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_i2c_write_async(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_ctrl *c_ctrl, enum cci_i2c_queue_t queue,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_i2c_reg_setting *cci_i2c_write_cfg;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_i2c_reg_setting *cci_i2c_write_cfg_w;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	INIT_WORK(&write_async->work, msm_cci_write_async_helper);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		kzalloc(sizeof(struct msm_camera_i2c_reg_array)*
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		(sizeof(struct msm_camera_i2c_reg_array)*
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_pinctrl_init(struct cci_device *cci_dev)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_pinctrl_info *cci_pctrl = NULL;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static uint32_t msm_cci_cycles_per_ms(unsigned long clk)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static uint32_t *msm_cci_get_clk_rates(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_ctrl *c_ctrl)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_cci_clk_params_t *clk_params = NULL;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		cci_dev->cycles_per_us = msm_cci_cycles_per_ms(clk);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:			cci_dev->cycles_per_us = msm_cci_cycles_per_ms(clk);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_i2c_set_sync_prms(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_ctrl *c_ctrl)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_init(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_ctrl *c_ctrl)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:				msm_camera_io_w_mb(CCI_M0_RESET_RMSK,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:				msm_camera_io_w_mb(CCI_M1_RESET_RMSK,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	ret = msm_cci_pinctrl_init(cci_dev);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_camera_request_gpio_table(cci_dev->cci_gpio_tbl,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_camera_config_vreg(&cci_dev->pdev->dev, cci_dev->cci_vreg,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_camera_enable_vreg(&cci_dev->pdev->dev, cci_dev->cci_vreg,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	clk_rates = msm_cci_get_clk_rates(cci_dev, c_ctrl);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_camera_clk_enable(&cci_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_camera_enable_irq(cci_dev->irq, true);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	cci_dev->hw_version = msm_camera_io_r_mb(cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(CCI_RESET_CMD_RMSK, cci_dev->base +
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(0x1, cci_dev->base + CCI_RESET_CMD_ADDR);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(CCI_IRQ_MASK_0_RMSK,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(CCI_IRQ_MASK_0_RMSK,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(0x1, cci_dev->base + CCI_IRQ_GLOBAL_CLEAR_CMD_ADDR);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_enable_irq(cci_dev->irq, false);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_clk_enable(&cci_dev->pdev->dev, cci_dev->cci_clk_info,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_config_vreg(&cci_dev->pdev->dev, cci_dev->cci_vreg,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_request_gpio_table(cci_dev->cci_gpio_tbl,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_release(struct v4l2_subdev *sd)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_enable_irq(cci_dev->irq, false);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_clk_enable(&cci_dev->pdev->dev, cci_dev->cci_clk_info,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_camera_enable_vreg(&cci_dev->pdev->dev, cci_dev->cci_vreg,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_camera_config_vreg(&cci_dev->pdev->dev, cci_dev->cci_vreg,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_request_gpio_table(cci_dev->cci_gpio_tbl,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_write(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_ctrl *c_ctrl)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_master_info *cci_master_info;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_i2c_write(sd, c_ctrl,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_i2c_write_async(sd, c_ctrl,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:				rc = msm_cci_i2c_write(sd, c_ctrl, i,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_i2c_write(sd, c_ctrl,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_i2c_write_async(sd, c_ctrl,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_config(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	struct msm_camera_cci_ctrl *cci_ctrl)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_init(sd, cci_ctrl);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_release(sd);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_i2c_read_bytes(sd, cci_ctrl);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_write(sd, cci_ctrl);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_i2c_set_sync_prms(sd, cci_ctrl);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static irqreturn_t msm_cci_irq(int irq_num, void *data)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	irq = msm_camera_io_r_mb(cci_dev->base + CCI_IRQ_STATUS_0_ADDR);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(irq, cci_dev->base + CCI_IRQ_CLEAR_0_ADDR);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_io_w_mb(0x1, cci_dev->base + CCI_IRQ_GLOBAL_CLEAR_CMD_ADDR);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		struct msm_camera_cci_master_info *cci_master_info;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		struct msm_camera_cci_master_info *cci_master_info;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		struct msm_camera_cci_master_info *cci_master_info;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		struct msm_camera_cci_master_info *cci_master_info;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(CCI_M0_RESET_RMSK,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(CCI_M1_RESET_RMSK,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(CCI_M0_HALT_REQ_RMSK,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_camera_io_w_mb(CCI_M1_HALT_REQ_RMSK,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int msm_cci_irq_routine(struct v4l2_subdev *sd, u32 status,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	ret = msm_cci_irq(cci_dev->irq->start, cci_dev);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	CDBG("%s: msm_cci_irq return %d\n", __func__, ret);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static long msm_cci_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_config(sd, arg);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		struct msm_camera_cci_ctrl ctrl_cmd;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		rc = msm_cci_config(sd, &ctrl_cmd);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static struct v4l2_subdev_core_ops msm_cci_subdev_core_ops = {
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	.ioctl = &msm_cci_subdev_ioctl,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	.interrupt_service_routine = msm_cci_irq_routine,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static const struct v4l2_subdev_ops msm_cci_subdev_ops = {
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	.core = &msm_cci_subdev_core_ops,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static const struct v4l2_subdev_internal_ops msm_cci_internal_ops;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static void msm_cci_init_cci_params(struct cci_device *new_cci_dev)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int32_t msm_cci_init_gpio_params(struct cci_device *cci_dev)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static void msm_cci_init_default_clk_params(struct cci_device *cci_dev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static void msm_cci_init_clk_params(struct cci_device *cci_dev)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:			msm_cci_init_default_clk_params(cci_dev, count);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:struct v4l2_subdev *msm_cci_get_subdev(void)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int msm_cci_probe(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	v4l2_subdev_init(&new_cci_dev->msm_sd.sd, &msm_cci_subdev_ops);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	snprintf(new_cci_dev->msm_sd.sd.name,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:			ARRAY_SIZE(new_cci_dev->msm_sd.sd.name), "msm_cci");
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	v4l2_set_subdevdata(&new_cci_dev->msm_sd.sd, new_cci_dev);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	platform_set_drvdata(pdev, &new_cci_dev->msm_sd.sd);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	CDBG("%s sd %pK\n", __func__, &new_cci_dev->msm_sd.sd);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_camera_get_clk_info_and_rates(pdev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		pr_err("%s: msm_cci_get_clk_info() failed\n", __func__);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	new_cci_dev->base = msm_camera_get_reg_base(pdev, "cci", true);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	new_cci_dev->irq = msm_camera_get_irq(pdev, "cci");
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_camera_register_irq(pdev, new_cci_dev->irq,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		msm_cci_irq, IRQF_TRIGGER_RISING, "cci", new_cci_dev);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_enable_irq(new_cci_dev->irq, false);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	new_cci_dev->msm_sd.sd.internal_ops = &msm_cci_internal_ops;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	new_cci_dev->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	media_entity_pads_init(&new_cci_dev->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	new_cci_dev->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_CCI;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	new_cci_dev->msm_sd.sd.entity.name = new_cci_dev->msm_sd.sd.name;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	new_cci_dev->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x6;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_sd_register(&new_cci_dev->msm_sd);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_cci_init_cci_params(new_cci_dev);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_cci_init_clk_params(new_cci_dev);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_cci_init_gpio_params(new_cci_dev);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	rc = msm_camera_get_dt_vreg_data(new_cci_dev->pdev->dev.of_node,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		pr_err("%s: msm_camera_get_dt_vreg_data fail\n", __func__);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	g_cci_subdev = &new_cci_dev->msm_sd.sd;
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:								"msm_cci_wq");
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	CDBG("%s cci subdev %pK\n", __func__, &new_cci_dev->msm_sd.sd);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_put_reg_base(pdev, new_cci_dev->base, "cci", true);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int msm_cci_exit(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_put_clk_info_and_rates(pdev,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	msm_camera_put_reg_base(pdev, cci_dev->base, "cci", true);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static const struct of_device_id msm_cci_dt_match[] = {
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:MODULE_DEVICE_TABLE(of, msm_cci_dt_match);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	.probe = msm_cci_probe,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:	.remove = msm_cci_exit,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:		.of_match_table = msm_cci_dt_match,
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static int __init msm_cci_init_module(void)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:static void __exit msm_cci_exit_module(void)
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:module_init(msm_cci_init_module);
media/platform/msm/camera_v2/sensor/cci/msm_cci.c:module_exit(msm_cci_exit_module);
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:#include <media/msm_cam_sensor.h>
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:struct msm_camera_cci_client {
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:enum msm_cci_cmd_type {
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:struct msm_camera_cci_wait_sync_cfg {
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:struct msm_camera_cci_gpio_cfg {
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:struct msm_camera_cci_i2c_read_cfg {
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:	enum msm_camera_i2c_reg_addr_type addr_type;
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:struct msm_camera_cci_i2c_queue_info {
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:struct msm_camera_cci_ctrl {
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:	struct msm_camera_cci_client *cci_info;
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:	enum msm_cci_cmd_type cmd;
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:		struct msm_camera_i2c_reg_setting cci_i2c_write_cfg;
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:		struct msm_camera_cci_i2c_read_cfg cci_i2c_read_cfg;
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:		struct msm_camera_cci_wait_sync_cfg cci_wait_sync_cfg;
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:		struct msm_camera_cci_gpio_cfg gpio_cfg;
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:struct msm_camera_cci_master_info {
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:struct msm_cci_clk_params_t {
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:enum msm_cci_state_t {
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:	enum msm_cci_state_t cci_state;
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:	struct msm_cam_clk_info *cci_clk_info;
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:	struct msm_camera_cci_i2c_queue_info
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:	struct msm_camera_cci_master_info cci_master_info[NUM_MASTERS];
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:	struct msm_cci_clk_params_t cci_clk_params[I2C_MAX_MODES];
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:	struct msm_pinctrl_info cci_pinctrl;
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:	struct msm_camera_cci_wait_sync_cfg cci_wait_sync_cfg;
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:enum msm_cci_i2c_cmd_type {
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:enum msm_cci_gpio_cmd_type {
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:	struct msm_camera_cci_ctrl c_ctrl;
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:struct v4l2_subdev *msm_cci_get_subdev(void);
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:static inline struct v4l2_subdev *msm_cci_get_subdev(void)
media/platform/msm/camera_v2/sensor/cci/msm_cci.h:	_IOWR('V', BASE_VIDIOC_PRIVATE + 23, struct msm_camera_cci_ctrl *)
media/platform/msm/camera_v2/sensor/csid/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/sensor/csid/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/sensor/csid/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/sensor/csid/Makefile:obj-$(CONFIG_MSM_CSID) += msm_csid.o
media/platform/msm/camera_v2/sensor/csid/include/msm_csid_2_0_hwreg.h:#include <sensor/csid/msm_csid.h>
media/platform/msm/camera_v2/sensor/csid/include/msm_csid_2_2_hwreg.h:#include <sensor/csid/msm_csid.h>
media/platform/msm/camera_v2/sensor/csid/include/msm_csid_3_0_hwreg.h:#include <sensor/csid/msm_csid.h>
media/platform/msm/camera_v2/sensor/csid/include/msm_csid_3_1_hwreg.h:#include <sensor/csid/msm_csid.h>
media/platform/msm/camera_v2/sensor/csid/include/msm_csid_3_2_hwreg.h:#include <sensor/csid/msm_csid.h>
media/platform/msm/camera_v2/sensor/csid/include/msm_csid_3_4_1_hwreg.h:#include <sensor/csid/msm_csid.h>
media/platform/msm/camera_v2/sensor/csid/include/msm_csid_3_4_2_hwreg.h:#include <sensor/csid/msm_csid.h>
media/platform/msm/camera_v2/sensor/csid/include/msm_csid_3_4_3_hwreg.h:#include <sensor/csid/msm_csid.h>
media/platform/msm/camera_v2/sensor/csid/include/msm_csid_3_5_1_hwreg.h:#include <sensor/csid/msm_csid.h>
media/platform/msm/camera_v2/sensor/csid/include/msm_csid_3_5_hwreg.h:#include <sensor/csid/msm_csid.h>
media/platform/msm/camera_v2/sensor/csid/include/msm_csid_3_6_0_hwreg.h:#include <sensor/csid/msm_csid.h>
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "msm_csid.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "msm_camera_tz_util.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "include/msm_csid_2_0_hwreg.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "include/msm_csid_2_2_hwreg.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "include/msm_csid_3_0_hwreg.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "include/msm_csid_3_1_hwreg.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "include/msm_csid_3_2_hwreg.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "include/msm_csid_3_5_hwreg.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "include/msm_csid_3_4_1_hwreg.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "include/msm_csid_3_4_2_hwreg.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "include/msm_csid_3_4_3_hwreg.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "include/msm_csid_3_6_0_hwreg.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#include "include/msm_csid_3_5_1_hwreg.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:#define MSM_CSID_DRV_NAME                    "msm_csid"
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static struct v4l2_file_operations msm_csid_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static inline uint32_t msm_camera_vio_r(
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	return msm_camera_tz_r(base_addr, offset,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static inline void msm_camera_vio_w(uint32_t data,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_tz_w(data, base_addr, offset,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static inline void msm_camera_vio_w_def(uint32_t data,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_tz_w_deferred(data, base_addr, offset,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static int msm_csid_cid_lut(
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	struct msm_camera_csid_lut_params *csid_lut_params,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		val = msm_camera_vio_r(csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w(val, csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w(val, csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static void msm_csid_set_debug_reg(struct csid_device *csid_dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	struct msm_camera_csid_params *csid_params)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w(0x7f010800 | val, csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w(0x7f010800 | val, csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w(val, csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w(val, csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static void msm_csid_set_debug_reg(struct csid_device *csid_dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	struct msm_camera_csid_params *csid_params)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w(0x7f010a00 | val, csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w(0x7f010a00 | val, csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w(val, csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w(val, csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static void msm_csid_set_debug_reg(struct csid_device *csid_dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	struct msm_camera_csid_params *csid_params)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static void msm_csid_set_sof_freeze_debug_reg(
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	if (csid_dev && msm_camera_tz_is_secured(
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		val = msm_camera_io_r(csid_dev->base +
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_io_w(val, csid_dev->base +
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_io_w(0, csid_dev->base +
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_io_w(val, csid_dev->base +
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_io_w(val, csid_dev->base +
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static int msm_csid_reset(struct csid_device *csid_dev)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	if (msm_camera_tz_is_secured(
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_enable_irq(csid_dev->irq, false);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_camera_tz_reset_hw_block(
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w(csid_dev->ctrl_reg->csid_reg.csid_rst_stb_all,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		irq = msm_camera_vio_r(csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static bool msm_csid_find_max_clk_rate(struct csid_device *csid_dev)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static int msm_csid_seccam_send_topology(struct csid_device *csid_dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	struct msm_camera_csid_params *csid_params)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static int msm_csid_seccam_reset_pipeline(struct csid_device *csid_dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	struct msm_camera_csid_params *csid_params)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static int msm_csid_config(struct csid_device *csid_dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	struct msm_camera_csid_params *csid_params)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_tz_clear_tzbsp_status();
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	rc = msm_csid_reset(csid_dev);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		pr_err("%s:%d msm_csid_reset failed\n", __func__, __LINE__);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	if (!msm_csid_find_max_clk_rate(csid_dev))
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		pr_err("msm_csid_find_max_clk_rate failed\n");
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	clk_rate = msm_camera_clk_set_rate(&csid_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_testmode_parms *tm;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w_def(val, csidbase,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w_def(val, csidbase,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w_def(val, csidbase,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w(csid_dev->testmode_params.payload_mode,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			msm_camera_vio_w(val, csidbase,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			msm_camera_vio_w(val, csidbase,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			msm_camera_vio_w(val, csidbase,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			msm_camera_vio_w(val, csidbase,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	rc = msm_csid_cid_lut(&csid_params->lut_params, csid_dev);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_csid_set_debug_reg(csid_dev, csid_params);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_w(0x00A06437, csidbase,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static irqreturn_t msm_csid_irq(int irq_num, void *data)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	irq = msm_camera_io_r(csid_dev->base +
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		short_dt = msm_camera_io_r(csid_dev->base +
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_io_w(0x101, csid_dev->base +
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_io_w(irq, csid_dev->base +
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static irqreturn_t msm_csid_irq(int irq_num, void *data)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	if (csid_dev && msm_camera_tz_is_secured(
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			msm_csid_set_sof_freeze_debug_reg(csid_dev, false);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	irq = msm_camera_io_r(csid_dev->base +
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_io_w(irq, csid_dev->base +
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static int msm_csid_irq_routine(struct v4l2_subdev *sd, u32 status,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	ret = msm_csid_irq(csid_dev->irq->start, csid_dev);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static int msm_csid_init(struct csid_device *csid_dev, uint32_t *csid_version)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	rc = msm_camera_config_vreg(&csid_dev->pdev->dev, csid_dev->csid_vreg,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	rc = msm_camera_config_vreg(&csid_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	rc = msm_camera_enable_vreg(&csid_dev->pdev->dev, csid_dev->csid_vreg,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	rc = msm_camera_enable_vreg(&csid_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	rc = msm_camera_clk_enable(&csid_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_vio_r(csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	if (msm_camera_tz_is_secured(
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_camera_enable_irq(csid_dev->irq, false);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_camera_enable_irq(csid_dev->irq, true);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	rc = msm_csid_reset(csid_dev);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		pr_err("%s:%d msm_csid_reset failed\n", __func__, __LINE__);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		goto msm_csid_reset_fail;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:msm_csid_reset_fail:
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_enable_irq(csid_dev->irq, false);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_clk_enable(&csid_dev->pdev->dev, csid_dev->csid_clk_info,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_enable_vreg(&csid_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_enable_vreg(&csid_dev->pdev->dev, csid_dev->csid_vreg,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_config_vreg(&csid_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_config_vreg(&csid_dev->pdev->dev, csid_dev->csid_vreg,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static int msm_csid_release(struct csid_device *csid_dev)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_camera_tz_clear_tzbsp_status();
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	irq = msm_camera_vio_r(csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_vio_w(irq, csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_vio_w(0, csid_dev->base,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_enable_irq(csid_dev->irq, false);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_clk_enable(&csid_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_enable_vreg(&csid_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_enable_vreg(&csid_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_config_vreg(&csid_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_config_vreg(&csid_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static int32_t msm_csid_cmd(struct csid_device *csid_dev, void *arg)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_init(csid_dev, &cdata->cfg.csid_version);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			sizeof(struct msm_camera_csid_testmode_parms))) {
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_params csid_params;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_vc_cfg *vc_cfg = NULL;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			sizeof(struct msm_camera_csid_params))) {
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:					sizeof(struct msm_camera_csid_vc_cfg));
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_config(csid_dev, &csid_params);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_params csid_params;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			sizeof(struct msm_camera_csid_params))) {
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_seccam_send_topology(csid_dev, &csid_params);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_params csid_params;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			sizeof(struct msm_camera_csid_params))) {
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_seccam_reset_pipeline(csid_dev, &csid_params);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_release(csid_dev);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static int32_t msm_csid_get_subdev_id(struct csid_device *csid_dev, void *arg)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static long msm_csid_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_get_subdev_id(csid_dev, arg);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_cmd(csid_dev, arg);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			msm_csid_set_sof_freeze_debug_reg(csid_dev, true);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_csid_set_sof_freeze_debug_reg(csid_dev, false);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_release(csid_dev);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static int32_t msm_csid_cmd32(struct csid_device *csid_dev, void *arg)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_init(csid_dev, &cdata->cfg.csid_version);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			sizeof(struct msm_camera_csid_testmode_parms))) {
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_params csid_params;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_vc_cfg *vc_cfg = NULL;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_lut_params32 lut_par32;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_params32 csid_params32;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_vc_cfg vc_cfg32;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			sizeof(struct msm_camera_csid_params32))) {
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			vc_cfg = kzalloc(sizeof(struct msm_camera_csid_vc_cfg),
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			/* msm_camera_csid_vc_cfg size
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_config(csid_dev, &csid_params);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_params csid_params;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_params32 csid_params32;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			sizeof(struct msm_camera_csid_params32))) {
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_seccam_send_topology(csid_dev, &csid_params);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_params csid_params;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		struct msm_camera_csid_params32 csid_params32;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			sizeof(struct msm_camera_csid_params32))) {
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_seccam_reset_pipeline(csid_dev, &csid_params);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_release(csid_dev);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static long msm_csid_subdev_ioctl32(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_get_subdev_id(csid_dev, arg);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_cmd32(csid_dev, arg);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			msm_csid_set_sof_freeze_debug_reg(csid_dev, true);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_csid_set_sof_freeze_debug_reg(csid_dev, false);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		rc = msm_csid_release(csid_dev);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static long msm_csid_subdev_do_ioctl32(
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	return msm_csid_subdev_ioctl32(sd, cmd, arg);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static long msm_csid_subdev_fops_ioctl32(struct file *file, unsigned int cmd,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	return video_usercopy(file, cmd, arg, msm_csid_subdev_do_ioctl32);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static const struct v4l2_subdev_internal_ops msm_csid_internal_ops;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static struct v4l2_subdev_core_ops msm_csid_subdev_core_ops = {
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	.ioctl = &msm_csid_subdev_ioctl,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	.interrupt_service_routine = msm_csid_irq_routine,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static const struct v4l2_subdev_ops msm_csid_subdev_ops = {
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	.core = &msm_csid_subdev_core_ops,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	v4l2_subdev_init(&new_csid_dev->msm_sd.sd, &msm_csid_subdev_ops);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	v4l2_set_subdevdata(&new_csid_dev->msm_sd.sd, new_csid_dev);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	platform_set_drvdata(pdev, &new_csid_dev->msm_sd.sd);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	rc = msm_camera_get_clk_info(pdev, &new_csid_dev->csid_clk_info,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		pr_err("%s: msm_camera_get_clk_info failed\n", __func__);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	rc = msm_camera_get_dt_vreg_data(pdev->dev.of_node,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	new_csid_dev->base = msm_camera_get_reg_base(pdev, "csid", true);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	new_csid_dev->irq = msm_camera_get_irq(pdev, "csid");
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	new_csid_dev->msm_sd.sd.internal_ops = &msm_csid_internal_ops;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	new_csid_dev->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	snprintf(new_csid_dev->msm_sd.sd.name,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:			ARRAY_SIZE(new_csid_dev->msm_sd.sd.name), "msm_csid");
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	media_entity_pads_init(&new_csid_dev->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	new_csid_dev->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_CSID;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	new_csid_dev->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x5;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_sd_register(&new_csid_dev->msm_sd);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_cam_copy_v4l2_subdev_fops(&msm_csid_v4l2_subdev_fops);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_csid_v4l2_subdev_fops.compat_ioctl32 = msm_csid_subdev_fops_ioctl32;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	new_csid_dev->msm_sd.sd.devnode->fops = &msm_csid_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	rc = msm_camera_register_irq(pdev, new_csid_dev->irq,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		msm_csid_irq, IRQF_TRIGGER_RISING, "csid", new_csid_dev);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	rc = msm_camera_enable_irq(new_csid_dev->irq, false);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_put_reg_base(pdev, new_csid_dev->base, "csid", true);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static int msm_csid_exit(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_put_clk_info(pdev, &csid_dev->csid_clk_info,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	msm_camera_put_reg_base(pdev, csid_dev->base, "csid", true);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static const struct of_device_id msm_csid_dt_match[] = {
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:MODULE_DEVICE_TABLE(of, msm_csid_dt_match);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:	.remove = msm_csid_exit,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:		.of_match_table = msm_csid_dt_match,
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static int __init msm_csid_init_module(void)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:static void __exit msm_csid_exit_module(void)
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:module_init(msm_csid_init_module);
media/platform/msm/camera_v2/sensor/csid/msm_csid.c:module_exit(msm_csid_exit_module);
media/platform/msm/camera_v2/sensor/csid/msm_csid.h:#include <media/msm_cam_sensor.h>
media/platform/msm/camera_v2/sensor/csid/msm_csid.h:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/csid/msm_csid.h:enum msm_csid_state_t {
media/platform/msm/camera_v2/sensor/csid/msm_csid.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/sensor/csid/msm_csid.h:	enum msm_csid_state_t csid_state;
media/platform/msm/camera_v2/sensor/csid/msm_csid.h:	struct msm_cam_clk_info *csid_clk_info;
media/platform/msm/camera_v2/sensor/csid/msm_csid.h:	struct msm_camera_csid_testmode_parms testmode_params;
media/platform/msm/camera_v2/sensor/csid/msm_csid.h:	struct msm_camera_csid_params  current_csid_params;
media/platform/msm/camera_v2/sensor/csiphy/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/sensor/csiphy/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/sensor/csiphy/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/sensor/csiphy/Makefile:obj-$(CONFIG_MSM_CSIPHY) += msm_csiphy.o
media/platform/msm/camera_v2/sensor/csiphy/include/msm_csiphy_10_0_0_hwreg.h:#include <sensor/csiphy/msm_csiphy.h>
media/platform/msm/camera_v2/sensor/csiphy/include/msm_csiphy_2_0_hwreg.h:#include <sensor/csiphy/msm_csiphy.h>
media/platform/msm/camera_v2/sensor/csiphy/include/msm_csiphy_2_2_hwreg.h:#include <sensor/csiphy/msm_csiphy.h>
media/platform/msm/camera_v2/sensor/csiphy/include/msm_csiphy_3_0_hwreg.h:#include <sensor/csiphy/msm_csiphy.h>
media/platform/msm/camera_v2/sensor/csiphy/include/msm_csiphy_3_1_hwreg.h:#include <sensor/csiphy/msm_csiphy.h>
media/platform/msm/camera_v2/sensor/csiphy/include/msm_csiphy_3_2_hwreg.h:#include <sensor/csiphy/msm_csiphy.h>
media/platform/msm/camera_v2/sensor/csiphy/include/msm_csiphy_3_4_2_1_hwreg.h:#include <sensor/csiphy/msm_csiphy.h>
media/platform/msm/camera_v2/sensor/csiphy/include/msm_csiphy_3_4_2_hwreg.h:#include <sensor/csiphy/msm_csiphy.h>
media/platform/msm/camera_v2/sensor/csiphy/include/msm_csiphy_3_5_hwreg.h:#include <sensor/csiphy/msm_csiphy.h>
media/platform/msm/camera_v2/sensor/csiphy/include/msm_csiphy_5_0_1_hwreg.h:#include <sensor/csiphy/msm_csiphy.h>
media/platform/msm/camera_v2/sensor/csiphy/include/msm_csiphy_5_0_hwreg.h:#include <sensor/csiphy/msm_csiphy.h>
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#include "msm_csiphy.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#include "include/msm_csiphy_2_0_hwreg.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#include "include/msm_csiphy_2_2_hwreg.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#include "include/msm_csiphy_3_0_hwreg.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#include "include/msm_csiphy_3_1_hwreg.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#include "include/msm_csiphy_3_2_hwreg.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#include "include/msm_csiphy_3_4_2_hwreg.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#include "include/msm_csiphy_3_4_2_1_hwreg.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#include "include/msm_csiphy_3_5_hwreg.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#include "include/msm_csiphy_5_0_hwreg.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#include "include/msm_csiphy_5_0_1_hwreg.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#include "include/msm_csiphy_10_0_0_hwreg.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:#define MSM_CSIPHY_DRV_NAME                      "msm_csiphy"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static struct v4l2_file_operations msm_csiphy_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static void msm_csiphy_write_settings(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_settings.settings[i].data,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(data,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(data,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(data,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(data,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(data,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(data,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static void msm_csiphy_cphy_irq_config(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	struct msm_camera_csiphy_params *csiphy_params)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int msm_csiphy_snps_2_lane_config(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	struct msm_camera_csiphy_params *csiphy_params,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_snps_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w((snps_v100_freq_values[i].hs_freq &
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_snps_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w((snps_v100_freq_values[i].hs_freq &
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_snps_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w((snps_v100_freq_values[i].osc_freq &
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w((snps_v100_freq_values[i].osc_freq &
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_snps_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_snps_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_snps_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_snps_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int msm_csiphy_snps_lane_config(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	struct msm_camera_csiphy_params *csiphy_params)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		clk_mux_reg = msm_camera_io_r(csiphy_dev->clk_mux_base);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(clk_mux_reg, csiphy_dev->clk_mux_base);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		ret = msm_csiphy_snps_2_lane_config(csiphy_dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		ret = msm_csiphy_snps_2_lane_config(csiphy_dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_snps_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(!(csiphy_dev->ctrl_reg->csiphy_snps_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_snps_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(value,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(mask_reset_A,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(mask_ctrl_1_A,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(mask_reset_B,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(mask_ctrl_1_A|mask_ctrl_1_B,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(mask_shutdown_A,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(mask_reset_B,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(mask_ctrl_1_A|mask_ctrl_1_B,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			value = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_snps_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int msm_csiphy_3phase_lane_config(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	struct msm_camera_csiphy_params *csiphy_params)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(lane_enable,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w((csiphy_params->settle_cnt & 0xff),
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(0x40,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x2,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x6,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_csiphy_cphy_irq_config(csiphy_dev, csiphy_params);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int msm_csiphy_3phase_lane_config_v50(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	struct msm_camera_csiphy_params *csiphy_params)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(lane_enable,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w((csiphy_params->settle_cnt & 0xff),
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_csiphy_cphy_irq_config(csiphy_dev, csiphy_params);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int msm_csiphy_2phase_lane_config(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	struct msm_camera_csiphy_params *csiphy_params)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		lane_enable = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(lane_enable,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(val, csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w((csiphy_params->settle_cnt & 0xFF),
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(0x52,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(0x1f,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_csiphy_cphy_irq_config(csiphy_dev, csiphy_params);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int msm_csiphy_2phase_lane_config_v50(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	struct msm_camera_csiphy_params *csiphy_params)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	lane_enable = msm_camera_io_r(csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w((csiphy_params->settle_cnt & 0xFF),
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(lane_enable,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_csiphy_write_settings(csiphy_dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:				msm_camera_io_w(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:				msm_camera_io_w(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:				msm_camera_io_w(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:				msm_camera_io_w(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_3ph_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_csiphy_cphy_irq_config(csiphy_dev, csiphy_params);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int msm_csiphy_lane_config(struct csiphy_device *csiphy_dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	struct msm_camera_csiphy_params *csiphy_params)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	clk_rate = msm_camera_clk_set_rate(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		rc = msm_csiphy_snps_lane_config(csiphy_dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		val = msm_camera_io_r(csiphy_dev->clk_mux_base);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(val, csiphy_dev->clk_mux_base);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			rc = msm_camera_clk_enable(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:				rc = msm_csiphy_3phase_lane_config_v50(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:				rc = msm_csiphy_3phase_lane_config(csiphy_dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:				rc = msm_csiphy_2phase_lane_config(csiphy_dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:				rc = msm_csiphy_2phase_lane_config_v50(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:				rc = msm_csiphy_2phase_lane_config(csiphy_dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(0x1, csiphybase + csiphy_dev->ctrl_reg->csiphy_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(0x1, csiphybase + csiphy_dev->ctrl_reg->csiphy_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w((lane_mask << 2) | val,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x10, csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_params->settle_cnt,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x24,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x24,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w((lane_mask << 1) | val,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_params->combo_mode <<
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x10,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_params->settle_cnt,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(csiphy_dev->ctrl_reg->csiphy_reg
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(lane_val, csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(0x17, csiphybase +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static void msm_csiphy_disable_irq(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static irqreturn_t msm_csiphy_irq(int irq_num, void *data)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_csiphy_disable_irq(csiphy_dev);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		irq = msm_camera_io_r(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(irq,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			irq = msm_camera_io_r(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(irq,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(0x1, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static void msm_csiphy_reset(struct csiphy_device *csiphy_dev)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(0x1, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static void msm_csiphy_3ph_reset(struct csiphy_device *csiphy_dev)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(0x1, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static void msm_csiphy_snps_reset(struct csiphy_device *csiphy_dev)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(0x1, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static void msm_csiphy_snps_release(struct csiphy_device *csiphy_dev)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int msm_csiphy_init(struct csiphy_device *csiphy_dev)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	rc = msm_camera_config_vreg(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	rc = msm_camera_enable_vreg(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	rc = msm_camera_clk_enable(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	rc = msm_camera_enable_irq(csiphy_dev->irq, true);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_csiphy_snps_reset(csiphy_dev);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_csiphy_3ph_reset(csiphy_dev);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_csiphy_reset(csiphy_dev);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_r(csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_enable_vreg(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_config_vreg(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int msm_csiphy_init(struct csiphy_device *csiphy_dev)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	rc = msm_camera_config_vreg(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	rc = msm_camera_enable_vreg(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	rc = msm_camera_clk_enable(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_csiphy_snps_reset(csiphy_dev);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_csiphy_3ph_reset(csiphy_dev);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_csiphy_reset(csiphy_dev);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_r(csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_enable_vreg(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_config_vreg(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int msm_csiphy_release(struct csiphy_device *csiphy_dev, void *arg)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	struct msm_camera_csi_lane_params *csi_lane_params;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	csi_lane_params = (struct msm_camera_csi_lane_params *)arg;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_csiphy_snps_release(csiphy_dev);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:					msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:					msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:					msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	rc = msm_camera_enable_irq(csiphy_dev->irq, false);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_clk_enable(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_clk_enable(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_enable_vreg(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_config_vreg(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int msm_csiphy_release(struct csiphy_device *csiphy_dev, void *arg)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	struct msm_camera_csi_lane_params *csi_lane_params;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	csi_lane_params = (struct msm_camera_csi_lane_params *)arg;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_csiphy_snps_release(csiphy_dev);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:					msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:					msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:					msm_camera_io_w(0x0,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			msm_camera_io_w(0x0, csiphy_dev->base +
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		rc = msm_camera_enable_irq(csiphy_dev->irq, false);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_clk_enable(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_clk_enable(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_enable_vreg(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_config_vreg(&csiphy_dev->pdev->dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int32_t msm_csiphy_cmd(struct csiphy_device *csiphy_dev, void *arg)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	struct msm_camera_csiphy_params csiphy_params;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	struct msm_camera_csi_lane_params csi_lane_params;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		rc = msm_csiphy_init(csiphy_dev);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			sizeof(struct msm_camera_csiphy_params))) {
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			rc = msm_camera_enable_irq(csiphy_dev->irq, false);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		rc = msm_csiphy_lane_config(csiphy_dev, &csiphy_params);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			sizeof(struct msm_camera_csi_lane_params))) {
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		rc = msm_csiphy_release(csiphy_dev, &csi_lane_params);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int32_t msm_csiphy_get_subdev_id(struct csiphy_device *csiphy_dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static long msm_csiphy_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		rc = msm_csiphy_get_subdev_id(csiphy_dev, arg);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		rc = msm_csiphy_cmd(csiphy_dev, arg);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		rc = msm_csiphy_release(csiphy_dev, arg);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:			rc = msm_camera_enable_irq(csiphy_dev->irq, true);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		rc = msm_camera_enable_irq(csiphy_dev->irq, false);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static long msm_csiphy_subdev_do_ioctl(
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		return msm_csiphy_subdev_ioctl(sd, cmd, &csiphy_data);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		return msm_csiphy_subdev_ioctl(sd, cmd, arg);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static long msm_csiphy_subdev_fops_ioctl(struct file *file, unsigned int cmd,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	return video_usercopy(file, cmd, arg, msm_csiphy_subdev_do_ioctl);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static const struct v4l2_subdev_internal_ops msm_csiphy_internal_ops;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static struct v4l2_subdev_core_ops msm_csiphy_subdev_core_ops = {
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	.ioctl = &msm_csiphy_subdev_ioctl,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static const struct v4l2_subdev_ops msm_csiphy_subdev_ops = {
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	.core = &msm_csiphy_subdev_core_ops,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int msm_csiphy_get_clk_info(struct csiphy_device *csiphy_dev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	rc = msm_camera_get_clk_info(csiphy_dev->pdev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_put_clk_info(csiphy_dev->pdev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	v4l2_subdev_init(&new_csiphy_dev->msm_sd.sd, &msm_csiphy_subdev_ops);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	v4l2_set_subdevdata(&new_csiphy_dev->msm_sd.sd, new_csiphy_dev);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	platform_set_drvdata(pdev, &new_csiphy_dev->msm_sd.sd);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	new_csiphy_dev->msm_sd.sd.internal_ops = &msm_csiphy_internal_ops;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	new_csiphy_dev->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	snprintf(new_csiphy_dev->msm_sd.sd.name,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		ARRAY_SIZE(new_csiphy_dev->msm_sd.sd.name), "msm_csiphy");
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	media_entity_pads_init(&new_csiphy_dev->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	new_csiphy_dev->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_CSIPHY;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	new_csiphy_dev->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x4;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_sd_register(&new_csiphy_dev->msm_sd);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	rc = msm_camera_get_dt_vreg_data(pdev->dev.of_node,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	rc = msm_csiphy_get_clk_info(new_csiphy_dev, pdev);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		pr_err("%s: msm_csiphy_get_clk_info() failed\n", __func__);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	new_csiphy_dev->base = msm_camera_get_reg_base(pdev, "csiphy", true);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		new_csiphy_dev->clk_mux_base = msm_camera_get_reg_base(pdev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	new_csiphy_dev->irq = msm_camera_get_irq(pdev, "csiphy");
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	rc = msm_camera_register_irq(pdev, new_csiphy_dev->irq,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_csiphy_irq, IRQF_TRIGGER_RISING, "csiphy", new_csiphy_dev);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_enable_irq(new_csiphy_dev->irq, false);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_cam_copy_v4l2_subdev_fops(&msm_csiphy_v4l2_subdev_fops);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_csiphy_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_csiphy_subdev_fops_ioctl;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	new_csiphy_dev->msm_sd.sd.devnode->fops =
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		&msm_csiphy_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_put_reg_base(pdev, new_csiphy_dev->clk_mux_base,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_put_reg_base(pdev, new_csiphy_dev->base, "csiphy", true);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int msm_csiphy_exit(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_put_clk_info(pdev,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	msm_camera_put_reg_base(pdev, csiphy_dev->base, "csiphy", true);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		msm_camera_put_reg_base(pdev, csiphy_dev->clk_mux_base,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static const struct of_device_id msm_csiphy_dt_match[] = {
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:MODULE_DEVICE_TABLE(of, msm_csiphy_dt_match);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:	.remove = msm_csiphy_exit,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:		.of_match_table = msm_csiphy_dt_match,
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static int __init msm_csiphy_init_module(void)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:static void __exit msm_csiphy_exit_module(void)
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:module_init(msm_csiphy_init_module);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.c:module_exit(msm_csiphy_exit_module);
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h:#include <media/msm_cam_sensor.h>
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h:enum msm_csiphy_state_t {
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h:	enum msm_csiphy_state_t csiphy_state;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h:	struct msm_cam_clk_info *csiphy_all_clk_info;
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h:	struct msm_cam_clk_info csiphy_clk_info[CSIPHY_NUM_CLK_MAX];
media/platform/msm/camera_v2/sensor/csiphy/msm_csiphy.h:	struct msm_cam_clk_info csiphy_3p_clk_info[2];
media/platform/msm/camera_v2/sensor/eeprom/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/sensor/eeprom/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/sensor/eeprom/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/sensor/eeprom/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
media/platform/msm/camera_v2/sensor/eeprom/Makefile:obj-$(CONFIG_MSM_EEPROM) += msm_eeprom.o
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:#include "msm_cci.h"
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:#include "msm_eeprom.h"
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:DEFINE_MSM_MUTEX(msm_eeprom_mutex);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static struct v4l2_file_operations msm_eeprom_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c: * msm_get_read_mem_size - Get the total size for allocation
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_get_read_mem_size
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	(struct msm_eeprom_memory_map_array *eeprom_map_array)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_mem_map_t *eeprom_map;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	if (eeprom_map_array->msm_size_of_max_mappings >
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:			eeprom_map_array->msm_size_of_max_mappings);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	for (j = 0; j < eeprom_map_array->msm_size_of_max_mappings; j++) {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c: * msm_eeprom_verify_sum - verify crc32 checksum
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_verify_sum(const char *mem, uint32_t size, uint32_t sum)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c: * msm_eeprom_match_crc - verify multiple regions using crc
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static uint32_t msm_eeprom_match_crc(struct msm_eeprom_memory_block_t *data)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_memory_map_t *map;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_eeprom_verify_sum(memptr, map[j].mem.valid_size,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int read_eeprom_memory(struct msm_eeprom_ctrl_t *e_ctrl,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_memory_block_t *block)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_memory_map_t *emap = block->map;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_board_info *eb_info;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c: * msm_eeprom_parse_memory_map() - parse memory map in device node
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_parse_memory_map(struct device_node *of,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_memory_block_t *data)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_memory_map_t *map;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int eeprom_parse_memory_map(struct msm_eeprom_ctrl_t *e_ctrl,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_memory_map_array *eeprom_map_array)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_mem_map_t *eeprom_map;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->cal_data.num_data = msm_get_read_mem_size(eeprom_map_array);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	for (j = 0; j < eeprom_map_array->msm_size_of_max_mappings; j++) {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c: * msm_eeprom_power_up - Do eeprom power up here
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_power_up(struct msm_eeprom_ctrl_t *e_ctrl,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_camera_power_ctrl_t *power_info)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_camera_fill_vreg_params(
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_camera_fill_vreg_params(
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		pr_err("%s:%d failed msm_camera_fill_vreg_params for PDOWN rc %d\n",
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_camera_power_up(power_info, e_ctrl->eeprom_device_type,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c: * msm_eeprom_power_up - Do power up, parse and power down
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int eeprom_init_config(struct msm_eeprom_ctrl_t *e_ctrl,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_cfg_data *cdata = argp;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_sensor_power_setting_array *power_setting_array = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_camera_power_ctrl_t *power_info;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_memory_map_array *memory_map_arr = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		kzalloc(sizeof(struct msm_sensor_power_setting_array),
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	memory_map_arr = kzalloc(sizeof(struct msm_eeprom_memory_map_array),
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		sizeof(struct msm_sensor_power_setting_array))) {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		sizeof(struct msm_eeprom_memory_map_array))) {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_eeprom_power_up(e_ctrl, power_info);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_camera_power_down(power_info, e_ctrl->eeprom_device_type,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_get_cmm_data(struct msm_eeprom_ctrl_t *e_ctrl,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:				       struct msm_eeprom_cfg_data *cdata)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_cmm_t *cmm_data = &e_ctrl->eboard_info->cmm_data;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int eeprom_config_read_cal_data(struct msm_eeprom_ctrl_t *e_ctrl,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_cfg_data *cdata)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_config(struct msm_eeprom_ctrl_t *e_ctrl,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_cfg_data *cdata =
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		(struct msm_eeprom_cfg_data *)argp;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_eeprom_get_cmm_data(e_ctrl, cdata);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_get_subdev_id(struct msm_eeprom_ctrl_t *e_ctrl,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static long msm_eeprom_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_ctrl_t *e_ctrl = v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		return msm_eeprom_get_subdev_id(e_ctrl, argp);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		return msm_eeprom_config(e_ctrl, argp);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static struct msm_camera_i2c_fn_t msm_eeprom_cci_func_tbl = {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_read = msm_camera_cci_i2c_read,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_read_seq = msm_camera_cci_i2c_read_seq,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_write = msm_camera_cci_i2c_write,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_write_seq = msm_camera_cci_i2c_write_seq,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_write_table = msm_camera_cci_i2c_write_table,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_write_seq_table = msm_camera_cci_i2c_write_seq_table,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_camera_cci_i2c_write_table_w_microdelay,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_util = msm_sensor_cci_i2c_util,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_poll = msm_camera_cci_i2c_poll,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static struct msm_camera_i2c_fn_t msm_eeprom_qup_func_tbl = {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_read = msm_camera_qup_i2c_read,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_read_seq = msm_camera_qup_i2c_read_seq,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_write = msm_camera_qup_i2c_write,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_write_table = msm_camera_qup_i2c_write_table,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_write_seq_table = msm_camera_qup_i2c_write_seq_table,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_camera_qup_i2c_write_table_w_microdelay,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static struct msm_camera_i2c_fn_t msm_eeprom_spi_func_tbl = {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_read = msm_camera_spi_read,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.i2c_read_seq = msm_camera_spi_read_seq,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_open(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_ctrl_t *e_ctrl =  v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_close(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_ctrl_t *e_ctrl =  v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static const struct v4l2_subdev_internal_ops msm_eeprom_internal_ops = {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.open = msm_eeprom_open,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.close = msm_eeprom_close,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static struct v4l2_subdev_core_ops msm_eeprom_subdev_core_ops = {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.ioctl = msm_eeprom_subdev_ioctl,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static struct v4l2_subdev_ops msm_eeprom_subdev_ops = {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.core = &msm_eeprom_subdev_core_ops,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_get_dt_data(struct msm_eeprom_ctrl_t *e_ctrl)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_board_info *eb_info;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_camera_power_ctrl_t *power_info =
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_camera_gpio_conf *gconf = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_camera_get_dt_vreg_data(of_node, &power_info->cam_vreg,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_camera_get_dt_power_setting_data(of_node,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	power_info->gpio_conf = kzalloc(sizeof(struct msm_camera_gpio_conf),
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_camera_get_dt_gpio_req_tbl(of_node, gconf,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_camera_init_gpio_pin_tbl(of_node, gconf,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_i2c_probe(struct i2c_client *client,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_ctrl_t *e_ctrl = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_board_info *eb_info = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_camera_power_ctrl_t *power_info = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->eeprom_v4l2_subdev_ops = &msm_eeprom_subdev_ops;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->eeprom_mutex = &msm_eeprom_mutex;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->i2c_client.i2c_func_tbl = &msm_eeprom_qup_func_tbl;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		struct msm_eeprom_board_info), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_camera_i2c_dev_get_clk_info(
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		pr_err("failed: msm_camera_get_clk_info rc %d\n", rc);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_eeprom_get_dt_data(e_ctrl);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_eeprom_parse_memory_map(of_node, &e_ctrl->cal_data);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_camera_power_up(power_info, e_ctrl->eeprom_device_type,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		e_ctrl->is_supported |= msm_eeprom_match_crc(&e_ctrl->cal_data);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_camera_power_down(power_info,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	v4l2_i2c_subdev_init(&e_ctrl->msm_sd.sd,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	v4l2_set_subdevdata(&e_ctrl->msm_sd.sd, e_ctrl);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->msm_sd.sd.internal_ops = &msm_eeprom_internal_ops;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	snprintf(e_ctrl->msm_sd.sd.name,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		ARRAY_SIZE(e_ctrl->msm_sd.sd.name), "msm_eeprom");
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	media_entity_pads_init(&e_ctrl->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_EEPROM;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_sd_register(&e_ctrl->msm_sd);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_camera_power_down(power_info, e_ctrl->eeprom_device_type,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_i2c_remove(struct i2c_client *client)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_ctrl_t  *e_ctrl;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl = (struct msm_eeprom_ctrl_t *)v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_camera_i2c_dev_put_clk_info(&e_ctrl->i2c_client.client->dev,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_spi_parse_of(struct msm_camera_spi_client *spic)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_match_id(struct msm_eeprom_ctrl_t *e_ctrl)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_camera_i2c_client *client = &e_ctrl->i2c_client;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_camera_spi_query_id(client, 0, &id[0], 2);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_cmm_dts(struct msm_eeprom_board_info *eb_info,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_cmm_t *cmm_data = &eb_info->cmm_data;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_spi_setup(struct spi_device *spi)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_ctrl_t *e_ctrl = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_camera_i2c_client *client = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_camera_spi_client *spi_client;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_board_info *eb_info;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_camera_power_ctrl_t *power_info = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->eeprom_v4l2_subdev_ops = &msm_eeprom_subdev_ops;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->eeprom_mutex = &msm_eeprom_mutex;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	client->i2c_func_tbl = &msm_eeprom_spi_func_tbl;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_eeprom_cmm_dts(e_ctrl->eboard_info, spi->dev.of_node);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_camera_i2c_dev_get_clk_info(
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		pr_err("failed: msm_camera_get_clk_info rc %d\n", rc);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_eeprom_get_dt_data(e_ctrl);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_eeprom_spi_parse_of(spi_client);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_eeprom_parse_memory_map(spi->dev.of_node,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_camera_power_up(power_info, e_ctrl->eeprom_device_type,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_eeprom_match_id(e_ctrl);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:			e_ctrl->is_supported |= msm_eeprom_match_crc(
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_camera_power_down(power_info,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	v4l2_spi_subdev_init(&e_ctrl->msm_sd.sd,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	v4l2_set_subdevdata(&e_ctrl->msm_sd.sd, e_ctrl);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->msm_sd.sd.internal_ops = &msm_eeprom_internal_ops;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	media_entity_pads_init(&e_ctrl->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_EEPROM;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_sd_register(&e_ctrl->msm_sd);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_camera_power_down(power_info, e_ctrl->eeprom_device_type,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_camera_i2c_dev_put_clk_info(
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_spi_probe(struct spi_device *spi)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	return msm_eeprom_spi_setup(spi);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_spi_remove(struct spi_device *sdev)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_ctrl_t  *e_ctrl;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl = (struct msm_eeprom_ctrl_t *)v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_camera_i2c_dev_put_clk_info(
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static void msm_eeprom_copy_power_settings_compat(
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_sensor_power_setting_array *ps,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_sensor_power_setting_array32 *ps32)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int eeprom_config_read_cal_data32(struct msm_eeprom_ctrl_t *e_ctrl,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_cfg_data32 *cdata32 =
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		(struct msm_eeprom_cfg_data32 *) arg;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_cfg_data cdata;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int eeprom_init_config32(struct msm_eeprom_ctrl_t *e_ctrl,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_cfg_data32 *cdata32 = argp;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_sensor_power_setting_array *power_setting_array = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_sensor_power_setting_array32 *power_setting_array32 = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_camera_power_ctrl_t *power_info = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_memory_map_array *mem_map_array = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		kzalloc(sizeof(struct msm_sensor_power_setting_array32),
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		kzalloc(sizeof(struct msm_sensor_power_setting_array),
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		kzalloc(sizeof(struct msm_eeprom_memory_map_array),
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		sizeof(struct msm_sensor_power_setting_array32))) {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		sizeof(struct msm_eeprom_memory_map_array))) {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_eeprom_copy_power_settings_compat(
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_eeprom_power_up(e_ctrl, power_info);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_camera_power_down(power_info,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_config32(struct msm_eeprom_ctrl_t *e_ctrl,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_cfg_data32 *cdata =
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		(struct msm_eeprom_cfg_data32 *)argp;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static long msm_eeprom_subdev_ioctl32(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_ctrl_t *e_ctrl = v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		return msm_eeprom_get_subdev_id(e_ctrl, argp);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		return msm_eeprom_config32(e_ctrl, argp);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static long msm_eeprom_subdev_do_ioctl32(
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	return msm_eeprom_subdev_ioctl32(sd, cmd, arg);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static long msm_eeprom_subdev_fops_ioctl32(struct file *file, unsigned int cmd,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	return video_usercopy(file, cmd, arg, msm_eeprom_subdev_do_ioctl32);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_platform_probe(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_camera_cci_client *cci_client = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_ctrl_t *e_ctrl = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_board_info *eb_info = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_camera_power_ctrl_t *power_info = NULL;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->eeprom_v4l2_subdev_ops = &msm_eeprom_subdev_ops;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->eeprom_mutex = &msm_eeprom_mutex;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->i2c_client.i2c_func_tbl = &msm_eeprom_cci_func_tbl;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		struct msm_camera_cci_client), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		struct msm_eeprom_board_info), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	cci_client->cci_subdev = msm_cci_get_subdev();
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_camera_get_clk_info(e_ctrl->pdev,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		pr_err("failed: msm_camera_get_clk_info rc %d\n", rc);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = msm_eeprom_get_dt_data(e_ctrl);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_eeprom_parse_memory_map(of_node, &e_ctrl->cal_data);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_camera_power_up(power_info, e_ctrl->eeprom_device_type,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		e_ctrl->is_supported |= msm_eeprom_match_crc(&e_ctrl->cal_data);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		rc = msm_camera_power_down(power_info,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	v4l2_subdev_init(&e_ctrl->msm_sd.sd,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	v4l2_set_subdevdata(&e_ctrl->msm_sd.sd, e_ctrl);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	platform_set_drvdata(pdev, &e_ctrl->msm_sd.sd);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->msm_sd.sd.internal_ops = &msm_eeprom_internal_ops;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	snprintf(e_ctrl->msm_sd.sd.name,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		ARRAY_SIZE(e_ctrl->msm_sd.sd.name), "msm_eeprom");
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	media_entity_pads_init(&e_ctrl->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_EEPROM;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_sd_register(&e_ctrl->msm_sd);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_cam_copy_v4l2_subdev_fops(&msm_eeprom_v4l2_subdev_fops);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_eeprom_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		msm_eeprom_subdev_fops_ioctl32;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl->msm_sd.sd.devnode->fops = &msm_eeprom_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_camera_power_down(power_info, e_ctrl->eeprom_device_type,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int msm_eeprom_platform_remove(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	struct msm_eeprom_ctrl_t  *e_ctrl;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	e_ctrl = (struct msm_eeprom_ctrl_t *)v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	msm_camera_put_clk_info(e_ctrl->pdev,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static const struct of_device_id msm_eeprom_dt_match[] = {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:MODULE_DEVICE_TABLE(of, msm_eeprom_dt_match);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static struct platform_driver msm_eeprom_platform_driver = {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		.of_match_table = msm_eeprom_dt_match,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.probe = msm_eeprom_platform_probe,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.remove = msm_eeprom_platform_remove,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static const struct i2c_device_id msm_eeprom_i2c_id[] = {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	{ "msm_eeprom", (kernel_ulong_t)NULL},
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static struct i2c_driver msm_eeprom_i2c_driver = {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.id_table = msm_eeprom_i2c_id,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.probe  = msm_eeprom_i2c_probe,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.remove = msm_eeprom_i2c_remove,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		.name = "msm_eeprom",
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static struct spi_driver msm_eeprom_spi_driver = {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:		.of_match_table = msm_eeprom_dt_match,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.probe = msm_eeprom_spi_probe,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	.remove = msm_eeprom_spi_remove,
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static int __init msm_eeprom_init_module(void)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = platform_driver_register(&msm_eeprom_platform_driver);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	rc = spi_register_driver(&msm_eeprom_spi_driver);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	return i2c_add_driver(&msm_eeprom_i2c_driver);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:static void __exit msm_eeprom_exit_module(void)
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	platform_driver_unregister(&msm_eeprom_platform_driver);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	spi_unregister_driver(&msm_eeprom_spi_driver);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:	i2c_del_driver(&msm_eeprom_i2c_driver);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:module_init(msm_eeprom_init_module);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.c:module_exit(msm_eeprom_exit_module);
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.h:#include <media/msmb_camera.h>
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.h:#include "msm_camera_i2c.h"
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.h:#include "msm_camera_spi.h"
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.h:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.h:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.h:struct msm_eeprom_ctrl_t;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.h:struct msm_eeprom_ctrl_t {
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.h:	enum msm_camera_device_type_t eeprom_device_type;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.h:	struct msm_camera_i2c_client i2c_client;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.h:	struct msm_eeprom_board_info *eboard_info;
media/platform/msm/camera_v2/sensor/eeprom/msm_eeprom.h:	struct msm_eeprom_memory_block_t cal_data;
media/platform/msm/camera_v2/sensor/flash/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
media/platform/msm/camera_v2/sensor/flash/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/sensor/flash/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/sensor/flash/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/sensor/flash/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_flash.o
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:#include "msm_flash.h"
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:#include "msm_cci.h"
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:DEFINE_MSM_MUTEX(msm_flash_mutex);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static struct v4l2_file_operations msm_flash_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static const struct of_device_id msm_flash_dt_match[] = {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static struct msm_flash_table msm_i2c_flash_table;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static struct msm_flash_table msm_gpio_flash_table;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static struct msm_flash_table msm_pmic_flash_table;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static struct msm_flash_table *flash_table[] = {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	&msm_i2c_flash_table,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	&msm_gpio_flash_table,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	&msm_pmic_flash_table
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static struct msm_camera_i2c_fn_t msm_sensor_cci_func_tbl = {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	.i2c_read = msm_camera_cci_i2c_read,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	.i2c_read_seq = msm_camera_cci_i2c_read_seq,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	.i2c_write = msm_camera_cci_i2c_write,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	.i2c_write_table = msm_camera_cci_i2c_write_table,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	.i2c_write_seq_table = msm_camera_cci_i2c_write_seq_table,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		msm_camera_cci_i2c_write_table_w_microdelay,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	.i2c_util = msm_sensor_cci_i2c_util,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	.i2c_poll =  msm_camera_cci_i2c_poll,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static void msm_torch_brightness_set(struct led_classdev *led_cdev,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static struct led_classdev msm_torch_led[MAX_LED_TRIGGERS] = {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.brightness_set	= msm_torch_brightness_set,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.brightness_set	= msm_torch_brightness_set,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.brightness_set	= msm_torch_brightness_set,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_torch_create_classdev(struct platform_device *pdev,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *fctrl =
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		(struct msm_flash_ctrl_t *)data;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:			CDBG("%s:%d msm_torch_brightness_set for torch %d",
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:			msm_torch_brightness_set(&msm_torch_led[i],
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:				&msm_torch_led[i]);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_get_subdev_id(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl, void *arg)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_i2c_write_table(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_camera_i2c_reg_setting_array *settings)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_camera_i2c_reg_setting conf_array;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static void msm_flash_copy_power_settings_compat(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_sensor_power_setting *ps,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_sensor_power_setting32 *ps32, uint32_t size)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_i2c_init(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_cfg_data_t *flash_data)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_init_info_t *flash_init_info =
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_camera_i2c_reg_setting_array *settings = NULL;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_camera_cci_client *cci_client = NULL;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_sensor_power_setting_array32 *power_setting_array32 = NULL;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:			sizeof(struct msm_sensor_power_setting_array32));
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:			sizeof(struct msm_sensor_power_setting), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:			sizeof(struct msm_sensor_power_setting)*
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:			sizeof(struct msm_sensor_power_setting)*
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		msm_flash_copy_power_settings_compat(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		msm_flash_copy_power_settings_compat(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		sizeof(struct msm_sensor_power_setting_array))) {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		goto msm_flash_i2c_init_fail;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	rc = msm_camera_power_up(&flash_ctrl->power_info,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		pr_err("%s msm_camera_power_up failed %d\n",
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		goto msm_flash_i2c_init_fail;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:				struct msm_camera_i2c_reg_setting_array));
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		rc = msm_flash_i2c_write_table(flash_ctrl, settings);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:			pr_err("%s:%d msm_flash_i2c_write_table rc %d failed\n",
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:msm_flash_i2c_init_fail:
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_gpio_init(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_cfg_data_t *flash_data)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_i2c_release(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	rc = msm_camera_power_down(&flash_ctrl->power_info,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		pr_err("%s msm_camera_power_down failed %d\n",
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_off(struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_cfg_data_t *flash_data)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_i2c_write_setting_array(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_cfg_data_t *flash_data)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_camera_i2c_reg_setting_array *settings = NULL;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:				struct msm_camera_i2c_reg_setting_array));
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	rc = msm_flash_i2c_write_table(flash_ctrl, settings);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		pr_err("%s:%d msm_flash_i2c_write_table rc = %d failed\n",
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_init(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_cfg_data_t *flash_data)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	enum msm_flash_driver_type flash_driver_type = FLASH_DRIVER_DEFAULT;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_init_prepare(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_cfg_data_t *flash_data)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_cfg_data_t flash_data_k;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_init_info_t flash_init_info;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:			sizeof(struct msm_flash_init_info_t))) {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		return msm_flash_init(flash_ctrl, &flash_data_k);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	 * data to local memory in msm_flash_subdev_do_ioctl()
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	return msm_flash_init(flash_ctrl, flash_data);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_cfg_data_t flash_data_k;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_init_info_t flash_init_info;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		sizeof(struct msm_flash_init_info_t))) {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	return msm_flash_init(flash_ctrl, &flash_data_k);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_prepare(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_low(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_cfg_data_t *flash_data)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_high(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_cfg_data_t *flash_data)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_query_current(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_query_data_t *flash_query_data)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_release(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_config(struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_cfg_data_t *flash_data =
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		(struct msm_flash_cfg_data_t *) argp;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		rc = msm_flash_init_prepare(flash_ctrl, flash_data);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	rc = msm_flash_prepare(flash_ctrl);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_query_data(struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_query_data_t *flash_query =
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		(struct msm_flash_query_data_t *) argp;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static long msm_flash_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *fctrl = NULL;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		return msm_flash_get_subdev_id(fctrl, argp);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		return msm_flash_config(fctrl, argp);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:			return msm_flash_prepare(fctrl);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		return msm_flash_query_data(fctrl, argp);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static struct v4l2_subdev_core_ops msm_flash_subdev_core_ops = {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	.ioctl = msm_flash_subdev_ioctl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static struct v4l2_subdev_ops msm_flash_subdev_ops = {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	.core = &msm_flash_subdev_core_ops,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static const struct v4l2_subdev_internal_ops msm_flash_internal_ops;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_get_pmic_source_info(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *fctrl)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_get_dt_data(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *fctrl)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	rc = msm_flash_get_pmic_source_info(of_node, fctrl);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		pr_err("%s:%d msm_flash_get_pmic_source_info failed rc %d\n",
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	rc = msm_sensor_driver_get_gpio_data(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		pr_err("%s:%d msm_sensor_driver_get_gpio_data failed rc %d\n",
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static long msm_flash_subdev_do_ioctl(
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_cfg_data_t32 *u32;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_cfg_data_t flash_data;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_init_info_t32 flash_init_info32;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_init_info_t flash_init_info;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	u32 = (struct msm_flash_cfg_data_t32 *)arg;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:				sizeof(struct msm_flash_init_info_t32))) {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		return msm_flash_subdev_ioctl(sd, cmd, arg);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	rc =  msm_flash_subdev_ioctl(sd, cmd, &flash_data);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static long msm_flash_subdev_fops_ioctl(struct file *file,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	return video_usercopy(file, cmd, arg, msm_flash_subdev_do_ioctl);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int32_t msm_flash_platform_probe(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_flash_ctrl_t *flash_ctrl = NULL;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	struct msm_camera_cci_client *cci_client = NULL;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	flash_ctrl = kzalloc(sizeof(struct msm_flash_ctrl_t), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	memset(flash_ctrl, 0, sizeof(struct msm_flash_ctrl_t));
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	rc = msm_flash_get_dt_data(pdev->dev.of_node, flash_ctrl);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		pr_err("%s:%d msm_flash_get_dt_data failed\n",
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	flash_ctrl->flash_mutex = &msm_flash_mutex;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	flash_ctrl->flash_i2c_client.i2c_func_tbl = &msm_sensor_cci_func_tbl;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		sizeof(struct msm_camera_cci_client), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	cci_client->cci_subdev = msm_cci_get_subdev();
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	v4l2_subdev_init(&flash_ctrl->msm_sd.sd, &msm_flash_subdev_ops);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	v4l2_set_subdevdata(&flash_ctrl->msm_sd.sd, flash_ctrl);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	flash_ctrl->msm_sd.sd.internal_ops = &msm_flash_internal_ops;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	flash_ctrl->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	snprintf(flash_ctrl->msm_sd.sd.name,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		ARRAY_SIZE(flash_ctrl->msm_sd.sd.name),
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		"msm_camera_flash");
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	media_entity_pads_init(&flash_ctrl->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	flash_ctrl->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_FLASH;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	flash_ctrl->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x1;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	msm_sd_register(&flash_ctrl->msm_sd);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		flash_ctrl->msm_sd.sd.entity.name);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	msm_cam_copy_v4l2_subdev_fops(&msm_flash_v4l2_subdev_fops);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	msm_flash_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		msm_flash_subdev_fops_ioctl;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	flash_ctrl->msm_sd.sd.devnode->fops = &msm_flash_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		rc = msm_torch_create_classdev(pdev, flash_ctrl);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	return msm_flash_platform_probe(pdev);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:MODULE_DEVICE_TABLE(of, msm_flash_dt_match);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static struct platform_driver msm_flash_platform_driver = {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	.probe = msm_flash_platform_probe,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.of_match_table = msm_flash_dt_match,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static int __init msm_flash_init_module(void)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	rc = platform_driver_register(&msm_flash_platform_driver);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static void __exit msm_flash_exit_module(void)
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:	platform_driver_unregister(&msm_flash_platform_driver);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static struct msm_flash_table msm_pmic_flash_table = {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_release = msm_flash_release,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_off = msm_flash_off,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_low = msm_flash_low,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_high = msm_flash_high,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_query_current = msm_flash_query_current,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static struct msm_flash_table msm_gpio_flash_table = {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_init = msm_flash_gpio_init,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_release = msm_flash_release,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_off = msm_flash_off,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_low = msm_flash_low,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_high = msm_flash_high,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:static struct msm_flash_table msm_i2c_flash_table = {
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_init = msm_flash_i2c_init,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_release = msm_flash_i2c_release,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_off = msm_flash_i2c_write_setting_array,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_low = msm_flash_i2c_write_setting_array,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:		.camera_flash_high = msm_flash_i2c_write_setting_array,
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:module_init(msm_flash_init_module);
media/platform/msm/camera_v2/sensor/flash/msm_flash.c:module_exit(msm_flash_exit_module);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:#include <media/msm_cam_sensor.h>
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:#include "msm_camera_i2c.h"
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:enum msm_camera_flash_state_t {
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:struct msm_flash_ctrl_t;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:struct msm_flash_func_t {
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	int32_t (*camera_flash_init)(struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:		struct msm_flash_cfg_data_t *flash_data);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	int32_t (*camera_flash_release)(struct msm_flash_ctrl_t *flash_ctrl);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	int32_t (*camera_flash_off)(struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:		struct msm_flash_cfg_data_t *flash_data);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	int32_t (*camera_flash_low)(struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:		struct msm_flash_cfg_data_t *flash_data);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	int32_t (*camera_flash_high)(struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:		struct msm_flash_cfg_data_t *flash_data);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:		struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:		struct msm_flash_query_data_t *flash_query_data);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:struct msm_flash_table {
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	enum msm_flash_driver_type flash_driver_type;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	struct msm_flash_func_t func_tbl;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:struct msm_flash_reg_t {
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	struct msm_camera_i2c_reg_setting *init_setting;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	struct msm_camera_i2c_reg_setting *off_setting;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	struct msm_camera_i2c_reg_setting *release_setting;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	struct msm_camera_i2c_reg_setting *low_setting;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	struct msm_camera_i2c_reg_setting *high_setting;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:struct msm_flash_ctrl_t {
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	struct msm_camera_i2c_client flash_i2c_client;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	struct msm_flash_func_t *func_tbl;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	struct msm_camera_power_ctrl_t power_info;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	enum msm_camera_device_type_t flash_device_type;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	struct msm_sensor_power_setting_array power_setting_array;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	enum msm_flash_driver_type flash_driver_type;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	enum msm_camera_flash_state_t flash_state;
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:	int32_t (*platform_flash_init)(struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:		struct msm_flash_cfg_data_t *flash_data);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:int msm_flash_i2c_probe(struct i2c_client *client,
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:int msm_flash_probe(struct platform_device *pdev, const void *data);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:int32_t msm_flash_create_v4lsubdev(struct platform_device *pdev,
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:int32_t msm_led_i2c_flash_create_v4lsubdev(void *data);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:int32_t msm_led_i2c_trigger_get_subdev_id(struct msm_flash_ctrl_t *fctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:int32_t msm_led_i2c_trigger_config(struct msm_flash_ctrl_t *fctrl,
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:int msm_flash_led_init(struct msm_flash_ctrl_t *fctrl);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:int msm_flash_led_release(struct msm_flash_ctrl_t *fctrl);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:int msm_flash_led_off(struct msm_flash_ctrl_t *fctrl);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:int msm_flash_led_low(struct msm_flash_ctrl_t *fctrl);
media/platform/msm/camera_v2/sensor/flash/msm_flash.h:int msm_flash_led_high(struct msm_flash_ctrl_t *fctrl);
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:#include "msm_flash.h"
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:static const struct of_device_id msm_gpio_flash_dt_match[] = {
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:static struct msm_flash_table qm215_gpio_flash_table;
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:MODULE_DEVICE_TABLE(of, msm_flash_dt_match);
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_flash_cfg_data_t *flash_data)
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_camera_power_ctrl_t *power_info = NULL;
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_camera_gpio_num_info *gpio_num_info = NULL;
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_flash_cfg_data_t *flash_data)
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_camera_power_ctrl_t *power_info = NULL;
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_camera_gpio_num_info *gpio_num_info = NULL;
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_flash_ctrl_t *flash_ctrl)
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:static int32_t qm215_flash_off(struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_flash_cfg_data_t *flash_data)
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_camera_power_ctrl_t *power_info = NULL;
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_camera_gpio_num_info *gpio_num_info = NULL;
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_flash_cfg_data_t *flash_data)
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:static int32_t qm215_platform_flash_init(struct msm_flash_ctrl_t *flash_ctrl,
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_flash_cfg_data_t *flash_data)
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_flash_ctrl_t *flash_ctrl = NULL;
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_camera_power_ctrl_t *power_info = NULL;
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	struct msm_camera_gpio_conf *gpio_conf = NULL;
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:			(struct msm_flash_ctrl_t *) platform_get_drvdata(pdev);
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:		rc = msm_camera_request_gpio_table(gpio_conf->cam_gpio_req_tbl,
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:static struct platform_driver msm_gpio_flash_platform_driver = {
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:		.of_match_table = msm_gpio_flash_dt_match,
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	rc = platform_driver_register(&msm_gpio_flash_platform_driver);
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:	platform_driver_unregister(&msm_gpio_flash_platform_driver);
media/platform/msm/camera_v2/sensor/flash/qm215_gpio_flash.c:static struct msm_flash_table qm215_gpio_flash_table = {
media/platform/msm/camera_v2/sensor/io/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/
media/platform/msm/camera_v2/sensor/io/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/sensor/io/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor
media/platform/msm/camera_v2/sensor/io/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
media/platform/msm/camera_v2/sensor/io/Makefile:obj-$(CONFIG_MSMB_CAMERA)   += msm_camera_cci_i2c.o msm_camera_qup_i2c.o msm_camera_spi.o msm_camera_dt_util.o msm_camera_tz_i2c.o
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:#include "msm_camera_i2c.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:#include "msm_cci.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:int32_t msm_camera_cci_i2c_read(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_cci_ctrl cci_ctrl;
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:int32_t msm_camera_cci_i2c_read_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_cci_ctrl cci_ctrl;
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:int32_t msm_camera_cci_i2c_write(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_cci_ctrl cci_ctrl;
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_reg_array reg_conf_tbl;
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:int32_t msm_camera_cci_i2c_write_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_cci_ctrl cci_ctrl;
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_reg_array *reg_conf_tbl = NULL;
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:		(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:static int32_t msm_camera_cci_i2c_write_table_cmd(
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_reg_setting *write_setting,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	enum msm_cci_cmd_type cmd)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_cci_ctrl cci_ctrl;
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:int32_t msm_camera_cci_i2c_write_table_async(
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	return msm_camera_cci_i2c_write_table_cmd(client, write_setting,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:int32_t msm_camera_cci_i2c_write_table_sync(
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	return msm_camera_cci_i2c_write_table_cmd(client, write_setting,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:int32_t msm_camera_cci_i2c_write_table_sync_block(
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	return msm_camera_cci_i2c_write_table_cmd(client, write_setting,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:int32_t msm_camera_cci_i2c_write_table(
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	return msm_camera_cci_i2c_write_table_cmd(client, write_setting,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:int32_t msm_camera_cci_i2c_write_seq_table(
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_seq_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_seq_reg_array *reg_setting;
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:		rc = msm_camera_cci_i2c_write_seq(client, reg_setting->reg_addr,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:int32_t msm_camera_cci_i2c_write_table_w_microdelay(
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_cci_ctrl cci_ctrl;
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:static int32_t msm_camera_cci_i2c_compare(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	rc = msm_camera_cci_i2c_read(client, addr, &reg_data, data_len);
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:int32_t msm_camera_cci_i2c_poll(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	enum msm_camera_i2c_data_type data_type, uint32_t delay_ms)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:		rc = msm_camera_cci_i2c_compare(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:static int32_t msm_camera_cci_i2c_set_mask(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	enum msm_camera_i2c_data_type data_type, uint16_t set_mask)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	rc = msm_camera_cci_i2c_read(client, addr, &reg_data, data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	rc = msm_camera_cci_i2c_write(client, addr, reg_data, data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:static int32_t msm_camera_cci_i2c_set_write_mask_data(
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:		rc = msm_camera_cci_i2c_write(client, addr, data, data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:		rc = msm_camera_cci_i2c_read(client, addr, &reg_data,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:		rc = msm_camera_cci_i2c_write(client, addr, reg_data,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:int32_t msm_camera_cci_i2c_write_conf_tbl(
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_i2c_reg_conf *reg_conf_tbl, uint16_t size,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:		enum msm_camera_i2c_data_type dt;
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:			rc = msm_camera_cci_i2c_poll(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:				rc = msm_camera_cci_i2c_write(
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:				rc = msm_camera_cci_i2c_set_mask(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:				rc = msm_camera_cci_i2c_set_mask(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:				rc = msm_camera_cci_i2c_set_mask(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:				rc = msm_camera_cci_i2c_set_mask(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:				rc = msm_camera_cci_i2c_set_write_mask_data(
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:int32_t msm_sensor_cci_i2c_util(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_cci_i2c.c:	struct msm_camera_cci_ctrl cci_ctrl;
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:#include "msm_camera_i2c_mux.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:#include "msm_cci.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:int msm_camera_fill_vreg_params(struct camera_vreg_t *cam_vreg,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	int num_vreg, struct msm_sensor_power_setting *power_setting,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:int msm_sensor_get_sub_module_index(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:				    struct  msm_sensor_info_t **s_info)
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_sensor_info_t *sensor_info;
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:int msm_sensor_get_dt_actuator_data(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:				    struct msm_actuator_info **act_info)
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_actuator_info *actuator_info;
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:int msm_sensor_get_dt_csi_data(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_camera_csi_lane_params **csi_lane_params)
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_camera_csi_lane_params *clp;
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:int msm_camera_get_dt_power_setting_data(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_camera_power_ctrl_t *power_info)
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_sensor_power_setting *ps;
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_sensor_power_setting *power_setting;
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:		struct msm_sensor_power_setting power_down_setting_t;
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:int msm_camera_get_dt_gpio_req_tbl(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_camera_gpio_conf *gconf, uint16_t *gpio_array,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:int msm_camera_init_gpio_pin_tbl(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_camera_gpio_conf *gconf, uint16_t *gpio_array,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	gconf->gpio_num_info = kzalloc(sizeof(struct msm_camera_gpio_num_info),
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:int msm_camera_get_dt_vreg_data(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:static int msm_camera_enable_i2c_mux(struct msm_camera_i2c_conf *i2c_conf)
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:static int msm_camera_disable_i2c_mux(struct msm_camera_i2c_conf *i2c_conf)
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:int msm_camera_pinctrl_init(
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_pinctrl_info *sensor_pctrl, struct device *dev)
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:static int msm_cam_sensor_handle_reg_gpio(int seq_val,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_camera_gpio_conf *gconf, int val)
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:int32_t msm_sensor_driver_get_gpio_data(
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_camera_gpio_conf **gpio_conf,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_camera_gpio_conf *gconf = NULL;
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	gconf = kzalloc(sizeof(struct msm_camera_gpio_conf),
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	rc = msm_camera_get_dt_gpio_req_tbl(of_node, gconf, gpio_array,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:		pr_err("failed in msm_camera_get_dt_gpio_req_tbl\n");
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	rc = msm_camera_init_gpio_pin_tbl(of_node, gconf, gpio_array,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:		pr_err("failed in msm_camera_init_gpio_pin_tbl\n");
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:int msm_camera_power_up(struct msm_camera_power_ctrl_t *ctrl,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	enum msm_camera_device_type_t device_type,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_camera_i2c_client *sensor_i2c_client)
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_sensor_power_setting *power_setting = NULL;
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	ret = msm_camera_pinctrl_init(&(ctrl->pinctrl_info), ctrl->dev);
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	rc = msm_camera_request_gpio_table(
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:			rc = msm_camera_clk_enable(ctrl->dev,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:				msm_camera_config_single_vreg(ctrl->dev,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:			rc = msm_cam_sensor_handle_reg_gpio(
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:				msm_camera_enable_i2c_mux(ctrl->i2c_conf);
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:				msm_camera_config_single_vreg(ctrl->dev,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:			msm_cam_sensor_handle_reg_gpio(power_setting->seq_val,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:				msm_camera_disable_i2c_mux(ctrl->i2c_conf);
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	msm_camera_request_gpio_table(
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:static struct msm_sensor_power_setting*
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:msm_camera_get_power_settings(struct msm_camera_power_ctrl_t *ctrl,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:				enum msm_sensor_power_seq_type_t seq_type,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_sensor_power_setting *power_setting, *ps = NULL;
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:int msm_camera_power_down(struct msm_camera_power_ctrl_t *ctrl,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	enum msm_camera_device_type_t device_type,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_camera_i2c_client *sensor_i2c_client)
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_sensor_power_setting *pd = NULL;
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	struct msm_sensor_power_setting *ps;
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:			msm_camera_clk_enable(ctrl->dev,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:			ps = msm_camera_get_power_settings(ctrl,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:					msm_camera_config_single_vreg(ctrl->dev,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:			ret = msm_cam_sensor_handle_reg_gpio(pd->seq_val,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:				msm_camera_disable_i2c_mux(ctrl->i2c_conf);
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.c:	msm_camera_request_gpio_table(
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:#include "msm_camera_i2c.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:int msm_sensor_get_sub_module_index(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:	struct  msm_sensor_info_t **s_info);
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:int msm_sensor_get_dt_actuator_data(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:	struct msm_actuator_info **act_info);
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:int msm_sensor_get_dt_csi_data(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:	struct msm_camera_csi_lane_params **csi_lane_params);
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:int msm_camera_get_dt_power_setting_data(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:	struct msm_camera_power_ctrl_t *power_info);
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:int msm_camera_get_dt_gpio_req_tbl(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:	struct msm_camera_gpio_conf *gconf, uint16_t *gpio_array,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:int msm_camera_init_gpio_pin_tbl(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:	struct msm_camera_gpio_conf *gconf, uint16_t *gpio_array,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:int msm_camera_get_dt_vreg_data(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:int msm_camera_power_up(struct msm_camera_power_ctrl_t *ctrl,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:	enum msm_camera_device_type_t device_type,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:	struct msm_camera_i2c_client *sensor_i2c_client);
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:int msm_camera_power_down(struct msm_camera_power_ctrl_t *ctrl,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:	enum msm_camera_device_type_t device_type,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:	struct msm_camera_i2c_client *sensor_i2c_client);
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:int msm_camera_fill_vreg_params(struct camera_vreg_t *cam_vreg,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:	int num_vreg, struct msm_sensor_power_setting *power_setting,
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:int msm_camera_pinctrl_init
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:	(struct msm_pinctrl_info *sensor_pctrl, struct device *dev);
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:int32_t msm_sensor_driver_get_gpio_data(
media/platform/msm/camera_v2/sensor/io/msm_camera_dt_util.h:	struct msm_camera_gpio_conf **gpio_conf,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:#include <media/msm_cam_sensor.h>
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:struct msm_camera_i2c_client {
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_fn_t *i2c_func_tbl;
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_cci_client *cci_client;
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_spi_client *spi_client;
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	enum msm_camera_i2c_reg_addr_type addr_type;
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:struct msm_camera_i2c_fn_t {
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	int (*i2c_read)(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	int32_t (*i2c_read_seq)(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	int (*i2c_write)(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	int (*i2c_write_seq)(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	int32_t (*i2c_write_table)(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	int32_t (*i2c_write_seq_table)(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		struct msm_camera_i2c_seq_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	int32_t (*i2c_util)(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	int32_t (*i2c_write_conf_tbl)(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		struct msm_camera_i2c_reg_conf *reg_conf_tbl, uint16_t size,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	int32_t (*i2c_poll)(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		enum msm_camera_i2c_data_type data_type, uint32_t delay_ms);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	int32_t (*i2c_read_burst)(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	int32_t (*i2c_write_burst)(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		struct msm_camera_i2c_reg_array *reg_setting, uint32_t reg_size,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	int32_t (*i2c_write_table_async)(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	int32_t (*i2c_write_table_sync)(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:		struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_cci_i2c_read(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_cci_i2c_read_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_cci_i2c_write(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_cci_i2c_write_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_cci_i2c_write_table(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_cci_i2c_write_table_async(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_cci_i2c_write_table_sync(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_cci_i2c_write_table_sync_block(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_cci_i2c_write_seq_table(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_seq_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_cci_i2c_write_table_w_microdelay(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_cci_i2c_write_conf_tbl(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_conf *reg_conf_tbl, uint16_t size,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_sensor_cci_i2c_util(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_cci_i2c_poll(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	enum msm_camera_i2c_data_type data_type, uint32_t delay_ms);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_qup_i2c_read(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_qup_i2c_read_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_qup_i2c_write(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_qup_i2c_write_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_qup_i2c_write_table(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_qup_i2c_write_seq_table(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_seq_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_qup_i2c_write_table_w_microdelay(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_qup_i2c_write_conf_tbl(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_conf *reg_conf_tbl, uint16_t size,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_qup_i2c_poll(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	enum msm_camera_i2c_data_type data_type, uint32_t delay_ms);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_register_sensor(void *s_ctrl_p);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_power_up(struct msm_camera_i2c_client *client);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_power_down(struct msm_camera_i2c_client *client);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_read(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_read_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_write(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_write_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_write_table(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_write_table_async(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_write_table_sync(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_write_table_sync_block(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_write_seq_table(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_seq_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_write_table_w_microdelay(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_write_conf_tbl(
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	struct msm_camera_i2c_reg_conf *reg_conf_tbl, uint16_t size,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_sensor_tz_i2c_util(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:int32_t msm_camera_tz_i2c_poll(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c.h:	enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:#include "msm_camera_i2c_mux.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:#define MSM_I2C_MUX_DRV_NAME "msm_cam_i2c_mux"
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:static int msm_i2c_mux_config(struct i2c_mux_device *mux_device, uint8_t *mode)
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:	val = msm_camera_io_r(mux_device->ctl_base);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:		msm_camera_io_w(val | 0x3, mux_device->ctl_base);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:		msm_camera_io_w(((val | 0x2) & ~(0x1)), mux_device->ctl_base);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:		val = msm_camera_io_r(mux_device->ctl_base);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:		msm_camera_io_w(((val | 0x1) & ~(0x2)), mux_device->ctl_base);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:		val = msm_camera_io_r(mux_device->ctl_base);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:static int msm_i2c_mux_init(struct i2c_mux_device *mux_device)
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:		val = msm_camera_io_r(mux_device->rw_base);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:		msm_camera_io_w((val | 0x200), mux_device->rw_base);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:static int msm_i2c_mux_release(struct i2c_mux_device *mux_device)
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:		val = msm_camera_io_r(mux_device->rw_base);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:		msm_camera_io_w((val & ~0x200), mux_device->rw_base);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:static long msm_i2c_mux_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:		rc = msm_i2c_mux_config(mux_device, (uint8_t *) arg);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:		rc = msm_i2c_mux_init(mux_device);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:		rc = msm_i2c_mux_release(mux_device);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:static struct v4l2_subdev_core_ops msm_i2c_mux_subdev_core_ops = {
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:	.ioctl = &msm_i2c_mux_subdev_ioctl,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:static const struct v4l2_subdev_ops msm_i2c_mux_subdev_ops = {
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:	.core = &msm_i2c_mux_subdev_core_ops,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:	v4l2_subdev_init(&mux_device->subdev, &msm_i2c_mux_subdev_ops);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:	mux_device->ctl_base = msm_camera_get_reg_base(pdev,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:	mux_device->rw_base = msm_camera_get_reg_base(pdev, "i2c_mux_rw", true);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:	msm_camera_put_reg_base(pdev, mux_device->ctl_base,
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:	msm_camera_put_reg_base(pdev, mux_device->rw_base, "i2c_mux_ctl", true);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:	msm_camera_put_reg_base(pdev, mux_device->ctl_base, "i2c_mux_rw", true);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:static int __init msm_camera_i2c_mux_init_module(void)
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:static void __exit msm_camera_i2c_mux_exit_module(void)
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:module_init(msm_camera_i2c_mux_init_module);
media/platform/msm/camera_v2/sensor/io/msm_camera_i2c_mux.c:module_exit(msm_camera_i2c_mux_exit_module);
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:#include "msm_camera_i2c.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:static int32_t msm_camera_qup_i2c_rxdata(
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	struct msm_camera_i2c_client *dev_client, unsigned char *rxdata,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:static int32_t msm_camera_qup_i2c_txdata(
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	struct msm_camera_i2c_client *dev_client, unsigned char *txdata,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:int32_t msm_camera_qup_i2c_read(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	rc = msm_camera_qup_i2c_rxdata(client, buf, data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:int32_t msm_camera_qup_i2c_read_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	rc = msm_camera_qup_i2c_rxdata(client, buf, num_byte);
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:int32_t msm_camera_qup_i2c_write(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	rc = msm_camera_qup_i2c_txdata(client, buf, len);
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:int32_t msm_camera_qup_i2c_write_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	rc = msm_camera_qup_i2c_txdata(client, buf, len+num_byte);
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:int32_t msm_camera_qup_i2c_write_table(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	struct msm_camera_i2c_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	struct msm_camera_i2c_reg_array *reg_setting;
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:		rc = msm_camera_qup_i2c_write(client, reg_setting->reg_addr,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:int32_t msm_camera_qup_i2c_write_seq_table(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	struct msm_camera_i2c_seq_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	struct msm_camera_i2c_seq_reg_array *reg_setting;
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:		rc = msm_camera_qup_i2c_write_seq(client, reg_setting->reg_addr,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:int32_t msm_camera_qup_i2c_write_table_w_microdelay(
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	struct msm_camera_i2c_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	struct msm_camera_i2c_reg_array *reg_setting = NULL;
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:		rc = msm_camera_qup_i2c_write(client, reg_setting->reg_addr,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:static int32_t msm_camera_qup_i2c_compare(
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	struct msm_camera_i2c_client *client, uint32_t addr, uint16_t data,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	rc = msm_camera_qup_i2c_read(client, addr, &reg_data, data_len);
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:int32_t msm_camera_qup_i2c_poll(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	enum msm_camera_i2c_data_type data_type, uint32_t delay_ms)
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:		rc = msm_camera_qup_i2c_compare(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:static int32_t msm_camera_qup_i2c_set_mask(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	enum msm_camera_i2c_data_type data_type, uint16_t set_mask)
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	rc = msm_camera_qup_i2c_read(client, addr, &reg_data, data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	rc = msm_camera_qup_i2c_write(client, addr, reg_data, data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:static int32_t msm_camera_qup_i2c_set_write_mask_data(
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:		rc = msm_camera_qup_i2c_write(client, addr, data, data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:		rc = msm_camera_qup_i2c_read(client, addr, &reg_data,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:		rc = msm_camera_qup_i2c_write(client, addr, reg_data,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:int32_t msm_camera_qup_i2c_write_conf_tbl(
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	struct msm_camera_i2c_reg_conf *reg_conf_tbl, uint16_t size,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:		enum msm_camera_i2c_data_type dt;
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:			rc = msm_camera_qup_i2c_poll(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:				rc = msm_camera_qup_i2c_write(
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:				rc = msm_camera_qup_i2c_set_mask(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:				rc = msm_camera_qup_i2c_set_mask(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:				rc = msm_camera_qup_i2c_set_mask(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:				rc = msm_camera_qup_i2c_set_mask(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_qup_i2c.c:				rc = msm_camera_qup_i2c_set_write_mask_data(
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:#include "msm_camera_spi.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:static int msm_camera_spi_txfr(struct spi_device *spi, char *txbuf,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:static int msm_camera_spi_txfr_read(struct spi_device *spi, char *txbuf,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c: * msm_camera_set_addr() - helper function to set transfer address
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:static void msm_camera_set_addr(uint32_t addr, uint8_t addr_len,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:				enum msm_camera_i2c_reg_addr_type type,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c: * msm_camera_spi_tx_helper() - wrapper for SPI transaction
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:static int32_t msm_camera_spi_tx_helper(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_spi_inst *inst, uint32_t addr, uint8_t *data,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	hlen = msm_camera_spi_get_hlen(inst);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	msm_camera_set_addr(addr, inst->addr_len, client->addr_type, ctx + 1);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	while ((rc = msm_camera_spi_txfr(spi, ctx, crx, len)) && retries) {
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:static int32_t msm_camera_spi_tx_read(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_spi_inst *inst, uint32_t addr, uint8_t *data,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	hlen = msm_camera_spi_get_hlen(inst);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:		msm_camera_set_addr(addr, inst->addr_len, client->addr_type,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	while ((rc = msm_camera_spi_txfr_read(spi, ctx, crx, hlen, num_byte))
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:int32_t msm_camera_spi_read(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	rc = msm_camera_spi_tx_read(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:int32_t msm_camera_spi_read_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	return msm_camera_spi_tx_helper(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c: * msm_camera_spi_read_seq_l()- function for large SPI reads
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c: * obtained by msm_camera_spi_get_hlen().
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:int32_t msm_camera_spi_read_seq_l(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	return msm_camera_spi_tx_helper(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:int32_t msm_camera_spi_query_id(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	return msm_camera_spi_tx_helper(client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:static int32_t msm_camera_spi_read_status_reg(
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_i2c_client *client, uint8_t *status)
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_spi_inst *rs =
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	return msm_camera_spi_tx_helper(client, rs, 0, status, 1, NULL, NULL);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:static int32_t msm_camera_spi_device_busy(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	rc = msm_camera_spi_read_status_reg(client,  &st);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:static int32_t msm_camera_spi_wait(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_spi_inst *inst)
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:		rc = msm_camera_spi_device_busy(client, &busy);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:static int32_t msm_camera_spi_write_enable(
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_i2c_client *client)
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_spi_inst *we =
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	rc = msm_camera_spi_tx_helper(client, we, 0, NULL, 0, NULL, NULL);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:int32_t msm_camera_spi_erase(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_spi_inst *se = &client->spi_client->cmd_tbl.erase;
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:		rc = msm_camera_spi_write_enable(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:		rc = msm_camera_spi_tx_helper(client, se, cur, NULL, 0,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:		rc = msm_camera_spi_wait(client, se);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c: * msm_camera_spi_page_program() - core function to perform write
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c: * used outside msm_camera_spi_write_seq().
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:static int32_t msm_camera_spi_page_program(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_spi_inst *pg =
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	rc = msm_camera_spi_write_enable(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	msm_camera_set_addr(addr, pg->addr_len, client->addr_type, tx + 1);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:		rc = msm_camera_spi_wait(client, pg);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	rc = msm_camera_spi_wait(client, pg);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:int32_t msm_camera_spi_write_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_spi_inst *pg =
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:		rc = msm_camera_spi_page_program(client, addr, data,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:		rc = msm_camera_spi_page_program(client, addr, pdata,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:int32_t msm_camera_spi_write(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	uint32_t addr, uint16_t data, enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_spi_inst *pg =
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	rc = msm_camera_spi_page_program(client, addr, buf,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:int32_t msm_camera_spi_write_table(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_i2c_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_i2c_reg_array *reg_setting;
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:		rc = msm_camera_spi_write(client, reg_setting->reg_addr,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:static uint32_t msm_get_burst_size(struct msm_camera_i2c_reg_array *reg_setting,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:static int32_t msm_camera_spi_send_burst(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_i2c_reg_array *reg_setting, uint32_t reg_size,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_burst_info *info,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_spi_inst *pg =
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:		rc = msm_camera_spi_txfr(client->spi_client->spi_master,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:		rc = msm_camera_spi_txfr(client->spi_client->spi_master,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:int32_t msm_camera_spi_send_burst(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_i2c_reg_array *reg_setting, uint32_t reg_size,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_burst_info *info,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_spi_inst *pg =
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_spi_write_burst_packet tx_buf;
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:		rc = msm_camera_spi_txfr(client->spi_client->spi_master,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:		rc = msm_camera_spi_txfr(client->spi_client->spi_master,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:int32_t msm_camera_spi_write_burst(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_i2c_reg_array *reg_setting, uint32_t reg_size,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_burst_info burst_info;
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:				sizeof(struct msm_camera_burst_info));
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:				msm_get_burst_size(reg_setting, reg_size, k,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:			rc = msm_camera_spi_send_burst(client, reg_setting,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:			msm_camera_spi_write(client, reg_setting[k].reg_addr,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:int32_t msm_camera_spi_read_burst(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	struct msm_camera_spi_inst *pg =
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	uint32_t len = msm_camera_spi_get_hlen(pg);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.c:	rc = msm_camera_spi_txfr_read(client->spi_client->spi_master,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:#include <media/msm_cam_sensor.h>
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:#include "msm_camera_i2c.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:struct msm_camera_spi_inst {
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:struct msm_spi_write_burst_data {
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:struct msm_spi_write_burst_packet {
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	struct msm_spi_write_burst_data data_arr[MAX_SPI_SIZE];
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:struct msm_camera_burst_info {
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:struct msm_camera_spi_inst_tbl {
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	struct msm_camera_spi_inst read;
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	struct msm_camera_spi_inst read_seq;
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	struct msm_camera_spi_inst query_id;
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	struct msm_camera_spi_inst page_program;
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	struct msm_camera_spi_inst write_enable;
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	struct msm_camera_spi_inst read_status;
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	struct msm_camera_spi_inst erase;
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:struct msm_camera_spi_client {
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	struct msm_camera_spi_inst_tbl cmd_tbl;
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:uint16_t msm_camera_spi_get_hlen(struct msm_camera_spi_inst *inst)
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:int32_t msm_camera_spi_read(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:int32_t msm_camera_spi_read_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:int32_t msm_camera_spi_read_seq_l(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:int32_t msm_camera_spi_query_id(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:int32_t msm_camera_spi_write_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:int32_t msm_camera_spi_erase(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:int32_t msm_camera_spi_write(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	uint32_t addr, uint16_t data, enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:int32_t msm_camera_spi_write_table(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	struct msm_camera_i2c_reg_setting *write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:int32_t msm_camera_spi_write_burst(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	struct msm_camera_i2c_reg_array *reg_setting, uint32_t reg_size,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:int32_t msm_camera_spi_read_burst(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_spi.h:	enum msm_camera_i2c_data_type data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:#include "msm_camera_i2c.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:#include "msm_camera_tz_util.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:#include "msm_cci.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:#include "msm_sensor.h"
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:#pragma pack(push, msm_camera_tz_i2c, 1)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:struct msm_camera_tz_i2c_cci_generic_req_t {
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_tz_cmd_id_t cmd_id;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_tz_cmd_id_t cci_cmd_id;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:#define msm_camera_tz_i2c_cci_generic_rsp_t msm_camera_tz_generic_rsp_t
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:struct msm_camera_tz_i2c_power_up_req_t {
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_tz_cmd_id_t cmd_id;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:#define msm_camera_tz_i2c_power_up_rsp_t msm_camera_tz_generic_rsp_t
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:struct msm_camera_tz_i2c_power_down_req_t {
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_tz_cmd_id_t cmd_id;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:#define msm_camera_tz_i2c_power_down_rsp_t msm_camera_tz_generic_rsp_t
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:struct msm_camera_tz_i2c_cci_read_req_t {
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_tz_cmd_id_t cmd_id;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:struct msm_camera_tz_i2c_cci_read_rsp_t {
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_tz_status_t rc;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:struct msm_camera_tz_i2c_cci_write_req_t {
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_tz_cmd_id_t cmd_id;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:#define msm_camera_tz_i2c_cci_write_rsp_t msm_camera_tz_generic_rsp_t
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:struct msm_camera_tz_i2c_cci_util_req_t {
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_tz_cmd_id_t cmd_id;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:#define msm_camera_tz_i2c_cci_util_rsp_t msm_camera_tz_generic_rsp_t
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:#pragma pack(pop, msm_camera_tz_i2c)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:struct msm_camera_tz_i2c_sensor_info_t {
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_sensor_ctrl_t    *s_ctrl;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_fn_t  *saved_sensor_i2c_fn;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:static struct msm_camera_tz_i2c_sensor_info_t sensor_info[MAX_CAMERAS];
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:static int32_t msm_camera_tz_i2c_is_sensor_secure(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:static int32_t msm_camera_tz_i2c_ta_power_up(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_tz_i2c_power_up_req_t *cmd;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_tz_i2c_power_up_rsp_t *rsp;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	cmd_len = sizeof(struct msm_camera_tz_i2c_power_up_req_t);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	rsp_len = sizeof(struct msm_camera_tz_i2c_power_up_rsp_t);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:static int32_t msm_camera_tz_i2c_ta_power_down(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_tz_i2c_power_down_req_t *cmd;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_tz_i2c_power_down_rsp_t *rsp;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	cmd_len = sizeof(struct msm_camera_tz_i2c_power_down_req_t);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	rsp_len = sizeof(struct msm_camera_tz_i2c_power_down_rsp_t);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:static int32_t msm_camera_tz_i2c_ta_cci_generic(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_tz_cmd_id_t cci_cmd_id)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_tz_i2c_cci_generic_req_t *cmd;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_tz_i2c_cci_generic_rsp_t *rsp;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_is_sensor_secure(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	ta_qseecom_handle = msm_camera_tz_get_ta_handle();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	cmd_len = sizeof(struct msm_camera_tz_i2c_cci_generic_req_t);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	rsp_len = sizeof(struct msm_camera_tz_i2c_cci_generic_rsp_t);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:static int32_t msm_camera_tz_i2c_ta_cci_read(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_tz_i2c_cci_read_req_t *cmd;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_tz_i2c_cci_read_rsp_t *rsp;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_is_sensor_secure(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	ta_qseecom_handle = msm_camera_tz_get_ta_handle();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	cmd_len = sizeof(struct msm_camera_tz_i2c_cci_read_req_t);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	rsp_len = sizeof(struct msm_camera_tz_i2c_cci_read_rsp_t);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:static int32_t msm_camera_tz_i2c_ta_cci_write(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_tz_i2c_cci_write_req_t *cmd;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_tz_i2c_cci_write_rsp_t *rsp;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_is_sensor_secure(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	ta_qseecom_handle = msm_camera_tz_get_ta_handle();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	cmd_len = sizeof(struct msm_camera_tz_i2c_cci_write_req_t);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	rsp_len = sizeof(struct msm_camera_tz_i2c_cci_write_rsp_t);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:static int32_t msm_camera_tz_i2c_ta_cci_util(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_tz_i2c_cci_util_req_t *cmd;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_tz_i2c_cci_util_rsp_t *rsp;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_is_sensor_secure(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	ta_qseecom_handle = msm_camera_tz_get_ta_handle();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	cmd_len = sizeof(struct msm_camera_tz_i2c_cci_util_req_t);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	rsp_len = sizeof(struct msm_camera_tz_i2c_cci_util_rsp_t);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:static int32_t msm_camera_tz_i2c_ta_probe(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	sensor_id = msm_camera_tz_i2c_is_sensor_secure(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_lock();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:static int32_t msm_camera_tz_i2c_ta_done(void)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	msm_camera_tz_unlock();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_power_up(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_is_sensor_secure(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_load_ta();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:			msm_camera_tz_lock();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:			rc = msm_camera_tz_i2c_ta_power_up(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:				msm_camera_tz_get_ta_handle(),
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:				msm_camera_tz_unload_ta();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:			msm_camera_tz_unlock();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_power_down(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_is_sensor_secure(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_lock();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_power_down(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:			msm_camera_tz_get_ta_handle(),
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_unlock();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:			rc = msm_camera_tz_unload_ta();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_register_sensor(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_sensor_ctrl_t *s_ctrl = (struct msm_sensor_ctrl_t *)s_ctrl_p;
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_read(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_cci_read(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_i2c_ta_done();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_cci_i2c_read, client, addr, data, data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_read_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_cci_generic(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_i2c_ta_done();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_cci_i2c_read_seq, client, addr, data, num_byte);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_write(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_cci_write(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_i2c_ta_done();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_cci_i2c_write, client, addr, data, data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_write_seq(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_cci_generic(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_i2c_ta_done();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_cci_i2c_write_seq, client, addr, data, num_byte);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_write_table_async(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_cci_generic(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_i2c_ta_done();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_cci_i2c_write_table_async, client, write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_write_table_sync(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_cci_generic(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_i2c_ta_done();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_cci_i2c_write_table_sync, client, write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_write_table_sync_block(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_cci_generic(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_i2c_ta_done();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_cci_i2c_write_table_sync_block, client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_write_table(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_cci_generic(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_i2c_ta_done();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_cci_i2c_write_table, client, write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_write_seq_table(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_seq_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_cci_generic(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_i2c_ta_done();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_cci_i2c_write_seq_table, client, write_setting);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_write_table_w_microdelay(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_reg_setting *write_setting)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_cci_generic(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_i2c_ta_done();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_cci_i2c_write_table_w_microdelay, client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_poll(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_cci_generic(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_i2c_ta_done();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_cci_i2c_poll, client, addr, data, data_type);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_camera_tz_i2c_write_conf_tbl(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	struct msm_camera_i2c_reg_conf *reg_conf_tbl, uint16_t size,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_cci_generic(
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_i2c_ta_done();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_cci_i2c_write_conf_tbl, client, reg_conf_tbl, size,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:int32_t msm_sensor_tz_i2c_util(struct msm_camera_i2c_client *client,
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		rc = msm_camera_tz_i2c_ta_cci_util(client, cci_cmd);
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_camera_tz_i2c_ta_done();
media/platform/msm/camera_v2/sensor/io/msm_camera_tz_i2c.c:		msm_sensor_cci_i2c_util, client, cci_cmd);
media/platform/msm/camera_v2/sensor/ir_cut/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/sensor/ir_cut/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/sensor/ir_cut/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/sensor/ir_cut/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_ir_cut.o
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:#include "msm_ir_cut.h"
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:DEFINE_MSM_MUTEX(msm_ir_cut_mutex);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static struct v4l2_file_operations msm_ir_cut_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static const struct of_device_id msm_ir_cut_dt_match[] = {
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static struct msm_ir_cut_table msm_gpio_ir_cut_table;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static struct msm_ir_cut_table *ir_cut_table[] = {
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	&msm_gpio_ir_cut_table,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static int32_t msm_ir_cut_get_subdev_id(
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_ctrl_t *ir_cut_ctrl, void *arg)
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static int32_t msm_ir_cut_init(
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_ctrl_t *ir_cut_ctrl,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_cfg_data_t *ir_cut_data)
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static int32_t msm_ir_cut_release(
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_ctrl_t *ir_cut_ctrl)
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static int32_t msm_ir_cut_off(struct msm_ir_cut_ctrl_t *ir_cut_ctrl,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_cfg_data_t *ir_cut_data)
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		rc = msm_camera_request_gpio_table(
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		rc = msm_camera_request_gpio_table(
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static int32_t msm_ir_cut_on(
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_ctrl_t *ir_cut_ctrl,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_cfg_data_t *ir_cut_data)
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		rc = msm_camera_request_gpio_table(
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		rc = msm_camera_request_gpio_table(
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static int32_t msm_ir_cut_handle_init(
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_ctrl_t *ir_cut_ctrl,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_cfg_data_t *ir_cut_data)
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	enum msm_ir_cut_driver_type ir_cut_driver_type =
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static int32_t msm_ir_cut_config(struct msm_ir_cut_ctrl_t *ir_cut_ctrl,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_cfg_data_t *ir_cut_data =
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		(struct msm_ir_cut_cfg_data_t *) argp;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		rc = msm_ir_cut_handle_init(ir_cut_ctrl, ir_cut_data);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static long msm_ir_cut_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_ctrl_t *fctrl = NULL;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		return msm_ir_cut_get_subdev_id(fctrl, argp);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		return msm_ir_cut_config(fctrl, argp);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static struct v4l2_subdev_core_ops msm_ir_cut_subdev_core_ops = {
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	.ioctl = msm_ir_cut_subdev_ioctl,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static struct v4l2_subdev_ops msm_ir_cut_subdev_ops = {
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	.core = &msm_ir_cut_subdev_core_ops,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static int msm_ir_cut_close(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_ctrl_t *ir_cut_ctrl = v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static const struct v4l2_subdev_internal_ops msm_ir_cut_internal_ops = {
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	.close = msm_ir_cut_close,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static int32_t msm_ir_cut_get_gpio_dt_data(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		struct msm_ir_cut_ctrl_t *fctrl)
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_camera_gpio_conf *gconf = NULL;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:			 kzalloc(sizeof(struct msm_camera_gpio_conf),
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		rc = msm_camera_get_dt_gpio_req_tbl(of_node, gconf,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static int32_t msm_ir_cut_get_dt_data(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_ctrl_t *fctrl)
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	rc = msm_ir_cut_get_gpio_dt_data(of_node, fctrl);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		pr_err("%s:%d msm_ir_cut_get_gpio_dt_data failed rc %d\n",
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static long msm_ir_cut_subdev_do_ioctl(
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_cfg_data_t32 *u32 =
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		(struct msm_ir_cut_cfg_data_t32 *)arg;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_cfg_data_t ir_cut_data;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		return msm_ir_cut_subdev_ioctl(sd, cmd, arg);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	rc = msm_ir_cut_subdev_ioctl(sd, cmd, &ir_cut_data);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static long msm_ir_cut_subdev_fops_ioctl(struct file *file,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	return video_usercopy(file, cmd, arg, msm_ir_cut_subdev_do_ioctl);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static int32_t msm_ir_cut_platform_probe(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	struct msm_ir_cut_ctrl_t *ir_cut_ctrl = NULL;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	ir_cut_ctrl = kzalloc(sizeof(struct msm_ir_cut_ctrl_t), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	memset(ir_cut_ctrl, 0, sizeof(struct msm_ir_cut_ctrl_t));
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	rc = msm_ir_cut_get_dt_data(pdev->dev.of_node, ir_cut_ctrl);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		pr_err("%s:%d msm_ir_cut_get_dt_data failed\n",
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	rc = msm_sensor_driver_get_gpio_data(&(ir_cut_ctrl->gconf),
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	rc = msm_camera_pinctrl_init(
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	ir_cut_ctrl->ir_cut_mutex = &msm_ir_cut_mutex;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	v4l2_subdev_init(&ir_cut_ctrl->msm_sd.sd, &msm_ir_cut_subdev_ops);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	v4l2_set_subdevdata(&ir_cut_ctrl->msm_sd.sd, ir_cut_ctrl);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	ir_cut_ctrl->msm_sd.sd.internal_ops = &msm_ir_cut_internal_ops;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	ir_cut_ctrl->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	snprintf(ir_cut_ctrl->msm_sd.sd.name,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		ARRAY_SIZE(ir_cut_ctrl->msm_sd.sd.name),
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		"msm_camera_ir_cut");
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	media_entity_pads_init(&ir_cut_ctrl->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	ir_cut_ctrl->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_IR_CUT;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	ir_cut_ctrl->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x1;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	msm_sd_register(&ir_cut_ctrl->msm_sd);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		ir_cut_ctrl->msm_sd.sd.entity.name);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	msm_ir_cut_v4l2_subdev_fops = v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	msm_ir_cut_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		msm_ir_cut_subdev_fops_ioctl;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	ir_cut_ctrl->msm_sd.sd.devnode->fops = &msm_ir_cut_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:MODULE_DEVICE_TABLE(of, msm_ir_cut_dt_match);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static struct platform_driver msm_ir_cut_platform_driver = {
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	.probe = msm_ir_cut_platform_probe,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		.of_match_table = msm_ir_cut_dt_match,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static int __init msm_ir_cut_init_module(void)
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	rc = platform_driver_register(&msm_ir_cut_platform_driver);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static void __exit msm_ir_cut_exit_module(void)
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:	platform_driver_unregister(&msm_ir_cut_platform_driver);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:static struct msm_ir_cut_table msm_gpio_ir_cut_table = {
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		.camera_ir_cut_init = msm_ir_cut_init,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		.camera_ir_cut_release = msm_ir_cut_release,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		.camera_ir_cut_off = msm_ir_cut_off,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:		.camera_ir_cut_on = msm_ir_cut_on,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:module_init(msm_ir_cut_init_module);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.c:module_exit(msm_ir_cut_exit_module);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:enum msm_camera_ir_cut_state_t {
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:enum msm_ir_cut_driver_type {
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:struct msm_ir_cut_ctrl_t;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:struct msm_ir_cut_func_t {
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	int32_t (*camera_ir_cut_init)(struct msm_ir_cut_ctrl_t *ir_cut_ctrl,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:		struct msm_ir_cut_cfg_data_t *ir_cut_data);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	int32_t (*camera_ir_cut_release)(struct msm_ir_cut_ctrl_t *ir_cut_ctrl);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	int32_t (*camera_ir_cut_off)(struct msm_ir_cut_ctrl_t *ir_cut_ctrl,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:		struct msm_ir_cut_cfg_data_t *ir_cut_data);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	int32_t (*camera_ir_cut_on)(struct msm_ir_cut_ctrl_t *ir_cut_ctrl,
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:		struct msm_ir_cut_cfg_data_t *ir_cut_data);
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:struct msm_ir_cut_table {
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	enum msm_ir_cut_driver_type ir_cut_driver_type;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	struct msm_ir_cut_func_t func_tbl;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:struct msm_ir_cut_ctrl_t {
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	struct msm_ir_cut_func_t *func_tbl;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	struct msm_camera_power_ctrl_t power_info;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	enum msm_camera_device_type_t ir_cut_device_type;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	enum msm_ir_cut_driver_type ir_cut_driver_type;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	enum msm_camera_ir_cut_state_t ir_cut_state;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	struct msm_camera_gpio_conf *gconf;
media/platform/msm/camera_v2/sensor/ir_cut/msm_ir_cut.h:	struct msm_pinctrl_info pinctrl_info;
media/platform/msm/camera_v2/sensor/ir_led/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/sensor/ir_led/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/sensor/ir_led/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/sensor/ir_led/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_ir_led.o
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:#include "msm_ir_led.h"
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:DEFINE_MSM_MUTEX(msm_ir_led_mutex);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static struct v4l2_file_operations msm_ir_led_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static const struct of_device_id msm_ir_led_dt_match[] = {
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static struct msm_ir_led_table msm_default_ir_led_table;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static struct msm_ir_led_table *ir_led_table[] = {
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	&msm_default_ir_led_table,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static int32_t msm_ir_led_get_subdev_id(
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_ctrl_t *ir_led_ctrl, void *arg)
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static int32_t msm_ir_led_init(
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_ctrl_t *ir_led_ctrl,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_cfg_data_t *ir_led_data)
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static int32_t msm_ir_led_release(
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_ctrl_t *ir_led_ctrl)
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static int32_t msm_ir_led_off(struct msm_ir_led_ctrl_t *ir_led_ctrl,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_cfg_data_t *ir_led_data)
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static int32_t msm_ir_led_on(
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_ctrl_t *ir_led_ctrl,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_cfg_data_t *ir_led_data)
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static int32_t msm_ir_led_handle_init(
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_ctrl_t *ir_led_ctrl,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_cfg_data_t *ir_led_data)
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	enum msm_ir_led_driver_type ir_led_driver_type =
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static int32_t msm_ir_led_config(struct msm_ir_led_ctrl_t *ir_led_ctrl,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_cfg_data_t *ir_led_data =
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		(struct msm_ir_led_cfg_data_t *) argp;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		rc = msm_ir_led_handle_init(ir_led_ctrl, ir_led_data);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static long msm_ir_led_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_ctrl_t *fctrl = NULL;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		return msm_ir_led_get_subdev_id(fctrl, argp);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		return msm_ir_led_config(fctrl, argp);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static struct v4l2_subdev_core_ops msm_ir_led_subdev_core_ops = {
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	.ioctl = msm_ir_led_subdev_ioctl,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static struct v4l2_subdev_ops msm_ir_led_subdev_ops = {
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	.core = &msm_ir_led_subdev_core_ops,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static int msm_ir_led_close(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_ctrl_t *ir_led_ctrl = v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static const struct v4l2_subdev_internal_ops msm_ir_led_internal_ops = {
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	.close = msm_ir_led_close,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static int32_t msm_ir_led_get_dt_data(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_ctrl_t *fctrl)
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static long msm_ir_led_subdev_do_ioctl(
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_cfg_data_t32 *u32 =
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		(struct msm_ir_led_cfg_data_t32 *)arg;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_cfg_data_t ir_led_data;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		return msm_ir_led_subdev_ioctl(sd, cmd, arg);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	rc = msm_ir_led_subdev_ioctl(sd, cmd, &ir_led_data);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static long msm_ir_led_subdev_fops_ioctl(struct file *file,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	return video_usercopy(file, cmd, arg, msm_ir_led_subdev_do_ioctl);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static int32_t msm_ir_led_platform_probe(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	struct msm_ir_led_ctrl_t *ir_led_ctrl = NULL;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	ir_led_ctrl = devm_kzalloc(&pdev->dev, sizeof(struct msm_ir_led_ctrl_t),
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	rc = msm_ir_led_get_dt_data(pdev->dev.of_node, ir_led_ctrl);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		pr_err("msm_ir_led_get_dt_data failed\n");
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	ir_led_ctrl->ir_led_mutex = &msm_ir_led_mutex;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	v4l2_subdev_init(&ir_led_ctrl->msm_sd.sd, &msm_ir_led_subdev_ops);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	v4l2_set_subdevdata(&ir_led_ctrl->msm_sd.sd, ir_led_ctrl);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	ir_led_ctrl->msm_sd.sd.internal_ops = &msm_ir_led_internal_ops;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	ir_led_ctrl->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	snprintf(ir_led_ctrl->msm_sd.sd.name,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		ARRAY_SIZE(ir_led_ctrl->msm_sd.sd.name),
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		"msm_camera_ir_led");
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	media_entity_pads_init(&ir_led_ctrl->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	ir_led_ctrl->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_IR_LED;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	ir_led_ctrl->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x1;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	msm_sd_register(&ir_led_ctrl->msm_sd);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		ir_led_ctrl->msm_sd.sd.entity.name);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	msm_ir_led_v4l2_subdev_fops = v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	msm_ir_led_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		msm_ir_led_subdev_fops_ioctl;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	ir_led_ctrl->msm_sd.sd.devnode->fops = &msm_ir_led_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:MODULE_DEVICE_TABLE(of, msm_ir_led_dt_match);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static struct platform_driver msm_ir_led_platform_driver = {
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	.probe = msm_ir_led_platform_probe,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		.of_match_table = msm_ir_led_dt_match,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static int __init msm_ir_led_init_module(void)
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	rc = platform_driver_register(&msm_ir_led_platform_driver);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static void __exit msm_ir_led_exit_module(void)
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:	platform_driver_unregister(&msm_ir_led_platform_driver);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:static struct msm_ir_led_table msm_default_ir_led_table = {
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		.camera_ir_led_init = msm_ir_led_init,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		.camera_ir_led_release = msm_ir_led_release,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		.camera_ir_led_off = msm_ir_led_off,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:		.camera_ir_led_on = msm_ir_led_on,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:module_init(msm_ir_led_init_module);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.c:module_exit(msm_ir_led_exit_module);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:#include <media/msm_cam_sensor.h>
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:enum msm_camera_ir_led_state_t {
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:enum msm_ir_led_driver_type {
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:struct msm_ir_led_ctrl_t;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:struct msm_ir_led_func_t {
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:	int32_t (*camera_ir_led_init)(struct msm_ir_led_ctrl_t *ir_led_ctrl,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:		struct msm_ir_led_cfg_data_t *ir_led_data);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:	int32_t (*camera_ir_led_release)(struct msm_ir_led_ctrl_t *ir_led_ctrl);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:	int32_t (*camera_ir_led_off)(struct msm_ir_led_ctrl_t *ir_led_ctrl,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:		struct msm_ir_led_cfg_data_t *ir_led_data);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:	int32_t (*camera_ir_led_on)(struct msm_ir_led_ctrl_t *ir_led_ctrl,
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:		struct msm_ir_led_cfg_data_t *ir_led_data);
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:struct msm_ir_led_table {
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:	enum msm_ir_led_driver_type ir_led_driver_type;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:	struct msm_ir_led_func_t func_tbl;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:struct msm_ir_led_ctrl_t {
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:	struct msm_ir_led_func_t *func_tbl;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:	struct msm_camera_power_ctrl_t power_info;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:	enum msm_camera_device_type_t ir_led_device_type;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:	enum msm_ir_led_driver_type ir_led_driver_type;
media/platform/msm/camera_v2/sensor/ir_led/msm_ir_led.h:	enum msm_camera_ir_led_state_t ir_led_state;
media/platform/msm/camera_v2/sensor/laser_led/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/sensor/laser_led/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/sensor/laser_led/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/sensor/laser_led/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
media/platform/msm/camera_v2/sensor/laser_led/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_laser_led.o
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:#include "msm_laser_led.h"
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:#include "msm_cci.h"
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:DEFINE_MSM_MUTEX(msm_laser_led_mutex);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static struct v4l2_file_operations msm_laser_led_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static const struct of_device_id msm_laser_led_dt_match[] = {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static long msm_laser_led_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static int32_t msm_laser_led_get_subdev_id(
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_ctrl_t *laser_led_ctrl, void __user *arg)
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static struct msm_camera_i2c_fn_t msm_sensor_cci_func_tbl = {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	.i2c_read = msm_camera_cci_i2c_read,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	.i2c_read_seq = msm_camera_cci_i2c_read_seq,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	.i2c_write = msm_camera_cci_i2c_write,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	.i2c_write_table = msm_camera_cci_i2c_write_table,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	.i2c_write_seq_table = msm_camera_cci_i2c_write_seq_table,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		msm_camera_cci_i2c_write_table_w_microdelay,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	.i2c_util = msm_sensor_cci_i2c_util,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	.i2c_poll =  msm_camera_cci_i2c_poll,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static int32_t msm_laser_led_init(
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_ctrl_t *laser_led_ctrl,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_camera_cci_client *cci_client = NULL;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_cfg_data_t __user *laser_led_data =
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		(struct msm_laser_led_cfg_data_t __user *) argp;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static int msm_laser_led_close(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_ctrl_t *l_ctrl =  v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static long msm_laser_led_subdev_do_ioctl(
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		rc =  msm_laser_led_subdev_ioctl(sd, cmd, arg);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static long msm_laser_led_subdev_fops_ioctl(struct file *file,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	return msm_laser_led_subdev_do_ioctl(file, cmd, (void *)arg);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static int32_t msm_laser_led_control32(
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_ctrl_t *laser_led_ctrl,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_camera_i2c_reg_setting32 conf_array32;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_camera_i2c_reg_setting conf_array;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_cfg_data_t32 laser_led_data;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		sizeof(struct msm_laser_led_cfg_data_t32))) {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		sizeof(struct msm_camera_i2c_reg_setting32))) {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		sizeof(struct msm_camera_i2c_reg_array))) {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static int32_t msm_laser_led_init32(
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_ctrl_t *laser_led_ctrl,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_cfg_data_t32 __user *laser_led_data =
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		(struct msm_laser_led_cfg_data_t32 __user *) argp;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_camera_cci_client *cci_client = NULL;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static int32_t msm_laser_led_control(
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_ctrl_t *laser_led_ctrl,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_camera_i2c_reg_setting conf_array;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_cfg_data_t laser_led_data;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		sizeof(struct msm_laser_led_cfg_data_t))) {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		sizeof(struct msm_camera_i2c_reg_setting))) {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		sizeof(struct msm_camera_i2c_reg_array))) {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static int32_t msm_laser_led_config(struct msm_laser_led_ctrl_t *laser_led_ctrl,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	enum msm_laser_led_cfg_type_t cfg_type;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_cfg_data_t32 __user *laser_led_data =
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		(struct msm_laser_led_cfg_data_t32 __user *) argp;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_cfg_data_t __user *laser_led_data =
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		(struct msm_laser_led_cfg_data_t __user *) argp;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		sizeof(enum msm_laser_led_cfg_type_t))) {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:			rc = msm_laser_led_init32(laser_led_ctrl, argp);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:			rc = msm_laser_led_init(laser_led_ctrl, argp);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:			rc = msm_laser_led_control32(laser_led_ctrl, argp);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:			rc = msm_laser_led_control(laser_led_ctrl, argp);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static long msm_laser_led_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_ctrl_t *lctrl = NULL;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		return msm_laser_led_get_subdev_id(lctrl, argp);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		return msm_laser_led_config(lctrl, argp);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		return msm_laser_led_close(sd, NULL);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static struct v4l2_subdev_core_ops msm_laser_led_subdev_core_ops = {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	.ioctl = msm_laser_led_subdev_ioctl,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static struct v4l2_subdev_ops msm_laser_led_subdev_ops = {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	.core = &msm_laser_led_subdev_core_ops,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static const struct v4l2_subdev_internal_ops msm_laser_led_internal_ops = {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	.close = msm_laser_led_close,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static int32_t msm_laser_led_platform_probe(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_laser_led_ctrl_t *laser_led_ctrl = NULL;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	struct msm_camera_cci_client *cci_client = NULL;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		sizeof(struct msm_laser_led_ctrl_t), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	laser_led_ctrl->i2c_client.i2c_func_tbl = &msm_sensor_cci_func_tbl;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	laser_led_ctrl->laser_led_mutex = &msm_laser_led_mutex;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		struct msm_camera_cci_client), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	cci_client->cci_subdev = msm_cci_get_subdev();
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	v4l2_subdev_init(&laser_led_ctrl->msm_sd.sd, &msm_laser_led_subdev_ops);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	v4l2_set_subdevdata(&laser_led_ctrl->msm_sd.sd, laser_led_ctrl);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	laser_led_ctrl->msm_sd.sd.internal_ops = &msm_laser_led_internal_ops;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	laser_led_ctrl->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	snprintf(laser_led_ctrl->msm_sd.sd.name,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		ARRAY_SIZE(laser_led_ctrl->msm_sd.sd.name),
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		"msm_camera_laser_led");
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	media_entity_pads_init(&laser_led_ctrl->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	laser_led_ctrl->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_LASER_LED;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	laser_led_ctrl->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x1;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	msm_sd_register(&laser_led_ctrl->msm_sd);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		laser_led_ctrl->msm_sd.sd.entity.name);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	msm_laser_led_v4l2_subdev_fops = v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	msm_laser_led_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		msm_laser_led_subdev_fops_ioctl;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	laser_led_ctrl->msm_sd.sd.devnode->fops =
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		&msm_laser_led_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:MODULE_DEVICE_TABLE(of, msm_laser_led_dt_match);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static struct platform_driver msm_laser_led_platform_driver = {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	.probe = msm_laser_led_platform_probe,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:		.of_match_table = msm_laser_led_dt_match,
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static int __init msm_laser_led_init_module(void)
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	rc = platform_driver_register(&msm_laser_led_platform_driver);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:static void __exit msm_laser_led_exit_module(void)
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:	platform_driver_unregister(&msm_laser_led_platform_driver);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:module_init(msm_laser_led_init_module);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.c:module_exit(msm_laser_led_exit_module);
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:#include <media/msmb_camera.h>
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:#include <media/msm_cam_sensor.h>
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:#include "msm_camera_i2c.h"
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:enum msm_camera_laser_led_state_t {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:struct msm_laser_led_ctrl_t;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:struct msm_laser_led_ctrl_t {
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:	struct msm_laser_led_func_t *func_tbl;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:	struct msm_camera_power_ctrl_t power_info;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:	struct msm_camera_i2c_client i2c_client;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:	enum msm_camera_device_type_t laser_led_device_type;
media/platform/msm/camera_v2/sensor/laser_led/msm_laser_led.h:	enum msm_camera_laser_led_state_t laser_led_state;
media/platform/msm/camera_v2/sensor/msm_sensor.c:#include "msm_sensor.h"
media/platform/msm/camera_v2/sensor/msm_sensor.c:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/msm_sensor.c:#include "msm_cci.h"
media/platform/msm/camera_v2/sensor/msm_sensor.c:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/sensor/msm_sensor.c:#include "msm_camera_i2c_mux.h"
media/platform/msm/camera_v2/sensor/msm_sensor.c:static struct msm_camera_i2c_fn_t msm_sensor_cci_func_tbl;
media/platform/msm/camera_v2/sensor/msm_sensor.c:static struct msm_camera_i2c_fn_t msm_sensor_secure_func_tbl;
media/platform/msm/camera_v2/sensor/msm_sensor.c:static void msm_sensor_adjust_mclk(struct msm_camera_power_ctrl_t *ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor.c:	struct msm_sensor_power_setting *power_setting;
media/platform/msm/camera_v2/sensor/msm_sensor.c:static void msm_sensor_misc_regulator(
media/platform/msm/camera_v2/sensor/msm_sensor.c:	struct msm_sensor_ctrl_t *sctrl, uint32_t enable)
media/platform/msm/camera_v2/sensor/msm_sensor.c:int32_t msm_sensor_free_sensor_data(struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor.c:	struct msm_camera_sensor_slave_info *slave_info = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		msm_camera_i2c_dev_put_clk_info(
media/platform/msm/camera_v2/sensor/msm_sensor.c:		msm_camera_put_clk_info(s_ctrl->pdev,
media/platform/msm/camera_v2/sensor/msm_sensor.c:int msm_sensor_power_down(struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor.c:	struct msm_camera_power_ctrl_t *power_info;
media/platform/msm/camera_v2/sensor/msm_sensor.c:	enum msm_camera_device_type_t sensor_device_type;
media/platform/msm/camera_v2/sensor/msm_sensor.c:	struct msm_camera_i2c_client *sensor_i2c_client;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		msm_camera_tz_i2c_power_down(sensor_i2c_client);
media/platform/msm/camera_v2/sensor/msm_sensor.c:	return msm_camera_power_down(power_info, sensor_device_type,
media/platform/msm/camera_v2/sensor/msm_sensor.c:int msm_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor.c:	struct msm_camera_power_ctrl_t *power_info;
media/platform/msm/camera_v2/sensor/msm_sensor.c:	struct msm_camera_i2c_client *sensor_i2c_client;
media/platform/msm/camera_v2/sensor/msm_sensor.c:	struct msm_camera_slave_info *slave_info;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		msm_sensor_adjust_mclk(power_info);
media/platform/msm/camera_v2/sensor/msm_sensor.c:			rc = msm_camera_tz_i2c_power_up(sensor_i2c_client);
media/platform/msm/camera_v2/sensor/msm_sensor.c:					&msm_sensor_cci_func_tbl;
media/platform/msm/camera_v2/sensor/msm_sensor.c:					&msm_sensor_secure_func_tbl;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		rc = msm_camera_power_up(power_info, s_ctrl->sensor_device_type,
media/platform/msm/camera_v2/sensor/msm_sensor.c:		rc = msm_sensor_check_id(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.c:			msm_camera_power_down(power_info,
media/platform/msm/camera_v2/sensor/msm_sensor.c:static uint16_t msm_sensor_id_by_mask(struct msm_sensor_ctrl_t *s_ctrl,
media/platform/msm/camera_v2/sensor/msm_sensor.c:int msm_sensor_match_id(struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor.c:	struct msm_camera_i2c_client *sensor_i2c_client;
media/platform/msm/camera_v2/sensor/msm_sensor.c:	struct msm_camera_slave_info *slave_info;
media/platform/msm/camera_v2/sensor/msm_sensor.c:	if (msm_sensor_id_by_mask(s_ctrl, chipid) != slave_info->sensor_id) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:static struct msm_sensor_ctrl_t *get_sctrl(struct v4l2_subdev *sd)
media/platform/msm/camera_v2/sensor/msm_sensor.c:	return container_of(container_of(sd, struct msm_sd_subdev, sd),
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_sensor_ctrl_t, msm_sd);
media/platform/msm/camera_v2/sensor/msm_sensor.c:static void msm_sensor_stop_stream(struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor.c:	mutex_lock(s_ctrl->msm_sensor_mutex);
media/platform/msm/camera_v2/sensor/msm_sensor.c:				msm_sensor_misc_regulator(s_ctrl, 0);
media/platform/msm/camera_v2/sensor/msm_sensor.c:	mutex_unlock(s_ctrl->msm_sensor_mutex);
media/platform/msm/camera_v2/sensor/msm_sensor.c:static int msm_sensor_get_af_status(struct msm_sensor_ctrl_t *s_ctrl,
media/platform/msm/camera_v2/sensor/msm_sensor.c:static long msm_sensor_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	struct msm_sensor_ctrl_t *s_ctrl = get_sctrl(sd);
media/platform/msm/camera_v2/sensor/msm_sensor.c:		return msm_sensor_get_af_status(s_ctrl, argp);
media/platform/msm/camera_v2/sensor/msm_sensor.c:		msm_sensor_stop_stream(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.c:static long msm_sensor_subdev_do_ioctl(
media/platform/msm/camera_v2/sensor/msm_sensor.c:		return msm_sensor_subdev_ioctl(sd, cmd, arg);
media/platform/msm/camera_v2/sensor/msm_sensor.c:long msm_sensor_subdev_fops_ioctl(struct file *file,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	return video_usercopy(file, cmd, arg, msm_sensor_subdev_do_ioctl);
media/platform/msm/camera_v2/sensor/msm_sensor.c:static int msm_sensor_config32(struct msm_sensor_ctrl_t *s_ctrl,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	mutex_lock(s_ctrl->msm_sensor_mutex);
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_reg_setting32 conf_array32;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_reg_setting conf_array;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_reg_array *reg_setting = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_reg_setting32))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_reg_array))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_read_config read_config;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_read_config *read_config_ptr = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor.c:			(struct msm_camera_i2c_read_config *)
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_read_config))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_array_write_config32 write_config32;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_array_write_config write_config;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_reg_array *reg_setting = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor.c:				struct msm_camera_i2c_array_write_config32))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/msm_sensor.c:				sizeof(struct msm_camera_i2c_reg_array))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_seq_reg_setting32 conf_array32;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_seq_reg_setting conf_array;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_seq_reg_array *reg_setting = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_seq_reg_setting32))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:			(sizeof(struct msm_camera_i2c_seq_reg_array)),
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_seq_reg_array))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:				msm_sensor_misc_regulator(s_ctrl, 1);
media/platform/msm/camera_v2/sensor/msm_sensor.c:				msm_sensor_misc_regulator(s_ctrl, 0);
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_reg_setting32 stop_setting32;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_reg_setting *stop_setting =
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_reg_setting32))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_reg_array)) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:				(sizeof(struct msm_camera_i2c_reg_array)),
media/platform/msm/camera_v2/sensor/msm_sensor.c:				sizeof(struct msm_camera_i2c_reg_array))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_cci_ctrl cci_ctrl;
media/platform/msm/camera_v2/sensor/msm_sensor.c:	mutex_unlock(s_ctrl->msm_sensor_mutex);
media/platform/msm/camera_v2/sensor/msm_sensor.c:int msm_sensor_config(struct msm_sensor_ctrl_t *s_ctrl, void *argp)
media/platform/msm/camera_v2/sensor/msm_sensor.c:	mutex_lock(s_ctrl->msm_sensor_mutex);
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_reg_setting conf_array;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_reg_array *reg_setting = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_reg_setting))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_reg_array))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_read_config read_config;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_read_config *read_config_ptr = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor.c:			(struct msm_camera_i2c_read_config *)cdata->cfg.setting;
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_read_config))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_array_write_config write_config;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_reg_array *reg_setting = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_array_write_config))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:			(sizeof(struct msm_camera_i2c_reg_array)), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/msm_sensor.c:				sizeof(struct msm_camera_i2c_reg_array))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_seq_reg_setting conf_array;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_seq_reg_array *reg_setting = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_seq_reg_setting))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:			(sizeof(struct msm_camera_i2c_seq_reg_array)),
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_seq_reg_array))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:				msm_sensor_misc_regulator(s_ctrl, 1);
media/platform/msm/camera_v2/sensor/msm_sensor.c:				msm_sensor_misc_regulator(s_ctrl, 0);
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_reg_setting *stop_setting =
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_i2c_reg_array *reg_setting = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_reg_setting))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:			sizeof(struct msm_camera_i2c_reg_array)) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:				(sizeof(struct msm_camera_i2c_reg_array)),
media/platform/msm/camera_v2/sensor/msm_sensor.c:				sizeof(struct msm_camera_i2c_reg_array))) {
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_cci_ctrl cci_ctrl;
media/platform/msm/camera_v2/sensor/msm_sensor.c:	mutex_unlock(s_ctrl->msm_sensor_mutex);
media/platform/msm/camera_v2/sensor/msm_sensor.c:int msm_sensor_check_id(struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor.c:		rc = msm_sensor_match_id(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.c:static int msm_sensor_power(struct v4l2_subdev *sd, int on)
media/platform/msm/camera_v2/sensor/msm_sensor.c:	struct msm_sensor_ctrl_t *s_ctrl = get_sctrl(sd);
media/platform/msm/camera_v2/sensor/msm_sensor.c:	mutex_lock(s_ctrl->msm_sensor_mutex);
media/platform/msm/camera_v2/sensor/msm_sensor.c:	mutex_unlock(s_ctrl->msm_sensor_mutex);
media/platform/msm/camera_v2/sensor/msm_sensor.c:static struct v4l2_subdev_core_ops msm_sensor_subdev_core_ops = {
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.ioctl = msm_sensor_subdev_ioctl,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.s_power = msm_sensor_power,
media/platform/msm/camera_v2/sensor/msm_sensor.c:static struct v4l2_subdev_ops msm_sensor_subdev_ops = {
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.core = &msm_sensor_subdev_core_ops,
media/platform/msm/camera_v2/sensor/msm_sensor.c:static struct msm_sensor_fn_t msm_sensor_func_tbl = {
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.sensor_config = msm_sensor_config,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.sensor_config32 = msm_sensor_config32,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.sensor_power_up = msm_sensor_power_up,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.sensor_power_down = msm_sensor_power_down,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.sensor_match_id = msm_sensor_match_id,
media/platform/msm/camera_v2/sensor/msm_sensor.c:static struct msm_camera_i2c_fn_t msm_sensor_cci_func_tbl = {
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_read = msm_camera_cci_i2c_read,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_read_seq = msm_camera_cci_i2c_read_seq,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write = msm_camera_cci_i2c_write,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_table = msm_camera_cci_i2c_write_table,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_seq_table = msm_camera_cci_i2c_write_seq_table,
media/platform/msm/camera_v2/sensor/msm_sensor.c:		msm_camera_cci_i2c_write_table_w_microdelay,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_util = msm_sensor_cci_i2c_util,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_conf_tbl = msm_camera_cci_i2c_write_conf_tbl,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_table_async = msm_camera_cci_i2c_write_table_async,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_table_sync = msm_camera_cci_i2c_write_table_sync,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_table_sync_block = msm_camera_cci_i2c_write_table_sync_block,
media/platform/msm/camera_v2/sensor/msm_sensor.c:static struct msm_camera_i2c_fn_t msm_sensor_qup_func_tbl = {
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_read = msm_camera_qup_i2c_read,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_read_seq = msm_camera_qup_i2c_read_seq,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write = msm_camera_qup_i2c_write,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_table = msm_camera_qup_i2c_write_table,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_seq_table = msm_camera_qup_i2c_write_seq_table,
media/platform/msm/camera_v2/sensor/msm_sensor.c:		msm_camera_qup_i2c_write_table_w_microdelay,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_conf_tbl = msm_camera_qup_i2c_write_conf_tbl,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_table_async = msm_camera_qup_i2c_write_table,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_table_sync = msm_camera_qup_i2c_write_table,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_table_sync_block = msm_camera_qup_i2c_write_table,
media/platform/msm/camera_v2/sensor/msm_sensor.c:static struct msm_camera_i2c_fn_t msm_sensor_secure_func_tbl = {
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_read = msm_camera_tz_i2c_read,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_read_seq = msm_camera_tz_i2c_read_seq,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write = msm_camera_tz_i2c_write,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_table = msm_camera_tz_i2c_write_table,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_seq_table = msm_camera_tz_i2c_write_seq_table,
media/platform/msm/camera_v2/sensor/msm_sensor.c:		msm_camera_tz_i2c_write_table_w_microdelay,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_util = msm_sensor_tz_i2c_util,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_conf_tbl = msm_camera_tz_i2c_write_conf_tbl,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_table_async = msm_camera_tz_i2c_write_table_async,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_table_sync = msm_camera_tz_i2c_write_table_sync,
media/platform/msm/camera_v2/sensor/msm_sensor.c:	.i2c_write_table_sync_block = msm_camera_tz_i2c_write_table_sync_block,
media/platform/msm/camera_v2/sensor/msm_sensor.c:int32_t msm_sensor_init_default_params(struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor.c:	struct msm_camera_cci_client *cci_client = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		struct msm_camera_cci_client), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/msm_sensor.c:		cci_client->cci_subdev = msm_cci_get_subdev();
media/platform/msm/camera_v2/sensor/msm_sensor.c:			msm_camera_tz_i2c_register_sensor((void *)s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.c:				&msm_sensor_cci_func_tbl;
media/platform/msm/camera_v2/sensor/msm_sensor.c:				&msm_sensor_qup_func_tbl;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		s_ctrl->func_tbl = &msm_sensor_func_tbl;
media/platform/msm/camera_v2/sensor/msm_sensor.c:		s_ctrl->sensor_v4l2_subdev_ops = &msm_sensor_subdev_ops;
media/platform/msm/camera_v2/sensor/msm_sensor.c:	s_ctrl->msm_sd.sd.entity.flags = mount_pos | MEDIA_ENT_FL_DEFAULT;
media/platform/msm/camera_v2/sensor/msm_sensor.h:#include <media/msm_cam_sensor.h>
media/platform/msm/camera_v2/sensor/msm_sensor.h:#include "msm_camera_i2c.h"
media/platform/msm/camera_v2/sensor/msm_sensor.h:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/msm_sensor.h:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/msm_sensor.h:enum msm_sensor_sensor_slave_info_type {
media/platform/msm/camera_v2/sensor/msm_sensor.h:struct msm_sensor_ctrl_t;
media/platform/msm/camera_v2/sensor/msm_sensor.h:enum msm_sensor_state_t {
media/platform/msm/camera_v2/sensor/msm_sensor.h:struct msm_sensor_fn_t {
media/platform/msm/camera_v2/sensor/msm_sensor.h:	int (*sensor_config)(struct msm_sensor_ctrl_t *s_ctrl, void *argp);
media/platform/msm/camera_v2/sensor/msm_sensor.h:	int (*sensor_config32)(struct msm_sensor_ctrl_t *s_ctrl, void *argp);
media/platform/msm/camera_v2/sensor/msm_sensor.h:	int (*sensor_power_down)(struct msm_sensor_ctrl_t *s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.h:	int (*sensor_power_up)(struct msm_sensor_ctrl_t *s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.h:	int (*sensor_match_id)(struct msm_sensor_ctrl_t *s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.h:struct msm_sensor_ctrl_t {
media/platform/msm/camera_v2/sensor/msm_sensor.h:	struct mutex *msm_sensor_mutex;
media/platform/msm/camera_v2/sensor/msm_sensor.h:	enum msm_camera_device_type_t sensor_device_type;
media/platform/msm/camera_v2/sensor/msm_sensor.h:	struct msm_camera_sensor_board_info *sensordata;
media/platform/msm/camera_v2/sensor/msm_sensor.h:	struct msm_sensor_power_setting_array power_setting_array;
media/platform/msm/camera_v2/sensor/msm_sensor.h:	struct msm_sensor_packed_cfg_t *cfg_override;
media/platform/msm/camera_v2/sensor/msm_sensor.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/sensor/msm_sensor.h:	struct msm_camera_i2c_client *sensor_i2c_client;
media/platform/msm/camera_v2/sensor/msm_sensor.h:	struct msm_sensor_fn_t *func_tbl;
media/platform/msm/camera_v2/sensor/msm_sensor.h:	struct msm_camera_i2c_reg_setting stop_setting;
media/platform/msm/camera_v2/sensor/msm_sensor.h:	enum msm_sensor_state_t sensor_state;
media/platform/msm/camera_v2/sensor/msm_sensor.h:	enum msm_camera_stream_type_t camera_stream_type;
media/platform/msm/camera_v2/sensor/msm_sensor.h:int msm_sensor_config(struct msm_sensor_ctrl_t *s_ctrl, void *argp);
media/platform/msm/camera_v2/sensor/msm_sensor.h:int msm_sensor_power_up(struct msm_sensor_ctrl_t *s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.h:int msm_sensor_power_down(struct msm_sensor_ctrl_t *s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.h:int msm_sensor_check_id(struct msm_sensor_ctrl_t *s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.h:int msm_sensor_match_id(struct msm_sensor_ctrl_t *s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.h:int msm_sensor_update_cfg(struct msm_sensor_ctrl_t *s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.h:int msm_sensor_free_sensor_data(struct msm_sensor_ctrl_t *s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.h:int32_t msm_sensor_init_default_params(struct msm_sensor_ctrl_t *s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor.h:int32_t msm_sensor_get_dt_gpio_req_tbl(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/msm_sensor.h:	struct msm_camera_gpio_conf *gconf, uint16_t *gpio_array,
media/platform/msm/camera_v2/sensor/msm_sensor.h:int32_t msm_sensor_get_dt_gpio_set_tbl(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/msm_sensor.h:	struct msm_camera_gpio_conf *gconf, uint16_t *gpio_array,
media/platform/msm/camera_v2/sensor/msm_sensor.h:int32_t msm_sensor_init_gpio_pin_tbl(struct device_node *of_node,
media/platform/msm/camera_v2/sensor/msm_sensor.h:	struct msm_camera_gpio_conf *gconf, uint16_t *gpio_array,
media/platform/msm/camera_v2/sensor/msm_sensor.h:long msm_sensor_subdev_fops_ioctl(struct file *file,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:#include "msm_sensor.h"
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:#include "msm_cci.h"
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:#include "msm_sensor_driver.h"
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static struct v4l2_file_operations msm_sensor_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_driver_platform_probe(struct platform_device *pdev);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static struct msm_sensor_ctrl_t *g_sctrl[MAX_CAMERAS];
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int msm_sensor_platform_remove(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_ctrl_t  *s_ctrl;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	msm_sensor_free_sensor_data(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	kfree(s_ctrl->msm_sensor_mutex);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static const struct of_device_id msm_sensor_driver_dt_match[] = {
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:MODULE_DEVICE_TABLE(of, msm_sensor_driver_dt_match);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static struct platform_driver msm_sensor_platform_driver = {
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	.probe = msm_sensor_driver_platform_probe,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		.of_match_table = msm_sensor_driver_dt_match,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	.remove = msm_sensor_platform_remove,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static struct v4l2_subdev_info msm_sensor_driver_subdev_info[] = {
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_driver_create_i2c_v4l_subdev
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:			(struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	snprintf(s_ctrl->msm_sd.sd.name,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		sizeof(s_ctrl->msm_sd.sd.name), "%s",
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	v4l2_i2c_subdev_init(&s_ctrl->msm_sd.sd, client,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	v4l2_set_subdevdata(&s_ctrl->msm_sd.sd, client);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	s_ctrl->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	media_entity_pads_init(&s_ctrl->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	s_ctrl->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_SENSOR;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	s_ctrl->msm_sd.sd.entity.name =	s_ctrl->msm_sd.sd.name;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	s_ctrl->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x3;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sd_register(&s_ctrl->msm_sd);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		pr_err("failed: msm_sd_register rc %d\n", rc);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	msm_sensor_v4l2_subdev_fops = v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	msm_sensor_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		msm_sensor_subdev_fops_ioctl;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	s_ctrl->msm_sd.sd.devnode->fops =
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		&msm_sensor_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_driver_create_v4l_subdev
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:			(struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	v4l2_subdev_init(&s_ctrl->msm_sd.sd, s_ctrl->sensor_v4l2_subdev_ops);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	snprintf(s_ctrl->msm_sd.sd.name, sizeof(s_ctrl->msm_sd.sd.name), "%s",
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	v4l2_set_subdevdata(&s_ctrl->msm_sd.sd, s_ctrl->pdev);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	s_ctrl->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	media_entity_pads_init(&s_ctrl->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	s_ctrl->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_SENSOR;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	s_ctrl->msm_sd.sd.entity.name = s_ctrl->msm_sd.sd.name;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	s_ctrl->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x3;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sd_register(&s_ctrl->msm_sd);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		pr_err("failed: msm_sd_register rc %d\n", rc);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	msm_cam_copy_v4l2_subdev_fops(&msm_sensor_v4l2_subdev_fops);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	msm_sensor_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		msm_sensor_subdev_fops_ioctl;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	s_ctrl->msm_sd.sd.devnode->fops =
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		&msm_sensor_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_fill_eeprom_subdevid_by_name(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:				struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct  msm_sensor_info_t *sensor_info;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_fill_actuator_subdevid_by_name(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:				struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct  msm_sensor_info_t *sensor_info;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_fill_laser_led_subdevid_by_name(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:				struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct  msm_sensor_info_t *sensor_info;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_fill_flash_subdevid_by_name(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:				struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct  msm_sensor_info_t *sensor_info;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_fill_ois_subdevid_by_name(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:				struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct  msm_sensor_info_t *sensor_info;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_fill_slave_info_init_params(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_camera_sensor_slave_info *slave_info,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_info_t *sensor_info)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_init_params *sensor_init_params;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_validate_slave_info(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_info_t *sensor_info)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_get_pw_settings_compat(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_power_setting *ps,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_power_setting *us_ps, uint32_t size)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_power_setting32 *ps32 =
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_create_pd_settings(void *setting,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_power_setting *pd, uint32_t size_down,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_power_setting *pu)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_power_setting pd_tmp;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		rc = msm_sensor_get_pw_settings_compat(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_get_power_down_settings(void *setting,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_camera_sensor_slave_info *slave_info,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_camera_power_ctrl_t *power_info)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_power_setting *pd = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:			rc = msm_sensor_get_pw_settings_compat(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		rc = msm_sensor_create_pd_settings(setting, pd, size_down,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_get_power_up_settings(void *setting,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_camera_sensor_slave_info *slave_info,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_camera_power_ctrl_t *power_info)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_power_setting *pu = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		rc = msm_sensor_get_pw_settings_compat(pu,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_get_power_settings(void *setting,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_camera_sensor_slave_info *slave_info,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_camera_power_ctrl_t *power_info)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_get_power_up_settings(setting, slave_info, power_info);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_get_power_down_settings(setting, slave_info,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static void msm_sensor_fill_sensor_info(struct msm_sensor_ctrl_t *s_ctrl,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_info_t *sensor_info, char *entity_name)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	strlcpy(entity_name, s_ctrl->msm_sd.sd.entity.name, MAX_SENSOR_NAME);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_driver_is_special_support(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_ctrl_t *s_ctrl,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_camera_sensor_board_info *sensordata = s_ctrl->sensordata;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:int32_t msm_sensor_driver_probe(void *setting,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_info_t *probed_info, char *entity_name)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_ctrl_t            *s_ctrl = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_camera_cci_client        *cci_client = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_camera_sensor_slave_info *slave_info = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_camera_slave_info        *camera_info = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_camera_i2c_reg_array     *reg_setting = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_id_info_t         *id_info = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		struct msm_camera_sensor_slave_info32 *slave_info32 =
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:					(struct msm_camera_i2c_reg_array)),
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:				sizeof(struct msm_camera_i2c_reg_array))) {
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:			(struct msm_sensor_power_setting *)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:			(struct msm_sensor_power_setting *)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:					(struct msm_camera_i2c_reg_array)),
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:				sizeof(struct msm_camera_i2c_reg_array))) {
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		if (!msm_sensor_driver_is_special_support(s_ctrl,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:			msm_sensor_fill_sensor_info(s_ctrl,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_get_power_settings(setting, slave_info,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	camera_info = kzalloc(sizeof(struct msm_camera_slave_info), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_camera_fill_vreg_params(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		pr_err("failed: msm_camera_get_dt_power_setting_data rc %d\n",
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_camera_fill_vreg_params(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		pr_err("failed: msm_camera_fill_vreg_params for PDOWN rc %d\n",
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_fill_eeprom_subdevid_by_name(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_fill_actuator_subdevid_by_name(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_fill_laser_led_subdevid_by_name(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_fill_ois_subdevid_by_name(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_fill_flash_subdevid_by_name(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		rc = msm_sensor_driver_create_v4l_subdev(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		rc = msm_sensor_driver_create_i2c_v4l_subdev(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_fill_slave_info_init_params(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_validate_slave_info(s_ctrl->sensordata->sensor_info);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	s_ctrl->msm_sd.sd.entity.flags = mount_pos | MEDIA_ENT_FL_DEFAULT;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	msm_sensor_fill_sensor_info(s_ctrl, probed_info, entity_name);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_driver_get_dt_data(struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_camera_sensor_board_info *sensordata = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_get_sub_module_index(of_node, &sensordata->sensor_info);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_camera_get_dt_vreg_data(of_node,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		pr_err("failed: msm_camera_get_dt_vreg_data rc %d\n", rc);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_driver_get_gpio_data
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		pr_err("failed: msm_sensor_driver_get_gpio_data rc %d\n", rc);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_driver_parse(struct msm_sensor_ctrl_t *s_ctrl)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	s_ctrl->msm_sensor_mutex = kzalloc(sizeof(*s_ctrl->msm_sensor_mutex),
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	if (!s_ctrl->msm_sensor_mutex) {
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_driver_get_dt_data(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	mutex_init(s_ctrl->msm_sensor_mutex);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	s_ctrl->sensor_v4l2_subdev_info = msm_sensor_driver_subdev_info;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		ARRAY_SIZE(msm_sensor_driver_subdev_info);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_init_default_params(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		pr_err("failed: msm_sensor_init_default_params rc %d\n", rc);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	kfree(s_ctrl->msm_sensor_mutex);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_driver_platform_probe(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_ctrl_t *s_ctrl = NULL;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_driver_parse(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		pr_err("failed: msm_sensor_driver_parse rc %d\n", rc);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_camera_get_clk_info(s_ctrl->pdev,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		pr_err("failed: msm_camera_get_clk_info rc %d\n", rc);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int32_t msm_sensor_driver_i2c_probe(struct i2c_client *client,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_ctrl_t *s_ctrl;
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = msm_sensor_driver_parse(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		pr_err("failed: msm_sensor_driver_parse rc %d\n", rc);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:		rc = msm_camera_i2c_dev_get_clk_info(
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:			pr_err("failed: msm_camera_i2c_dev_get_clk_info rc %d\n",
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int msm_sensor_driver_i2c_remove(struct i2c_client *client)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	struct msm_sensor_ctrl_t  *s_ctrl = i2c_get_clientdata(client);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	msm_sensor_free_sensor_data(s_ctrl);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	kfree(s_ctrl->msm_sensor_mutex);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static struct i2c_driver msm_sensor_driver_i2c = {
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	.probe  = msm_sensor_driver_i2c_probe,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	.remove = msm_sensor_driver_i2c_remove,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static int __init msm_sensor_driver_init(void)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = platform_driver_register(&msm_sensor_platform_driver);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	rc = i2c_add_driver(&msm_sensor_driver_i2c);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:static void __exit msm_sensor_driver_exit(void)
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	platform_driver_unregister(&msm_sensor_platform_driver);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:	i2c_del_driver(&msm_sensor_driver_i2c);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:module_init(msm_sensor_driver_init);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:module_exit(msm_sensor_driver_exit);
media/platform/msm/camera_v2/sensor/msm_sensor_driver.c:MODULE_DESCRIPTION("msm_sensor_driver");
media/platform/msm/camera_v2/sensor/msm_sensor_driver.h:#include "msm_sensor.h"
media/platform/msm/camera_v2/sensor/msm_sensor_driver.h:int32_t msm_sensor_driver_probe(void *setting,
media/platform/msm/camera_v2/sensor/msm_sensor_driver.h:	struct msm_sensor_info_t *probed_info, char *entity_name);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:#include "msm_sensor_init.h"
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:#include "msm_sensor_driver.h"
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:#include "msm_sensor.h"
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:static struct msm_sensor_init_t *s_init;
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:static struct v4l2_file_operations msm_sensor_init_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:static long msm_sensor_init_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:static struct v4l2_subdev_core_ops msm_sensor_init_subdev_core_ops = {
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	.ioctl = msm_sensor_init_subdev_ioctl,
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:static struct v4l2_subdev_ops msm_sensor_init_subdev_ops = {
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	.core = &msm_sensor_init_subdev_core_ops,
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:static const struct v4l2_subdev_internal_ops msm_sensor_init_internal_ops;
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:static int msm_sensor_wait_for_probe_done(struct msm_sensor_init_t *s_init)
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:		CDBG("msm_cam_get_module_init_status -2\n");
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:static int32_t msm_sensor_driver_cmd(struct msm_sensor_init_t *s_init,
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:		rc = msm_sensor_driver_probe(cfg->cfg.setting,
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:		msm_sensor_wait_for_probe_done(s_init);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:static long msm_sensor_init_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	struct msm_sensor_init_t *s_init = v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:		rc = msm_sensor_driver_cmd(s_init, arg);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:static long msm_sensor_init_subdev_do_ioctl(
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:		rc = msm_sensor_init_subdev_ioctl(sd, cmd, &sensor_init_data);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:		return msm_sensor_init_subdev_ioctl(sd, cmd, arg);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:static long msm_sensor_init_subdev_fops_ioctl(
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	return video_usercopy(file, cmd, arg, msm_sensor_init_subdev_do_ioctl);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:static int __init msm_sensor_init_module(void)
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	/* Allocate memory for msm_sensor_init control structure */
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	s_init = kzalloc(sizeof(struct msm_sensor_init_t), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	/* Create /dev/v4l-subdevX for msm_sensor_init */
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	v4l2_subdev_init(&s_init->msm_sd.sd, &msm_sensor_init_subdev_ops);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	snprintf(s_init->msm_sd.sd.name, sizeof(s_init->msm_sd.sd.name), "%s",
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:		"msm_sensor_init");
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	v4l2_set_subdevdata(&s_init->msm_sd.sd, s_init);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	s_init->msm_sd.sd.internal_ops = &msm_sensor_init_internal_ops;
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	s_init->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	media_entity_pads_init(&s_init->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	s_init->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_SENSOR_INIT;
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	s_init->msm_sd.sd.entity.name = s_init->msm_sd.sd.name;
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	s_init->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x6;
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	ret = msm_sd_register(&s_init->msm_sd);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:		CDBG("%s: msm_sd_register error = %d\n", __func__, ret);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	msm_cam_copy_v4l2_subdev_fops(&msm_sensor_init_v4l2_subdev_fops);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	msm_sensor_init_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:		msm_sensor_init_subdev_fops_ioctl;
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	s_init->msm_sd.sd.devnode->fops =
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:		&msm_sensor_init_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:static void __exit msm_sensor_exit_module(void)
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:	msm_sd_unregister(&s_init->msm_sd);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:module_init(msm_sensor_init_module);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:module_exit(msm_sensor_exit_module);
media/platform/msm/camera_v2/sensor/msm_sensor_init.c:MODULE_DESCRIPTION("msm_sensor_init");
media/platform/msm/camera_v2/sensor/msm_sensor_init.h:#include "msm_sensor.h"
media/platform/msm/camera_v2/sensor/msm_sensor_init.h:struct msm_sensor_init_t {
media/platform/msm/camera_v2/sensor/msm_sensor_init.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/sensor/ois/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2
media/platform/msm/camera_v2/sensor/ois/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/common
media/platform/msm/camera_v2/sensor/ois/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/io
media/platform/msm/camera_v2/sensor/ois/Makefile:ccflags-y += -Idrivers/media/platform/msm/camera_v2/sensor/cci
media/platform/msm/camera_v2/sensor/ois/Makefile:obj-$(CONFIG_MSMB_CAMERA) += msm_ois.o
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:#include "msm_sd.h"
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:#include "msm_ois.h"
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:#include "msm_cci.h"
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:DEFINE_MSM_MUTEX(msm_ois_mutex);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static struct v4l2_file_operations msm_ois_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_power_up(struct msm_ois_ctrl_t *o_ctrl);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_power_down(struct msm_ois_ctrl_t *o_ctrl);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static struct i2c_driver msm_ois_i2c_driver;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	enum msm_camera_i2c_data_type data_type)
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_download(struct msm_ois_ctrl_t *o_ctrl)
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	enum msm_camera_i2c_reg_addr_type save_addr_type;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_data_config(struct msm_ois_ctrl_t *o_ctrl,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_ois_slave_info *slave_info)
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_camera_cci_client *cci_client = NULL;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		sizeof(struct msm_ois_opcode));
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_write_settings(struct msm_ois_ctrl_t *o_ctrl,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_camera_i2c_seq_reg_array *reg_setting;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:			kzalloc(sizeof(struct msm_camera_i2c_seq_reg_array),
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:				rc = msm_camera_cci_i2c_read_seq
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_vreg_control(struct msm_ois_ctrl_t *o_ctrl,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_ois_vreg *vreg_cfg;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		rc = msm_camera_config_single_vreg(&(o_ctrl->pdev->dev),
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_power_down(struct msm_ois_ctrl_t *o_ctrl)
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	enum msm_sensor_power_seq_gpio_t gpio;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		rc = msm_ois_vreg_control(o_ctrl, 0);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:				rc = msm_camera_request_gpio_table(
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int msm_ois_init(struct msm_ois_ctrl_t *o_ctrl)
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_control(struct msm_ois_ctrl_t *o_ctrl,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_ois_set_info_t *set_info)
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_camera_cci_client *cci_client = NULL;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		rc = msm_ois_write_settings(o_ctrl,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_config(struct msm_ois_ctrl_t *o_ctrl,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_ois_cfg_data *cdata =
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		(struct msm_ois_cfg_data *)argp;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		rc = msm_ois_init(o_ctrl);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:			pr_err("msm_ois_init failed %d\n", rc);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		rc = msm_ois_power_down(o_ctrl);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:			pr_err("msm_ois_power_down failed %d\n", rc);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		rc = msm_ois_power_up(o_ctrl);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		rc = msm_ois_control(o_ctrl, &cdata->cfg.set_info);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		struct msm_camera_i2c_seq_reg_setting conf_array;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		struct msm_camera_i2c_seq_reg_array *reg_setting = NULL;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:				sizeof(struct msm_camera_i2c_seq_reg_setting));
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:			sizeof(struct msm_camera_i2c_seq_reg_setting))) {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:			(sizeof(struct msm_camera_i2c_seq_reg_array)),
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:			sizeof(struct msm_camera_i2c_seq_reg_array))) {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_config_download(struct msm_ois_ctrl_t *o_ctrl,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_ois_cfg_download_data *cdata =
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		(struct msm_ois_cfg_download_data *)argp;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		rc = msm_ois_data_config(o_ctrl, &cdata->slave_info);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		rc = msm_ois_download(o_ctrl);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_get_subdev_id(struct msm_ois_ctrl_t *o_ctrl,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static struct msm_camera_i2c_fn_t msm_sensor_cci_func_tbl = {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_read = msm_camera_cci_i2c_read,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_read_seq = msm_camera_cci_i2c_read_seq,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_write = msm_camera_cci_i2c_write,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_write_table = msm_camera_cci_i2c_write_table,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_write_seq = msm_camera_cci_i2c_write_seq,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_write_seq_table = msm_camera_cci_i2c_write_seq_table,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		msm_camera_cci_i2c_write_table_w_microdelay,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_util = msm_sensor_cci_i2c_util,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_poll =  msm_camera_cci_i2c_poll,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static struct msm_camera_i2c_fn_t msm_sensor_qup_func_tbl = {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_read = msm_camera_qup_i2c_read,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_read_seq = msm_camera_qup_i2c_read_seq,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_write = msm_camera_qup_i2c_write,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_write_table = msm_camera_qup_i2c_write_table,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_write_seq = msm_camera_qup_i2c_write_seq,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_write_seq_table = msm_camera_qup_i2c_write_seq_table,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		msm_camera_qup_i2c_write_table_w_microdelay,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.i2c_poll = msm_camera_qup_i2c_poll,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int msm_ois_close(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_ois_ctrl_t *o_ctrl =  v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static const struct v4l2_subdev_internal_ops msm_ois_internal_ops = {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.close = msm_ois_close,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static long msm_ois_subdev_ioctl(struct v4l2_subdev *sd,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_ois_ctrl_t *o_ctrl = v4l2_get_subdevdata(sd);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		return msm_ois_get_subdev_id(o_ctrl, argp);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		return msm_ois_config(o_ctrl, argp);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		return msm_ois_config_download(o_ctrl, argp);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		rc = msm_ois_power_down(o_ctrl);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		return msm_ois_close(sd, NULL);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_power_up(struct msm_ois_ctrl_t *o_ctrl)
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	enum msm_sensor_power_seq_gpio_t gpio;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	rc = msm_ois_vreg_control(o_ctrl, 1);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:			rc = msm_camera_request_gpio_table(
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static struct v4l2_subdev_core_ops msm_ois_subdev_core_ops = {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.ioctl = msm_ois_subdev_ioctl,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static struct v4l2_subdev_ops msm_ois_subdev_ops = {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.core = &msm_ois_subdev_core_ops,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static const struct i2c_device_id msm_ois_i2c_id[] = {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_i2c_probe(struct i2c_client *client,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_ois_ctrl_t *ois_ctrl_t = NULL;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	ois_ctrl_t = kzalloc(sizeof(struct msm_ois_ctrl_t),
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	ois_ctrl_t->i2c_driver = &msm_ois_i2c_driver;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	ois_ctrl_t->i2c_client.i2c_func_tbl = &msm_sensor_qup_func_tbl;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	ois_ctrl_t->ois_v4l2_subdev_ops = &msm_ois_subdev_ops;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	ois_ctrl_t->ois_mutex = &msm_ois_mutex;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	snprintf(ois_ctrl_t->msm_sd.sd.name, sizeof(ois_ctrl_t->msm_sd.sd.name),
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	v4l2_i2c_subdev_init(&ois_ctrl_t->msm_sd.sd,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	v4l2_set_subdevdata(&ois_ctrl_t->msm_sd.sd, ois_ctrl_t);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	ois_ctrl_t->msm_sd.sd.internal_ops = &msm_ois_internal_ops;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	ois_ctrl_t->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	media_entity_pads_init(&ois_ctrl_t->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	ois_ctrl_t->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_OIS;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	ois_ctrl_t->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x2;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_sd_register(&ois_ctrl_t->msm_sd);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static long msm_ois_subdev_do_ioctl(
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_ois_cfg_data32 *u32;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_ois_cfg_data ois_data;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_camera_i2c_seq_reg_setting settings;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_camera_i2c_seq_reg_setting32 settings32;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	u32 = (struct msm_ois_cfg_data32 *)arg;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:			sizeof(struct msm_camera_i2c_seq_reg_setting32))) {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:				sizeof(struct msm_camera_i2c_seq_reg_array));
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	rc = msm_ois_subdev_ioctl(sd, cmd, parg);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static long msm_ois_subdev_fops_ioctl(struct file *file, unsigned int cmd,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	return video_usercopy(file, cmd, arg, msm_ois_subdev_do_ioctl);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int32_t msm_ois_platform_probe(struct platform_device *pdev)
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_camera_cci_client *cci_client = NULL;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_ois_ctrl_t *msm_ois_t = NULL;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	struct msm_ois_vreg *vreg_cfg;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t = kzalloc(sizeof(struct msm_ois_ctrl_t),
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	if (!msm_ois_t)
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t->oboard_info = kzalloc(sizeof(
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		struct msm_ois_board_info), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	if (!msm_ois_t->oboard_info) {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		kfree(msm_ois_t);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		&msm_ois_t->cci_master);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	CDBG("qcom,cci-master %d, rc %d\n", msm_ois_t->cci_master, rc);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	if (rc < 0 || msm_ois_t->cci_master >= MASTER_MAX) {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		vreg_cfg = &msm_ois_t->vreg_cfg;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		rc = msm_camera_get_dt_vreg_data((&pdev->dev)->of_node,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	rc = msm_sensor_driver_get_gpio_data(&(msm_ois_t->gconf),
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		msm_ois_t->cam_pinctrl_status = 1;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		rc = msm_camera_pinctrl_init(
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:			&(msm_ois_t->pinctrl_info), &(pdev->dev));
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:			msm_ois_t->cam_pinctrl_status = 0;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t->ois_v4l2_subdev_ops = &msm_ois_subdev_ops;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t->ois_mutex = &msm_ois_mutex;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t->pdev = pdev;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t->ois_device_type = MSM_CAMERA_PLATFORM_DEVICE;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t->i2c_client.i2c_func_tbl = &msm_sensor_cci_func_tbl;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t->i2c_client.cci_client = kzalloc(sizeof(
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		struct msm_camera_cci_client), GFP_KERNEL);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	if (!msm_ois_t->i2c_client.cci_client) {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		kfree(msm_ois_t->vreg_cfg.cam_vreg);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	cci_client = msm_ois_t->i2c_client.cci_client;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	cci_client->cci_subdev = msm_cci_get_subdev();
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	cci_client->cci_i2c_master = msm_ois_t->cci_master;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	v4l2_subdev_init(&msm_ois_t->msm_sd.sd,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		msm_ois_t->ois_v4l2_subdev_ops);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	v4l2_set_subdevdata(&msm_ois_t->msm_sd.sd, msm_ois_t);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t->msm_sd.sd.internal_ops = &msm_ois_internal_ops;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	snprintf(msm_ois_t->msm_sd.sd.name,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		ARRAY_SIZE(msm_ois_t->msm_sd.sd.name), "msm_ois");
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	media_entity_pads_init(&msm_ois_t->msm_sd.sd.entity, 0, NULL);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t->msm_sd.sd.entity.function = MSM_CAMERA_SUBDEV_OIS;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x2;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_sd_register(&msm_ois_t->msm_sd);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t->ois_state = OIS_DISABLE_STATE;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_cam_copy_v4l2_subdev_fops(&msm_ois_v4l2_subdev_fops);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_v4l2_subdev_fops.compat_ioctl32 =
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		msm_ois_subdev_fops_ioctl;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	msm_ois_t->msm_sd.sd.devnode->fops =
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		&msm_ois_v4l2_subdev_fops;
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	kfree(msm_ois_t->oboard_info);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	kfree(msm_ois_t->gconf);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	kfree(msm_ois_t);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static const struct of_device_id msm_ois_i2c_dt_match[] = {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:MODULE_DEVICE_TABLE(of, msm_ois_i2c_dt_match);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static struct i2c_driver msm_ois_i2c_driver = {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.id_table = msm_ois_i2c_id,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.probe  = msm_ois_i2c_probe,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.remove = __exit_p(msm_ois_i2c_remove),
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		.of_match_table = msm_ois_i2c_dt_match,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static const struct of_device_id msm_ois_dt_match[] = {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:MODULE_DEVICE_TABLE(of, msm_ois_dt_match);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static struct platform_driver msm_ois_platform_driver = {
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	.probe = msm_ois_platform_probe,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:		.of_match_table = msm_ois_dt_match,
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static int __init msm_ois_init_module(void)
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	rc = platform_driver_register(&msm_ois_platform_driver);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	return i2c_add_driver(&msm_ois_i2c_driver);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:static void __exit msm_ois_exit_module(void)
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	platform_driver_unregister(&msm_ois_platform_driver);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:	i2c_del_driver(&msm_ois_i2c_driver);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:module_init(msm_ois_init_module);
media/platform/msm/camera_v2/sensor/ois/msm_ois.c:module_exit(msm_ois_exit_module);
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:#include <media/msmb_camera.h>
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:#include "msm_camera_i2c.h"
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:#include "msm_camera_dt_util.h"
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:#include "msm_camera_io_util.h"
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:struct msm_ois_ctrl_t;
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:enum msm_ois_state_t {
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:struct msm_ois_vreg {
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:struct msm_ois_board_info {
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:	struct msm_ois_opcode opcode;
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:struct msm_ois_ctrl_t {
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:	struct msm_camera_i2c_client i2c_client;
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:	enum msm_camera_device_type_t ois_device_type;
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:	struct msm_sd_subdev msm_sd;
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:	enum msm_camera_i2c_data_type i2c_data_type;
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:	enum msm_ois_state_t ois_state;
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:	struct msm_ois_vreg vreg_cfg;
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:	struct msm_camera_gpio_conf *gconf;
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:	struct msm_pinctrl_info pinctrl_info;
media/platform/msm/camera_v2/sensor/ois/msm_ois.h:	struct msm_ois_board_info *oboard_info;
media/platform/msm/cvp/Makefile:ccflags-y += -I$(srctree)/drivers/media/platform/msm/cvp/
media/platform/msm/cvp/Makefile:ccflags-y += -I$(srctree)/drivers/media/platform/msm/synx/
media/platform/msm/cvp/Makefile:msm-cvp-objs := msm_v4l2_cvp.o \
media/platform/msm/cvp/Makefile:				msm_v4l2_private.o \
media/platform/msm/cvp/Makefile:				msm_cvp_platform.o \
media/platform/msm/cvp/Makefile:				msm_cvp_common.o \
media/platform/msm/cvp/Makefile:				msm_cvp_core.o \
media/platform/msm/cvp/Makefile:				msm_cvp.o \
media/platform/msm/cvp/Makefile:				msm_smem.o \
media/platform/msm/cvp/Makefile:				msm_cvp_debug.o \
media/platform/msm/cvp/Makefile:				msm_cvp_res_parse.o \
media/platform/msm/cvp/Makefile:				msm_cvp_clocks.o \
media/platform/msm/cvp/Makefile:				msm_cvp_dsp.o
media/platform/msm/cvp/Makefile:obj-$(CONFIG_MSM_CVP_V4L2) := msm-cvp.o
media/platform/msm/cvp/cvp_core_hfi.c:#include "msm_cvp_debug.h"
media/platform/msm/cvp/cvp_core_hfi.c:struct cvp_hfi_device *cvp_hfi_initialize(enum msm_cvp_hfi_type hfi_type,
media/platform/msm/cvp/cvp_core_hfi.c:		u32 device_id, struct msm_cvp_platform_resources *res,
media/platform/msm/cvp/cvp_core_hfi.c:void cvp_hfi_deinitialize(enum msm_cvp_hfi_type hfi_type,
media/platform/msm/cvp/cvp_core_hfi.h:#include "msm_cvp_resources.h"
media/platform/msm/cvp/cvp_core_hfi.h:	struct msm_cvp_smem mem_data;
media/platform/msm/cvp/cvp_core_hfi.h:	struct msm_cvp_fw fw;
media/platform/msm/cvp/cvp_core_hfi.h:	struct msm_cvp_gov_data bus_vote;
media/platform/msm/cvp/cvp_core_hfi.h:	msm_cvp_callback callback;
media/platform/msm/cvp/cvp_core_hfi.h:	struct msm_cvp_platform_resources *res;
media/platform/msm/cvp/cvp_core_hfi.h:	struct msm_cvp_cb_info *response_pkt;
media/platform/msm/cvp/cvp_core_hfi.h:	struct msm_cvp_capability *sys_init_capabilities;
media/platform/msm/cvp/cvp_core_hfi.h:		struct msm_cvp_platform_resources *res,
media/platform/msm/cvp/cvp_hfi.c:#include "msm_cvp_debug.h"
media/platform/msm/cvp/cvp_hfi.c:#include "msm_cvp_dsp.h"
media/platform/msm/cvp/cvp_hfi.c:const struct msm_cvp_hfi_defs cvp_hfi_defs[] = {
media/platform/msm/cvp/cvp_hfi.c:const struct msm_cvp_gov_data CVP_DEFAULT_BUS_VOTE = {
media/platform/msm/cvp/cvp_hfi.c:	msm_cvp_res_handle_fatal_hw_error(device->res,
media/platform/msm/cvp/cvp_hfi.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/cvp_hfi.c:	core = list_first_entry(&cvp_driver->cores, struct msm_cvp_core, list);
media/platform/msm/cvp/cvp_hfi.c:		msm_cvp_res_handle_fatal_hw_error(device->res, true);
media/platform/msm/cvp/cvp_hfi.c:	if (msm_cvp_debug & CVP_PKT) {
media/platform/msm/cvp/cvp_hfi.c:	if ((msm_cvp_debug & CVP_PKT) &&
media/platform/msm/cvp/cvp_hfi.c:	struct msm_cvp_smem *alloc = &mem->mem_data;
media/platform/msm/cvp/cvp_hfi.c:	rc = msm_cvp_smem_alloc(
media/platform/msm/cvp/cvp_hfi.c:static void __smem_free(struct iris_hfi_device *dev, struct msm_cvp_smem *mem)
media/platform/msm/cvp/cvp_hfi.c:	msm_cvp_smem_free(mem);
media/platform/msm/cvp/cvp_hfi.c:		msm_cvp_res_handle_fatal_hw_error(device->res, true);
media/platform/msm/cvp/cvp_hfi.c:		msm_cvp_res_handle_fatal_hw_error(device->res, true);
media/platform/msm/cvp/cvp_hfi.c:	rc = msm_bus_scale_update_bw(bus->client, ab, 0);
media/platform/msm/cvp/cvp_hfi.c:		rc = msm_bus_scale_update_bw(bus->client, 0, 0);
media/platform/msm/cvp/cvp_hfi.c:			rc = msm_bus_scale_update_bw(bus->client,
media/platform/msm/cvp/cvp_hfi.c:			if (msm_cvp_clock_voting)
media/platform/msm/cvp/cvp_hfi.c:				freq = msm_cvp_clock_voting;
media/platform/msm/cvp/cvp_hfi.c:			trace_msm_cvp_perf_clock_scale(cl->name, freq);
media/platform/msm/cvp/cvp_hfi.c:				device->res->msm_cvp_pwr_collapse_delay))) {
media/platform/msm/cvp/cvp_hfi.c:	struct msm_cvp_smem *mem_data = &device->dsp_iface_q_table.mem_data;
media/platform/msm/cvp/cvp_hfi.c:	struct msm_cvp_smem *mem_data;
media/platform/msm/cvp/cvp_hfi.c:	cb = msm_cvp_smem_get_context_bank(MSM_CVP_UNKNOWN, 0, dev->res, 0);
media/platform/msm/cvp/cvp_hfi.c:	memset(mem_data, 0, sizeof(struct msm_cvp_smem));
media/platform/msm/cvp/cvp_hfi.c:	strlcpy(q_tbl_hdr->name, "msm_v4l2_cvp", sizeof(q_tbl_hdr->name));
media/platform/msm/cvp/cvp_hfi.c:		cb = msm_cvp_smem_get_context_bank(MSM_CVP_UNKNOWN,
media/platform/msm/cvp/cvp_hfi.c:	if ((msm_cvp_fw_debug_mode & HFI_DEBUG_MODE_QDSS) && num_entries) {
media/platform/msm/cvp/cvp_hfi.c:	strlcpy(q_tbl_hdr->name, "msm_v4l2_cvp", sizeof(q_tbl_hdr->name));
media/platform/msm/cvp/cvp_hfi.c:		cb = msm_cvp_smem_get_context_bank(MSM_CVP_UNKNOWN, false,
media/platform/msm/cvp/cvp_hfi.c:	__sys_set_debug(device, msm_cvp_fw_debug);
media/platform/msm/cvp/cvp_hfi.c:	if (__sys_set_debug(device, msm_cvp_fw_debug))
media/platform/msm/cvp/cvp_hfi.c:	if (__sys_set_power_control(device, msm_cvp_fw_low_power_mode))
media/platform/msm/cvp/cvp_hfi.c:	if (msm_cvp_fw_coverage) {
media/platform/msm/cvp/cvp_hfi.c:		if (__sys_set_coverage(sess->device, msm_cvp_fw_coverage))
media/platform/msm/cvp/cvp_hfi.c:	struct msm_cvp_cb_cmd_done cmd_done = {0};
media/platform/msm/cvp/cvp_hfi.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/cvp_hfi.c:	core = list_first_entry(&cvp_driver->cores, struct msm_cvp_core, list);
media/platform/msm/cvp/cvp_hfi.c:			device->res->msm_cvp_pwr_collapse_delay));
media/platform/msm/cvp/cvp_hfi.c:			device->res->msm_cvp_pwr_collapse_delay));
media/platform/msm/cvp/cvp_hfi.c:static void process_system_msg(struct msm_cvp_cb_info *info,
media/platform/msm/cvp/cvp_hfi.c:static void **get_session_id(struct msm_cvp_cb_info *info)
media/platform/msm/cvp/cvp_hfi.c:	struct msm_cvp_cb_info *packets;
media/platform/msm/cvp/cvp_hfi.c:		struct msm_cvp_cb_info info = {
media/platform/msm/cvp/cvp_hfi.c:		struct msm_cvp_cb_info *info = &packets[packet_count++];
media/platform/msm/cvp/cvp_hfi.c:				device->res->msm_cvp_pwr_collapse_delay))) {
media/platform/msm/cvp/cvp_hfi.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/cvp_hfi.c:	core = list_first_entry(&cvp_driver->cores, struct msm_cvp_core, list);
media/platform/msm/cvp/cvp_hfi.c:		struct msm_cvp_cb_info *r = &device->response_pkt[i];
media/platform/msm/cvp/cvp_hfi.c:		struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/cvp_hfi.c:			"msm_cvp", device);
media/platform/msm/cvp/cvp_hfi.c:static int __handle_reset_clk(struct msm_cvp_platform_resources *res,
media/platform/msm/cvp/cvp_hfi.c:		msm_bus_scale_unregister(bus->client);
media/platform/msm/cvp/cvp_hfi.c:		if (!strcmp(bus->governor, "msm-cvp-llcc")) {
media/platform/msm/cvp/cvp_hfi.c:			if (msm_cvp_syscache_disable) {
media/platform/msm/cvp/cvp_hfi.c:		bus->client = msm_bus_scale_register(bus->master, bus->slave,
media/platform/msm/cvp/cvp_hfi.c:				struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/cvp_hfi.c:		kzalloc(sizeof(struct msm_cvp_capability)
media/platform/msm/cvp/cvp_hfi.c:	msm_cvp_res_handle_fatal_hw_error(device->res, true);
media/platform/msm/cvp/cvp_hfi.c:	if (!msm_cvp_fw_low_power_mode) {
media/platform/msm/cvp/cvp_hfi.c:	if (msm_cvp_syscache_disable || !is_sys_cache_present(device))
media/platform/msm/cvp/cvp_hfi.c:			msm_cvp_res_handle_fatal_hw_error(device->res, true);
media/platform/msm/cvp/cvp_hfi.c:	if (msm_cvp_syscache_disable || !is_sys_cache_present(device))
media/platform/msm/cvp/cvp_hfi.c:	if (msm_cvp_syscache_disable || !is_sys_cache_present(device))
media/platform/msm/cvp/cvp_hfi.c:	__sys_set_debug(device, msm_cvp_fw_debug);
media/platform/msm/cvp/cvp_hfi.c:	trace_msm_v4l2_cvp_fw_load_start("msm_v4l2_cvp cvp fw load start");
media/platform/msm/cvp/cvp_hfi.c:	trace_msm_v4l2_cvp_fw_load_end("msm_v4l2_cvp cvp fw load end");
media/platform/msm/cvp/cvp_hfi.c:	trace_msm_v4l2_cvp_fw_load_end("msm_v4l2_cvp cvp fw load end");
media/platform/msm/cvp/cvp_hfi.c:			struct msm_cvp_platform_resources *res,
media/platform/msm/cvp/cvp_hfi.c:		"msm_cvp_workerq_iris");
media/platform/msm/cvp/cvp_hfi.c:				struct msm_cvp_platform_resources *res,
media/platform/msm/cvp/cvp_hfi.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/cvp_hfi.c:	core = list_first_entry(&cvp_driver->cores, struct msm_cvp_core, list);
media/platform/msm/cvp/cvp_hfi.c:		struct msm_cvp_platform_resources *res,
media/platform/msm/cvp/cvp_hfi.h:#include <media/msm_media_info.h>
media/platform/msm/cvp/cvp_hfi.h:struct msm_cvp_fw {
media/platform/msm/cvp/cvp_hfi.h:		struct msm_cvp_cb_info *info);
media/platform/msm/cvp/cvp_hfi_api.h:#include "msm_cvp_core.h"
media/platform/msm/cvp/cvp_hfi_api.h:#include "msm_cvp_resources.h"
media/platform/msm/cvp/cvp_hfi_api.h:struct msm_cvp_capability {
media/platform/msm/cvp/cvp_hfi_api.h:	struct msm_cvp_capability *capabilities;
media/platform/msm/cvp/cvp_hfi_api.h:	struct msm_cvp_capability capability;
media/platform/msm/cvp/cvp_hfi_api.h:struct msm_cvp_cb_cmd_done {
media/platform/msm/cvp/cvp_hfi_api.h:struct msm_cvp_cb_event {
media/platform/msm/cvp/cvp_hfi_api.h:struct msm_cvp_cb_data_done {
media/platform/msm/cvp/cvp_hfi_api.h:struct msm_cvp_cb_info {
media/platform/msm/cvp/cvp_hfi_api.h:		struct msm_cvp_cb_cmd_done cmd;
media/platform/msm/cvp/cvp_hfi_api.h:		struct msm_cvp_cb_event event;
media/platform/msm/cvp/cvp_hfi_api.h:		struct msm_cvp_cb_data_done data;
media/platform/msm/cvp/cvp_hfi_api.h:enum msm_cvp_hfi_type {
media/platform/msm/cvp/cvp_hfi_api.h:enum msm_cvp_thermal_level {
media/platform/msm/cvp/cvp_hfi_api.h:struct msm_cvp_gov_data {
media/platform/msm/cvp/cvp_hfi_api.h:enum msm_cvp_power_mode {
media/platform/msm/cvp/cvp_hfi_api.h:	enum msm_cvp_power_mode power_mode;
media/platform/msm/cvp/cvp_hfi_api.h:struct msm_cvp_hfi_defs {
media/platform/msm/cvp/cvp_hfi_api.h:typedef void (*msm_cvp_callback) (u32 response, void *callback);
media/platform/msm/cvp/cvp_hfi_api.h:struct cvp_hfi_device *cvp_hfi_initialize(enum msm_cvp_hfi_type hfi_type,
media/platform/msm/cvp/cvp_hfi_api.h:		u32 device_id, struct msm_cvp_platform_resources *res,
media/platform/msm/cvp/cvp_hfi_api.h:void cvp_hfi_deinitialize(enum msm_cvp_hfi_type hfi_type,
media/platform/msm/cvp/cvp_hfi_api.h:extern const struct msm_cvp_hfi_defs cvp_hfi_defs[];
media/platform/msm/cvp/hfi_packetization.c:#include "msm_cvp_debug.h"
media/platform/msm/cvp/hfi_packetization.c:	if (msm_cvp_fw_debug_mode
media/platform/msm/cvp/hfi_packetization.c:		hfi->debug_mode = msm_cvp_fw_debug_mode;
media/platform/msm/cvp/hfi_packetization.c:	struct msm_cvp_inst *inst = session->session_id;
media/platform/msm/cvp/hfi_packetization.c:		struct msm_cvp_ubwc_config_data *ubwc_config)
media/platform/msm/cvp/hfi_packetization.h:		struct msm_cvp_ubwc_config_data *ubwc_config);
media/platform/msm/cvp/hfi_response_handler.c:#include "msm_cvp_debug.h"
media/platform/msm/cvp/hfi_response_handler.c:#include "msm_cvp_common.h"
media/platform/msm/cvp/hfi_response_handler.c:extern struct msm_cvp_drv *cvp_driver;
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_info *info,
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_inst *inst);
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_cmd_done cmd_done = {0};
media/platform/msm/cvp/hfi_response_handler.c:		struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_cmd_done cmd_done = {0};
media/platform/msm/cvp/hfi_response_handler.c:		struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:		*info = (struct msm_cvp_cb_info) {
media/platform/msm/cvp/hfi_response_handler.c:		struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_cmd_done cmd_done = {0};
media/platform/msm/cvp/hfi_response_handler.c:		struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_cmd_done cmd_done = {0};
media/platform/msm/cvp/hfi_response_handler.c:		struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_cmd_done cmd_done = {0};
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_cmd_done cmd_done = {0};
media/platform/msm/cvp/hfi_response_handler.c:		struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_cmd_done cmd_done = {0};
media/platform/msm/cvp/hfi_response_handler.c:		struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_cmd_done cmd_done = {0};
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_cmd_done cmd_done = {0};
media/platform/msm/cvp/hfi_response_handler.c:static struct msm_cvp_inst *cvp_get_inst_from_id(struct msm_cvp_core *core,
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_inst *inst = NULL;
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_inst *inst = NULL;
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/hfi_response_handler.c:	core = list_first_entry(&cvp_driver->cores, struct msm_cvp_core, list);
media/platform/msm/cvp/hfi_response_handler.c:			msm_cvp_unmap_buf_cpu(inst, ktid);
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_cmd_done cmd_done = {0};
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_cmd_done cmd_done = {0};
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_cmd_done cmd_done = {0};
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_cb_info *info,
media/platform/msm/cvp/hfi_response_handler.c:	struct msm_cvp_inst *inst)
media/platform/msm/cvp/hfi_response_handler.c:		struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:		*info = (struct msm_cvp_cb_info) {
media/platform/msm/cvp/hfi_response_handler.c:		struct msm_cvp_cb_info *info)
media/platform/msm/cvp/hfi_response_handler.c:	typedef int (*pkt_func_def)(u32, void *, struct msm_cvp_cb_info *info);
media/platform/msm/cvp/msm_cvp.c:#include "msm_cvp.h"
media/platform/msm/cvp/msm_cvp.c:		struct msm_cvp_inst *inst, struct msm_cvp_internal_buffer *cbuf)
media/platform/msm/cvp/msm_cvp.c:	if (!(tag & msm_cvp_debug) || !inst || !cbuf)
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_get_session_info(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *s;
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_session_get_iova_addr_d(
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_internal_buffer **cbuf_ptr,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_internal_buffer *cbuf;
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_session_get_iova_addr(
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_internal_buffer *cbuf;
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_map_buf_dsp(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_internal_buffer *cbuf;
media/platform/msm/cvp/msm_cvp.c:	rc = msm_cvp_smem_map_dma_buf(inst, &cbuf->smem);
media/platform/msm/cvp/msm_cvp.c:		msm_cvp_smem_unmap_dma_buf(inst, &cbuf->smem);
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_unmap_buf_dsp(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_internal_buffer *cbuf;
media/platform/msm/cvp/msm_cvp.c:		msm_cvp_smem_unmap_dma_buf(inst, &cbuf->smem);
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_map_buf_cpu_d(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_internal_buffer **cbuf_ptr)
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_internal_buffer *cbuf;
media/platform/msm/cvp/msm_cvp.c:	rc = msm_cvp_smem_map_dma_buf(inst, &cbuf->smem);
media/platform/msm/cvp/msm_cvp.c:		msm_cvp_smem_unmap_dma_buf(inst, &cbuf->smem);
media/platform/msm/cvp/msm_cvp.c:static void __msm_cvp_cache_operations(struct msm_cvp_internal_buffer *cbuf)
media/platform/msm/cvp/msm_cvp.c:	msm_cvp_smem_cache_operations(cbuf->smem.dma_buf, cache_op,
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_map_buf_user_persist(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:		dma_buf = msm_cvp_smem_get_dma_buf(in_buf->fd);
media/platform/msm/cvp/msm_cvp.c:		msm_cvp_smem_put_dma_buf(dma_buf);
media/platform/msm/cvp/msm_cvp.c:	rc = msm_cvp_session_get_iova_addr(inst, in_buf, iova);
media/platform/msm/cvp/msm_cvp.c:	rc = msm_cvp_smem_map_dma_buf(inst, &cbuf->smem);
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_map_buf_cpu(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:				struct msm_cvp_frame *frame)
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_internal_buffer *cbuf;
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_frame_buf *frame_buf;
media/platform/msm/cvp/msm_cvp.c:		dma_buf = msm_cvp_smem_get_dma_buf(in_buf->fd);
media/platform/msm/cvp/msm_cvp.c:		msm_cvp_smem_put_dma_buf(dma_buf);
media/platform/msm/cvp/msm_cvp.c:	rc = msm_cvp_session_get_iova_addr(inst, in_buf, iova);
media/platform/msm/cvp/msm_cvp.c:	rc = msm_cvp_smem_map_dma_buf(inst, &cbuf->smem);
media/platform/msm/cvp/msm_cvp.c:	__msm_cvp_cache_operations(cbuf);
media/platform/msm/cvp/msm_cvp.c:		msm_cvp_smem_unmap_dma_buf(inst, &cbuf->smem);
media/platform/msm/cvp/msm_cvp.c:static void __unmap_buf(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:		struct msm_cvp_frame_buf *frame_buf)
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_internal_buffer *cbuf, *dummy;
media/platform/msm/cvp/msm_cvp.c:			msm_cvp_smem_unmap_dma_buf(inst, &cbuf->smem);
media/platform/msm/cvp/msm_cvp.c:void msm_cvp_unmap_buf_cpu(struct msm_cvp_inst *inst, u64 ktid)
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_frame *frame, *dummy1;
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_frame_buf *frame_buf, *dummy2;
media/platform/msm/cvp/msm_cvp.c:static bool _cvp_msg_pending(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_session_receive_hfi(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *s;
media/platform/msm/cvp/msm_cvp.c:		msm_cvp_comm_kill_session(inst);
media/platform/msm/cvp/msm_cvp.c:			msm_cvp_unmap_buf_cpu(inst, ktid);
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_map_user_persist(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_map_buf_user_persist(inst, new_buf, &iova);
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_map_buf(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_internal_buffer *cbuf = NULL;
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_frame *frame;
media/platform/msm/cvp/msm_cvp.c:			rc = msm_cvp_map_buf_cpu(inst, new_buf, &iova, frame);
media/platform/msm/cvp/msm_cvp.c:				struct msm_cvp_frame_buf *frame_buf, *dummy;
media/platform/msm/cvp/msm_cvp.c:			rc = msm_cvp_session_get_iova_addr_d(inst,
media/platform/msm/cvp/msm_cvp.c:				rc = msm_cvp_map_buf_cpu_d(inst,
media/platform/msm/cvp/msm_cvp.c:			msm_cvp_smem_cache_operations(
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_session_process_hfi(
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *s;
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_map_user_persist(inst, in_pkt, offset, buf_num);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_map_buf(inst, in_pkt, offset, buf_num);
media/platform/msm/cvp/msm_cvp.c:static void msm_cvp_thread_fence_run(struct work_struct *data)
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_fence_thread_data *fence_thread_data;
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_cvp.c:		container_of(data, struct msm_cvp_fence_thread_data, work);
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_session_process_hfi_fence(
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *s;
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_fence_thread_data *fence_thread_data;
media/platform/msm/cvp/msm_cvp.c:	rc = msm_cvp_map_buf(inst, in_pkt, offset, buf_num);
media/platform/msm/cvp/msm_cvp.c:	INIT_WORK(&fence_thread_data->work, msm_cvp_thread_fence_run);
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_session_cvp_dfs_frame_response(
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_session_cvp_dme_frame_response(
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_session_cvp_persist_response(
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_send_cmd(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:static bool is_subblock_profile_existed(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp.c:static void aggregate_power_update(struct msm_cvp_core *core,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_cvp.c:static void aggregate_power_request(struct msm_cvp_core *core,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp.c:	core = list_first_entry(&cvp_driver->cores, struct msm_cvp_core, list);
media/platform/msm/cvp/msm_cvp.c:	rc = msm_bus_scale_update_bw(bus->client, bw_sum, 0);
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_request_power(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *s;
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_update_power(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *s;
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_register_buffer(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *s;
media/platform/msm/cvp/msm_cvp.c:	rc = msm_cvp_map_buf_dsp(inst, buf);
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_unregister_buffer(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_inst *s;
media/platform/msm/cvp/msm_cvp.c:	rc = msm_cvp_unmap_buf_dsp(inst, buf);
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_session_create(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp.c:	rc = msm_cvp_comm_try_state(inst, MSM_CVP_OPEN_DONE);
media/platform/msm/cvp/msm_cvp.c:static int session_state_check_init(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp.c:	return msm_cvp_session_create(inst);
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_session_start(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_session_stop(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_session_ctrl(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_session_stop(inst, arg);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_session_start(inst, arg);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_session_create(inst);
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_get_sysprop(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:static int msm_cvp_set_sysprop(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp.c:int msm_cvp_handle_syscall(struct msm_cvp_inst *inst, struct cvp_kmd_arg *arg)
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_get_session_info(inst, session);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_request_power(inst, power);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_update_power(inst);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_register_buffer(inst, buf);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_unregister_buffer(inst, buf);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_send_cmd(inst, send_cmd);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_session_receive_hfi(inst, out_pkt);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_session_process_hfi(inst, in_pkt,
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_session_cvp_dfs_frame_response(inst, dfs_frame);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_session_cvp_dme_frame_response(inst, dme_frame);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_session_cvp_persist_response(inst, pbuf_cmd);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_session_process_hfi_fence(inst, arg);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_session_ctrl(inst, arg);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_get_sysprop(inst, arg);
media/platform/msm/cvp/msm_cvp.c:		rc = msm_cvp_set_sysprop(inst, arg);
media/platform/msm/cvp/msm_cvp.c:int msm_cvp_session_deinit(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_internal_buffer *cbuf, *dummy;
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_frame *frame, *dummy1;
media/platform/msm/cvp/msm_cvp.c:	struct msm_cvp_frame_buf *frame_buf, *dummy2;
media/platform/msm/cvp/msm_cvp.c:	rc = msm_cvp_comm_try_state(inst, MSM_CVP_CLOSE_DONE);
media/platform/msm/cvp/msm_cvp.c:		msm_cvp_smem_unmap_dma_buf(inst, &cbuf->smem);
media/platform/msm/cvp/msm_cvp.c:		msm_cvp_smem_unmap_dma_buf(inst, &cbuf->smem);
media/platform/msm/cvp/msm_cvp.c:int msm_cvp_session_init(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp.h:#include "msm_cvp_internal.h"
media/platform/msm/cvp/msm_cvp.h:#include "msm_cvp_common.h"
media/platform/msm/cvp/msm_cvp.h:#include "msm_cvp_clocks.h"
media/platform/msm/cvp/msm_cvp.h:#include "msm_cvp_debug.h"
media/platform/msm/cvp/msm_cvp.h:#include "msm_cvp_dsp.h"
media/platform/msm/cvp/msm_cvp.h:int msm_cvp_handle_syscall(struct msm_cvp_inst *inst, struct cvp_kmd_arg *arg);
media/platform/msm/cvp/msm_cvp.h:int msm_cvp_session_init(struct msm_cvp_inst *inst);
media/platform/msm/cvp/msm_cvp.h:int msm_cvp_session_deinit(struct msm_cvp_inst *inst);
media/platform/msm/cvp/msm_cvp_clocks.c:#include "msm_cvp_common.h"
media/platform/msm/cvp/msm_cvp_clocks.c:#include "msm_cvp_debug.h"
media/platform/msm/cvp/msm_cvp_clocks.c:#include "msm_cvp_clocks.h"
media/platform/msm/cvp/msm_cvp_clocks.c:int msm_cvp_set_clocks(struct msm_cvp_core *core)
media/platform/msm/cvp/msm_cvp_clocks.h:#include "msm_cvp_internal.h"
media/platform/msm/cvp/msm_cvp_clocks.h:int msm_cvp_set_clocks(struct msm_cvp_core *core);
media/platform/msm/cvp/msm_cvp_common.c:#include "msm_cvp_common.h"
media/platform/msm/cvp/msm_cvp_common.c:#include "msm_cvp_debug.h"
media/platform/msm/cvp/msm_cvp_common.c:#include "msm_cvp_clocks.h"
media/platform/msm/cvp/msm_cvp_common.c:#include "msm_cvp.h"
media/platform/msm/cvp/msm_cvp_common.c:struct msm_cvp_core *get_cvp_core(int core_id)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_cb_cmd_done *response = data;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_common.c:		sys_init_msg->codec_count * sizeof(struct msm_cvp_capability));
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst = container_of(kref,
media/platform/msm/cvp/msm_cvp_common.c:			struct msm_cvp_inst, kref);
media/platform/msm/cvp/msm_cvp_common.c:	msm_cvp_destroy(inst);
media/platform/msm/cvp/msm_cvp_common.c:void cvp_put_inst(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:struct msm_cvp_inst *cvp_get_inst(struct msm_cvp_core *core,
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst = NULL;
media/platform/msm/cvp/msm_cvp_common.c:struct msm_cvp_inst *cvp_get_inst_validate(struct msm_cvp_core *core,
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *s;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_cb_cmd_done *response = data;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_cb_cmd_done *response = data;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_cb_cmd_done *response = data;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_cb_cmd_done *response = data;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_common.c:void change_cvp_inst_state(struct msm_cvp_inst *inst, enum instance_state state)
media/platform/msm/cvp/msm_cvp_common.c:		struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:int wait_for_sess_signal_receipt(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_common.c:			inst->core->resources.msm_cvp_hw_rsp_timeout));
media/platform/msm/cvp/msm_cvp_common.c:int wait_for_sess_signal_receipt_fence(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_common.c:static int wait_for_state(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_common.c:void msm_cvp_notify_event(struct msm_cvp_inst *inst, int event_type)
media/platform/msm/cvp/msm_cvp_common.c:static void msm_cvp_comm_generate_max_clients_error(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_cb_cmd_done response = {0};
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_cb_cmd_done *response = data;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst = NULL;
media/platform/msm/cvp/msm_cvp_common.c:			msm_cvp_comm_generate_max_clients_error(inst);
media/platform/msm/cvp/msm_cvp_common.c:			msm_cvp_comm_generate_session_error(inst);
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_cb_cmd_done *response = data;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_cb_cmd_done *response = data;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst = NULL;
media/platform/msm/cvp/msm_cvp_common.c:		msm_cvp_comm_session_clean(inst);
media/platform/msm/cvp/msm_cvp_common.c:	msm_cvp_notify_event(inst, event);
media/platform/msm/cvp/msm_cvp_common.c:static void msm_comm_clean_notify_client(struct msm_cvp_core *core)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst = NULL;
media/platform/msm/cvp/msm_cvp_common.c:		msm_cvp_notify_event(inst,
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_cb_cmd_done *response = data;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_core *core = NULL;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst = NULL;
media/platform/msm/cvp/msm_cvp_common.c:	msm_cvp_noc_error_info(core);
media/platform/msm/cvp/msm_cvp_common.c:			msm_cvp_comm_print_inst_info(inst);
media/platform/msm/cvp/msm_cvp_common.c:	msm_cvp_handle_hw_error(core);
media/platform/msm/cvp/msm_cvp_common.c:void msm_cvp_comm_session_clean(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_cb_cmd_done *response = data;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_cvp_common.c:static inline enum msm_cvp_thermal_level msm_comm_cvp_thermal_level(int level)
media/platform/msm/cvp/msm_cvp_common.c:static bool is_core_turbo(struct msm_cvp_core *core, unsigned long freq)
media/platform/msm/cvp/msm_cvp_common.c:static bool is_thermal_permissible(struct msm_cvp_core *core)
media/platform/msm/cvp/msm_cvp_common.c:	enum msm_cvp_thermal_level tl;
media/platform/msm/cvp/msm_cvp_common.c:	if (msm_cvp_thermal_mitigation_disabled) {
media/platform/msm/cvp/msm_cvp_common.c:			msm_cvp_thermal_mitigation_disabled);
media/platform/msm/cvp/msm_cvp_common.c:	tl = msm_comm_cvp_thermal_level(cvp_driver->thermal_level);
media/platform/msm/cvp/msm_cvp_common.c:static int msm_comm_session_abort(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:				inst->core->resources.msm_cvp_hw_rsp_timeout));
media/platform/msm/cvp/msm_cvp_common.c:		msm_cvp_comm_generate_sys_error(inst);
media/platform/msm/cvp/msm_cvp_common.c:static void handle_thermal_event(struct msm_cvp_core *core)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_cvp_common.c:			rc = msm_comm_session_abort(inst);
media/platform/msm/cvp/msm_cvp_common.c:			msm_cvp_notify_event(inst,
media/platform/msm/cvp/msm_cvp_common.c:			msm_cvp_comm_generate_session_error(inst);
media/platform/msm/cvp/msm_cvp_common.c:	msm_comm_clean_notify_client(core);
media/platform/msm/cvp/msm_cvp_common.c:void msm_cvp_comm_handle_thermal_event(void)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_common.c:int msm_cvp_comm_check_core_init(struct msm_cvp_core *core)
media/platform/msm/cvp/msm_cvp_common.c:		msecs_to_jiffies(core->resources.msm_cvp_hw_rsp_timeout));
media/platform/msm/cvp/msm_cvp_common.c:static int msm_comm_init_core_done(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:	rc = msm_cvp_comm_check_core_init(inst->core);
media/platform/msm/cvp/msm_cvp_common.c:		msm_cvp_comm_generate_sys_error(inst);
media/platform/msm/cvp/msm_cvp_common.c:static int msm_comm_init_core(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_common.c:				sizeof(struct msm_cvp_capability), GFP_KERNEL);
media/platform/msm/cvp/msm_cvp_common.c:int msm_cvp_deinit_core(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_common.c:			core->resources.msm_cvp_firmware_unload_delay : 0));
media/platform/msm/cvp/msm_cvp_common.c:			core->resources.msm_cvp_firmware_unload_delay : 0);
media/platform/msm/cvp/msm_cvp_common.c:static int msm_comm_session_init_done(int flipped_state,
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:		msm_cvp_comm_generate_sys_error(inst);
media/platform/msm/cvp/msm_cvp_common.c:static int msm_comm_session_init(int flipped_state,
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:static int msm_comm_session_close(int flipped_state,
media/platform/msm/cvp/msm_cvp_common.c:			struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:int msm_cvp_comm_suspend(int core_id)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_common.c:int msm_cvp_comm_try_state(struct msm_cvp_inst *inst, int state)
media/platform/msm/cvp/msm_cvp_common.c:		rc = msm_comm_init_core(inst);
media/platform/msm/cvp/msm_cvp_common.c:		rc = msm_comm_init_core_done(inst);
media/platform/msm/cvp/msm_cvp_common.c:		rc = msm_comm_session_init(flipped_state, inst);
media/platform/msm/cvp/msm_cvp_common.c:		rc = msm_comm_session_init_done(flipped_state, inst);
media/platform/msm/cvp/msm_cvp_common.c:		rc = msm_comm_session_close(flipped_state, inst);
media/platform/msm/cvp/msm_cvp_common.c:		msm_cvp_comm_session_clean(inst);
media/platform/msm/cvp/msm_cvp_common.c:		rc = msm_cvp_deinit_core(inst);
media/platform/msm/cvp/msm_cvp_common.c:		msm_cvp_comm_kill_session(inst);
media/platform/msm/cvp/msm_cvp_common.c:		trace_msm_cvp_common_state_change((void *)inst,
media/platform/msm/cvp/msm_cvp_common.c:int msm_cvp_noc_error_info(struct msm_cvp_core *core)
media/platform/msm/cvp/msm_cvp_common.c:int msm_cvp_trigger_ssr(struct msm_cvp_core *core,
media/platform/msm/cvp/msm_cvp_common.c:void msm_cvp_ssr_handler(struct work_struct *work)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_common.c:	core = container_of(work, struct msm_cvp_core, ssr_work);
media/platform/msm/cvp/msm_cvp_common.c:		struct msm_cvp_inst *inst = NULL, *s;
media/platform/msm/cvp/msm_cvp_common.c:			msm_cvp_comm_kill_session(inst);
media/platform/msm/cvp/msm_cvp_common.c:void msm_cvp_comm_generate_session_error(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_cb_cmd_done response = {0};
media/platform/msm/cvp/msm_cvp_common.c:void msm_cvp_comm_generate_sys_error(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_cb_cmd_done response  = {0};
media/platform/msm/cvp/msm_cvp_common.c:int msm_cvp_comm_kill_session(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:		rc = msm_comm_session_abort(inst);
media/platform/msm/cvp/msm_cvp_common.c:void msm_cvp_fw_unload_handler(struct work_struct *work)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_core *core = NULL;
media/platform/msm/cvp/msm_cvp_common.c:	core = container_of(work, struct msm_cvp_core, fw_unload_work.work);
media/platform/msm/cvp/msm_cvp_common.c:void print_cvp_buffer(u32 tag, const char *str, struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_common.c:		struct msm_cvp_internal_buffer *cbuf)
media/platform/msm/cvp/msm_cvp_common.c:void msm_cvp_comm_print_inst_info(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_internal_buffer *cbuf;
media/platform/msm/cvp/msm_cvp_common.c:int msm_cvp_comm_unmap_cvp_buffer(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_common.c:		struct msm_cvp_internal_buffer *cbuf)
media/platform/msm/cvp/msm_cvp_common.c:	rc = msm_cvp_smem_unmap_dma_buf(inst, &cbuf->smem);
media/platform/msm/cvp/msm_cvp_common.c:static int set_internal_buf_on_fw(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_common.c:				struct msm_cvp_smem *handle, bool reuse)
media/platform/msm/cvp/msm_cvp_common.c:static int allocate_and_set_internal_bufs(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_common.c:			u32 buffer_size, struct msm_cvp_list *buf_list)
media/platform/msm/cvp/msm_cvp_common.c:	rc = msm_cvp_smem_alloc(buffer_size, 1, smem_flags, 0,
media/platform/msm/cvp/msm_cvp_common.c:	msm_cvp_smem_free(&binfo->smem);
media/platform/msm/cvp/msm_cvp_common.c:int cvp_comm_set_arp_buffers(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:int cvp_comm_release_persist_buffers(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_smem *handle;
media/platform/msm/cvp/msm_cvp_common.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_common.c:			msm_cvp_smem_free(handle);
media/platform/msm/cvp/msm_cvp_common.c:			msm_cvp_smem_unmap_dma_buf(inst, &buf->smem);
media/platform/msm/cvp/msm_cvp_common.c:		struct msm_cvp_inst *inst, struct cvp_kmd_buffer *cbuf)
media/platform/msm/cvp/msm_cvp_common.c:	if (!(tag & msm_cvp_debug) || !inst || !cbuf)
media/platform/msm/cvp/msm_cvp_common.h:#include "msm_cvp_internal.h"
media/platform/msm/cvp/msm_cvp_common.h:void cvp_put_inst(struct msm_cvp_inst *inst);
media/platform/msm/cvp/msm_cvp_common.h:struct msm_cvp_inst *cvp_get_inst(struct msm_cvp_core *core,
media/platform/msm/cvp/msm_cvp_common.h:struct msm_cvp_inst *cvp_get_inst_validate(struct msm_cvp_core *core,
media/platform/msm/cvp/msm_cvp_common.h:void cvp_change_inst_state(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_common.h:struct msm_cvp_core *get_cvp_core(int core_id);
media/platform/msm/cvp/msm_cvp_common.h:int msm_cvp_comm_try_state(struct msm_cvp_inst *inst, int state);
media/platform/msm/cvp/msm_cvp_common.h:int msm_cvp_deinit_core(struct msm_cvp_inst *inst);
media/platform/msm/cvp/msm_cvp_common.h:int msm_cvp_comm_suspend(int core_id);
media/platform/msm/cvp/msm_cvp_common.h:void msm_cvp_comm_session_clean(struct msm_cvp_inst *inst);
media/platform/msm/cvp/msm_cvp_common.h:int msm_cvp_comm_kill_session(struct msm_cvp_inst *inst);
media/platform/msm/cvp/msm_cvp_common.h:void msm_cvp_comm_generate_session_error(struct msm_cvp_inst *inst);
media/platform/msm/cvp/msm_cvp_common.h:void msm_cvp_comm_generate_sys_error(struct msm_cvp_inst *inst);
media/platform/msm/cvp/msm_cvp_common.h:int msm_cvp_comm_smem_cache_operations(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_common.h:		struct msm_cvp_smem *mem, enum smem_cache_ops cache_ops);
media/platform/msm/cvp/msm_cvp_common.h:int msm_cvp_comm_check_core_init(struct msm_cvp_core *core);
media/platform/msm/cvp/msm_cvp_common.h:void msm_cvp_comm_print_inst_info(struct msm_cvp_inst *inst);
media/platform/msm/cvp/msm_cvp_common.h:int msm_cvp_comm_unmap_cvp_buffer(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_common.h:		struct msm_cvp_internal_buffer *cbuf);
media/platform/msm/cvp/msm_cvp_common.h:		struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_common.h:		struct msm_cvp_internal_buffer *cbuf);
media/platform/msm/cvp/msm_cvp_common.h:int wait_for_sess_signal_receipt(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_common.h:int wait_for_sess_signal_receipt_fence(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_common.h:int cvp_comm_set_arp_buffers(struct msm_cvp_inst *inst);
media/platform/msm/cvp/msm_cvp_common.h:int cvp_comm_release_persist_buffers(struct msm_cvp_inst *inst);
media/platform/msm/cvp/msm_cvp_common.h:		struct msm_cvp_inst *inst, struct cvp_kmd_buffer *cbuf);
media/platform/msm/cvp/msm_cvp_common.h:void msm_cvp_unmap_buf_cpu(struct msm_cvp_inst *inst, u64 ktid);
media/platform/msm/cvp/msm_cvp_core.c:#include "msm_cvp_core.h"
media/platform/msm/cvp/msm_cvp_core.c:#include "msm_cvp_internal.h"
media/platform/msm/cvp/msm_cvp_core.c:#include "msm_cvp_debug.h"
media/platform/msm/cvp/msm_cvp_core.c:#include "msm_cvp.h"
media/platform/msm/cvp/msm_cvp_core.c:#include "msm_cvp_common.h"
media/platform/msm/cvp/msm_cvp_core.c:#include "msm_cvp_clocks.h"
media/platform/msm/cvp/msm_cvp_core.c:#include <uapi/media/msm_media_info.h>
media/platform/msm/cvp/msm_cvp_core.c:int msm_cvp_est_cycles(struct cvp_kmd_usecase_desc *cvp_desc,
media/platform/msm/cvp/msm_cvp_core.c:EXPORT_SYMBOL(msm_cvp_est_cycles);
media/platform/msm/cvp/msm_cvp_core.c:int msm_cvp_poll(void *instance, struct file *filp,
media/platform/msm/cvp/msm_cvp_core.c:EXPORT_SYMBOL(msm_cvp_poll);
media/platform/msm/cvp/msm_cvp_core.c:int msm_cvp_private(void *cvp_inst, unsigned int cmd,
media/platform/msm/cvp/msm_cvp_core.c:	struct msm_cvp_inst *inst = (struct msm_cvp_inst *)cvp_inst;
media/platform/msm/cvp/msm_cvp_core.c:	rc = msm_cvp_handle_syscall(inst, arg);
media/platform/msm/cvp/msm_cvp_core.c:EXPORT_SYMBOL(msm_cvp_private);
media/platform/msm/cvp/msm_cvp_core.c:static bool msm_cvp_check_for_inst_overload(struct msm_cvp_core *core)
media/platform/msm/cvp/msm_cvp_core.c:	struct msm_cvp_inst *inst = NULL;
media/platform/msm/cvp/msm_cvp_core.c:static int _init_session_queue(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_core.c:static void _deinit_session_queue(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_core.c:void *msm_cvp_open(int core_id, int session_type)
media/platform/msm/cvp/msm_cvp_core.c:	struct msm_cvp_inst *inst = NULL;
media/platform/msm/cvp/msm_cvp_core.c:	struct msm_cvp_core *core = NULL;
media/platform/msm/cvp/msm_cvp_core.c:	if (msm_cvp_check_for_inst_overload(core)) {
media/platform/msm/cvp/msm_cvp_core.c:	msm_cvp_session_init(inst);
media/platform/msm/cvp/msm_cvp_core.c:	rc = msm_cvp_comm_try_state(inst, MSM_CVP_CORE_INIT_DONE);
media/platform/msm/cvp/msm_cvp_core.c:		msm_cvp_debugfs_init_inst(inst, core->debugfs_root);
media/platform/msm/cvp/msm_cvp_core.c:EXPORT_SYMBOL(msm_cvp_open);
media/platform/msm/cvp/msm_cvp_core.c:static void msm_cvp_cleanup_instance(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_core.c:	max_retries =  inst->core->resources.msm_cvp_hw_rsp_timeout >> 1;
media/platform/msm/cvp/msm_cvp_core.c:	(inst->core->resources.msm_cvp_hw_rsp_timeout >> 1) - max_retries);
media/platform/msm/cvp/msm_cvp_core.c:int msm_cvp_destroy(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_core.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_core.c:	msm_cvp_debugfs_deinit_inst(inst);
media/platform/msm/cvp/msm_cvp_core.c:	struct msm_cvp_inst *inst = container_of(kref,
media/platform/msm/cvp/msm_cvp_core.c:			struct msm_cvp_inst, kref);
media/platform/msm/cvp/msm_cvp_core.c:	msm_cvp_destroy(inst);
media/platform/msm/cvp/msm_cvp_core.c:int msm_cvp_close(void *instance)
media/platform/msm/cvp/msm_cvp_core.c:	struct msm_cvp_inst *inst = instance;
media/platform/msm/cvp/msm_cvp_core.c:	msm_cvp_cleanup_instance(inst);
media/platform/msm/cvp/msm_cvp_core.c:		msm_cvp_session_deinit(inst);
media/platform/msm/cvp/msm_cvp_core.c:	rc = msm_cvp_comm_try_state(inst, MSM_CVP_CORE_UNINIT);
media/platform/msm/cvp/msm_cvp_core.c:		rc = msm_cvp_deinit_core(inst);
media/platform/msm/cvp/msm_cvp_core.c:	msm_cvp_comm_session_clean(inst);
media/platform/msm/cvp/msm_cvp_core.c:EXPORT_SYMBOL(msm_cvp_close);
media/platform/msm/cvp/msm_cvp_core.c:int msm_cvp_suspend(int core_id)
media/platform/msm/cvp/msm_cvp_core.c:	return msm_cvp_comm_suspend(core_id);
media/platform/msm/cvp/msm_cvp_core.c:EXPORT_SYMBOL(msm_cvp_suspend);
media/platform/msm/cvp/msm_cvp_core.h:#include <linux/msm_ion.h>
media/platform/msm/cvp/msm_cvp_core.h:#include <media/msm_cvp_private.h>
media/platform/msm/cvp/msm_cvp_core.h:#include <media/msm_cvp_utils.h>
media/platform/msm/cvp/msm_cvp_core.h:#include <media/msm_cvp_vidc.h>
media/platform/msm/cvp/msm_cvp_core.h:struct msm_cvp_smem {
media/platform/msm/cvp/msm_cvp_core.h:void *msm_cvp_open(int core_id, int session_type);
media/platform/msm/cvp/msm_cvp_core.h:int msm_cvp_close(void *instance);
media/platform/msm/cvp/msm_cvp_core.h:int msm_cvp_suspend(int core_id);
media/platform/msm/cvp/msm_cvp_core.h:int msm_cvp_poll(void *instance, struct file *filp,
media/platform/msm/cvp/msm_cvp_core.h:int msm_cvp_private(void *cvp_inst, unsigned int cmd,
media/platform/msm/cvp/msm_cvp_core.h:int msm_cvp_est_cycles(struct cvp_kmd_usecase_desc *cvp_desc,
media/platform/msm/cvp/msm_cvp_debug.c:#include "msm_cvp_debug.h"
media/platform/msm/cvp/msm_cvp_debug.c:#include "msm_cvp_common.h"
media/platform/msm/cvp/msm_cvp_debug.c:int msm_cvp_debug = CVP_ERR | CVP_WARN | CVP_FW;
media/platform/msm/cvp/msm_cvp_debug.c:EXPORT_SYMBOL(msm_cvp_debug);
media/platform/msm/cvp/msm_cvp_debug.c:int msm_cvp_debug_out = CVP_OUT_PRINTK;
media/platform/msm/cvp/msm_cvp_debug.c:EXPORT_SYMBOL(msm_cvp_debug_out);
media/platform/msm/cvp/msm_cvp_debug.c:int msm_cvp_fw_debug = 0x18;
media/platform/msm/cvp/msm_cvp_debug.c:int msm_cvp_fw_debug_mode = 0;
media/platform/msm/cvp/msm_cvp_debug.c:int msm_cvp_fw_low_power_mode = 1;
media/platform/msm/cvp/msm_cvp_debug.c:bool msm_cvp_fw_coverage = !true;
media/platform/msm/cvp/msm_cvp_debug.c:bool msm_cvp_thermal_mitigation_disabled = !true;
media/platform/msm/cvp/msm_cvp_debug.c:int msm_cvp_clock_voting = !1;
media/platform/msm/cvp/msm_cvp_debug.c:bool msm_cvp_syscache_disable = !true;
media/platform/msm/cvp/msm_cvp_debug.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_debug.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_cvp_debug.c:	struct msm_cvp_core *core = file->private_data;
media/platform/msm/cvp/msm_cvp_debug.c:	struct msm_cvp_core *core = filp->private_data;
media/platform/msm/cvp/msm_cvp_debug.c:		msm_cvp_trigger_ssr(core, ssr_trigger_val);
media/platform/msm/cvp/msm_cvp_debug.c:struct dentry *msm_cvp_debugfs_init_drv(void)
media/platform/msm/cvp/msm_cvp_debug.c:	dir = debugfs_create_dir("msm_cvp", NULL);
media/platform/msm/cvp/msm_cvp_debug.c:	__debugfs_create(x32, "debug_level", &msm_cvp_debug) &&
media/platform/msm/cvp/msm_cvp_debug.c:	__debugfs_create(x32, "fw_level", &msm_cvp_fw_debug) &&
media/platform/msm/cvp/msm_cvp_debug.c:	__debugfs_create(u32, "fw_debug_mode", &msm_cvp_fw_debug_mode) &&
media/platform/msm/cvp/msm_cvp_debug.c:	__debugfs_create(bool, "fw_coverage", &msm_cvp_fw_coverage) &&
media/platform/msm/cvp/msm_cvp_debug.c:			&msm_cvp_fw_low_power_mode) &&
media/platform/msm/cvp/msm_cvp_debug.c:	__debugfs_create(u32, "debug_output", &msm_cvp_debug_out) &&
media/platform/msm/cvp/msm_cvp_debug.c:			&msm_cvp_thermal_mitigation_disabled) &&
media/platform/msm/cvp/msm_cvp_debug.c:			&msm_cvp_syscache_disable);
media/platform/msm/cvp/msm_cvp_debug.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_debug.c:	core = list_first_entry(&cvp_driver->cores, struct msm_cvp_core, list);
media/platform/msm/cvp/msm_cvp_debug.c:		msm_cvp_clock_voting = 0;
media/platform/msm/cvp/msm_cvp_debug.c:		msm_cvp_clock_voting = tbl[tbl_size-1].clock_rate;
media/platform/msm/cvp/msm_cvp_debug.c:		msm_cvp_clock_voting = tbl[i].clock_rate;
media/platform/msm/cvp/msm_cvp_debug.c:			msm_cvp_clock_voting);
media/platform/msm/cvp/msm_cvp_debug.c:		msm_cvp_clock_voting);
media/platform/msm/cvp/msm_cvp_debug.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_debug.c:	core = list_first_entry(&cvp_driver->cores, struct msm_cvp_core, list);
media/platform/msm/cvp/msm_cvp_debug.c:	if (msm_cvp_clock_voting)
media/platform/msm/cvp/msm_cvp_debug.c:		*val = msm_cvp_clock_voting;
media/platform/msm/cvp/msm_cvp_debug.c:struct dentry *msm_cvp_debugfs_init_core(struct msm_cvp_core *core,
media/platform/msm/cvp/msm_cvp_debug.c:		dprintk(CVP_ERR, "Failed to create debugfs for msm_cvp\n");
media/platform/msm/cvp/msm_cvp_debug.c:static int publish_unreleased_reference(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_debug.c:	struct msm_cvp_inst *inst = container_of(kref,
media/platform/msm/cvp/msm_cvp_debug.c:			struct msm_cvp_inst, kref);
media/platform/msm/cvp/msm_cvp_debug.c:	msm_cvp_destroy(inst);
media/platform/msm/cvp/msm_cvp_debug.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_debug.c:	struct msm_cvp_inst *inst, *temp = NULL;
media/platform/msm/cvp/msm_cvp_debug.c:struct dentry *msm_cvp_debugfs_init_inst(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_debug.c:		dprintk(CVP_ERR, "Failed to create debugfs for msm_cvp\n");
media/platform/msm/cvp/msm_cvp_debug.c:void msm_cvp_debugfs_deinit_inst(struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_cvp_debug.h:#include "msm_cvp_internal.h"
media/platform/msm/cvp/msm_cvp_debug.h:#include "trace/events/msm_cvp_events.h"
media/platform/msm/cvp/msm_cvp_debug.h:#define CVP_DBG_LABEL "msm_cvp"
media/platform/msm/cvp/msm_cvp_debug.h:enum msm_cvp_debugfs_event {
media/platform/msm/cvp/msm_cvp_debug.h:extern int msm_cvp_debug;
media/platform/msm/cvp/msm_cvp_debug.h:extern int msm_cvp_debug_out;
media/platform/msm/cvp/msm_cvp_debug.h:extern int msm_cvp_fw_debug;
media/platform/msm/cvp/msm_cvp_debug.h:extern int msm_cvp_fw_debug_mode;
media/platform/msm/cvp/msm_cvp_debug.h:extern int msm_cvp_fw_low_power_mode;
media/platform/msm/cvp/msm_cvp_debug.h:extern bool msm_cvp_fw_coverage;
media/platform/msm/cvp/msm_cvp_debug.h:extern bool msm_cvp_thermal_mitigation_disabled;
media/platform/msm/cvp/msm_cvp_debug.h:extern int msm_cvp_clock_voting;
media/platform/msm/cvp/msm_cvp_debug.h:extern bool msm_cvp_syscache_disable;
media/platform/msm/cvp/msm_cvp_debug.h:		if (msm_cvp_debug & __level) { \
media/platform/msm/cvp/msm_cvp_debug.h:			if (msm_cvp_debug_out == CVP_OUT_PRINTK) { \
media/platform/msm/cvp/msm_cvp_debug.h:struct dentry *msm_cvp_debugfs_init_drv(void);
media/platform/msm/cvp/msm_cvp_debug.h:struct dentry *msm_cvp_debugfs_init_core(struct msm_cvp_core *core,
media/platform/msm/cvp/msm_cvp_debug.h:struct dentry *msm_cvp_debugfs_init_inst(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_debug.h:void msm_cvp_debugfs_deinit_inst(struct msm_cvp_inst *inst);
media/platform/msm/cvp/msm_cvp_debug.h:static inline void tic(struct msm_cvp_inst *i, enum profiling_points p,
media/platform/msm/cvp/msm_cvp_debug.h:	if ((msm_cvp_debug & CVP_PROF) &&
media/platform/msm/cvp/msm_cvp_debug.h:static inline void toc(struct msm_cvp_inst *i, enum profiling_points p)
media/platform/msm/cvp/msm_cvp_debug.h:	if ((msm_cvp_debug & CVP_PROF) &&
media/platform/msm/cvp/msm_cvp_debug.h:static inline void show_stats(struct msm_cvp_inst *i)
media/platform/msm/cvp/msm_cvp_debug.h:				(msm_cvp_debug & CVP_PROF)) {
media/platform/msm/cvp/msm_cvp_debug.h:static inline void msm_cvp_res_handle_fatal_hw_error(
media/platform/msm/cvp/msm_cvp_debug.h:	struct msm_cvp_platform_resources *resources,
media/platform/msm/cvp/msm_cvp_debug.h:static inline void msm_cvp_handle_hw_error(struct msm_cvp_core *core)
media/platform/msm/cvp/msm_cvp_debug.h:	msm_cvp_res_handle_fatal_hw_error(&core->resources, enable_fatal);
media/platform/msm/cvp/msm_cvp_dsp.c:#include "msm_cvp_dsp.h"
media/platform/msm/cvp/msm_cvp_dsp.c:void msm_cvp_cdsp_ssr_handler(struct work_struct *work)
media/platform/msm/cvp/msm_cvp_dsp.c:	strlcpy(q_tbl_hdr->name, "msm_v4l2_cvp", sizeof(q_tbl_hdr->name));
media/platform/msm/cvp/msm_cvp_dsp.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_dsp.c:			struct msm_cvp_core, list);
media/platform/msm/cvp/msm_cvp_dsp.c:			core->resources.msm_cvp_dsp_rsp_timeout);
media/platform/msm/cvp/msm_cvp_dsp.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_dsp.c:	core = list_first_entry(&cvp_driver->cores, struct msm_cvp_core, list);
media/platform/msm/cvp/msm_cvp_dsp.c:	timeout = msecs_to_jiffies(core->resources.msm_cvp_dsp_rsp_timeout);
media/platform/msm/cvp/msm_cvp_dsp.c:		.name = "qcom,msm_cvp_dsp_rpmsg",
media/platform/msm/cvp/msm_cvp_dsp.c:	INIT_WORK(&me->ssr_work, msm_cvp_cdsp_ssr_handler);
media/platform/msm/cvp/msm_cvp_dsp.h:#include "msm_cvp_debug.h"
media/platform/msm/cvp/msm_cvp_internal.h:#include <linux/msm-bus.h>
media/platform/msm/cvp/msm_cvp_internal.h:#include <linux/msm-bus-board.h>
media/platform/msm/cvp/msm_cvp_internal.h:#include "msm_cvp_core.h"
media/platform/msm/cvp/msm_cvp_internal.h:#include <media/msm_media_info.h>
media/platform/msm/cvp/msm_cvp_internal.h:#include <media/msm_cvp_private.h>
media/platform/msm/cvp/msm_cvp_internal.h:struct msm_cvp_inst;
media/platform/msm/cvp/msm_cvp_internal.h:struct msm_cvp_list {
media/platform/msm/cvp/msm_cvp_internal.h:static inline void INIT_MSM_CVP_LIST(struct msm_cvp_list *mlist)
media/platform/msm/cvp/msm_cvp_internal.h:static inline void DEINIT_MSM_CVP_LIST(struct msm_cvp_list *mlist)
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_smem smem;
media/platform/msm/cvp/msm_cvp_internal.h:struct msm_cvp_common_data {
media/platform/msm/cvp/msm_cvp_internal.h:struct msm_cvp_ubwc_config_data {
media/platform/msm/cvp/msm_cvp_internal.h:struct msm_cvp_platform_data {
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_common_data *common_data;
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_ubwc_config_data *ubwc_config;
media/platform/msm/cvp/msm_cvp_internal.h:struct msm_cvp_drv {
media/platform/msm/cvp/msm_cvp_internal.h:struct msm_cvp_debug {
media/platform/msm/cvp/msm_cvp_internal.h:enum msm_cvp_modes {
media/platform/msm/cvp/msm_cvp_internal.h:struct msm_cvp_core {
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_platform_data *platform_data;
media/platform/msm/cvp/msm_cvp_internal.h:	enum msm_cvp_hfi_type hfi_type;
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_platform_resources resources;
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_capability *capabilities;
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_core_ops *core_ops;
media/platform/msm/cvp/msm_cvp_internal.h:struct msm_cvp_inst {
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_list freqs;
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_list persistbufs;
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_list cvpcpubufs;
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_list cvpdspbufs;
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_list frames;
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_debug debug;
media/platform/msm/cvp/msm_cvp_internal.h:	enum msm_cvp_modes flags;
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_capability capability;
media/platform/msm/cvp/msm_cvp_internal.h:struct msm_cvp_fence_thread_data {
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_cvp_internal.h:extern struct msm_cvp_drv *cvp_driver;
media/platform/msm/cvp/msm_cvp_internal.h:int msm_cvp_trigger_ssr(struct msm_cvp_core *core,
media/platform/msm/cvp/msm_cvp_internal.h:int msm_cvp_noc_error_info(struct msm_cvp_core *core);
media/platform/msm/cvp/msm_cvp_internal.h:void msm_cvp_queue_v4l2_event(struct msm_cvp_inst *inst, int event_type);
media/platform/msm/cvp/msm_cvp_internal.h:enum msm_cvp_flags {
media/platform/msm/cvp/msm_cvp_internal.h:struct msm_cvp_internal_buffer {
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_smem smem;
media/platform/msm/cvp/msm_cvp_internal.h:struct msm_cvp_frame_buf {
media/platform/msm/cvp/msm_cvp_internal.h:struct msm_cvp_frame {
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_list bufs;
media/platform/msm/cvp/msm_cvp_internal.h:void msm_cvp_comm_handle_thermal_event(void);
media/platform/msm/cvp/msm_cvp_internal.h:int msm_cvp_smem_alloc(size_t size, u32 align, u32 flags, int map_kernel,
media/platform/msm/cvp/msm_cvp_internal.h:	void  *res, u32 session_type, struct msm_cvp_smem *smem);
media/platform/msm/cvp/msm_cvp_internal.h:int msm_cvp_smem_free(struct msm_cvp_smem *smem);
media/platform/msm/cvp/msm_cvp_internal.h:struct context_bank_info *msm_cvp_smem_get_context_bank(u32 session_type,
media/platform/msm/cvp/msm_cvp_internal.h:	bool is_secure, struct msm_cvp_platform_resources *res,
media/platform/msm/cvp/msm_cvp_internal.h:int msm_cvp_smem_map_dma_buf(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_internal.h:				struct msm_cvp_smem *smem);
media/platform/msm/cvp/msm_cvp_internal.h:int msm_cvp_smem_unmap_dma_buf(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_cvp_internal.h:	struct msm_cvp_smem *smem);
media/platform/msm/cvp/msm_cvp_internal.h:struct dma_buf *msm_cvp_smem_get_dma_buf(int fd);
media/platform/msm/cvp/msm_cvp_internal.h:void msm_cvp_smem_put_dma_buf(void *dma_buf);
media/platform/msm/cvp/msm_cvp_internal.h:int msm_cvp_smem_cache_operations(struct dma_buf *dbuf,
media/platform/msm/cvp/msm_cvp_internal.h:void msm_cvp_fw_unload_handler(struct work_struct *work);
media/platform/msm/cvp/msm_cvp_internal.h:void msm_cvp_ssr_handler(struct work_struct *work);
media/platform/msm/cvp/msm_cvp_internal.h: * XXX: normally should be in msm_cvp_core.h, but that's meant for public APIs,
media/platform/msm/cvp/msm_cvp_internal.h:int msm_cvp_destroy(struct msm_cvp_inst *inst);
media/platform/msm/cvp/msm_cvp_platform.c:#include "msm_cvp_internal.h"
media/platform/msm/cvp/msm_cvp_platform.c:#include "msm_cvp_debug.h"
media/platform/msm/cvp/msm_cvp_platform.c:static struct msm_cvp_common_data default_common_data[] = {
media/platform/msm/cvp/msm_cvp_platform.c:static struct msm_cvp_common_data sm8250_common_data[] = {
media/platform/msm/cvp/msm_cvp_platform.c:static struct msm_cvp_ubwc_config_data kona_ubwc_data[] = {
media/platform/msm/cvp/msm_cvp_platform.c:static struct msm_cvp_platform_data default_data = {
media/platform/msm/cvp/msm_cvp_platform.c:static struct msm_cvp_platform_data sm8250_data = {
media/platform/msm/cvp/msm_cvp_platform.c:static const struct of_device_id msm_cvp_dt_match[] = {
media/platform/msm/cvp/msm_cvp_platform.c:MODULE_DEVICE_TABLE(of, msm_cvp_dt_match);
media/platform/msm/cvp/msm_cvp_platform.c:	struct msm_cvp_platform_data *driver_data;
media/platform/msm/cvp/msm_cvp_platform.c:	match = of_match_node(msm_cvp_dt_match, dev->of_node);
media/platform/msm/cvp/msm_cvp_platform.c:	driver_data = (struct msm_cvp_platform_data *)match->data;
media/platform/msm/cvp/msm_cvp_res_parse.c:#include "msm_cvp_debug.h"
media/platform/msm/cvp/msm_cvp_res_parse.c:#include "msm_cvp_resources.h"
media/platform/msm/cvp/msm_cvp_res_parse.c:#include "msm_cvp_res_parse.h"
media/platform/msm/cvp/msm_cvp_res_parse.c:static inline struct device *msm_iommu_get_ctx(const char *ctx_name)
media/platform/msm/cvp/msm_cvp_res_parse.c:static inline void msm_cvp_free_allowed_clocks_table(
media/platform/msm/cvp/msm_cvp_res_parse.c:		struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:static inline void msm_cvp_free_cycles_per_mb_table(
media/platform/msm/cvp/msm_cvp_res_parse.c:		struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:static inline void msm_cvp_free_reg_table(
media/platform/msm/cvp/msm_cvp_res_parse.c:			struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:static inline void msm_cvp_free_qdss_addr_table(
media/platform/msm/cvp/msm_cvp_res_parse.c:			struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:static inline void msm_cvp_free_bus_vectors(
media/platform/msm/cvp/msm_cvp_res_parse.c:			struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:static inline void msm_cvp_free_regulator_table(
media/platform/msm/cvp/msm_cvp_res_parse.c:			struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:static inline void msm_cvp_free_clock_table(
media/platform/msm/cvp/msm_cvp_res_parse.c:			struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:void msm_cvp_free_platform_resources(
media/platform/msm/cvp/msm_cvp_res_parse.c:			struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:	msm_cvp_free_clock_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	msm_cvp_free_regulator_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	msm_cvp_free_allowed_clocks_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	msm_cvp_free_reg_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	msm_cvp_free_qdss_addr_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	msm_cvp_free_bus_vectors(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:static int msm_cvp_load_reg_table(struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:		msm_cvp_free_reg_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:static int msm_cvp_load_qdss_table(struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:		msm_cvp_free_qdss_addr_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:static int msm_cvp_load_subcache_info(struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c: * msm_cvp_load_u32_table() - load dtsi table entries
media/platform/msm/cvp/msm_cvp_res_parse.c:int msm_cvp_load_u32_table(struct platform_device *pdev,
media/platform/msm/cvp/msm_cvp_res_parse.c:EXPORT_SYMBOL(msm_cvp_load_u32_table);
media/platform/msm/cvp/msm_cvp_res_parse.c:static int msm_cvp_load_allowed_clocks_table(
media/platform/msm/cvp/msm_cvp_res_parse.c:		struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:	rc = msm_cvp_load_u32_table(pdev, pdev->dev.of_node,
media/platform/msm/cvp/msm_cvp_res_parse.c:static int msm_cvp_populate_mem_cdsp(struct device *dev,
media/platform/msm/cvp/msm_cvp_res_parse.c:		struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:static int msm_cvp_populate_bus(struct device *dev,
media/platform/msm/cvp/msm_cvp_res_parse.c:		struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:static int msm_cvp_load_regulator_table(
media/platform/msm/cvp/msm_cvp_res_parse.c:		struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:	msm_cvp_free_regulator_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:static int msm_cvp_load_clock_table(
media/platform/msm/cvp/msm_cvp_res_parse.c:		struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:static int msm_cvp_load_reset_table(
media/platform/msm/cvp/msm_cvp_res_parse.c:		struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:static int find_key_value(struct msm_cvp_platform_data *platform_data,
media/platform/msm/cvp/msm_cvp_res_parse.c:	struct msm_cvp_common_data *common_data = platform_data->common_data;
media/platform/msm/cvp/msm_cvp_res_parse.c:		struct msm_cvp_core *core)
media/platform/msm/cvp/msm_cvp_res_parse.c:	struct msm_cvp_platform_data *platform_data;
media/platform/msm/cvp/msm_cvp_res_parse.c:	struct msm_cvp_platform_resources *res;
media/platform/msm/cvp/msm_cvp_res_parse.c:	res->msm_cvp_pwr_collapse_delay = find_key_value(platform_data,
media/platform/msm/cvp/msm_cvp_res_parse.c:	res->msm_cvp_firmware_unload_delay = find_key_value(platform_data,
media/platform/msm/cvp/msm_cvp_res_parse.c:	res->msm_cvp_hw_rsp_timeout = find_key_value(platform_data,
media/platform/msm/cvp/msm_cvp_res_parse.c:	res->msm_cvp_dsp_rsp_timeout = find_key_value(platform_data,
media/platform/msm/cvp/msm_cvp_res_parse.c:		struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_cvp_res_parse.c:	rc = msm_cvp_load_subcache_info(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	rc = msm_cvp_load_qdss_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	rc = msm_cvp_load_reg_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	rc = msm_cvp_load_regulator_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	rc = msm_cvp_load_clock_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	rc = msm_cvp_load_allowed_clocks_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	rc = msm_cvp_load_reset_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	msm_cvp_free_allowed_clocks_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	msm_cvp_free_clock_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	msm_cvp_free_regulator_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:	msm_cvp_free_reg_table(res);
media/platform/msm/cvp/msm_cvp_res_parse.c:static int msm_cvp_setup_context_bank(struct msm_cvp_platform_resources *res,
media/platform/msm/cvp/msm_cvp_res_parse.c:int msm_cvp_smmu_fault_handler(struct iommu_domain *domain,
media/platform/msm/cvp/msm_cvp_res_parse.c:	struct msm_cvp_core *core = token;
media/platform/msm/cvp/msm_cvp_res_parse.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_cvp_res_parse.c:		msm_cvp_comm_print_inst_info(inst);
media/platform/msm/cvp/msm_cvp_res_parse.c:static int msm_cvp_populate_context_bank(struct device *dev,
media/platform/msm/cvp/msm_cvp_res_parse.c:		struct msm_cvp_core *core)
media/platform/msm/cvp/msm_cvp_res_parse.c:	rc = msm_cvp_setup_context_bank(&core->resources, cb, dev);
media/platform/msm/cvp/msm_cvp_res_parse.c:		msm_cvp_smmu_fault_handler, (void *)core);
media/platform/msm/cvp/msm_cvp_res_parse.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_res_parse.c:	rc = msm_cvp_populate_context_bank(&pdev->dev, core);
media/platform/msm/cvp/msm_cvp_res_parse.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_res_parse.c:	return msm_cvp_populate_bus(&pdev->dev, &core->resources);
media/platform/msm/cvp/msm_cvp_res_parse.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_cvp_res_parse.c:	return msm_cvp_populate_mem_cdsp(&pdev->dev, &core->resources);
media/platform/msm/cvp/msm_cvp_res_parse.h:#include "msm_cvp_resources.h"
media/platform/msm/cvp/msm_cvp_res_parse.h:#include "msm_cvp_common.h"
media/platform/msm/cvp/msm_cvp_res_parse.h:void msm_cvp_free_platform_resources(
media/platform/msm/cvp/msm_cvp_res_parse.h:		struct msm_cvp_platform_resources *res);
media/platform/msm/cvp/msm_cvp_res_parse.h:		struct msm_cvp_core *core);
media/platform/msm/cvp/msm_cvp_res_parse.h:		struct msm_cvp_platform_resources *res);
media/platform/msm/cvp/msm_cvp_res_parse.h:int msm_cvp_load_u32_table(struct platform_device *pdev,
media/platform/msm/cvp/msm_cvp_resources.h:#include "msm_cvp_core.h"
media/platform/msm/cvp/msm_cvp_resources.h:	struct msm_bus_client_handle *client;
media/platform/msm/cvp/msm_cvp_resources.h:struct msm_cvp_mem_cdsp {
media/platform/msm/cvp/msm_cvp_resources.h:struct msm_cvp_platform_resources {
media/platform/msm/cvp/msm_cvp_resources.h:	int msm_cvp_hw_rsp_timeout;
media/platform/msm/cvp/msm_cvp_resources.h:	int msm_cvp_dsp_rsp_timeout;
media/platform/msm/cvp/msm_cvp_resources.h:	int msm_cvp_firmware_unload_delay;
media/platform/msm/cvp/msm_cvp_resources.h:	uint32_t msm_cvp_pwr_collapse_delay;
media/platform/msm/cvp/msm_cvp_resources.h:	struct msm_cvp_mem_cdsp mem_cdsp;
media/platform/msm/cvp/msm_cvp_resources.h:	struct msm_cvp_ubwc_config_data *ubwc_config;
media/platform/msm/cvp/msm_cvp_resources.h:static inline bool is_iommu_present(struct msm_cvp_platform_resources *res)
media/platform/msm/cvp/msm_smem.c:#include <linux/msm_dma_iommu_mapping.h>
media/platform/msm/cvp/msm_smem.c:#include <linux/msm_ion.h>
media/platform/msm/cvp/msm_smem.c:#include "msm_cvp_core.h"
media/platform/msm/cvp/msm_smem.c:#include "msm_cvp_debug.h"
media/platform/msm/cvp/msm_smem.c:#include "msm_cvp_resources.h"
media/platform/msm/cvp/msm_smem.c:static int msm_dma_get_device_address(struct dma_buf *dbuf, u32 align,
media/platform/msm/cvp/msm_smem.c:	u32 session_type, struct msm_cvp_platform_resources *res,
media/platform/msm/cvp/msm_smem.c:		cb = msm_cvp_smem_get_context_bank(
media/platform/msm/cvp/msm_smem.c:			msm_cvp_res_handle_fatal_hw_error(res,
media/platform/msm/cvp/msm_smem.c:		trace_msm_cvp_smem_buffer_iommu_op_start("MAP", 0, 0,
media/platform/msm/cvp/msm_smem.c:		trace_msm_cvp_smem_buffer_iommu_op_end("MAP", 0, 0,
media/platform/msm/cvp/msm_smem.c:static int msm_dma_put_device_address(u32 flags,
media/platform/msm/cvp/msm_smem.c:	trace_msm_cvp_smem_buffer_iommu_op_start("UNMAP", 0, 0, 0, 0, 0);
media/platform/msm/cvp/msm_smem.c:	trace_msm_cvp_smem_buffer_iommu_op_end("UNMAP", 0, 0, 0, 0, 0);
media/platform/msm/cvp/msm_smem.c:struct dma_buf *msm_cvp_smem_get_dma_buf(int fd)
media/platform/msm/cvp/msm_smem.c:void msm_cvp_smem_put_dma_buf(void *dma_buf)
media/platform/msm/cvp/msm_smem.c:int msm_cvp_smem_map_dma_buf(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_smem.c:				struct msm_cvp_smem *smem)
media/platform/msm/cvp/msm_smem.c:		dbuf = msm_cvp_smem_get_dma_buf(smem->fd);
media/platform/msm/cvp/msm_smem.c:	rc = msm_dma_get_device_address(dbuf, align, &iova, &buffer_size,
media/platform/msm/cvp/msm_smem.c:int msm_cvp_smem_unmap_dma_buf(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_smem.c:				struct msm_cvp_smem *smem)
media/platform/msm/cvp/msm_smem.c:	rc = msm_dma_put_device_address(smem->flags, &smem->mapping_info);
media/platform/msm/cvp/msm_smem.c:	msm_cvp_smem_put_dma_buf(smem->dma_buf);
media/platform/msm/cvp/msm_smem.c:	struct msm_cvp_platform_resources *res, u32 session_type,
media/platform/msm/cvp/msm_smem.c:	struct msm_cvp_smem *mem)
media/platform/msm/cvp/msm_smem.c:	trace_msm_cvp_smem_buffer_dma_op_start("ALLOC", (u32)ion_flags,
media/platform/msm/cvp/msm_smem.c:	trace_msm_cvp_smem_buffer_dma_op_end("ALLOC", (u32)ion_flags,
media/platform/msm/cvp/msm_smem.c:	rc = msm_dma_get_device_address(dbuf, align, &iova, &buffer_size, flags,
media/platform/msm/cvp/msm_smem.c:static int free_dma_mem(struct msm_cvp_smem *mem)
media/platform/msm/cvp/msm_smem.c:		msm_dma_put_device_address(mem->flags, &mem->mapping_info);
media/platform/msm/cvp/msm_smem.c:		trace_msm_cvp_smem_buffer_dma_op_start("FREE",
media/platform/msm/cvp/msm_smem.c:		trace_msm_cvp_smem_buffer_dma_op_end(
media/platform/msm/cvp/msm_smem.c:int msm_cvp_smem_alloc(size_t size, u32 align, u32 flags, int map_kernel,
media/platform/msm/cvp/msm_smem.c:	void *res, u32 session_type, struct msm_cvp_smem *smem)
media/platform/msm/cvp/msm_smem.c:				(struct msm_cvp_platform_resources *)res,
media/platform/msm/cvp/msm_smem.c:int msm_cvp_smem_free(struct msm_cvp_smem *smem)
media/platform/msm/cvp/msm_smem.c:int msm_cvp_smem_cache_operations(struct dma_buf *dbuf,
media/platform/msm/cvp/msm_smem.c:struct context_bank_info *msm_cvp_smem_get_context_bank(u32 session_type,
media/platform/msm/cvp/msm_smem.c:	bool is_secure, struct msm_cvp_platform_resources *res,
media/platform/msm/cvp/msm_v4l2_cvp.c:#include "msm_cvp_core.h"
media/platform/msm/cvp/msm_v4l2_cvp.c:#include "msm_cvp_common.h"
media/platform/msm/cvp/msm_v4l2_cvp.c:#include "msm_cvp_debug.h"
media/platform/msm/cvp/msm_v4l2_cvp.c:#include "msm_cvp_internal.h"
media/platform/msm/cvp/msm_v4l2_cvp.c:#include "msm_cvp_res_parse.h"
media/platform/msm/cvp/msm_v4l2_cvp.c:#include "msm_cvp_resources.h"
media/platform/msm/cvp/msm_v4l2_cvp.c:#include "msm_v4l2_private.h"
media/platform/msm/cvp/msm_v4l2_cvp.c:#include "msm_cvp_clocks.h"
media/platform/msm/cvp/msm_v4l2_cvp.c:struct msm_cvp_drv *cvp_driver;
media/platform/msm/cvp/msm_v4l2_cvp.c:	struct msm_cvp_core *core = container_of(inode->i_cdev,
media/platform/msm/cvp/msm_v4l2_cvp.c:		struct msm_cvp_core, cdev);
media/platform/msm/cvp/msm_v4l2_cvp.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_v4l2_cvp.c:	inst = msm_cvp_open(core->id, MSM_CVP_USER);
media/platform/msm/cvp/msm_v4l2_cvp.c:	struct msm_cvp_inst *inst = filp->private_data;
media/platform/msm/cvp/msm_v4l2_cvp.c:	rc = msm_cvp_close(inst);
media/platform/msm/cvp/msm_v4l2_cvp.c:	struct msm_cvp_inst *inst = filp->private_data;
media/platform/msm/cvp/msm_v4l2_cvp.c:static int read_platform_resources(struct msm_cvp_core *core,
media/platform/msm/cvp/msm_v4l2_cvp.c:static int msm_cvp_initialize_core(struct platform_device *pdev,
media/platform/msm/cvp/msm_v4l2_cvp.c:				struct msm_cvp_core *core)
media/platform/msm/cvp/msm_v4l2_cvp.c:	INIT_DELAYED_WORK(&core->fw_unload_work, msm_cvp_fw_unload_handler);
media/platform/msm/cvp/msm_v4l2_cvp.c:	INIT_WORK(&core->ssr_work, msm_cvp_ssr_handler);
media/platform/msm/cvp/msm_v4l2_cvp.c:	struct msm_cvp_core *core = dev_get_drvdata(dev);
media/platform/msm/cvp/msm_v4l2_cvp.c:			return snprintf(buf, PAGE_SIZE, "msm_cvp\n");
media/platform/msm/cvp/msm_v4l2_cvp.c:	struct msm_cvp_core *core = NULL;
media/platform/msm/cvp/msm_v4l2_cvp.c:	core->resources.msm_cvp_pwr_collapse_delay = val;
media/platform/msm/cvp/msm_v4l2_cvp.c:	struct msm_cvp_core *core = NULL;
media/platform/msm/cvp/msm_v4l2_cvp.c:		core->resources.msm_cvp_pwr_collapse_delay);
media/platform/msm/cvp/msm_v4l2_cvp.c:	msm_cvp_comm_handle_thermal_event();
media/platform/msm/cvp/msm_v4l2_cvp.c:		struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_v4l2_cvp.c:		inst = msm_cvp_open(MSM_CORE_CVP, MSM_CVP_BOOT);
media/platform/msm/cvp/msm_v4l2_cvp.c:		rc = msm_cvp_close(inst);
media/platform/msm/cvp/msm_v4l2_cvp.c:static struct attribute *msm_cvp_core_attrs[] = {
media/platform/msm/cvp/msm_v4l2_cvp.c:static struct attribute_group msm_cvp_core_attr_group = {
media/platform/msm/cvp/msm_v4l2_cvp.c:		.attrs = msm_cvp_core_attrs,
media/platform/msm/cvp/msm_v4l2_cvp.c:static const struct of_device_id msm_cvp_dt_match[] = {
media/platform/msm/cvp/msm_v4l2_cvp.c:	{.compatible = "qcom,msm-cvp"},
media/platform/msm/cvp/msm_v4l2_cvp.c:	{.compatible = "qcom,msm-cvp,context-bank"},
media/platform/msm/cvp/msm_v4l2_cvp.c:	{.compatible = "qcom,msm-cvp,bus"},
media/platform/msm/cvp/msm_v4l2_cvp.c:	{.compatible = "qcom,msm-cvp,mem-cdsp"},
media/platform/msm/cvp/msm_v4l2_cvp.c:static int msm_probe_cvp_device(struct platform_device *pdev)
media/platform/msm/cvp/msm_v4l2_cvp.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_v4l2_cvp.c:	rc = msm_cvp_initialize_core(pdev, core);
media/platform/msm/cvp/msm_v4l2_cvp.c:	rc = sysfs_create_group(&core->dev->kobj, &msm_cvp_core_attr_group);
media/platform/msm/cvp/msm_v4l2_cvp.c:			dprintk(CVP_DBG, "msm_cvp: request probe defer\n");
media/platform/msm/cvp/msm_v4l2_cvp.c:	core->debugfs_root = msm_cvp_debugfs_init_core(
media/platform/msm/cvp/msm_v4l2_cvp.c:	 * Trigger probe for each sub-device i.e. qcom,msm-cvp,context-bank.
media/platform/msm/cvp/msm_v4l2_cvp.c:	 * When msm_cvp_probe is called for each sub-device, parse the
media/platform/msm/cvp/msm_v4l2_cvp.c:	rc = of_platform_populate(pdev->dev.of_node, msm_cvp_dt_match, NULL,
media/platform/msm/cvp/msm_v4l2_cvp.c:	sysfs_remove_group(&pdev->dev.kobj, &msm_cvp_core_attr_group);
media/platform/msm/cvp/msm_v4l2_cvp.c:static int msm_cvp_probe_mem_cdsp(struct platform_device *pdev)
media/platform/msm/cvp/msm_v4l2_cvp.c:static int msm_cvp_probe_context_bank(struct platform_device *pdev)
media/platform/msm/cvp/msm_v4l2_cvp.c:static int msm_cvp_probe_bus(struct platform_device *pdev)
media/platform/msm/cvp/msm_v4l2_cvp.c:static int msm_cvp_probe(struct platform_device *pdev)
media/platform/msm/cvp/msm_v4l2_cvp.c:	 * the end of the probe function after msm-cvp device probe is
media/platform/msm/cvp/msm_v4l2_cvp.c:	if (of_device_is_compatible(pdev->dev.of_node, "qcom,msm-cvp")) {
media/platform/msm/cvp/msm_v4l2_cvp.c:		return msm_probe_cvp_device(pdev);
media/platform/msm/cvp/msm_v4l2_cvp.c:		"qcom,msm-cvp,bus")) {
media/platform/msm/cvp/msm_v4l2_cvp.c:		return msm_cvp_probe_bus(pdev);
media/platform/msm/cvp/msm_v4l2_cvp.c:		"qcom,msm-cvp,context-bank")) {
media/platform/msm/cvp/msm_v4l2_cvp.c:		return msm_cvp_probe_context_bank(pdev);
media/platform/msm/cvp/msm_v4l2_cvp.c:		"qcom,msm-cvp,mem-cdsp")) {
media/platform/msm/cvp/msm_v4l2_cvp.c:		return msm_cvp_probe_mem_cdsp(pdev);
media/platform/msm/cvp/msm_v4l2_cvp.c:static int msm_cvp_remove(struct platform_device *pdev)
media/platform/msm/cvp/msm_v4l2_cvp.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_v4l2_cvp.c:	msm_cvp_free_platform_resources(&core->resources);
media/platform/msm/cvp/msm_v4l2_cvp.c:	sysfs_remove_group(&pdev->dev.kobj, &msm_cvp_core_attr_group);
media/platform/msm/cvp/msm_v4l2_cvp.c:static int msm_cvp_pm_suspend(struct device *dev)
media/platform/msm/cvp/msm_v4l2_cvp.c:	struct msm_cvp_core *core;
media/platform/msm/cvp/msm_v4l2_cvp.c:		!of_device_is_compatible(dev->of_node, "qcom,msm-cvp"))
media/platform/msm/cvp/msm_v4l2_cvp.c:	rc = msm_cvp_suspend(core->id);
media/platform/msm/cvp/msm_v4l2_cvp.c:static int msm_cvp_pm_resume(struct device *dev)
media/platform/msm/cvp/msm_v4l2_cvp.c:static const struct dev_pm_ops msm_cvp_pm_ops = {
media/platform/msm/cvp/msm_v4l2_cvp.c:	SET_SYSTEM_SLEEP_PM_OPS(msm_cvp_pm_suspend, msm_cvp_pm_resume)
media/platform/msm/cvp/msm_v4l2_cvp.c:MODULE_DEVICE_TABLE(of, msm_cvp_dt_match);
media/platform/msm/cvp/msm_v4l2_cvp.c:static struct platform_driver msm_cvp_driver = {
media/platform/msm/cvp/msm_v4l2_cvp.c:	.probe = msm_cvp_probe,
media/platform/msm/cvp/msm_v4l2_cvp.c:	.remove = msm_cvp_remove,
media/platform/msm/cvp/msm_v4l2_cvp.c:		.name = "msm_cvp_v4l2",
media/platform/msm/cvp/msm_v4l2_cvp.c:		.of_match_table = msm_cvp_dt_match,
media/platform/msm/cvp/msm_v4l2_cvp.c:		.pm = &msm_cvp_pm_ops,
media/platform/msm/cvp/msm_v4l2_cvp.c:static int __init msm_cvp_init(void)
media/platform/msm/cvp/msm_v4l2_cvp.c:			"Failed to allocate memroy for msm_cvp_drv\n");
media/platform/msm/cvp/msm_v4l2_cvp.c:	cvp_driver->debugfs_root = msm_cvp_debugfs_init_drv();
media/platform/msm/cvp/msm_v4l2_cvp.c:			"Failed to create debugfs for msm_cvp\n");
media/platform/msm/cvp/msm_v4l2_cvp.c:	rc = platform_driver_register(&msm_cvp_driver);
media/platform/msm/cvp/msm_v4l2_cvp.c:	cvp_driver->fence_data_cache = KMEM_CACHE(msm_cvp_fence_thread_data, 0);
media/platform/msm/cvp/msm_v4l2_cvp.c:	cvp_driver->frame_cache = KMEM_CACHE(msm_cvp_frame, 0);
media/platform/msm/cvp/msm_v4l2_cvp.c:	cvp_driver->frame_buf_cache = KMEM_CACHE(msm_cvp_frame_buf, 0);
media/platform/msm/cvp/msm_v4l2_cvp.c:	cvp_driver->internal_buf_cache = KMEM_CACHE(msm_cvp_internal_buffer, 0);
media/platform/msm/cvp/msm_v4l2_cvp.c:static void __exit msm_cvp_exit(void)
media/platform/msm/cvp/msm_v4l2_cvp.c:	platform_driver_unregister(&msm_cvp_driver);
media/platform/msm/cvp/msm_v4l2_cvp.c:module_init(msm_cvp_init);
media/platform/msm/cvp/msm_v4l2_cvp.c:module_exit(msm_cvp_exit);
media/platform/msm/cvp/msm_v4l2_private.c:#include "msm_v4l2_private.h"
media/platform/msm/cvp/msm_v4l2_private.c:			struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_v4l2_private.c:		struct msm_cvp_inst *inst)
media/platform/msm/cvp/msm_v4l2_private.c:static long cvp_ioctl(struct msm_cvp_inst *inst,
media/platform/msm/cvp/msm_v4l2_private.c:	rc = msm_cvp_private((void *)inst, cmd, karg);
media/platform/msm/cvp/msm_v4l2_private.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_v4l2_private.c:	struct msm_cvp_inst *inst;
media/platform/msm/cvp/msm_v4l2_private.h:#include <media/msm_cvp_private.h>
media/platform/msm/cvp/msm_v4l2_private.h:#include "msm_cvp_debug.h"
media/platform/msm/dvb/Kconfig:source "drivers/media/platform/msm/dvb/demux/Kconfig"
media/platform/msm/dvb/adapter/Makefile:ccflags-y += -Idrivers/media/platform/msm/dvb/include/
media/platform/msm/dvb/adapter/Makefile:ccflags-y += -Idrivers/media/platform/msm/dvb/demux/
media/platform/msm/dvb/demux/Makefile:ccflags-y += -Idrivers/media/platform/msm/dvb/include/
media/platform/msm/dvb/demux/mpq_dmx_plugin_common.c:		perms_list[i] = msm_secure_get_vmid_perms(vmid_list[i]);
media/platform/msm/dvb/demux/mpq_dmx_plugin_common.h:#include <linux/msm_ion.h>
media/platform/msm/dvb/demux/mpq_dmx_plugin_sw.c:static const struct of_device_id msm_match_table[] = {
media/platform/msm/dvb/demux/mpq_dmx_plugin_sw.c:		.of_match_table = msm_match_table,
media/platform/msm/dvb/demux/mpq_dmx_plugin_tspp_v1.c:static const struct of_device_id msm_match_table[] = {
media/platform/msm/dvb/demux/mpq_dmx_plugin_tspp_v1.c:		.of_match_table = msm_match_table,
media/platform/msm/npu/Makefile:obj-$(CONFIG_MSM_NPU)      := msm_npu.o
media/platform/msm/npu/Makefile:msm_npu-objs := npu_dbg.o \
media/platform/msm/npu/npu_common.h:#include <linux/msm_npu.h>
media/platform/msm/npu/npu_common.h:#include <linux/msm-bus.h>
media/platform/msm/npu/npu_common.h:	struct msm_bus_vectors vectors[MAX_PATHS * DBL_BUF];
media/platform/msm/npu/npu_common.h:	struct msm_bus_paths bw_levels[DBL_BUF];
media/platform/msm/npu/npu_common.h:	struct msm_bus_scale_pdata bw_data;
media/platform/msm/npu/npu_dev.c:#include <dt-bindings/msm/msm-bus-ids.h>
media/platform/msm/npu/npu_dev.c:#define DRIVER_NAME             "msm_npu"
media/platform/msm/npu/npu_dev.c:	{ .compatible = "qcom,msm-npu",},
media/platform/msm/npu/npu_dev.c:		.name = "msm_npu",
media/platform/msm/npu/npu_dev.c:	struct msm_npu_property prop;
media/platform/msm/npu/npu_dev.c:	struct msm_npu_get_info_ioctl req;
media/platform/msm/npu/npu_dev.c:	struct msm_npu_map_buf_ioctl req;
media/platform/msm/npu/npu_dev.c:	struct msm_npu_unmap_buf_ioctl req;
media/platform/msm/npu/npu_dev.c:	struct msm_npu_load_network_ioctl_v2 req;
media/platform/msm/npu/npu_dev.c:	struct msm_npu_unload_network_ioctl unload_req;
media/platform/msm/npu/npu_dev.c:	struct msm_npu_patch_info_v2 *patch_info = NULL;
media/platform/msm/npu/npu_dev.c:	struct msm_npu_unload_network_ioctl req;
media/platform/msm/npu/npu_dev.c:	struct msm_npu_exec_network_ioctl_v2 req;
media/platform/msm/npu/npu_dev.c:	struct msm_npu_patch_buf_info *patch_buf_info = NULL;
media/platform/msm/npu/npu_dev.c:	struct msm_npu_property prop;
media/platform/msm/npu/npu_dev.c:	struct msm_npu_property prop;
media/platform/msm/npu/npu_dev.c:	bwctrl->bus_client = msm_bus_scale_register_client(&bwctrl->bw_data);
media/platform/msm/npu/npu_dev.c:	ret = msm_bus_scale_client_update_request(bwctrl->bus_client, i);
media/platform/msm/npu/npu_dev.c:	msm_bus_scale_unregister_client(npu_dev->bwctrl.bus_client);
media/platform/msm/npu/npu_hw_access.c:#include <linux/msm_dma_iommu_mapping.h>
media/platform/msm/npu/npu_mgr.c:			if (prop_size > sizeof(struct msm_npu_property)) {
media/platform/msm/npu/npu_mgr.c:				prop_size = sizeof(struct msm_npu_property);
media/platform/msm/npu/npu_mgr.c:			struct msm_npu_get_info_ioctl *get_info_ioctl)
media/platform/msm/npu/npu_mgr.c:			struct msm_npu_map_buf_ioctl *map_ioctl)
media/platform/msm/npu/npu_mgr.c:			struct msm_npu_unmap_buf_ioctl *unmap_ioctl)
media/platform/msm/npu/npu_mgr.c:	struct msm_npu_patch_info_v2 *patch_info)
media/platform/msm/npu/npu_mgr.c:	struct msm_npu_property *property)
media/platform/msm/npu/npu_mgr.c:	struct msm_npu_property *property)
media/platform/msm/npu/npu_mgr.c:	struct msm_npu_property *prop_from_fw;
media/platform/msm/npu/npu_mgr.c:			struct msm_npu_load_network_ioctl_v2 *load_ioctl,
media/platform/msm/npu/npu_mgr.c:			struct msm_npu_patch_info_v2 *patch_info)
media/platform/msm/npu/npu_mgr.c:			struct msm_npu_unload_network_ioctl *unload)
media/platform/msm/npu/npu_mgr.c:	struct msm_npu_exec_network_ioctl_v2 *exec_ioctl,
media/platform/msm/npu/npu_mgr.c:	struct msm_npu_patch_buf_info *patch_buf_info)
media/platform/msm/npu/npu_mgr.c:	struct msm_npu_unload_network_ioctl unload_req;
media/platform/msm/npu/npu_mgr.c:	struct msm_npu_unmap_buf_ioctl unmap_req;
media/platform/msm/npu/npu_mgr.h:		struct msm_npu_property prop;
media/platform/msm/npu/npu_mgr.h:	struct msm_npu_property fw_caps;
media/platform/msm/npu/npu_mgr.h:	struct msm_npu_get_info_ioctl *get_info_ioctl);
media/platform/msm/npu/npu_mgr.h:	struct msm_npu_map_buf_ioctl *map_ioctl);
media/platform/msm/npu/npu_mgr.h:	struct msm_npu_unmap_buf_ioctl *unmap_ioctl);
media/platform/msm/npu/npu_mgr.h:	struct msm_npu_load_network_ioctl_v2 *load_ioctl,
media/platform/msm/npu/npu_mgr.h:	struct msm_npu_patch_info_v2 *patch_info);
media/platform/msm/npu/npu_mgr.h:	struct msm_npu_unload_network_ioctl *unload);
media/platform/msm/npu/npu_mgr.h:	struct msm_npu_exec_network_ioctl_v2 *exec_ioctl,
media/platform/msm/npu/npu_mgr.h:	struct msm_npu_patch_buf_info *patch_buf_info);
media/platform/msm/npu/npu_mgr.h:			struct msm_npu_property *property);
media/platform/msm/npu/npu_mgr.h:			struct msm_npu_property *property);
media/platform/msm/sde/rotator/sde_rotator_base.c:#include <linux/msm-bus.h>
media/platform/msm/sde/rotator/sde_rotator_base.c:#include <linux/msm-bus-board.h>
media/platform/msm/sde/rotator/sde_rotator_base.c:		ret = msm_bus_scale_client_update_request(sde_res->reg_bus_hdl,
media/platform/msm/sde/rotator/sde_rotator_base.c:static struct msm_bus_vectors mdp_reg_bus_vectors[] = {
media/platform/msm/sde/rotator/sde_rotator_base.c:static struct msm_bus_paths mdp_reg_bus_usecases[ARRAY_SIZE(
media/platform/msm/sde/rotator/sde_rotator_base.c:static struct msm_bus_scale_pdata mdp_reg_bus_scale_table = {
media/platform/msm/sde/rotator/sde_rotator_base.c:	struct msm_bus_scale_pdata *reg_bus_pdata;
media/platform/msm/sde/rotator/sde_rotator_base.c:			msm_bus_scale_register_client(reg_bus_pdata);
media/platform/msm/sde/rotator/sde_rotator_base.c:		msm_bus_scale_unregister_client(mdata->reg_bus_hdl);
media/platform/msm/sde/rotator/sde_rotator_core.c:#include <linux/msm-bus.h>
media/platform/msm/sde/rotator/sde_rotator_core.c:#include <linux/msm-bus-board.h>
media/platform/msm/sde/rotator/sde_rotator_core.c:static struct msm_bus_vectors rot_reg_bus_vectors[] = {
media/platform/msm/sde/rotator/sde_rotator_core.c:static struct msm_bus_paths rot_reg_bus_usecases[ARRAY_SIZE(
media/platform/msm/sde/rotator/sde_rotator_core.c:static struct msm_bus_scale_pdata rot_reg_bus_scale_table = {
media/platform/msm/sde/rotator/sde_rotator_core.c:		struct msm_bus_vectors *vect = NULL;
media/platform/msm/sde/rotator/sde_rotator_core.c:		struct msm_bus_scale_pdata *bw_table =
media/platform/msm/sde/rotator/sde_rotator_core.c:	ATRACE_BEGIN("msm_bus_scale_req_rot");
media/platform/msm/sde/rotator/sde_rotator_core.c:	ret = msm_bus_scale_client_update_request(bus->bus_hdl,
media/platform/msm/sde/rotator/sde_rotator_core.c:	ATRACE_END("msm_bus_scale_req_rot");
media/platform/msm/sde/rotator/sde_rotator_core.c:		ATRACE_BEGIN("msm_bus_scale_req_rot_reg");
media/platform/msm/sde/rotator/sde_rotator_core.c:		ret = msm_bus_scale_client_update_request(mgr->reg_bus.bus_hdl,
media/platform/msm/sde/rotator/sde_rotator_core.c:		ATRACE_END("msm_bus_scale_req_rot_reg");
media/platform/msm/sde/rotator/sde_rotator_core.c:			msm_bus_scale_client_update_context(
media/platform/msm/sde/rotator/sde_rotator_core.c:			msm_bus_scale_client_update_context(
media/platform/msm/sde/rotator/sde_rotator_core.c:	mgr->data_bus.bus_scale_pdata = msm_bus_cl_get_pdata(dev);
media/platform/msm/sde/rotator/sde_rotator_core.c:			SDEROT_ERR("msm_bus_cl_get_pdata failed. ret=%d\n",
media/platform/msm/sde/rotator/sde_rotator_core.c:				= msm_bus_pdata_from_node(dev, node);
media/platform/msm/sde/rotator/sde_rotator_core.c:		msm_bus_scale_unregister_client(mgr->data_bus.bus_hdl);
media/platform/msm/sde/rotator/sde_rotator_core.c:		msm_bus_scale_unregister_client(mgr->reg_bus.bus_hdl);
media/platform/msm/sde/rotator/sde_rotator_core.c:		msm_bus_scale_register_client(
media/platform/msm/sde/rotator/sde_rotator_core.c:			msm_bus_scale_register_client(
media/platform/msm/sde/rotator/sde_rotator_core.h: * @bus_hdl: msm bus scaling handle
media/platform/msm/sde/rotator/sde_rotator_core.h:	struct msm_bus_scale_pdata *bus_scale_pdata;
media/platform/msm/sde/rotator/sde_rotator_dev.c:	struct msm_sde_rotator_fence *fence = arg;
media/platform/msm/sde/rotator/sde_rotator_dev.c:	struct msm_sde_rotator_comp_ratio *comp_ratio = arg;
media/platform/msm/sde/rotator/sde_rotator_dev.c:		struct msm_sde_rotator_fence fence;
media/platform/msm/sde/rotator/sde_rotator_dev.c:				sizeof(struct msm_sde_rotator_fence)))
media/platform/msm/sde/rotator/sde_rotator_dev.c:				sizeof(struct msm_sde_rotator_fence)))
media/platform/msm/sde/rotator/sde_rotator_dev.c:		struct msm_sde_rotator_comp_ratio comp_ratio;
media/platform/msm/sde/rotator/sde_rotator_dev.c:				sizeof(struct msm_sde_rotator_comp_ratio)))
media/platform/msm/sde/rotator/sde_rotator_dev.c:				sizeof(struct msm_sde_rotator_comp_ratio)))
media/platform/msm/sde/rotator/sde_rotator_dev.h:#include <linux/msm-bus.h>
media/platform/msm/sde/rotator/sde_rotator_dev.h:#include <media/msm_sde_rotator.h>
media/platform/msm/sde/rotator/sde_rotator_formats.c:#include <media/msm_sde_rotator.h>
media/platform/msm/sde/rotator/sde_rotator_formats.h:#include <media/msm_sde_rotator.h>
media/platform/msm/sde/rotator/sde_rotator_smmu.c:#include <linux/msm_dma_iommu_mapping.h>
media/platform/msm/sde/rotator/sde_rotator_smmu.c: * msm_map_dma_buf is depricated with smmu v2 and it uses dma_map_sg instead
media/platform/msm/sde/rotator/sde_rotator_util.c:#include <linux/msm-bus.h>
media/platform/msm/sde/rotator/sde_rotator_util.c:#include <linux/msm-bus-board.h>
media/platform/msm/sde/rotator/sde_rotator_util.c:#include <media/msm_media_info.h>
media/platform/msm/vidc_3x/Kconfig:source "drivers/media/platform/msm/vidc_3x/governors/Kconfig"
media/platform/msm/vidc_3x/Makefile:obj-$(CONFIG_MSM_VIDC_3X_V4L2) := 	msm_v4l2_vidc.o \
media/platform/msm/vidc_3x/Makefile:				msm_vidc_common.o \
media/platform/msm/vidc_3x/Makefile:				msm_vidc.o \
media/platform/msm/vidc_3x/Makefile:				msm_vdec.o \
media/platform/msm/vidc_3x/Makefile:				msm_venc.o \
media/platform/msm/vidc_3x/Makefile:				msm_smem.o \
media/platform/msm/vidc_3x/Makefile:				msm_vidc_debug.o \
media/platform/msm/vidc_3x/Makefile:				msm_vidc_res_parse.o \
media/platform/msm/vidc_3x/Makefile:				msm_vidc_dcvs.o
media/platform/msm/vidc_3x/governors/Makefile:	-I$(srctree)/drivers/media/platform/msm/vidc_3x/
media/platform/msm/vidc_3x/governors/Makefile:obj-$(CONFIG_MSM_VIDC_3X_GOVERNORS) := msm_vidc_dyn_gov.o \
media/platform/msm/vidc_3x/governors/Makefile:	msm_vidc_table_gov.o
media/platform/msm/vidc_3x/governors/msm_vidc_dyn_gov.c:#include "../msm_vidc_internal.h"
media/platform/msm/vidc_3x/governors/msm_vidc_dyn_gov.c:#include "../msm_vidc_debug.h"
media/platform/msm/vidc_3x/governors/msm_vidc_dyn_gov.c:	if (msm_vidc_debug & VIDC_DBG) {
media/platform/msm/vidc_3x/governors/msm_vidc_dyn_gov.c:	if (msm_vidc_debug & VIDC_DBG) {
media/platform/msm/vidc_3x/governors/msm_vidc_dyn_gov.c:				struct msm_vidc_gov_data *vidc_data)
media/platform/msm/vidc_3x/governors/msm_vidc_dyn_gov.c:	trace_msm_vidc_perf_bus_vote(bus->name, ab_kbps);
media/platform/msm/vidc_3x/governors/msm_vidc_table_gov.c:#include "../msm_vidc_debug.h"
media/platform/msm/vidc_3x/governors/msm_vidc_table_gov.c:#include "../msm_vidc_res_parse.h"
media/platform/msm/vidc_3x/governors/msm_vidc_table_gov.c:#include "../msm_vidc_internal.h"
media/platform/msm/vidc_3x/governors/msm_vidc_table_gov.c:static int __get_bus_freq(struct msm_vidc_bus_table_gov *gov,
media/platform/msm/vidc_3x/governors/msm_vidc_table_gov.c:int msm_vidc_table_get_target_freq(struct msm_vidc_bus_table_gov *gov,
media/platform/msm/vidc_3x/governors/msm_vidc_table_gov.c:				struct msm_vidc_gov_data *vidc_data,
media/platform/msm/vidc_3x/hfi_packetization.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/hfi_packetization.c:	if (msm_vidc_fw_debug_mode
media/platform/msm/vidc_3x/hfi_packetization.c:		hfi->debug_mode = msm_vidc_fw_debug_mode;
media/platform/msm/vidc_3x/hfi_packetization.c:	trace_msm_v4l2_vidc_buffer_event_start("ETB",
media/platform/msm/vidc_3x/hfi_packetization.c:	trace_msm_v4l2_vidc_buffer_event_start("ETB",
media/platform/msm/vidc_3x/hfi_packetization.c:	trace_msm_v4l2_vidc_buffer_event_start("FTB",
media/platform/msm/vidc_3x/hfi_response_handler.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_capability *capability,
media/platform/msm/vidc_3x/hfi_response_handler.c:static enum msm_vidc_pixel_depth get_hal_pixel_depth(u32 hfi_bit_depth)
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_event event_notify = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	enum msm_vidc_pixel_depth luma_bit_depth, chroma_bit_depth;
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_event event_notify = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:static int hfi_process_sys_error(u32 device_id, struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:		*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:		*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_capability *capability)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_capability *capability;
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_capability *capability = NULL;
media/platform/msm/vidc_3x/hfi_response_handler.c:		u32 num_caps, struct msm_vidc_capability *capabilities,
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_capability *capability;
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_capability *capabilities,
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_capability *capability;
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_capability *capabilities,
media/platform/msm/vidc_3x/hfi_response_handler.c:			struct msm_vidc_capability capability;
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_data_done data_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	data_done.size = sizeof(struct msm_vidc_cb_data_done);
media/platform/msm/vidc_3x/hfi_response_handler.c:	trace_msm_v4l2_vidc_buffer_event_end("ETB",
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_data_done data_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:		data_done.size = sizeof(struct msm_vidc_cb_data_done);
media/platform/msm/vidc_3x/hfi_response_handler.c:		data_done.size = sizeof(struct msm_vidc_cb_data_done);
media/platform/msm/vidc_3x/hfi_response_handler.c:	trace_msm_v4l2_vidc_buffer_event_end("FTB",
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	cmd_done.size = sizeof(struct msm_vidc_cb_cmd_done);
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	struct msm_vidc_cb_data_done data_done = {0};
media/platform/msm/vidc_3x/hfi_response_handler.c:	data_done.size = sizeof(struct msm_vidc_cb_data_done);
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:		*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	*info = (struct msm_vidc_cb_info) {
media/platform/msm/vidc_3x/hfi_response_handler.c:		struct msm_vidc_cb_info *info)
media/platform/msm/vidc_3x/hfi_response_handler.c:	typedef int (*pkt_func_def)(u32, void *, struct msm_vidc_cb_info *info);
media/platform/msm/vidc_3x/msm_smem.c:#include <linux/msm_dma_iommu_mapping.h>
media/platform/msm/vidc_3x/msm_smem.c:#include <linux/msm_ion.h>
media/platform/msm/vidc_3x/msm_smem.c:#include "media/msm_vidc.h"
media/platform/msm/vidc_3x/msm_smem.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/msm_smem.c:#include "msm_vidc_resources.h"
media/platform/msm/vidc_3x/msm_smem.c:static int msm_dma_get_device_address(struct dma_buf *dbuf, unsigned long align,
media/platform/msm/vidc_3x/msm_smem.c:	unsigned long session_type, struct msm_vidc_platform_resources *res,
media/platform/msm/vidc_3x/msm_smem.c:		cb = msm_smem_get_context_bank(
media/platform/msm/vidc_3x/msm_smem.c:		trace_msm_smem_buffer_iommu_op_start("MAP", 0, 0,
media/platform/msm/vidc_3x/msm_smem.c:		trace_msm_smem_buffer_iommu_op_end("MAP", 0, 0,
media/platform/msm/vidc_3x/msm_smem.c:static int msm_dma_put_device_address(u32 flags,
media/platform/msm/vidc_3x/msm_smem.c:	trace_msm_smem_buffer_iommu_op_start("UNMAP", 0, 0, 0, 0, 0);
media/platform/msm/vidc_3x/msm_smem.c:	trace_msm_smem_buffer_iommu_op_end("UNMAP", 0, 0, 0, 0, 0);
media/platform/msm/vidc_3x/msm_smem.c:struct dma_buf *msm_smem_get_dma_buf(int fd)
media/platform/msm/vidc_3x/msm_smem.c:void msm_smem_put_dma_buf(void *dma_buf)
media/platform/msm/vidc_3x/msm_smem.c:bool msm_smem_compare_buffers(int fd, void *dma_buf)
media/platform/msm/vidc_3x/msm_smem.c:	dma_plane = (unsigned long)msm_smem_get_dma_buf(
media/platform/msm/vidc_3x/msm_smem.c:	msm_smem_put_dma_buf((struct dma_buf *)dma_plane);
media/platform/msm/vidc_3x/msm_smem.c:int msm_smem_map_dma_buf(struct msm_vidc_inst *inst, struct msm_smem *smem)
media/platform/msm/vidc_3x/msm_smem.c:	dbuf = msm_smem_get_dma_buf(smem->fd);
media/platform/msm/vidc_3x/msm_smem.c:	rc = msm_dma_get_device_address(dbuf, align, &iova, &buffer_size,
media/platform/msm/vidc_3x/msm_smem.c:int msm_smem_unmap_dma_buf(struct msm_vidc_inst *inst, struct msm_smem *smem)
media/platform/msm/vidc_3x/msm_smem.c:	rc = msm_dma_put_device_address(smem->flags, &smem->mapping_info,
media/platform/msm/vidc_3x/msm_smem.c:	msm_smem_put_dma_buf(smem->dma_buf);
media/platform/msm/vidc_3x/msm_smem.c:struct msm_smem *msm_smem_user_to_kernel(struct msm_vidc_inst *inst, int fd,
media/platform/msm/vidc_3x/msm_smem.c:	struct msm_smem *mem;
media/platform/msm/vidc_3x/msm_smem.c:	rc = msm_smem_map_dma_buf(inst, mem);
media/platform/msm/vidc_3x/msm_smem.c:	struct msm_vidc_platform_resources *res, u32 session_type,
media/platform/msm/vidc_3x/msm_smem.c:	struct msm_smem *mem)
media/platform/msm/vidc_3x/msm_smem.c:	trace_msm_smem_buffer_dma_op_start("ALLOC", (u32)buffer_type,
media/platform/msm/vidc_3x/msm_smem.c:	trace_msm_smem_buffer_dma_op_end("ALLOC", (u32)buffer_type,
media/platform/msm/vidc_3x/msm_smem.c:	rc = msm_dma_get_device_address(dbuf, align, &iova,
media/platform/msm/vidc_3x/msm_smem.c:static int free_dma_mem(struct msm_smem *mem)
media/platform/msm/vidc_3x/msm_smem.c:		msm_dma_put_device_address(mem->flags,
media/platform/msm/vidc_3x/msm_smem.c:		trace_msm_smem_buffer_dma_op_start("FREE",
media/platform/msm/vidc_3x/msm_smem.c:		trace_msm_smem_buffer_dma_op_end("FREE", (u32)mem->buffer_type,
media/platform/msm/vidc_3x/msm_smem.c:int msm_smem_alloc(size_t size, u32 align, u32 flags,
media/platform/msm/vidc_3x/msm_smem.c:	void *res, u32 session_type, struct msm_smem *smem)
media/platform/msm/vidc_3x/msm_smem.c:				(struct msm_vidc_platform_resources *)res,
media/platform/msm/vidc_3x/msm_smem.c:int msm_smem_free(struct msm_smem *smem)
media/platform/msm/vidc_3x/msm_smem.c:int msm_smem_cache_operations(struct dma_buf *dbuf,
media/platform/msm/vidc_3x/msm_smem.c:struct context_bank_info *msm_smem_get_context_bank(u32 session_type,
media/platform/msm/vidc_3x/msm_smem.c:	bool is_secure, struct msm_vidc_platform_resources *res,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:#include <media/msm_vidc.h>
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:#include "msm_vidc_common.h"
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:#include "msm_vidc_internal.h"
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:#include "msm_vidc_res_parse.h"
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:#include "msm_vidc_resources.h"
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:struct msm_vidc_drv *vidc_driver;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:uint32_t msm_vidc_pwr_collapse_delay = 2000;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static inline struct msm_vidc_inst *get_vidc_inst(struct file *filp, void *fh)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:					struct msm_vidc_inst, event_handler);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_v4l2_open(struct file *filp)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_video_device *vid_dev =
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		container_of(vdev, struct msm_video_device, vdev);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_core *core = video_drvdata(filp);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	trace_msm_v4l2_vidc_open_start("v4l2-vidc open start");
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	vidc_inst = msm_vidc_open(core->id, vid_dev->type);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	trace_msm_v4l2_vidc_open_end("v4l2-vidc open end");
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_v4l2_close(struct file *filp)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	trace_msm_v4l2_vidc_close_start("v4l2-vidc close start");
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	rc = msm_vidc_release_buffers(vidc_inst,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	rc = msm_vidc_close(vidc_inst);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	trace_msm_v4l2_vidc_close_end("v4l2-vidc close end");
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_v4l2_querycap(struct file *filp, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(filp, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_querycap((void *)vidc_inst, cap);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:int msm_v4l2_enum_fmt(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(file, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_enum_fmt((void *)vidc_inst, f);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:int msm_v4l2_s_fmt(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(file, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_s_fmt((void *)vidc_inst, f);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:int msm_v4l2_g_fmt(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(file, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_g_fmt((void *)vidc_inst, f);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:int msm_v4l2_s_ctrl(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(file, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_s_ctrl((void *)vidc_inst, a);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:int msm_v4l2_g_ctrl(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(file, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_g_ctrl((void *)vidc_inst, a);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:int msm_v4l2_s_ext_ctrl(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(file, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_s_ext_ctrl((void *)vidc_inst, a);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:int msm_v4l2_reqbufs(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(file, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		rc = msm_vidc_release_buffers(vidc_inst, b->type);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_reqbufs((void *)vidc_inst, b);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:int msm_v4l2_prepare_buf(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_prepare_buf(get_vidc_inst(file, fh), b);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:int msm_v4l2_qbuf(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_qbuf(get_vidc_inst(file, fh), b);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:int msm_v4l2_dqbuf(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_dqbuf(get_vidc_inst(file, fh), b);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:int msm_v4l2_streamon(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(file, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_streamon((void *)vidc_inst, i);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:int msm_v4l2_streamoff(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(file, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_streamoff((void *)vidc_inst, i);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_v4l2_subscribe_event(struct v4l2_fh *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = container_of(fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:			struct msm_vidc_inst, event_handler);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_subscribe_event((void *)vidc_inst, sub);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_v4l2_unsubscribe_event(struct v4l2_fh *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = container_of(fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:			struct msm_vidc_inst, event_handler);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_unsubscribe_event((void *)vidc_inst, sub);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_v4l2_decoder_cmd(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(file, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_comm_cmd((void *)vidc_inst, (union msm_v4l2_cmd *)dec);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_v4l2_encoder_cmd(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(file, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_comm_cmd((void *)vidc_inst, (union msm_v4l2_cmd *)enc);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_v4l2_s_parm(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(file, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_comm_s_parm(vidc_inst, a);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_v4l2_g_parm(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_v4l2_enum_framesizes(struct file *file, void *fh,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(file, fh);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_enum_framesizes((void *)vidc_inst, fsize);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static const struct v4l2_ioctl_ops msm_v4l2_ioctl_ops = {
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_querycap = msm_v4l2_querycap,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_enum_fmt_vid_cap_mplane = msm_v4l2_enum_fmt,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_enum_fmt_vid_out_mplane = msm_v4l2_enum_fmt,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_s_fmt_vid_cap_mplane = msm_v4l2_s_fmt,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_s_fmt_vid_out_mplane = msm_v4l2_s_fmt,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_g_fmt_vid_cap_mplane = msm_v4l2_g_fmt,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_g_fmt_vid_out_mplane = msm_v4l2_g_fmt,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_reqbufs = msm_v4l2_reqbufs,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_prepare_buf = msm_v4l2_prepare_buf,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_qbuf = msm_v4l2_qbuf,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_dqbuf = msm_v4l2_dqbuf,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_streamon = msm_v4l2_streamon,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_streamoff = msm_v4l2_streamoff,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_s_ctrl = msm_v4l2_s_ctrl,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_g_ctrl = msm_v4l2_g_ctrl,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_s_ext_ctrls = msm_v4l2_s_ext_ctrl,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_subscribe_event = msm_v4l2_subscribe_event,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_unsubscribe_event = msm_v4l2_unsubscribe_event,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_decoder_cmd = msm_v4l2_decoder_cmd,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_encoder_cmd = msm_v4l2_encoder_cmd,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_s_parm = msm_v4l2_s_parm,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_g_parm = msm_v4l2_g_parm,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.vidioc_enum_framesizes = msm_v4l2_enum_framesizes,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static const struct v4l2_ioctl_ops msm_v4l2_enc_ioctl_ops = {
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static unsigned int msm_v4l2_poll(struct file *filp,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_inst *vidc_inst = get_vidc_inst(filp, NULL);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return msm_vidc_poll((void *)vidc_inst, filp, pt);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static const struct v4l2_file_operations msm_v4l2_vidc_fops = {
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.open = msm_v4l2_open,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.release = msm_v4l2_close,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.poll = msm_v4l2_poll,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:void msm_vidc_release_video_device(struct video_device *pvdev)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int read_platform_resources(struct msm_vidc_core *core,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_vidc_initialize_core(struct platform_device *pdev,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:				struct msm_vidc_core *core)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_core *core = dev_get_drvdata(dev);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	msm_vidc_pwr_collapse_delay = val;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	return scnprintf(buf, PAGE_SIZE, "%u\n", msm_vidc_pwr_collapse_delay);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	msm_comm_handle_thermal_event();
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static struct attribute *msm_vidc_core_attrs[] = {
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static struct attribute_group msm_vidc_core_attr_group = {
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		.attrs = msm_vidc_core_attrs,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static const struct of_device_id msm_vidc_dt_match[] = {
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	{.compatible = "qcom,msm-vidc"},
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	{.compatible = "qcom,msm-vidc,context-bank"},
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	{.compatible = "qcom,msm-vidc,bus"},
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static u32 msm_vidc_read_efuse_version(struct platform_device *pdev,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_vidc_probe_vidc_device(struct platform_device *pdev)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	rc = msm_vidc_initialize_core(pdev, core);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	rc = sysfs_create_group(&pdev->dev.kobj, &msm_vidc_core_attr_group);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		msm_vidc_release_video_device;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	core->vdev[MSM_VIDC_DECODER].vdev.fops = &msm_v4l2_vidc_fops;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	core->vdev[MSM_VIDC_DECODER].vdev.ioctl_ops = &msm_v4l2_ioctl_ops;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		msm_vidc_release_video_device;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	core->vdev[MSM_VIDC_ENCODER].vdev.fops = &msm_v4l2_vidc_fops;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	core->vdev[MSM_VIDC_ENCODER].vdev.ioctl_ops = &msm_v4l2_ioctl_ops;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:			dprintk(VIDC_DBG, "msm_vidc: request probe defer\n");
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	core->debugfs_root = msm_vidc_debugfs_init_core(
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		msm_vidc_read_efuse_version(pdev,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		msm_vidc_read_efuse_version(
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	 * Trigger probe for each sub-device i.e. qcom,msm-vidc,context-bank.
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	 * When msm_vidc_probe is called for each sub-device, parse the
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	rc = of_platform_populate(pdev->dev.of_node, msm_vidc_dt_match, NULL,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	sysfs_remove_group(&pdev->dev.kobj, &msm_vidc_core_attr_group);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_vidc_probe_context_bank(struct platform_device *pdev)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_vidc_probe_bus(struct platform_device *pdev)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_vidc_probe(struct platform_device *pdev)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	 * the end of the probe function after msm-vidc device probe is
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	if (of_device_is_compatible(pdev->dev.of_node, "qcom,msm-vidc")) {
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		return msm_vidc_probe_vidc_device(pdev);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		"qcom,msm-vidc,bus")) {
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		return msm_vidc_probe_bus(pdev);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		"qcom,msm-vidc,context-bank")) {
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		return msm_vidc_probe_context_bank(pdev);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_vidc_remove(struct platform_device *pdev)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	msm_vidc_free_platform_resources(&core->resources);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	sysfs_remove_group(&pdev->dev.kobj, &msm_vidc_core_attr_group);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_vidc_pm_suspend(struct device *dev)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		!of_device_is_compatible(dev->of_node, "qcom,msm-vidc"))
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	rc = msm_vidc_suspend(core->id);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int msm_vidc_pm_resume(struct device *dev)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static const struct dev_pm_ops msm_vidc_pm_ops = {
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	SET_SYSTEM_SLEEP_PM_OPS(msm_vidc_pm_suspend, msm_vidc_pm_resume)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:MODULE_DEVICE_TABLE(of, msm_vidc_dt_match);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static struct platform_driver msm_vidc_driver = {
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.probe = msm_vidc_probe,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	.remove = msm_vidc_remove,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		.name = "msm_vidc_v4l2",
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		.of_match_table = msm_vidc_dt_match,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:		.pm = &msm_vidc_pm_ops,
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static int __init msm_vidc_init(void)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:			"Failed to allocate memroy for msm_vidc_drv\n");
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	vidc_driver->debugfs_root = msm_vidc_debugfs_init_drv();
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:			"Failed to create debugfs for msm_vidc\n");
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	rc = platform_driver_register(&msm_vidc_driver);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:static void __exit msm_vidc_exit(void)
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:	platform_driver_unregister(&msm_vidc_driver);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:module_init(msm_vidc_init);
media/platform/msm/vidc_3x/msm_v4l2_vidc.c:module_exit(msm_vidc_exit);
media/platform/msm/vidc_3x/msm_vdec.c:#include "msm_vidc_internal.h"
media/platform/msm/vidc_3x/msm_vdec.c:#include "msm_vidc_common.h"
media/platform/msm/vidc_3x/msm_vdec.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/msm_vdec.c:#include "msm_vidc_dcvs.h"
media/platform/msm/vidc_3x/msm_vdec.c:#define MSM_VDEC_DVC_NAME "msm_vdec_8974"
media/platform/msm/vidc_3x/msm_vdec.c:static struct msm_vidc_ctrl msm_vdec_ctrls[] = {
media/platform/msm/vidc_3x/msm_vdec.c:#define NUM_CTRLS ARRAY_SIZE(msm_vdec_ctrls)
media/platform/msm/vidc_3x/msm_vdec.c:static u32 get_frame_size(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vdec.c:					const struct msm_vidc_format *fmt,
media/platform/msm/vidc_3x/msm_vdec.c:static u32 get_output_frame_size(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vdec.c:					const struct msm_vidc_format *fmt,
media/platform/msm/vidc_3x/msm_vdec.c:static int is_ctrl_valid_for_codec(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vdec.c:struct msm_vidc_format vdec_formats[] = {
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_streamon(struct msm_vidc_inst *inst, enum v4l2_buf_type i)
media/platform/msm/vidc_3x/msm_vdec.c:	q = msm_comm_get_vb2q(inst, i);
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_streamoff(struct msm_vidc_inst *inst, enum v4l2_buf_type i)
media/platform/msm/vidc_3x/msm_vdec.c:	q = msm_comm_get_vb2q(inst, i);
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_prepare_buf(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vdec.c:		buffer_info.buffer_type = msm_comm_get_hal_output_buffer(inst);
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_release_buf(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vdec.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vdec.c:		buffer_info.buffer_type = msm_comm_get_hal_output_buffer(inst);
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_qbuf(struct msm_vidc_inst *inst, struct v4l2_buffer *b)
media/platform/msm/vidc_3x/msm_vdec.c:	q = msm_comm_get_vb2q(inst, b->type);
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_dqbuf(struct msm_vidc_inst *inst, struct v4l2_buffer *b)
media/platform/msm/vidc_3x/msm_vdec.c:	q = msm_comm_get_vb2q(inst, b->type);
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_reqbufs(struct msm_vidc_inst *inst, struct v4l2_requestbuffers *b)
media/platform/msm/vidc_3x/msm_vdec.c:	q = msm_comm_get_vb2q(inst, b->type);
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_g_fmt(struct msm_vidc_inst *inst, struct v4l2_format *f)
media/platform/msm/vidc_3x/msm_vdec.c:	const struct msm_vidc_format *fmt = NULL;
media/platform/msm/vidc_3x/msm_vdec.c:		rc = msm_vidc_check_session_supported(inst);
media/platform/msm/vidc_3x/msm_vdec.c:static int set_default_properties(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vdec.c:		rc = msm_comm_s_ctrl(inst, &ctrl);
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_s_fmt(struct msm_vidc_inst *inst, struct v4l2_format *f)
media/platform/msm/vidc_3x/msm_vdec.c:	struct msm_vidc_format *fmt = NULL;
media/platform/msm/vidc_3x/msm_vdec.c:		fmt = msm_comm_get_pixel_fmt_fourcc(vdec_formats,
media/platform/msm/vidc_3x/msm_vdec.c:						sizeof(struct msm_vidc_format));
media/platform/msm/vidc_3x/msm_vdec.c:		if (msm_comm_get_stream_output_mode(inst) ==
media/platform/msm/vidc_3x/msm_vdec.c:			msm_comm_set_color_format(inst, HAL_BUFFER_OUTPUT2,
media/platform/msm/vidc_3x/msm_vdec.c:			ret = msm_comm_try_set_prop(inst,
media/platform/msm/vidc_3x/msm_vdec.c:			msm_comm_set_color_format(inst, HAL_BUFFER_OUTPUT,
media/platform/msm/vidc_3x/msm_vdec.c:		fmt = msm_comm_get_pixel_fmt_fourcc(vdec_formats,
media/platform/msm/vidc_3x/msm_vdec.c:						sizeof(struct msm_vidc_format));
media/platform/msm/vidc_3x/msm_vdec.c:		rc = msm_comm_try_state(inst, MSM_VIDC_CORE_INIT_DONE);
media/platform/msm/vidc_3x/msm_vdec.c:		rc = msm_comm_try_state(inst, MSM_VIDC_OPEN_DONE);
media/platform/msm/vidc_3x/msm_vdec.c:		rc = msm_vidc_check_session_supported(inst);
media/platform/msm/vidc_3x/msm_vdec.c:		msm_comm_try_set_prop(inst, HAL_PARAM_FRAME_SIZE, &frame_sz);
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_querycap(struct msm_vidc_inst *inst, struct v4l2_capability *cap)
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_enum_fmt(struct msm_vidc_inst *inst, struct v4l2_fmtdesc *f)
media/platform/msm/vidc_3x/msm_vdec.c:	const struct msm_vidc_format *fmt = NULL;
media/platform/msm/vidc_3x/msm_vdec.c:		fmt = msm_comm_get_pixel_fmt_index(vdec_formats,
media/platform/msm/vidc_3x/msm_vdec.c:		fmt = msm_comm_get_pixel_fmt_index(vdec_formats,
media/platform/msm/vidc_3x/msm_vdec.c:static int set_actual_buffer_count(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vdec.c:static int msm_vdec_queue_setup(struct vb2_queue *q,
media/platform/msm/vidc_3x/msm_vdec.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vdec.c:	rc = msm_comm_try_get_bufreqs(inst);
media/platform/msm/vidc_3x/msm_vdec.c:		rc = msm_comm_try_state(inst, MSM_VIDC_OPEN_DONE);
media/platform/msm/vidc_3x/msm_vdec.c:		rc = msm_comm_try_get_bufreqs(inst);
media/platform/msm/vidc_3x/msm_vdec.c:			msm_comm_get_hal_output_buffer(inst));
media/platform/msm/vidc_3x/msm_vdec.c:			+ msm_dcvs_get_extra_buff_count(inst));
media/platform/msm/vidc_3x/msm_vdec.c:					msm_comm_get_hal_output_buffer(inst));
media/platform/msm/vidc_3x/msm_vdec.c:			rc = msm_comm_try_get_bufreqs(inst);
media/platform/msm/vidc_3x/msm_vdec.c:		if (msm_comm_get_stream_output_mode(inst) ==
media/platform/msm/vidc_3x/msm_vdec.c:static inline int set_max_internal_buffers_size(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vdec.c:	msm_comm_try_set_prop(inst, HAL_PARAM_FRAME_SIZE, &frame_sz);
media/platform/msm/vidc_3x/msm_vdec.c:	rc = msm_comm_try_get_bufreqs(inst);
media/platform/msm/vidc_3x/msm_vdec.c:	msm_comm_try_set_prop(inst, HAL_PARAM_FRAME_SIZE, &frame_sz);
media/platform/msm/vidc_3x/msm_vdec.c:	rc = msm_comm_try_get_bufreqs(inst);
media/platform/msm/vidc_3x/msm_vdec.c:static inline int start_streaming(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vdec.c:	struct msm_vidc_format *fmt = NULL;
media/platform/msm/vidc_3x/msm_vdec.c:	if (msm_comm_get_stream_output_mode(inst) ==
media/platform/msm/vidc_3x/msm_vdec.c:		rc = msm_vidc_check_scaling_supported(inst);
media/platform/msm/vidc_3x/msm_vdec.c:	rc = msm_comm_set_scratch_buffers(inst);
media/platform/msm/vidc_3x/msm_vdec.c:	rc = msm_comm_set_persist_buffers(inst);
media/platform/msm/vidc_3x/msm_vdec.c:	if (msm_comm_get_stream_output_mode(inst) ==
media/platform/msm/vidc_3x/msm_vdec.c:		rc = msm_comm_set_output_buffers(inst);
media/platform/msm/vidc_3x/msm_vdec.c:	msm_comm_scale_clocks_and_bus(inst);
media/platform/msm/vidc_3x/msm_vdec.c:	rc = msm_comm_try_state(inst, MSM_VIDC_START_DONE);
media/platform/msm/vidc_3x/msm_vdec.c:	msm_dcvs_init_load(inst);
media/platform/msm/vidc_3x/msm_vdec.c:	if (msm_comm_get_stream_output_mode(inst) ==
media/platform/msm/vidc_3x/msm_vdec.c:		rc = msm_comm_queue_output_buffers(inst);
media/platform/msm/vidc_3x/msm_vdec.c:static inline int stop_streaming(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vdec.c:	rc = msm_comm_try_state(inst, MSM_VIDC_RELEASE_RESOURCES_DONE);
media/platform/msm/vidc_3x/msm_vdec.c:static int msm_vdec_start_streaming(struct vb2_queue *q, unsigned int count)
media/platform/msm/vidc_3x/msm_vdec.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vdec.c:	rc = msm_comm_qbuf(inst, NULL);
media/platform/msm/vidc_3x/msm_vdec.c:static void msm_vdec_stop_streaming(struct vb2_queue *q)
media/platform/msm/vidc_3x/msm_vdec.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vdec.c:	msm_comm_scale_clocks_and_bus(inst);
media/platform/msm/vidc_3x/msm_vdec.c:static void msm_vdec_buf_queue(struct vb2_buffer *vb)
media/platform/msm/vidc_3x/msm_vdec.c:	int rc = msm_comm_qbuf(vb2_get_drv_priv(vb->vb2_queue), vb);
media/platform/msm/vidc_3x/msm_vdec.c:static const struct vb2_ops msm_vdec_vb2q_ops = {
media/platform/msm/vidc_3x/msm_vdec.c:	.queue_setup = msm_vdec_queue_setup,
media/platform/msm/vidc_3x/msm_vdec.c:	.start_streaming = msm_vdec_start_streaming,
media/platform/msm/vidc_3x/msm_vdec.c:	.buf_queue = msm_vdec_buf_queue,
media/platform/msm/vidc_3x/msm_vdec.c:	.stop_streaming = msm_vdec_stop_streaming,
media/platform/msm/vidc_3x/msm_vdec.c:const struct vb2_ops *msm_vdec_get_vb2q_ops(void)
media/platform/msm/vidc_3x/msm_vdec.c:	return &msm_vdec_vb2q_ops;
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_inst_init(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vdec.c:						sizeof(struct msm_vidc_format));
media/platform/msm/vidc_3x/msm_vdec.c:						sizeof(struct msm_vidc_format));
media/platform/msm/vidc_3x/msm_vdec.c:static int try_get_ctrl(struct msm_vidc_inst *inst, struct v4l2_ctrl *ctrl)
media/platform/msm/vidc_3x/msm_vdec.c:		rc = msm_comm_try_get_prop(inst,
media/platform/msm/vidc_3x/msm_vdec.c:		rc = msm_comm_try_get_prop(inst,
media/platform/msm/vidc_3x/msm_vdec.c:			rc = msm_comm_try_get_prop(inst,
media/platform/msm/vidc_3x/msm_vdec.c:static int try_set_ctrl(struct msm_vidc_inst *inst, struct v4l2_ctrl *ctrl)
media/platform/msm/vidc_3x/msm_vdec.c:		extra.index = msm_comm_get_hal_extradata_index(ctrl->val);
media/platform/msm/vidc_3x/msm_vdec.c:		msm_comm_scale_clocks_and_bus(inst);
media/platform/msm/vidc_3x/msm_vdec.c:		layout.layout_type = msm_comm_get_hal_buffer_layout(ctrl->val);
media/platform/msm/vidc_3x/msm_vdec.c:static int try_set_ext_ctrl(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vdec.c:	 old_mode = msm_comm_g_ctrl_for_id(inst, control.id);
media/platform/msm/vidc_3x/msm_vdec.c:			rc = msm_comm_s_ctrl(inst, &control);
media/platform/msm/vidc_3x/msm_vdec.c:				if (!msm_comm_g_ctrl_for_id(inst, control.id)) {
media/platform/msm/vidc_3x/msm_vdec.c:					rc = msm_comm_release_output_buffers(
media/platform/msm/vidc_3x/msm_vdec.c:					msm_comm_set_color_format(inst,
media/platform/msm/vidc_3x/msm_vdec.c:					rc = msm_comm_try_get_bufreqs(inst);
media/platform/msm/vidc_3x/msm_vdec.c:				if (msm_comm_g_ctrl_for_id(inst, control.id)) {
media/platform/msm/vidc_3x/msm_vdec.c:					rc = msm_comm_set_color_format(inst,
media/platform/msm/vidc_3x/msm_vdec.c:					rc = msm_comm_try_get_bufreqs(inst);
media/platform/msm/vidc_3x/msm_vdec.c:static int msm_vdec_op_s_ctrl(struct v4l2_ctrl *ctrl)
media/platform/msm/vidc_3x/msm_vdec.c:	struct msm_vidc_inst *inst = container_of(ctrl->handler,
media/platform/msm/vidc_3x/msm_vdec.c:				struct msm_vidc_inst, ctrl_handler);
media/platform/msm/vidc_3x/msm_vdec.c:	rc = msm_comm_try_state(inst, MSM_VIDC_OPEN_DONE);
media/platform/msm/vidc_3x/msm_vdec.c:static int msm_vdec_op_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
media/platform/msm/vidc_3x/msm_vdec.c:	struct msm_vidc_inst *inst = container_of(ctrl->handler,
media/platform/msm/vidc_3x/msm_vdec.c:				struct msm_vidc_inst, ctrl_handler);
media/platform/msm/vidc_3x/msm_vdec.c:	rc = msm_comm_try_state(inst, MSM_VIDC_OPEN_DONE);
media/platform/msm/vidc_3x/msm_vdec.c:static const struct v4l2_ctrl_ops msm_vdec_ctrl_ops = {
media/platform/msm/vidc_3x/msm_vdec.c:	.s_ctrl = msm_vdec_op_s_ctrl,
media/platform/msm/vidc_3x/msm_vdec.c:	.g_volatile_ctrl = msm_vdec_op_g_volatile_ctrl,
media/platform/msm/vidc_3x/msm_vdec.c:const struct v4l2_ctrl_ops *msm_vdec_get_ctrl_ops(void)
media/platform/msm/vidc_3x/msm_vdec.c:	return &msm_vdec_ctrl_ops;
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_s_ext_ctrl(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vdec.c:int msm_vdec_ctrl_init(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vdec.c:	return msm_comm_ctrl_init(inst, msm_vdec_ctrls,
media/platform/msm/vidc_3x/msm_vdec.c:		ARRAY_SIZE(msm_vdec_ctrls), &msm_vdec_ctrl_ops);
media/platform/msm/vidc_3x/msm_vdec.h:#include <media/msm_vidc.h>
media/platform/msm/vidc_3x/msm_vdec.h:#include "msm_vidc_internal.h"
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_inst_init(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_ctrl_init(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_querycap(void *instance, struct v4l2_capability *cap);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_enum_fmt(void *instance, struct v4l2_fmtdesc *f);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_s_fmt(void *instance, struct v4l2_format *f);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_g_fmt(void *instance, struct v4l2_format *f);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_s_ext_ctrl(void *instance, struct v4l2_ext_controls *a);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_reqbufs(void *instance, struct v4l2_requestbuffers *b);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_prepare_buf(struct msm_vidc_inst *inst, struct v4l2_buffer *b);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_release_buf(struct msm_vidc_inst *inst, struct v4l2_buffer *b);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_qbuf(struct msm_vidc_inst *inst, struct v4l2_buffer *b);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_dqbuf(struct msm_vidc_inst *inst, struct v4l2_buffer *b);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_streamon(struct msm_vidc_inst *inst, enum v4l2_buf_type i);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_streamoff(struct msm_vidc_inst *inst, enum v4l2_buf_type i);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_cmd(struct msm_vidc_inst *inst, struct v4l2_decoder_cmd *dec);
media/platform/msm/vidc_3x/msm_vdec.h:int msm_vdec_s_parm(struct msm_vidc_inst *inst, struct v4l2_streamparm *a);
media/platform/msm/vidc_3x/msm_vdec.h:struct vb2_ops *msm_vdec_get_vb2q_ops(void);
media/platform/msm/vidc_3x/msm_venc.c:#include "msm_vidc_internal.h"
media/platform/msm/vidc_3x/msm_venc.c:#include "msm_vidc_common.h"
media/platform/msm/vidc_3x/msm_venc.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/msm_venc.c:#include "msm_vidc_dcvs.h"
media/platform/msm/vidc_3x/msm_venc.c:#define MSM_VENC_DVC_NAME "msm_venc_8974"
media/platform/msm/vidc_3x/msm_venc.c:static struct msm_vidc_ctrl msm_venc_ctrls[] = {
media/platform/msm/vidc_3x/msm_venc.c:struct msm_vidc_format_constraint enc_pix_format_constraints[] = {
media/platform/msm/vidc_3x/msm_venc.c:#define NUM_CTRLS ARRAY_SIZE(msm_venc_ctrls)
media/platform/msm/vidc_3x/msm_venc.c:static struct msm_vidc_format venc_formats[] = {
media/platform/msm/vidc_3x/msm_venc.c:static void msm_venc_update_plane_count(struct msm_vidc_inst *inst, int type)
media/platform/msm/vidc_3x/msm_venc.c:static int msm_venc_set_csc(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_venc.c:static int msm_venc_queue_setup(struct vb2_queue *q,
media/platform/msm/vidc_3x/msm_venc.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_venc.c:	rc = msm_comm_try_state(inst, MSM_VIDC_OPEN_DONE);
media/platform/msm/vidc_3x/msm_venc.c:	rc = msm_comm_try_get_bufreqs(inst);
media/platform/msm/vidc_3x/msm_venc.c:				msm_dcvs_get_extra_buff_count(inst);
media/platform/msm/vidc_3x/msm_venc.c:		msm_venc_update_plane_count(inst, CAPTURE_PORT);
media/platform/msm/vidc_3x/msm_venc.c:		msm_venc_update_plane_count(inst, OUTPUT_PORT);
media/platform/msm/vidc_3x/msm_venc.c:static int msm_venc_toggle_hier_p(struct msm_vidc_inst *inst, int layers)
media/platform/msm/vidc_3x/msm_venc.c:static inline int msm_venc_power_save_mode_enable(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_venc.c:	inst_load = msm_comm_get_inst_load(inst, quirks);
media/platform/msm/vidc_3x/msm_venc.c:		msm_dcvs_enc_set_power_save_mode(inst, true);
media/platform/msm/vidc_3x/msm_venc.c:static inline int start_streaming(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_venc.c:	msm_venc_power_save_mode_enable(inst);
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_vidc_check_scaling_supported(inst);
media/platform/msm/vidc_3x/msm_venc.c:	rc = msm_comm_try_get_bufreqs(inst);
media/platform/msm/vidc_3x/msm_venc.c:	rc = msm_comm_set_scratch_buffers(inst);
media/platform/msm/vidc_3x/msm_venc.c:	rc = msm_comm_set_persist_buffers(inst);
media/platform/msm/vidc_3x/msm_venc.c:	msm_comm_scale_clocks_and_bus(inst);
media/platform/msm/vidc_3x/msm_venc.c:	rc = msm_comm_try_state(inst, MSM_VIDC_START_DONE);
media/platform/msm/vidc_3x/msm_venc.c:	msm_dcvs_init_load(inst);
media/platform/msm/vidc_3x/msm_venc.c:static int msm_venc_start_streaming(struct vb2_queue *q, unsigned int count)
media/platform/msm/vidc_3x/msm_venc.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_venc.c:	rc = msm_comm_qbuf(inst, NULL);
media/platform/msm/vidc_3x/msm_venc.c:static void msm_venc_stop_streaming(struct vb2_queue *q)
media/platform/msm/vidc_3x/msm_venc.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_comm_try_state(inst, MSM_VIDC_RELEASE_RESOURCES_DONE);
media/platform/msm/vidc_3x/msm_venc.c:	msm_comm_scale_clocks_and_bus(inst);
media/platform/msm/vidc_3x/msm_venc.c:static void msm_venc_buf_queue(struct vb2_buffer *vb)
media/platform/msm/vidc_3x/msm_venc.c:	int rc = msm_comm_qbuf(vb2_get_drv_priv(vb->vb2_queue), vb);
media/platform/msm/vidc_3x/msm_venc.c:static const struct vb2_ops msm_venc_vb2q_ops = {
media/platform/msm/vidc_3x/msm_venc.c:	.queue_setup = msm_venc_queue_setup,
media/platform/msm/vidc_3x/msm_venc.c:	.start_streaming = msm_venc_start_streaming,
media/platform/msm/vidc_3x/msm_venc.c:	.buf_queue = msm_venc_buf_queue,
media/platform/msm/vidc_3x/msm_venc.c:	.stop_streaming = msm_venc_stop_streaming,
media/platform/msm/vidc_3x/msm_venc.c:const struct vb2_ops *msm_venc_get_vb2q_ops(void)
media/platform/msm/vidc_3x/msm_venc.c:	return &msm_venc_vb2q_ops;
media/platform/msm/vidc_3x/msm_venc.c:static int msm_venc_validate_qp_value(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_venc.c:static int try_set_ctrl(struct msm_vidc_inst *inst, struct v4l2_ctrl *ctrl)
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_venc_validate_qp_value(inst, ctrl);
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_venc_validate_qp_value(inst, ctrl);
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_venc_validate_qp_value(inst, ctrl);
media/platform/msm/vidc_3x/msm_venc.c:		extra.index = msm_comm_get_hal_extradata_index(ctrl->val);
media/platform/msm/vidc_3x/msm_venc.c:				msm_dcvs_init_load(inst);
media/platform/msm/vidc_3x/msm_venc.c:		msm_comm_scale_clocks_and_bus(inst);
media/platform/msm/vidc_3x/msm_venc.c:		msm_dcvs_enc_set_power_save_mode(inst,
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_venc_validate_qp_value(inst, ctrl);
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_venc_validate_qp_value(inst, ctrl);
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_venc_validate_qp_value(inst, ctrl);
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_venc_validate_qp_value(inst, ctrl);
media/platform/msm/vidc_3x/msm_venc.c:			rc = msm_venc_set_csc(inst);
media/platform/msm/vidc_3x/msm_venc.c:static int try_set_ext_ctrl(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_venc.c:	struct msm_vidc_capability *cap = NULL;
media/platform/msm/vidc_3x/msm_venc.c:				rc = msm_venc_toggle_hier_p(inst, false);
media/platform/msm/vidc_3x/msm_venc.c:			rc = msm_comm_s_ctrl(inst, &temp_ctrl);
media/platform/msm/vidc_3x/msm_venc.c:			rc = msm_comm_s_ctrl(inst, &temp_ctrl);
media/platform/msm/vidc_3x/msm_venc.c:			rc = msm_comm_s_ctrl(inst, &temp_ctrl);
media/platform/msm/vidc_3x/msm_venc.c:static int msm_venc_op_s_ctrl(struct v4l2_ctrl *ctrl)
media/platform/msm/vidc_3x/msm_venc.c:	struct msm_vidc_inst *inst = container_of(ctrl->handler,
media/platform/msm/vidc_3x/msm_venc.c:					struct msm_vidc_inst, ctrl_handler);
media/platform/msm/vidc_3x/msm_venc.c:	rc = msm_comm_try_state(inst, MSM_VIDC_OPEN_DONE);
media/platform/msm/vidc_3x/msm_venc.c:static int msm_venc_op_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
media/platform/msm/vidc_3x/msm_venc.c:static const struct v4l2_ctrl_ops msm_venc_ctrl_ops = {
media/platform/msm/vidc_3x/msm_venc.c:	.s_ctrl = msm_venc_op_s_ctrl,
media/platform/msm/vidc_3x/msm_venc.c:	.g_volatile_ctrl = msm_venc_op_g_volatile_ctrl,
media/platform/msm/vidc_3x/msm_venc.c:const struct v4l2_ctrl_ops *msm_venc_get_ctrl_ops(void)
media/platform/msm/vidc_3x/msm_venc.c:	return &msm_venc_ctrl_ops;
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_inst_init(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_venc.c:						sizeof(struct msm_vidc_format));
media/platform/msm/vidc_3x/msm_venc.c:						sizeof(struct msm_vidc_format));
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_s_ext_ctrl(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_querycap(struct msm_vidc_inst *inst, struct v4l2_capability *cap)
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_enum_fmt(struct msm_vidc_inst *inst, struct v4l2_fmtdesc *f)
media/platform/msm/vidc_3x/msm_venc.c:	const struct msm_vidc_format *fmt = NULL;
media/platform/msm/vidc_3x/msm_venc.c:		fmt = msm_comm_get_pixel_fmt_index(venc_formats,
media/platform/msm/vidc_3x/msm_venc.c:		fmt = msm_comm_get_pixel_fmt_index(venc_formats,
media/platform/msm/vidc_3x/msm_venc.c:static int msm_venc_set_csc(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_venc.c:	rc = msm_comm_try_set_prop(inst,
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_s_fmt(struct msm_vidc_inst *inst, struct v4l2_format *f)
media/platform/msm/vidc_3x/msm_venc.c:	struct msm_vidc_format *fmt = NULL;
media/platform/msm/vidc_3x/msm_venc.c:	struct msm_vidc_format_constraint *fmt_constraint;
media/platform/msm/vidc_3x/msm_venc.c:		fmt = msm_comm_get_pixel_fmt_fourcc(venc_formats,
media/platform/msm/vidc_3x/msm_venc.c:						sizeof(struct msm_vidc_format));
media/platform/msm/vidc_3x/msm_venc.c:		msm_venc_update_plane_count(inst, CAPTURE_PORT);
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_comm_try_state(inst, MSM_VIDC_OPEN_DONE);
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_vidc_check_session_supported(inst);
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_vidc_check_session_supported(inst);
media/platform/msm/vidc_3x/msm_venc.c:		fmt = msm_comm_get_pixel_fmt_fourcc(venc_formats,
media/platform/msm/vidc_3x/msm_venc.c:						sizeof(struct msm_vidc_format));
media/platform/msm/vidc_3x/msm_venc.c:		msm_venc_update_plane_count(inst, OUTPUT_PORT);
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_comm_set_color_format(inst, HAL_BUFFER_INPUT,
media/platform/msm/vidc_3x/msm_venc.c:		fmt_constraint = msm_comm_get_pixel_fmt_constraints(
media/platform/msm/vidc_3x/msm_venc.c:			rc = msm_comm_set_color_format_constraints(inst,
media/platform/msm/vidc_3x/msm_venc.c:				msm_comm_get_hal_output_buffer(inst),
media/platform/msm/vidc_3x/msm_venc.c:		rc = msm_comm_try_get_bufreqs(inst);
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_g_fmt(struct msm_vidc_inst *inst, struct v4l2_format *f)
media/platform/msm/vidc_3x/msm_venc.c:	const struct msm_vidc_format *fmt = NULL;
media/platform/msm/vidc_3x/msm_venc.c:	rc = msm_comm_try_get_bufreqs(inst);
media/platform/msm/vidc_3x/msm_venc.c:		msm_venc_update_plane_count(inst, CAPTURE_PORT);
media/platform/msm/vidc_3x/msm_venc.c:		msm_venc_update_plane_count(inst, OUTPUT_PORT);
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_reqbufs(struct msm_vidc_inst *inst, struct v4l2_requestbuffers *b)
media/platform/msm/vidc_3x/msm_venc.c:	q = msm_comm_get_vb2q(inst, b->type);
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_prepare_buf(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_release_buf(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_venc.c:	rc = msm_comm_try_state(inst, MSM_VIDC_RELEASE_RESOURCES_DONE);
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_qbuf(struct msm_vidc_inst *inst, struct v4l2_buffer *b)
media/platform/msm/vidc_3x/msm_venc.c:	q = msm_comm_get_vb2q(inst, b->type);
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_dqbuf(struct msm_vidc_inst *inst, struct v4l2_buffer *b)
media/platform/msm/vidc_3x/msm_venc.c:	q = msm_comm_get_vb2q(inst, b->type);
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_streamon(struct msm_vidc_inst *inst, enum v4l2_buf_type i)
media/platform/msm/vidc_3x/msm_venc.c:	q = msm_comm_get_vb2q(inst, i);
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_streamoff(struct msm_vidc_inst *inst, enum v4l2_buf_type i)
media/platform/msm/vidc_3x/msm_venc.c:	q = msm_comm_get_vb2q(inst, i);
media/platform/msm/vidc_3x/msm_venc.c:int msm_venc_ctrl_init(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_venc.c:	return msm_comm_ctrl_init(inst, msm_venc_ctrls,
media/platform/msm/vidc_3x/msm_venc.c:			ARRAY_SIZE(msm_venc_ctrls), &msm_venc_ctrl_ops);
media/platform/msm/vidc_3x/msm_venc.h:#include <media/msm_vidc.h>
media/platform/msm/vidc_3x/msm_venc.h:#include "msm_vidc_internal.h"
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_inst_init(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_ctrl_init(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_querycap(void *instance, struct v4l2_capability *cap);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_enum_fmt(void *instance, struct v4l2_fmtdesc *f);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_s_fmt(void *instance, struct v4l2_format *f);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_g_fmt(void *instance, struct v4l2_format *f);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_s_ext_ctrl(void *instance, struct v4l2_ext_controls *a);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_reqbufs(void *instance, struct v4l2_requestbuffers *b);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_prepare_buf(struct msm_vidc_inst *inst, struct v4l2_buffer *b);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_release_buf(struct msm_vidc_inst *inst, struct v4l2_buffer *b);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_qbuf(struct msm_vidc_inst *inst, struct v4l2_buffer *b);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_dqbuf(struct msm_vidc_inst *inst, struct v4l2_buffer *b);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_streamon(struct msm_vidc_inst *inst, enum v4l2_buf_type i);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_streamoff(struct msm_vidc_inst *inst, enum v4l2_buf_type i);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_cmd(struct msm_vidc_inst *inst, struct v4l2_encoder_cmd *enc);
media/platform/msm/vidc_3x/msm_venc.h:int msm_venc_s_parm(struct msm_vidc_inst *inst, struct v4l2_streamparm *a);
media/platform/msm/vidc_3x/msm_venc.h:struct vb2_ops *msm_venc_get_vb2q_ops(void);
media/platform/msm/vidc_3x/msm_vidc.c:#include <media/msm_vidc.h>
media/platform/msm/vidc_3x/msm_vidc.c:#include "msm_vidc_internal.h"
media/platform/msm/vidc_3x/msm_vidc.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/msm_vidc.c:#include "msm_vdec.h"
media/platform/msm/vidc_3x/msm_vidc.c:#include "msm_venc.h"
media/platform/msm/vidc_3x/msm_vidc.c:#include "msm_vidc_common.h"
media/platform/msm/vidc_3x/msm_vidc.c:#include "msm_vidc_dcvs.h"
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_poll(void *instance, struct file *filp,
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_poll);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_querycap(void *instance, struct v4l2_capability *cap)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:		rc = msm_vdec_querycap(instance, cap);
media/platform/msm/vidc_3x/msm_vidc.c:		rc = msm_venc_querycap(instance, cap);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_querycap);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_enum_fmt(void *instance, struct v4l2_fmtdesc *f)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_vdec_enum_fmt(instance, f);
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_venc_enum_fmt(instance, f);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_enum_fmt);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_s_fmt(void *instance, struct v4l2_format *f)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_vdec_s_fmt(instance, f);
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_venc_s_fmt(instance, f);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_s_fmt);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_g_fmt(void *instance, struct v4l2_format *f)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_vdec_g_fmt(instance, f);
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_venc_g_fmt(instance, f);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_g_fmt);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_s_ctrl(void *instance, struct v4l2_control *control)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:	return msm_comm_s_ctrl(instance, control);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_s_ctrl);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_g_ctrl(void *instance, struct v4l2_control *control)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:	return msm_comm_g_ctrl(instance, control);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_g_ctrl);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_s_ext_ctrl(void *instance, struct v4l2_ext_controls *control)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_vdec_s_ext_ctrl(instance, control);
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_venc_s_ext_ctrl(instance, control);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_s_ext_ctrl);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_reqbufs(void *instance, struct v4l2_requestbuffers *b)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_vdec_reqbufs(instance, b);
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_venc_reqbufs(instance, b);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_reqbufs);
media/platform/msm/vidc_3x/msm_vidc.c:struct buffer_info *get_registered_buf(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc.c:			bool dma_matches = msm_smem_compare_buffers(fd,
media/platform/msm/vidc_3x/msm_vidc.c:static struct msm_smem *get_same_fd_buffer(struct msm_vidc_inst *inst, int fd)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_smem *same_fd_handle = NULL;
media/platform/msm/vidc_3x/msm_vidc.c:			bool dma_matches = msm_smem_compare_buffers(fd,
media/platform/msm/vidc_3x/msm_vidc.c:struct buffer_info *device_to_uvaddr(struct msm_vidc_list *buf_list,
media/platform/msm/vidc_3x/msm_vidc.c:		struct msm_vidc_inst *inst, struct v4l2_buffer *b)
media/platform/msm/vidc_3x/msm_vidc.c:				struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc.c:				struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc.c:int map_and_register_buf(struct msm_vidc_inst *inst, struct v4l2_buffer *b)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_smem *same_fd_handle = NULL;
media/platform/msm/vidc_3x/msm_vidc.c:			rc = msm_smem_map_dma_buf(inst, &binfo->smem[i]);
media/platform/msm/vidc_3x/msm_vidc.c:			rc = msm_smem_map_dma_buf(inst, &binfo->smem[i]);
media/platform/msm/vidc_3x/msm_vidc.c:int unmap_and_deregister_buf(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc.c:			if (msm_smem_unmap_dma_buf(inst, &temp->smem[i]))
media/platform/msm/vidc_3x/msm_vidc.c:			msm_comm_smem_free(inst,
media/platform/msm/vidc_3x/msm_vidc.c:int qbuf_dynamic_buf(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_vdec_qbuf(inst, &b);
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_venc_qbuf(inst, &b);
media/platform/msm/vidc_3x/msm_vidc.c:int qbuf_cache_operations(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc.c:			rc = msm_smem_cache_operations(binfo->smem[i].dma_buf,
media/platform/msm/vidc_3x/msm_vidc.c:int dqbuf_cache_operations(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc.c:			rc = msm_smem_cache_operations(
media/platform/msm/vidc_3x/msm_vidc.c:		struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_prepare_buf(void *instance, struct v4l2_buffer *b)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_vdec_prepare_buf(instance, b);
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_venc_prepare_buf(instance, b);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_prepare_buf);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_release_buffers(void *instance, int buffer_type)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:		rc = msm_comm_try_state(inst, MSM_VIDC_RELEASE_RESOURCES_DONE);
media/platform/msm/vidc_3x/msm_vidc.c:			rc = msm_vdec_release_buf(instance,
media/platform/msm/vidc_3x/msm_vidc.c:			rc = msm_venc_release_buf(instance,
media/platform/msm/vidc_3x/msm_vidc.c:					msm_comm_smem_free(inst,
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_release_buffers);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_qbuf(void *instance, struct v4l2_buffer *b)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:			msm_comm_flush_dynamic_buffers(inst);
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_vdec_qbuf(instance, b);
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_venc_qbuf(instance, b);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_qbuf);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_dqbuf(void *instance, struct v4l2_buffer *b)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:		rc = msm_vdec_dqbuf(instance, b);
media/platform/msm/vidc_3x/msm_vidc.c:		rc = msm_venc_dqbuf(instance, b);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_dqbuf);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_streamon(void *instance, enum v4l2_buf_type i)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_vdec_streamon(instance, i);
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_venc_streamon(instance, i);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_streamon);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_streamoff(void *instance, enum v4l2_buf_type i)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_vdec_streamoff(instance, i);
media/platform/msm/vidc_3x/msm_vidc.c:		return msm_venc_streamoff(instance, i);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_streamoff);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_enum_framesizes(void *instance, struct v4l2_frmsizeenum *fsize)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_capability *capability = NULL;
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_enum_framesizes);
media/platform/msm/vidc_3x/msm_vidc.c:static const struct vb2_mem_ops msm_vidc_vb2_mem_ops = {
media/platform/msm/vidc_3x/msm_vidc.c:static inline int vb2_bufq_init(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc.c:		q->ops = msm_vdec_get_vb2q_ops();
media/platform/msm/vidc_3x/msm_vidc.c:		q->ops = msm_venc_get_vb2q_ops();
media/platform/msm/vidc_3x/msm_vidc.c:	q->mem_ops = &msm_vidc_vb2_mem_ops;
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *vidc_inst = (struct msm_vidc_inst *)inst;
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_subscribe_event(void *inst,
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *vidc_inst = (struct msm_vidc_inst *)inst;
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_subscribe_event);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_unsubscribe_event(void *inst,
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *vidc_inst = (struct msm_vidc_inst *)inst;
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_unsubscribe_event);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_dqevent(void *inst, struct v4l2_event *event)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *vidc_inst = (struct msm_vidc_inst *)inst;
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_dqevent);
media/platform/msm/vidc_3x/msm_vidc.c:static bool msm_vidc_check_for_inst_overload(struct msm_vidc_core *core)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = NULL;
media/platform/msm/vidc_3x/msm_vidc.c:void *msm_vidc_open(int core_id, int session_type)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = NULL;
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_core *core = NULL;
media/platform/msm/vidc_3x/msm_vidc.c:		msm_vdec_inst_init(inst);
media/platform/msm/vidc_3x/msm_vidc.c:		rc = msm_vdec_ctrl_init(inst);
media/platform/msm/vidc_3x/msm_vidc.c:		msm_venc_inst_init(inst);
media/platform/msm/vidc_3x/msm_vidc.c:		rc = msm_venc_ctrl_init(inst);
media/platform/msm/vidc_3x/msm_vidc.c:	msm_dcvs_init(inst);
media/platform/msm/vidc_3x/msm_vidc.c:	rc = msm_comm_try_state(inst, MSM_VIDC_CORE_INIT_DONE);
media/platform/msm/vidc_3x/msm_vidc.c:	if (msm_vidc_check_for_inst_overload(core)) {
media/platform/msm/vidc_3x/msm_vidc.c:		msm_vidc_debugfs_init_inst(inst, core->debugfs_root);
media/platform/msm/vidc_3x/msm_vidc.c:	msm_comm_ctrl_deinit(inst);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_open);
media/platform/msm/vidc_3x/msm_vidc.c:static void cleanup_instance(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc.c:		if (msm_comm_release_scratch_buffers(inst, false)) {
media/platform/msm/vidc_3x/msm_vidc.c:		if (msm_comm_release_persist_buffers(inst)) {
media/platform/msm/vidc_3x/msm_vidc.c:		msm_comm_release_eos_buffers(inst);
media/platform/msm/vidc_3x/msm_vidc.c:		if (msm_comm_release_output_buffers(inst)) {
media/platform/msm/vidc_3x/msm_vidc.c:			msm_comm_smem_free(inst, inst->extradata_handle);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_destroy(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc.c:	msm_comm_ctrl_deinit(inst);
media/platform/msm/vidc_3x/msm_vidc.c:	msm_vidc_debugfs_deinit_inst(inst);
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = container_of(kref,
media/platform/msm/vidc_3x/msm_vidc.c:				struct msm_vidc_inst, kref);
media/platform/msm/vidc_3x/msm_vidc.c:	msm_vidc_destroy(inst);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_close(void *instance)
media/platform/msm/vidc_3x/msm_vidc.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc.c:					msm_comm_smem_free(inst, &bi->smem[i]);
media/platform/msm/vidc_3x/msm_vidc.c:		rc = msm_comm_try_state(inst, MSM_VIDC_CORE_UNINIT);
media/platform/msm/vidc_3x/msm_vidc.c:		rc = msm_comm_force_cleanup(inst);
media/platform/msm/vidc_3x/msm_vidc.c:	msm_comm_session_clean(inst);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_close);
media/platform/msm/vidc_3x/msm_vidc.c:int msm_vidc_suspend(int core_id)
media/platform/msm/vidc_3x/msm_vidc.c:	return msm_comm_suspend(core_id);
media/platform/msm/vidc_3x/msm_vidc.c:EXPORT_SYMBOL(msm_vidc_suspend);
media/platform/msm/vidc_3x/msm_vidc_common.c:#include "msm_vidc_common.h"
media/platform/msm/vidc_3x/msm_vidc_common.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/msm_vidc_common.c:#include "msm_vidc_dcvs.h"
media/platform/msm/vidc_3x/msm_vidc_common.c:static void msm_comm_generate_session_error(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:static void msm_comm_generate_sys_error(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:bool msm_comm_turbo_session(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:static inline bool is_thumbnail_session(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:static inline bool is_low_power_session(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_g_ctrl(struct msm_vidc_inst *inst, struct v4l2_control *ctrl)
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_s_ctrl(struct msm_vidc_inst *inst, struct v4l2_control *ctrl)
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_g_ctrl_for_id(struct msm_vidc_inst *inst, int id)
media/platform/msm/vidc_3x/msm_vidc_common.c:	rc = msm_comm_g_ctrl(inst, &ctrl);
media/platform/msm/vidc_3x/msm_vidc_common.c:static struct v4l2_ctrl **get_super_cluster(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_ctrl_init(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:		struct msm_vidc_ctrl *drv_ctrls, u32 num_ctrls,
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_ctrl_deinit(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:static inline bool is_realtime_session(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:enum multi_stream msm_comm_get_stream_output_mode(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	switch (msm_comm_g_ctrl_for_id(inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_comm_get_mbs_per_frame(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_comm_get_mbs_per_sec(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	mb_per_frame = msm_comm_get_mbs_per_frame(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_get_inst_load(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:	load = msm_comm_get_mbs_per_sec(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:	if (msm_comm_turbo_session(inst)) {
media/platform/msm/vidc_3x/msm_vidc_common.c:			load = msm_comm_get_mbs_per_sec(inst) / inst->prop.fps;
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_get_load(struct msm_vidc_core *core,
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst = NULL;
media/platform/msm/vidc_3x/msm_vidc_common.c:		num_mbs_per_sec += msm_comm_get_inst_load(inst, quirks);
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_comm_vote_bus(struct msm_vidc_core *core)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst = NULL;
media/platform/msm/vidc_3x/msm_vidc_common.c:		if (msm_comm_turbo_session(inst))
media/platform/msm/vidc_3x/msm_vidc_common.c:struct msm_vidc_core *get_vidc_core(int core_id)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:const struct msm_vidc_format *msm_comm_get_pixel_fmt_index(
media/platform/msm/vidc_3x/msm_vidc_common.c:	const struct msm_vidc_format fmt[], int size, int index, int fmt_type)
media/platform/msm/vidc_3x/msm_vidc_common.c:struct msm_vidc_format *msm_comm_get_pixel_fmt_fourcc(
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_format fmt[], int size, int fourcc, int fmt_type)
media/platform/msm/vidc_3x/msm_vidc_common.c:struct msm_vidc_format_constraint *msm_comm_get_pixel_fmt_constraints(
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_format_constraint fmt[], int size, int fourcc)
media/platform/msm/vidc_3x/msm_vidc_common.c:u32 msm_comm_convert_color_fmt(u32 v4l2_fmt)
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_set_color_format_constraints(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:		struct msm_vidc_format_constraint *pix_constraint)
media/platform/msm/vidc_3x/msm_vidc_common.c:	hfi_fmt = msm_comm_convert_color_fmt(pix_constraint->fourcc);
media/platform/msm/vidc_3x/msm_vidc_common.c:struct buf_queue *msm_comm_get_vb2q(
media/platform/msm/vidc_3x/msm_vidc_common.c:		struct msm_vidc_inst *inst, enum v4l2_buf_type type)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:		sys_init_msg->codec_count * sizeof(struct msm_vidc_capability));
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst = container_of(kref,
media/platform/msm/vidc_3x/msm_vidc_common.c:				struct msm_vidc_inst, kref);
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_vidc_destroy(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:void put_inst(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:struct msm_vidc_inst *get_inst(struct msm_vidc_core *core,
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst = NULL;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:static void change_inst_state(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:		struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:static int wait_for_sess_signal_receipt(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:		msecs_to_jiffies(msm_vidc_hw_rsp_timeout));
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_kill_session(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		WARN_ON(msm_vidc_debug_timeout);
media/platform/msm/vidc_3x/msm_vidc_common.c:static int wait_for_state(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:void msm_vidc_queue_v4l2_event(struct msm_vidc_inst *inst, int event_type)
media/platform/msm/vidc_3x/msm_vidc_common.c:static void msm_comm_generate_max_clients_error(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done response = {0};
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst = NULL;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_capability *capability = NULL;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:			msm_comm_generate_max_clients_error(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:			msm_comm_generate_session_error(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:			sizeof(struct msm_vidc_capability));
media/platform/msm/vidc_3x/msm_vidc_common.c:			sizeof(struct msm_vidc_capability));
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst = NULL;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_event *event_notify = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_comm_g_ctrl_for_id(inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:			if (msm_comm_get_stream_output_mode(inst) ==
media/platform/msm/vidc_3x/msm_vidc_common.c:				rc = msm_comm_try_set_prop(inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_dcvs_init_load(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:	rc = msm_vidc_check_session_supported(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_vidc_queue_v4l2_event(inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_vidc_queue_v4l2_event(inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_generate_session_error(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_common.c:void validate_output_buffers(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_queue_output_buffers(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_common.c:	if (msm_comm_get_stream_output_mode(inst) ==
media/platform/msm/vidc_3x/msm_vidc_common.c:			rc = msm_comm_queue_output_buffers(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst = NULL;
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_session_clean(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_vidc_queue_v4l2_event(inst, event);
media/platform/msm/vidc_3x/msm_vidc_common.c:static void msm_comm_clean_notify_client(struct msm_vidc_core *core)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst = NULL;
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_vidc_queue_v4l2_event(inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core = NULL;
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_comm_clean_notify_client(core);
media/platform/msm/vidc_3x/msm_vidc_common.c:void msm_comm_session_clean(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_common.c:static bool is_eos_buffer(struct msm_vidc_inst *inst, u32 device_addr)
media/platform/msm/vidc_3x/msm_vidc_common.c:			msm_comm_smem_free(inst, &temp->smem);
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_data_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_vidc_debugfs_update(inst, MSM_VIDC_DEBUGFS_EVENT_EBD);
media/platform/msm/vidc_3x/msm_vidc_common.c:int buf_ref_get(struct msm_vidc_inst *inst, struct buffer_info *binfo)
media/platform/msm/vidc_3x/msm_vidc_common.c:int buf_ref_put(struct msm_vidc_inst *inst, struct buffer_info *binfo)
media/platform/msm/vidc_3x/msm_vidc_common.c:static void handle_dynamic_buffer(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:static int handle_multi_stream_buffers(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_smem *smem;
media/platform/msm/vidc_3x/msm_vidc_common.c:enum hal_buffer msm_comm_get_hal_output_buffer(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	if (msm_comm_get_stream_output_mode(inst) ==
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_data_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_common.c:	buffer_type = msm_comm_get_hal_output_buffer(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_vidc_debugfs_update(inst, MSM_VIDC_DEBUGFS_EVENT_FBD);
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_data_done *response = data;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_scale_clocks(struct msm_vidc_core *core)
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_get_load(core, MSM_VIDC_ENCODER, LOAD_CALC_NO_QUIRKS) +
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_get_load(core, MSM_VIDC_DECODER, LOAD_CALC_NO_QUIRKS);
media/platform/msm/vidc_3x/msm_vidc_common.c:	return msm_comm_scale_clocks_load(core, num_mbs_per_sec,
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_scale_clocks_load(struct msm_vidc_core *core,
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst = NULL;
media/platform/msm/vidc_3x/msm_vidc_common.c:		if (msm_comm_turbo_session(inst))
media/platform/msm/vidc_3x/msm_vidc_common.c:				msm_comm_get_inst_load(inst, quirks);
media/platform/msm/vidc_3x/msm_vidc_common.c:void msm_comm_scale_clocks_and_bus(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:	if (msm_comm_scale_clocks(core)) {
media/platform/msm/vidc_3x/msm_vidc_common.c:	if (msm_comm_vote_bus(core)) {
media/platform/msm/vidc_3x/msm_vidc_common.c:static inline enum msm_vidc_thermal_level msm_comm_vidc_thermal_level(int level)
media/platform/msm/vidc_3x/msm_vidc_common.c:static unsigned long msm_comm_get_clock_rate(struct msm_vidc_core *core)
media/platform/msm/vidc_3x/msm_vidc_common.c:static bool is_core_turbo(struct msm_vidc_core *core, unsigned long freq)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_platform_resources *res = &core->resources;
media/platform/msm/vidc_3x/msm_vidc_common.c:static bool is_thermal_permissible(struct msm_vidc_core *core)
media/platform/msm/vidc_3x/msm_vidc_common.c:	enum msm_vidc_thermal_level tl;
media/platform/msm/vidc_3x/msm_vidc_common.c:	if (!msm_vidc_thermal_mitigation_disabled) {
media/platform/msm/vidc_3x/msm_vidc_common.c:			msm_vidc_thermal_mitigation_disabled);
media/platform/msm/vidc_3x/msm_vidc_common.c:	tl = msm_comm_vidc_thermal_level(vidc_driver->thermal_level);
media/platform/msm/vidc_3x/msm_vidc_common.c:	freq = msm_comm_get_clock_rate(core);
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_comm_session_abort(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:			msecs_to_jiffies(msm_vidc_hw_rsp_timeout));
media/platform/msm/vidc_3x/msm_vidc_common.c:		WARN_ON(msm_vidc_debug_timeout);
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_comm_session_clean(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:static void handle_thermal_event(struct msm_vidc_core *core)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_common.c:			rc = msm_comm_session_abort(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:			msm_vidc_queue_v4l2_event(inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:			msm_comm_generate_session_error(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_comm_clean_notify_client(core);
media/platform/msm/vidc_3x/msm_vidc_common.c:void msm_comm_handle_thermal_event(void)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_check_core_init(struct msm_vidc_core *core)
media/platform/msm/vidc_3x/msm_vidc_common.c:		msecs_to_jiffies(msm_vidc_hw_rsp_timeout));
media/platform/msm/vidc_3x/msm_vidc_common.c:		WARN_ON(msm_vidc_debug_timeout);
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_comm_init_core_done(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	rc = msm_comm_check_core_init(inst->core);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_generate_sys_error(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_comm_init_core(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:				sizeof(struct msm_vidc_capability), GFP_KERNEL);
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_vidc_deinit_core(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_comm_scale_clocks_and_bus(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_force_cleanup(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_comm_kill_session(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:	return msm_vidc_deinit_core(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_comm_session_init(int flipped_state,
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:static void msm_vidc_print_running_insts(struct msm_vidc_core *core)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *temp;
media/platform/msm/vidc_3x/msm_vidc_common.c:			if (msm_comm_turbo_session(temp))
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_vidc_load_resources(int flipped_state,
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_get_load(core, MSM_VIDC_DECODER, quirks) +
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_get_load(core, MSM_VIDC_ENCODER, quirks);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_vidc_print_running_insts(core);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_kill_session(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_vidc_start(int flipped_state, struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_vidc_stop(int flipped_state, struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_vidc_release_res(int flipped_state, struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_comm_session_close(int flipped_state,
media/platform/msm/vidc_3x/msm_vidc_common.c:			struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_suspend(int core_id)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:		struct msm_vidc_inst *inst, enum hal_buffer buffer_type)
media/platform/msm/vidc_3x/msm_vidc_common.c:static int set_output_buffers(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:			rc = msm_comm_smem_alloc(inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_comm_smem_free(inst, &binfo->smem);
media/platform/msm/vidc_3x/msm_vidc_common.c:static int set_internal_buf_on_fw(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:				struct msm_smem *handle, bool reuse)
media/platform/msm/vidc_3x/msm_vidc_common.c:	rc = msm_comm_smem_cache_operations(inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:static bool reuse_internal_buffers(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:		enum hal_buffer buffer_type, struct msm_vidc_list *buf_list)
media/platform/msm/vidc_3x/msm_vidc_common.c:static int allocate_and_set_internal_bufs(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:			struct msm_vidc_list *buf_list)
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_comm_smem_alloc(inst, internal_bufreq->buffer_size,
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_comm_smem_free(inst, &binfo->smem);
media/platform/msm/vidc_3x/msm_vidc_common.c:static int set_internal_buffers(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:	enum hal_buffer buffer_type, struct msm_vidc_list *buf_list)
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_try_state(struct msm_vidc_inst *inst, int state)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_comm_init_core(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_comm_init_core_done(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_comm_session_init(flipped_state, inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_vidc_load_resources(flipped_state, inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_vidc_start(flipped_state, inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_vidc_stop(flipped_state, inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_vidc_release_res(flipped_state, inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_comm_session_close(flipped_state, inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_session_clean(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_vidc_deinit_core(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		trace_msm_vidc_common_state_change((void *)inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_vidc_comm_cmd(void *instance, union msm_v4l2_cmd *cmd)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_inst *inst = instance;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:			rc = msm_comm_kill_session(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_comm_flush(inst, flags);
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_comm_try_get_bufreqs(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:				msm_comm_get_hal_output_buffer(inst));
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_comm_smem_alloc(inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:		const struct vb2_buffer *vb, struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:		bool pic_decoding_mode = msm_comm_g_ctrl_for_id(inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:		data->buffer_type = msm_comm_get_hal_output_buffer(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:static unsigned int count_single_batch(struct msm_vidc_list *list,
media/platform/msm/vidc_3x/msm_vidc_common.c:static unsigned int count_buffers(struct msm_vidc_list *list,
media/platform/msm/vidc_3x/msm_vidc_common.c:static void log_frame(struct msm_vidc_inst *inst, struct vidc_frame_data *data,
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_vidc_debugfs_update(inst, MSM_VIDC_DEBUGFS_EVENT_ETB);
media/platform/msm/vidc_3x/msm_vidc_common.c:		if (msm_vidc_bitrate_clock_scaling &&
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_vidc_debugfs_update(inst, MSM_VIDC_DEBUGFS_EVENT_FTB);
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_dcvs_check_and_scale_clocks(inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:	if (msm_vidc_bitrate_clock_scaling && !inst->dcvs_mode &&
media/platform/msm/vidc_3x/msm_vidc_common.c:		if (msm_comm_scale_clocks(inst->core))
media/platform/msm/vidc_3x/msm_vidc_common.c:static int request_seq_header(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_qbuf(struct msm_vidc_inst *inst, struct vb2_buffer *vb)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:	batch_mode = msm_comm_g_ctrl_for_id(inst, V4L2_CID_VIDC_QBUF_MODE)
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_try_get_bufreqs(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	rc = msm_comm_try_get_prop(inst, HAL_PARAM_GET_BUFFER_REQUIREMENTS,
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_try_get_prop(struct msm_vidc_inst *inst, enum hal_property ptype,
media/platform/msm/vidc_3x/msm_vidc_common.c:		msecs_to_jiffies(msm_vidc_hw_rsp_timeout));
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_kill_session(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		WARN_ON(msm_vidc_debug_timeout);
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_release_output_buffers(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_smem *handle;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_smem_free(inst, &buf->smem);
media/platform/msm/vidc_3x/msm_vidc_common.c:static enum hal_buffer scratch_buf_sufficient(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_release_scratch_buffers(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_smem *handle;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:				msm_comm_kill_session(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_smem_free(inst, handle);
media/platform/msm/vidc_3x/msm_vidc_common.c:void msm_comm_release_eos_buffers(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_smem_free(inst, &buf->smem);
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_release_persist_buffers(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_smem *handle;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:				msm_comm_kill_session(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_smem_free(inst, handle);
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_try_set_prop(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_set_output_buffers(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	if (msm_comm_release_output_buffers(inst))
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_comm_release_output_buffers(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_set_scratch_buffers(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	if (msm_comm_release_scratch_buffers(inst, true))
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_comm_release_scratch_buffers(inst, false);
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_set_persist_buffers(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_comm_release_persist_buffers(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:static void msm_comm_flush_in_invalid_state(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_vidc_queue_v4l2_event(inst, V4L2_EVENT_MSM_VIDC_FLUSH_DONE);
media/platform/msm/vidc_3x/msm_vidc_common.c:void msm_comm_flush_dynamic_buffers(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:void msm_comm_flush_pending_dynamic_buffers(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_flush(struct msm_vidc_inst *inst, u32 flags)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_comm_flush_dynamic_buffers(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_flush_in_invalid_state(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_flush_pending_dynamic_buffers(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:			msm_vidc_debugfs_update(inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:enum hal_extradata_id msm_comm_get_hal_extradata_index(
media/platform/msm/vidc_3x/msm_vidc_common.c:enum hal_buffer_layout_type msm_comm_get_hal_buffer_layout(
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_vidc_trigger_ssr(struct msm_vidc_core *core,
media/platform/msm/vidc_3x/msm_vidc_common.c:static int msm_vidc_load_supported(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:		num_mbs_per_sec = msm_comm_get_load(inst->core,
media/platform/msm/vidc_3x/msm_vidc_common.c:		num_mbs_per_sec += msm_comm_get_load(inst->core,
media/platform/msm/vidc_3x/msm_vidc_common.c:			msm_vidc_print_running_insts(inst->core);
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_vidc_check_scaling_supported(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_vidc_check_session_supported(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_capability *capability;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:	rc = msm_vidc_load_supported(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_kill_session(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		mbs_per_frame = msm_comm_get_mbs_per_frame(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_kill_session(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:static void msm_comm_generate_session_error(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done response = {0};
media/platform/msm/vidc_3x/msm_vidc_common.c:static void msm_comm_generate_sys_error(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_common.c:	struct msm_vidc_cb_cmd_done response  = {0};
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_kill_session(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_common.c:		rc = msm_comm_session_abort(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:			msm_comm_generate_sys_error(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_generate_session_error(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_generate_session_error(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_smem_alloc(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:		int map_kernel, struct msm_smem *smem)
media/platform/msm/vidc_3x/msm_vidc_common.c:	rc = msm_smem_alloc(size, align, flags, buffer_type, map_kernel,
media/platform/msm/vidc_3x/msm_vidc_common.c:void msm_comm_smem_free(struct msm_vidc_inst *inst, struct msm_smem *mem)
media/platform/msm/vidc_3x/msm_vidc_common.c:	msm_smem_free(mem);
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_smem_cache_operations(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:		struct msm_smem *mem, enum smem_cache_ops cache_ops)
media/platform/msm/vidc_3x/msm_vidc_common.c:	return msm_smem_cache_operations(mem->dma_buf, mem->offset,
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_comm_set_color_format(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.c:int msm_vidc_comm_s_parm(struct msm_vidc_inst *inst, struct v4l2_streamparm *a)
media/platform/msm/vidc_3x/msm_vidc_common.c:			msm_dcvs_init_load(inst);
media/platform/msm/vidc_3x/msm_vidc_common.c:		msm_comm_scale_clocks_and_bus(inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:#include "msm_vidc_internal.h"
media/platform/msm/vidc_3x/msm_vidc_common.h:struct msm_vidc_core *get_vidc_core(int core_id);
media/platform/msm/vidc_3x/msm_vidc_common.h:const struct msm_vidc_format *msm_comm_get_pixel_fmt_index(
media/platform/msm/vidc_3x/msm_vidc_common.h:	const struct msm_vidc_format fmt[], int size, int index, int fmt_type);
media/platform/msm/vidc_3x/msm_vidc_common.h:struct msm_vidc_format *msm_comm_get_pixel_fmt_fourcc(
media/platform/msm/vidc_3x/msm_vidc_common.h:	struct msm_vidc_format fmt[], int size, int fourcc, int fmt_type);
media/platform/msm/vidc_3x/msm_vidc_common.h:struct msm_vidc_format_constraint *msm_comm_get_pixel_fmt_constraints(
media/platform/msm/vidc_3x/msm_vidc_common.h:	struct msm_vidc_format_constraint fmt[], int size, int fourcc);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_set_color_format_constraints(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.h:		struct msm_vidc_format_constraint *pix_constraint);
media/platform/msm/vidc_3x/msm_vidc_common.h:struct buf_queue *msm_comm_get_vb2q(
media/platform/msm/vidc_3x/msm_vidc_common.h:		struct msm_vidc_inst *inst, enum v4l2_buf_type type);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_try_state(struct msm_vidc_inst *inst, int state);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_try_get_bufreqs(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_try_set_prop(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_try_get_prop(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_set_scratch_buffers(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_set_persist_buffers(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_set_output_buffers(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_queue_output_buffers(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_qbuf(struct msm_vidc_inst *inst, struct vb2_buffer *vb);
media/platform/msm/vidc_3x/msm_vidc_common.h:void msm_comm_scale_clocks_and_bus(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_scale_clocks(struct msm_vidc_core *core);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_scale_clocks_load(struct msm_vidc_core *core,
media/platform/msm/vidc_3x/msm_vidc_common.h:void msm_comm_flush_dynamic_buffers(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_flush(struct msm_vidc_inst *inst, u32 flags);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_release_scratch_buffers(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_release_persist_buffers(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:void msm_comm_release_eos_buffers(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_release_output_buffers(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_force_cleanup(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_suspend(int core_id);
media/platform/msm/vidc_3x/msm_vidc_common.h:enum hal_extradata_id msm_comm_get_hal_extradata_index(
media/platform/msm/vidc_3x/msm_vidc_common.h:enum hal_buffer_layout_type msm_comm_get_hal_buffer_layout(
media/platform/msm/vidc_3x/msm_vidc_common.h:			struct msm_vidc_inst *inst, u32 buffer_type);
media/platform/msm/vidc_3x/msm_vidc_common.h:void msm_comm_session_clean(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_kill_session(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:enum multi_stream msm_comm_get_stream_output_mode(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:enum hal_buffer msm_comm_get_hal_output_buffer(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_smem_alloc(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.h:			struct msm_smem *smem);
media/platform/msm/vidc_3x/msm_vidc_common.h:void msm_comm_smem_free(struct msm_vidc_inst *inst, struct msm_smem *mem);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_smem_cache_operations(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.h:		struct msm_smem *mem, enum smem_cache_ops cache_ops);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_check_core_init(struct msm_vidc_core *core);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_get_inst_load(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_get_load(struct msm_vidc_core *core,
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_set_color_format(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_g_ctrl(struct msm_vidc_inst *inst, struct v4l2_control *ctrl);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_s_ctrl(struct msm_vidc_inst *inst, struct v4l2_control *ctrl);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_g_ctrl_for_id(struct msm_vidc_inst *inst, int id);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_ctrl_init(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_common.h:		struct msm_vidc_ctrl *drv_ctrls, u32 num_ctrls,
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_comm_ctrl_deinit(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:void msm_comm_cleanup_internal_buffers(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:int msm_vidc_comm_s_parm(struct msm_vidc_inst *inst, struct v4l2_streamparm *a);
media/platform/msm/vidc_3x/msm_vidc_common.h:bool msm_comm_turbo_session(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_common.h:struct msm_vidc_inst *get_inst(struct msm_vidc_core *core, void *session_id);
media/platform/msm/vidc_3x/msm_vidc_common.h:void put_inst(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:#include "msm_vidc_common.h"
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:#include "msm_vidc_dcvs.h"
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static bool msm_dcvs_check_supported(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static bool msm_dcvs_enc_check(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static int msm_dcvs_enc_scale_clocks(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static int msm_dcvs_dec_scale_clocks(struct msm_vidc_inst *inst, bool fbd);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static inline int msm_dcvs_get_mbs_per_frame(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static inline int msm_dcvs_count_active_instances(struct msm_vidc_core *core)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	struct msm_vidc_inst *inst = NULL;
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static bool msm_dcvs_check_codec_supported(int fourcc,
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static void msm_dcvs_update_dcvs_params(int idx, struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	struct msm_vidc_platform_resources *res = NULL;
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static void msm_dcvs_enc_check_and_scale_clocks(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	if (inst->session_type == MSM_VIDC_ENCODER && msm_vidc_enc_dcvs_mode) {
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		inst->dcvs_mode = msm_dcvs_check_supported(inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:			rc = msm_dcvs_enc_scale_clocks(inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static void msm_dcvs_dec_check_and_scale_clocks(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	if (inst->session_type != MSM_VIDC_DECODER || !msm_vidc_dec_dcvs_mode)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	if (msm_dcvs_check_supported(inst)) {
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	if (msm_vidc_dec_dcvs_mode && inst->dcvs_mode) {
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		msm_dcvs_monitor_buffer(inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		rc = msm_dcvs_dec_scale_clocks(inst, false);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:void msm_dcvs_check_and_scale_clocks(struct msm_vidc_inst *inst, bool is_etb)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		msm_dcvs_enc_check_and_scale_clocks(inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		msm_dcvs_dec_check_and_scale_clocks(inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static inline int get_pending_bufs_fw(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static inline void msm_dcvs_print_dcvs_stats(struct dcvs_stats *dcvs)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:void msm_dcvs_init_load(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	struct msm_vidc_platform_resources *res = NULL;
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	dcvs->load = msm_comm_get_inst_load(inst, LOAD_CALC_NO_QUIRKS);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		bool matches = msm_dcvs_check_codec_supported(
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:			msm_dcvs_update_dcvs_params(i, inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		msm_comm_get_hal_output_buffer(inst));
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:			msm_dcvs_get_extra_buff_count(inst) + 1;
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	msm_dcvs_print_dcvs_stats(dcvs);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:void msm_dcvs_init(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:void msm_dcvs_monitor_buffer(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:				msm_comm_get_hal_output_buffer(inst));
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static int msm_dcvs_enc_scale_clocks(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		rc = msm_comm_scale_clocks_load(core, dcvs->load,
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static int msm_dcvs_dec_scale_clocks(struct msm_vidc_inst *inst, bool fbd)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		msm_comm_get_hal_output_buffer(inst));
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		rc = msm_comm_scale_clocks_load(core, dcvs->load,
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static bool msm_dcvs_enc_check(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	struct msm_vidc_platform_resources *res = NULL;
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		msm_dcvs_check_codec_supported(
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	num_mbs_per_frame = msm_dcvs_get_mbs_per_frame(inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	instance_load = msm_comm_get_inst_load(inst, LOAD_CALC_NO_QUIRKS);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	if (msm_vidc_enc_dcvs_mode && is_codec_supported &&
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:static bool msm_dcvs_check_supported(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	struct msm_vidc_inst *temp = NULL;
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	struct msm_vidc_platform_resources *res = NULL;
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:	instance_count = msm_dcvs_count_active_instances(core);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		!msm_comm_turbo_session(inst)) {
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		num_mbs_per_frame = msm_dcvs_get_mbs_per_frame(inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		instance_load = msm_comm_get_inst_load(inst,
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:			msm_comm_get_hal_output_buffer(inst));
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:			msm_dcvs_check_codec_supported(
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:			!msm_comm_turbo_session(inst)) {
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		if (!msm_dcvs_enc_check(inst))
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:			if (!msm_comm_scale_clocks(core)) {
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:int msm_dcvs_get_extra_buff_count(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		if (msm_dcvs_enc_check(inst))
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:		if (msm_dcvs_check_supported(inst))
media/platform/msm/vidc_3x/msm_vidc_dcvs.c:void msm_dcvs_enc_set_power_save_mode(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_dcvs.h:#include "msm_vidc_internal.h"
media/platform/msm/vidc_3x/msm_vidc_dcvs.h:void msm_dcvs_init(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.h:void msm_dcvs_init_load(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.h:void msm_dcvs_monitor_buffer(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.h:void msm_dcvs_check_and_scale_clocks(struct msm_vidc_inst *inst, bool is_etb);
media/platform/msm/vidc_3x/msm_vidc_dcvs.h:int  msm_dcvs_get_extra_buff_count(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_dcvs.h:void msm_dcvs_enc_set_power_save_mode(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_debug.c:#include "msm_vidc_common.h"
media/platform/msm/vidc_3x/msm_vidc_debug.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/msm_vidc_debug.c:int msm_vidc_debug = 0;
media/platform/msm/vidc_3x/msm_vidc_debug.c:int msm_vidc_debug_out = 0;
media/platform/msm/vidc_3x/msm_vidc_debug.c:int msm_vidc_fw_debug = 0x18;
media/platform/msm/vidc_3x/msm_vidc_debug.c:int msm_vidc_fw_debug_mode = 0;
media/platform/msm/vidc_3x/msm_vidc_debug.c:int msm_vidc_fw_low_power_mode = 1;
media/platform/msm/vidc_3x/msm_vidc_debug.c:int msm_vidc_hw_rsp_timeout = 1000;
media/platform/msm/vidc_3x/msm_vidc_debug.c:bool msm_vidc_fw_coverage = true;
media/platform/msm/vidc_3x/msm_vidc_debug.c:bool msm_vidc_dec_dcvs_mode = true;
media/platform/msm/vidc_3x/msm_vidc_debug.c:bool msm_vidc_enc_dcvs_mode = true;
media/platform/msm/vidc_3x/msm_vidc_debug.c:bool msm_vidc_sys_idle_indicator = true;
media/platform/msm/vidc_3x/msm_vidc_debug.c:int msm_vidc_firmware_unload_delay = 15000;
media/platform/msm/vidc_3x/msm_vidc_debug.c:bool msm_vidc_thermal_mitigation_disabled = true;
media/platform/msm/vidc_3x/msm_vidc_debug.c:bool msm_vidc_bitrate_clock_scaling = true;
media/platform/msm/vidc_3x/msm_vidc_debug.c:bool msm_vidc_debug_timeout = true;
media/platform/msm/vidc_3x/msm_vidc_debug.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_debug.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_debug.c:	struct msm_vidc_core *core = file->private_data;
media/platform/msm/vidc_3x/msm_vidc_debug.c:	struct msm_vidc_core *core = filp->private_data;
media/platform/msm/vidc_3x/msm_vidc_debug.c:		msm_vidc_trigger_ssr(core, ssr_trigger_val);
media/platform/msm/vidc_3x/msm_vidc_debug.c:struct dentry *msm_vidc_debugfs_init_drv(void)
media/platform/msm/vidc_3x/msm_vidc_debug.c:	dir = debugfs_create_dir("msm_vidc", NULL);
media/platform/msm/vidc_3x/msm_vidc_debug.c:	__debugfs_create(x32, "debug_level", &msm_vidc_debug) &&
media/platform/msm/vidc_3x/msm_vidc_debug.c:	__debugfs_create(x32, "fw_level", &msm_vidc_fw_debug) &&
media/platform/msm/vidc_3x/msm_vidc_debug.c:	__debugfs_create(u32, "fw_debug_mode", &msm_vidc_fw_debug_mode) &&
media/platform/msm/vidc_3x/msm_vidc_debug.c:	__debugfs_create(bool, "fw_coverage", &msm_vidc_fw_coverage) &&
media/platform/msm/vidc_3x/msm_vidc_debug.c:	__debugfs_create(bool, "dcvs_dec_mode", &msm_vidc_dec_dcvs_mode) &&
media/platform/msm/vidc_3x/msm_vidc_debug.c:	__debugfs_create(bool, "dcvs_enc_mode", &msm_vidc_enc_dcvs_mode) &&
media/platform/msm/vidc_3x/msm_vidc_debug.c:			&msm_vidc_fw_low_power_mode) &&
media/platform/msm/vidc_3x/msm_vidc_debug.c:	__debugfs_create(u32, "debug_output", &msm_vidc_debug_out) &&
media/platform/msm/vidc_3x/msm_vidc_debug.c:	__debugfs_create(u32, "hw_rsp_timeout", &msm_vidc_hw_rsp_timeout) &&
media/platform/msm/vidc_3x/msm_vidc_debug.c:			&msm_vidc_sys_idle_indicator) &&
media/platform/msm/vidc_3x/msm_vidc_debug.c:			&msm_vidc_firmware_unload_delay) &&
media/platform/msm/vidc_3x/msm_vidc_debug.c:			&msm_vidc_thermal_mitigation_disabled) &&
media/platform/msm/vidc_3x/msm_vidc_debug.c:			&msm_vidc_bitrate_clock_scaling) &&
media/platform/msm/vidc_3x/msm_vidc_debug.c:			&msm_vidc_debug_timeout);
media/platform/msm/vidc_3x/msm_vidc_debug.c:struct dentry *msm_vidc_debugfs_init_core(struct msm_vidc_core *core,
media/platform/msm/vidc_3x/msm_vidc_debug.c:		dprintk(VIDC_ERR, "Failed to create debugfs for msm_vidc\n");
media/platform/msm/vidc_3x/msm_vidc_debug.c:static int publish_unreleased_reference(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_debug.c:	struct msm_vidc_inst *inst = container_of(kref,
media/platform/msm/vidc_3x/msm_vidc_debug.c:			struct msm_vidc_inst, kref);
media/platform/msm/vidc_3x/msm_vidc_debug.c:	msm_vidc_destroy(inst);
media/platform/msm/vidc_3x/msm_vidc_debug.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_debug.c:	struct msm_vidc_inst *inst, *temp = NULL;
media/platform/msm/vidc_3x/msm_vidc_debug.c:struct dentry *msm_vidc_debugfs_init_inst(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_debug.c:		dprintk(VIDC_ERR, "Failed to create debugfs for msm_vidc\n");
media/platform/msm/vidc_3x/msm_vidc_debug.c:void msm_vidc_debugfs_deinit_inst(struct msm_vidc_inst *inst)
media/platform/msm/vidc_3x/msm_vidc_debug.c:void msm_vidc_debugfs_update(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_debug.c:	enum msm_vidc_debugfs_event e)
media/platform/msm/vidc_3x/msm_vidc_debug.c:	struct msm_vidc_debug *d = &inst->debug;
media/platform/msm/vidc_3x/msm_vidc_debug.h:#include "msm_vidc_internal.h"
media/platform/msm/vidc_3x/msm_vidc_debug.h:#include "trace/events/msm_vidc.h"
media/platform/msm/vidc_3x/msm_vidc_debug.h:#define VIDC_DBG_LABEL "msm_vidc"
media/platform/msm/vidc_3x/msm_vidc_debug.h:#define VIDC_DBG_WARN_ENABLE (msm_vidc_debug & VIDC_INFO)
media/platform/msm/vidc_3x/msm_vidc_debug.h:enum msm_vidc_debugfs_event {
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern int msm_vidc_debug;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern int msm_vidc_debug_out;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern int msm_vidc_fw_debug;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern int msm_vidc_fw_debug_mode;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern int msm_vidc_fw_low_power_mode;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern int msm_vidc_hw_rsp_timeout;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern bool msm_vidc_fw_coverage;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern int msm_vidc_vpe_csc_601_to_709;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern bool msm_vidc_dec_dcvs_mode;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern bool msm_vidc_enc_dcvs_mode;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern bool msm_vidc_sys_idle_indicator;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern int msm_vidc_firmware_unload_delay;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern bool msm_vidc_thermal_mitigation_disabled;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern bool msm_vidc_bitrate_clock_scaling;
media/platform/msm/vidc_3x/msm_vidc_debug.h:extern bool msm_vidc_debug_timeout;
media/platform/msm/vidc_3x/msm_vidc_debug.h:		if (msm_vidc_debug & __level) { \
media/platform/msm/vidc_3x/msm_vidc_debug.h:			if (msm_vidc_debug_out == VIDC_OUT_PRINTK) { \
media/platform/msm/vidc_3x/msm_vidc_debug.h:struct dentry *msm_vidc_debugfs_init_drv(void);
media/platform/msm/vidc_3x/msm_vidc_debug.h:struct dentry *msm_vidc_debugfs_init_core(struct msm_vidc_core *core,
media/platform/msm/vidc_3x/msm_vidc_debug.h:struct dentry *msm_vidc_debugfs_init_inst(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_debug.h:void msm_vidc_debugfs_deinit_inst(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_debug.h:void msm_vidc_debugfs_update(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_debug.h:		enum msm_vidc_debugfs_event e);
media/platform/msm/vidc_3x/msm_vidc_debug.h:static inline void tic(struct msm_vidc_inst *i, enum profiling_points p,
media/platform/msm/vidc_3x/msm_vidc_debug.h:	if ((msm_vidc_debug & VIDC_PROF) &&
media/platform/msm/vidc_3x/msm_vidc_debug.h:static inline void toc(struct msm_vidc_inst *i, enum profiling_points p)
media/platform/msm/vidc_3x/msm_vidc_debug.h:	if ((msm_vidc_debug & VIDC_PROF) &&
media/platform/msm/vidc_3x/msm_vidc_debug.h:static inline void show_stats(struct msm_vidc_inst *i)
media/platform/msm/vidc_3x/msm_vidc_debug.h:				(msm_vidc_debug & VIDC_PROF)) {
media/platform/msm/vidc_3x/msm_vidc_internal.h:#include <linux/msm-bus.h>
media/platform/msm/vidc_3x/msm_vidc_internal.h:#include <linux/msm-bus-board.h>
media/platform/msm/vidc_3x/msm_vidc_internal.h:#include <media/msm_vidc.h>
media/platform/msm/vidc_3x/msm_vidc_internal.h:#include <media/msm_media_info.h>
media/platform/msm/vidc_3x/msm_vidc_internal.h:#define MSM_VIDC_DRV_NAME "msm_vidc_driver"
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct msm_vidc_list {
media/platform/msm/vidc_3x/msm_vidc_internal.h:static inline void INIT_MSM_VIDC_LIST(struct msm_vidc_list *mlist)
media/platform/msm/vidc_3x/msm_vidc_internal.h:static inline void DEINIT_MSM_VIDC_LIST(struct msm_vidc_list *mlist)
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_smem smem;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_smem smem;
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct msm_vidc_format {
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct msm_vidc_drv {
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct msm_video_device {
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct msm_vidc_debug {
media/platform/msm/vidc_3x/msm_vidc_internal.h:enum msm_vidc_modes {
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct msm_vidc_core {
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_video_device vdev[MSM_VIDC_MAX_DEVICES];
media/platform/msm/vidc_3x/msm_vidc_internal.h:	enum msm_vidc_hfi_type hfi_type;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_vidc_platform_resources resources;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_vidc_capability *capabilities;
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct msm_vidc_inst {
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_vidc_format fmts[MAX_PORT_NUM];
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_vidc_list pendingq;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_vidc_list scratchbufs;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_vidc_list persistbufs;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_vidc_list pending_getpropq;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_vidc_list outputbufs;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_vidc_list eosbufs;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_vidc_list registeredbufs;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_smem *extradata_handle;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_vidc_debug debug;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	enum msm_vidc_modes flags;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_vidc_capability capability;
media/platform/msm/vidc_3x/msm_vidc_internal.h:	enum msm_vidc_pixel_depth bit_depth;
media/platform/msm/vidc_3x/msm_vidc_internal.h:extern struct msm_vidc_drv *vidc_driver;
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct msm_vidc_ctrl_cluster {
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct msm_vidc_ctrl {
media/platform/msm/vidc_3x/msm_vidc_internal.h:int msm_vidc_trigger_ssr(struct msm_vidc_core *core,
media/platform/msm/vidc_3x/msm_vidc_internal.h:int msm_vidc_check_session_supported(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_internal.h:int msm_vidc_check_scaling_supported(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_internal.h:void msm_vidc_queue_v4l2_event(struct msm_vidc_inst *inst, int event_type);
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct msm_vidc_format_constraint {
media/platform/msm/vidc_3x/msm_vidc_internal.h:	struct msm_smem smem[VIDEO_MAX_PLANES];
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct buffer_info *device_to_uvaddr(struct msm_vidc_list *buf_list,
media/platform/msm/vidc_3x/msm_vidc_internal.h:int buf_ref_get(struct msm_vidc_inst *inst, struct buffer_info *binfo);
media/platform/msm/vidc_3x/msm_vidc_internal.h:int buf_ref_put(struct msm_vidc_inst *inst, struct buffer_info *binfo);
media/platform/msm/vidc_3x/msm_vidc_internal.h:int qbuf_cache_operations(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_internal.h:int dqbuf_cache_operations(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_internal.h:int qbuf_dynamic_buf(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_internal.h:int unmap_and_deregister_buf(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_internal.h:void msm_comm_handle_thermal_event(void);
media/platform/msm/vidc_3x/msm_vidc_internal.h:int msm_smem_alloc(size_t size, u32 align, u32 flags,
media/platform/msm/vidc_3x/msm_vidc_internal.h:		void  *res, u32 session_type, struct msm_smem *smem);
media/platform/msm/vidc_3x/msm_vidc_internal.h:int msm_smem_free(struct msm_smem *mem);
media/platform/msm/vidc_3x/msm_vidc_internal.h:int msm_smem_cache_operations(struct dma_buf *dbuf,
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct context_bank_info *msm_smem_get_context_bank(u32 session_type,
media/platform/msm/vidc_3x/msm_vidc_internal.h:	bool is_secure, struct msm_vidc_platform_resources *res,
media/platform/msm/vidc_3x/msm_vidc_internal.h:int msm_smem_map_dma_buf(struct msm_vidc_inst *inst, struct msm_smem *smem);
media/platform/msm/vidc_3x/msm_vidc_internal.h:int msm_smem_unmap_dma_buf(struct msm_vidc_inst *inst, struct msm_smem *smem);
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct dma_buf *msm_smem_get_dma_buf(int fd);
media/platform/msm/vidc_3x/msm_vidc_internal.h:void msm_smem_put_dma_buf(void *dma_buf);
media/platform/msm/vidc_3x/msm_vidc_internal.h:bool msm_smem_compare_buffers(int fd, void *dma_buf);
media/platform/msm/vidc_3x/msm_vidc_internal.h:struct msm_smem *msm_smem_user_to_kernel(struct msm_vidc_inst *inst,
media/platform/msm/vidc_3x/msm_vidc_internal.h:/* XXX: normally should be in msm_vidc.h, but that's meant for public APIs,
media/platform/msm/vidc_3x/msm_vidc_internal.h:int msm_vidc_destroy(struct msm_vidc_inst *inst);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:#include "msm_vidc_resources.h"
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:#include "msm_vidc_res_parse.h"
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline struct device *msm_iommu_get_ctx(const char *ctx_name)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_populate_legacy_context_bank(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:			struct msm_vidc_platform_resources *res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	return is_compatible("qcom,msm-ocmem") ? IMEM_OCMEM :
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		is_compatible("qcom,msm-vmem") ? IMEM_VMEM :
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_bus_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	struct msm_vidc_bus_table_gov *data = res->gov_data;
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_allowed_clocks_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_cycles_per_mb_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_platform_version_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_capability_version_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_freq_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_dcvs_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_dcvs_limit(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_imem_ab_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_reg_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:			struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_qdss_addr_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:			struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_bus_vectors(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:			struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_buffer_usage_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:			struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_regulator_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:			struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static inline void msm_vidc_free_clock_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:			struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:void msm_vidc_free_platform_resources(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:			struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_clock_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_bus_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_regulator_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_freq_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_platform_version_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_capability_version_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_dcvs_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_dcvs_limit(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_cycles_per_mb_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_allowed_clocks_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_reg_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_qdss_addr_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_bus_vectors(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_buffer_usage_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_reg_table(struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		msm_vidc_free_reg_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_qdss_table(struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		msm_vidc_free_qdss_addr_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_imem_ab_table(struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		msm_vidc_free_imem_ab_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c: * msm_vidc_load_u32_table() - load dtsi table entries
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:int msm_vidc_load_u32_table(struct platform_device *pdev,
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_platform_version_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_u32_table(pdev, pdev->dev.of_node,
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_capability_version_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_u32_table(pdev, pdev->dev.of_node,
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	struct msm_vidc_platform_resources *platform_res,
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_u32_table(pdev, pdev->dev.of_node,
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_allowed_clocks_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_u32_table(pdev, pdev->dev.of_node,
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_cycles_per_mb_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_freq_table(struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		msm_vidc_free_freq_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_dcvs_table(struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		msm_vidc_free_dcvs_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_dcvs_limit(struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		msm_vidc_free_dcvs_limit(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_populate_bus(struct device *dev,
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_buffer_usage_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_buffer_usage_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_regulator_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_regulator_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_clock_table(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_load_bus_table(struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	struct msm_vidc_bus_table_gov *gov_data;
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:			rc = msm_vidc_load_u32_table(pdev, child_node,
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_platform_version_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_capability_version_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_freq_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_dcvs_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_dcvs_limit(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_imem_ab_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_qdss_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_reg_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_buffer_usage_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_regulator_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_clock_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_cycles_per_mb_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_allowed_clocks_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_load_bus_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_populate_legacy_context_bank(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_allowed_clocks_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_bus_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_cycles_per_mb_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_clock_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_regulator_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_buffer_usage_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_reg_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	msm_vidc_free_freq_table(res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_setup_context_bank(struct context_bank_info *cb,
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:int msm_vidc_smmu_fault_handler(struct iommu_domain *domain,
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	struct msm_vidc_core *core = token;
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	struct msm_vidc_inst *inst;
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_populate_context_bank(struct device *dev,
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		struct msm_vidc_core *core)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	rc = msm_vidc_setup_context_bank(cb, dev);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		msm_vidc_smmu_fault_handler, (void *)core);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:static int msm_vidc_populate_legacy_context_bank(
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:			struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		cb->dev = msm_iommu_get_ctx(cb->name);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		rc = msm_vidc_setup_context_bank(cb, cb->dev);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:		rc = msm_vidc_populate_context_bank(&pdev->dev, core);
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	struct msm_vidc_core *core;
media/platform/msm/vidc_3x/msm_vidc_res_parse.c:	return msm_vidc_populate_bus(&pdev->dev, &core->resources);
media/platform/msm/vidc_3x/msm_vidc_res_parse.h:#include "msm_vidc_resources.h"
media/platform/msm/vidc_3x/msm_vidc_res_parse.h:void msm_vidc_free_platform_resources(
media/platform/msm/vidc_3x/msm_vidc_res_parse.h:		struct msm_vidc_platform_resources *res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.h:		struct msm_vidc_platform_resources *res);
media/platform/msm/vidc_3x/msm_vidc_res_parse.h:int msm_vidc_load_u32_table(struct platform_device *pdev,
media/platform/msm/vidc_3x/msm_vidc_resources.h:#include <media/msm_vidc.h>
media/platform/msm/vidc_3x/msm_vidc_resources.h:	struct msm_bus_client_handle *client;
media/platform/msm/vidc_3x/msm_vidc_resources.h:struct msm_vidc_bus_table_gov {
media/platform/msm/vidc_3x/msm_vidc_resources.h:struct msm_vidc_platform_resources {
media/platform/msm/vidc_3x/msm_vidc_resources.h:	struct msm_vidc_bus_table_gov *gov_data;
media/platform/msm/vidc_3x/msm_vidc_resources.h:static inline bool is_iommu_present(struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/msm_vidc_resources.h:extern uint32_t msm_vidc_pwr_collapse_delay;
media/platform/msm/vidc_3x/venus_boot.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/venus_boot.c:	struct msm_vidc_platform_resources *resources;
media/platform/msm/vidc_3x/venus_boot.c:	struct msm_vidc_platform_resources *res = venus_data->resources;
media/platform/msm/vidc_3x/venus_boot.c:	struct msm_vidc_platform_resources *res = venus_data->resources;
media/platform/msm/vidc_3x/venus_boot.c:	struct msm_vidc_platform_resources *res = venus_data->resources;
media/platform/msm/vidc_3x/venus_boot.c:int venus_boot_init(struct msm_vidc_platform_resources *res,
media/platform/msm/vidc_3x/venus_boot.h:#include "msm_vidc_resources.h"
media/platform/msm/vidc_3x/venus_boot.h:int venus_boot_init(struct msm_vidc_platform_resources *res,
media/platform/msm/vidc_3x/venus_hfi.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/venus_hfi.c:const struct msm_vidc_gov_data DEFAULT_BUS_VOTE = {
media/platform/msm/vidc_3x/venus_hfi.c:	if (msm_vidc_debug & VIDC_PKT) {
media/platform/msm/vidc_3x/venus_hfi.c:	if (msm_vidc_debug & VIDC_PKT) {
media/platform/msm/vidc_3x/venus_hfi.c:	struct msm_smem *alloc = &mem->mem_data;
media/platform/msm/vidc_3x/venus_hfi.c:	rc = msm_smem_alloc(size, align, flags, usage, 1, (void *)dev->res,
media/platform/msm/vidc_3x/venus_hfi.c:	rc = msm_smem_cache_operations(alloc->dma_buf, 0, alloc->size,
media/platform/msm/vidc_3x/venus_hfi.c:static void __smem_free(struct venus_hfi_device *dev, struct msm_smem *mem)
media/platform/msm/vidc_3x/venus_hfi.c:	msm_smem_free(mem);
media/platform/msm/vidc_3x/venus_hfi.c:	rc = msm_bus_scale_update_bw(bus->client, ab, 0);
media/platform/msm/vidc_3x/venus_hfi.c:			rc = msm_vidc_table_get_target_freq(
media/platform/msm/vidc_3x/venus_hfi.c:				msm_vidc_pwr_collapse_delay))) {
media/platform/msm/vidc_3x/venus_hfi.c:		cb = msm_smem_get_context_bank(MSM_VIDC_UNKNOWN,
media/platform/msm/vidc_3x/venus_hfi.c:	if ((msm_vidc_fw_debug_mode & HFI_DEBUG_MODE_QDSS) && num_entries) {
media/platform/msm/vidc_3x/venus_hfi.c:		cb = msm_smem_get_context_bank(MSM_VIDC_UNKNOWN, false,
media/platform/msm/vidc_3x/venus_hfi.c:	if (__sys_set_debug(device, msm_vidc_fw_debug))
media/platform/msm/vidc_3x/venus_hfi.c:		!msm_vidc_sys_idle_indicator))
media/platform/msm/vidc_3x/venus_hfi.c:	if (__sys_set_power_control(device, msm_vidc_fw_low_power_mode))
media/platform/msm/vidc_3x/venus_hfi.c:	if (!msm_vidc_fw_coverage) {
media/platform/msm/vidc_3x/venus_hfi.c:		if (__sys_set_coverage(sess->device, msm_vidc_fw_coverage))
media/platform/msm/vidc_3x/venus_hfi.c:	struct msm_vidc_cb_cmd_done cmd_done = {0};
media/platform/msm/vidc_3x/venus_hfi.c:			msecs_to_jiffies(msm_vidc_pwr_collapse_delay));
media/platform/msm/vidc_3x/venus_hfi.c:	struct msm_vidc_cb_info *packets;
media/platform/msm/vidc_3x/venus_hfi.c:		struct msm_vidc_cb_info info = {
media/platform/msm/vidc_3x/venus_hfi.c:		struct msm_vidc_cb_info *info = &packets[packet_count++];
media/platform/msm/vidc_3x/venus_hfi.c:			msecs_to_jiffies(msm_vidc_pwr_collapse_delay))) {
media/platform/msm/vidc_3x/venus_hfi.c:		struct msm_vidc_cb_info *r = &device->response_pkt[i];
media/platform/msm/vidc_3x/venus_hfi.c:		struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/venus_hfi.c:			"msm_vidc", device);
media/platform/msm/vidc_3x/venus_hfi.c:		msm_bus_scale_unregister(bus->client);
media/platform/msm/vidc_3x/venus_hfi.c:		bus->client = msm_bus_scale_register(bus->master, bus->slave,
media/platform/msm/vidc_3x/venus_hfi.c:				struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/venus_hfi.c:		kzalloc(sizeof(struct msm_vidc_capability)
media/platform/msm/vidc_3x/venus_hfi.c:				struct msm_vidc_platform_resources *res)
media/platform/msm/vidc_3x/venus_hfi.c:	if (!msm_vidc_fw_low_power_mode) {
media/platform/msm/vidc_3x/venus_hfi.c:	trace_msm_v4l2_vidc_fw_load_start("msm_v4l2_vidc venus_fw load start");
media/platform/msm/vidc_3x/venus_hfi.c:	trace_msm_v4l2_vidc_fw_load_end("msm_v4l2_vidc venus_fw load end");
media/platform/msm/vidc_3x/venus_hfi.c:	trace_msm_v4l2_vidc_fw_load_end("msm_v4l2_vidc venus_fw load end");
media/platform/msm/vidc_3x/venus_hfi.c:			struct msm_vidc_platform_resources *res,
media/platform/msm/vidc_3x/venus_hfi.c:		"msm_vidc_workerq_venus");
media/platform/msm/vidc_3x/venus_hfi.c:				struct msm_vidc_platform_resources *res,
media/platform/msm/vidc_3x/venus_hfi.c:		struct msm_vidc_platform_resources *res,
media/platform/msm/vidc_3x/venus_hfi.h:#include "msm_vidc_resources.h"
media/platform/msm/vidc_3x/venus_hfi.h:				struct msm_vidc_gov_data *vidc_data);
media/platform/msm/vidc_3x/venus_hfi.h:extern int msm_vidc_table_get_target_freq(struct msm_vidc_bus_table_gov *gov,
media/platform/msm/vidc_3x/venus_hfi.h:					struct msm_vidc_gov_data *vidc_data,
media/platform/msm/vidc_3x/venus_hfi.h:	struct msm_smem mem_data;
media/platform/msm/vidc_3x/venus_hfi.h:/* Internal data used in vidc_hal not exposed to msm_vidc*/
media/platform/msm/vidc_3x/venus_hfi.h:	struct msm_vidc_fw fw;
media/platform/msm/vidc_3x/venus_hfi.h:	struct msm_vidc_gov_data bus_vote;
media/platform/msm/vidc_3x/venus_hfi.h:	msm_vidc_callback callback;
media/platform/msm/vidc_3x/venus_hfi.h:	struct msm_vidc_platform_resources *res;
media/platform/msm/vidc_3x/venus_hfi.h:	struct msm_vidc_cb_info *response_pkt;
media/platform/msm/vidc_3x/venus_hfi.h:	struct msm_vidc_capability *sys_init_capabilities;
media/platform/msm/vidc_3x/venus_hfi.h:		struct msm_vidc_platform_resources *res,
media/platform/msm/vidc_3x/vidc_hfi.c:#include "msm_vidc_debug.h"
media/platform/msm/vidc_3x/vidc_hfi.c:struct hfi_device *vidc_hfi_initialize(enum msm_vidc_hfi_type hfi_type,
media/platform/msm/vidc_3x/vidc_hfi.c:		u32 device_id, struct msm_vidc_platform_resources *res,
media/platform/msm/vidc_3x/vidc_hfi.c:void vidc_hfi_deinitialize(enum msm_vidc_hfi_type hfi_type,
media/platform/msm/vidc_3x/vidc_hfi.h:#include <media/msm_media_info.h>
media/platform/msm/vidc_3x/vidc_hfi.h:struct msm_vidc_fw {
media/platform/msm/vidc_3x/vidc_hfi.h:		struct msm_vidc_cb_info *info);
media/platform/msm/vidc_3x/vidc_hfi_api.h:#include <media/msm_vidc.h>
media/platform/msm/vidc_3x/vidc_hfi_api.h:#include "msm_vidc_resources.h"
media/platform/msm/vidc_3x/vidc_hfi_api.h:struct msm_vidc_capability {
media/platform/msm/vidc_3x/vidc_hfi_api.h:	struct msm_vidc_capability *capabilities;
media/platform/msm/vidc_3x/vidc_hfi_api.h:	struct msm_vidc_capability capability;
media/platform/msm/vidc_3x/vidc_hfi_api.h:struct msm_vidc_cb_cmd_done {
media/platform/msm/vidc_3x/vidc_hfi_api.h:struct msm_vidc_cb_event {
media/platform/msm/vidc_3x/vidc_hfi_api.h:	enum msm_vidc_pixel_depth bit_depth;
media/platform/msm/vidc_3x/vidc_hfi_api.h:struct msm_vidc_cb_data_done {
media/platform/msm/vidc_3x/vidc_hfi_api.h:struct msm_vidc_cb_info {
media/platform/msm/vidc_3x/vidc_hfi_api.h:		struct msm_vidc_cb_cmd_done cmd;
media/platform/msm/vidc_3x/vidc_hfi_api.h:		struct msm_vidc_cb_event event;
media/platform/msm/vidc_3x/vidc_hfi_api.h:		struct msm_vidc_cb_data_done data;
media/platform/msm/vidc_3x/vidc_hfi_api.h:enum msm_vidc_hfi_type {
media/platform/msm/vidc_3x/vidc_hfi_api.h:enum msm_vidc_thermal_level {
media/platform/msm/vidc_3x/vidc_hfi_api.h:struct msm_vidc_gov_data {
media/platform/msm/vidc_3x/vidc_hfi_api.h:enum msm_vidc_power_mode {
media/platform/msm/vidc_3x/vidc_hfi_api.h:	enum msm_vidc_power_mode power_mode;
media/platform/msm/vidc_3x/vidc_hfi_api.h:	enum msm_vidc_power_mode power_mode[VIDC_MAX_SESSIONS];
media/platform/msm/vidc_3x/vidc_hfi_api.h:typedef void (*msm_vidc_callback) (u32 response, void *callback);
media/platform/msm/vidc_3x/vidc_hfi_api.h:struct hfi_device *vidc_hfi_initialize(enum msm_vidc_hfi_type hfi_type,
media/platform/msm/vidc_3x/vidc_hfi_api.h:		u32 device_id, struct msm_vidc_platform_resources *res,
media/platform/msm/vidc_3x/vidc_hfi_api.h:void vidc_hfi_deinitialize(enum msm_vidc_hfi_type hfi_type,
media/platform/msm/vidc_3x/vmem/vmem.c:#include <linux/msm-bus.h>
media/platform/msm/vidc_3x/vmem/vmem.c:		struct msm_bus_scale_pdata *pdata;
media/platform/msm/vidc_3x/vmem/vmem.c:	rc = msm_bus_scale_client_update_request(v->bus.priv, 1);
media/platform/msm/vidc_3x/vmem/vmem.c:	msm_bus_scale_client_update_request(v->bus.priv, 0);
media/platform/msm/vidc_3x/vmem/vmem.c:	msm_bus_scale_client_update_request(v->bus.priv, 0);
media/platform/msm/vidc_3x/vmem/vmem.c:	v->bus.pdata = msm_bus_cl_get_pdata(pdev);
media/platform/msm/vidc_3x/vmem/vmem.c:	v->bus.priv = msm_bus_scale_register_client(v->bus.pdata);
media/platform/msm/vidc_3x/vmem/vmem.c:	msm_bus_cl_clear_pdata(v->bus.pdata);
media/platform/msm/vidc_3x/vmem/vmem.c:	msm_bus_cl_clear_pdata(v->bus.pdata);
media/platform/msm/vidc_3x/vmem/vmem.c:	{.compatible = "qcom,msm-vmem"},
media/platform/msm/vidc_3x/vmem/vmem.c:		.name = "msm_vidc_vmem",
media/platform/qcom/camss/camss-csid.c:#define MSM_CSID_NAME "msm_csid"
media/platform/qcom/camss/camss-csid.c: * msm_csid_subdev_init - Initialize CSID device structure and resources
media/platform/qcom/camss/camss-csid.c:int msm_csid_subdev_init(struct camss *camss, struct csid_device *csid,
media/platform/qcom/camss/camss-csid.c: * msm_csid_get_csid_id - Get CSID HW module id
media/platform/qcom/camss/camss-csid.c:void msm_csid_get_csid_id(struct media_entity *entity, u8 *id)
media/platform/qcom/camss/camss-csid.c: * msm_csid_register_entity - Register subdev node for CSID module
media/platform/qcom/camss/camss-csid.c:int msm_csid_register_entity(struct csid_device *csid,
media/platform/qcom/camss/camss-csid.c: * msm_csid_unregister_entity - Unregister CSID module subdev node
media/platform/qcom/camss/camss-csid.c:void msm_csid_unregister_entity(struct csid_device *csid)
media/platform/qcom/camss/camss-csid.h:int msm_csid_subdev_init(struct camss *camss, struct csid_device *csid,
media/platform/qcom/camss/camss-csid.h:int msm_csid_register_entity(struct csid_device *csid,
media/platform/qcom/camss/camss-csid.h:void msm_csid_unregister_entity(struct csid_device *csid);
media/platform/qcom/camss/camss-csid.h:void msm_csid_get_csid_id(struct media_entity *entity, u8 *id);
media/platform/qcom/camss/camss-csiphy.c:#define MSM_CSIPHY_NAME "msm_csiphy"
media/platform/qcom/camss/camss-csiphy.c: * msm_csiphy_subdev_init - Initialize CSIPHY device structure and resources
media/platform/qcom/camss/camss-csiphy.c:int msm_csiphy_subdev_init(struct camss *camss,
media/platform/qcom/camss/camss-csiphy.c: * msm_csiphy_register_entity - Register subdev node for CSIPHY module
media/platform/qcom/camss/camss-csiphy.c:int msm_csiphy_register_entity(struct csiphy_device *csiphy,
media/platform/qcom/camss/camss-csiphy.c: * msm_csiphy_unregister_entity - Unregister CSIPHY module subdev node
media/platform/qcom/camss/camss-csiphy.c:void msm_csiphy_unregister_entity(struct csiphy_device *csiphy)
media/platform/qcom/camss/camss-csiphy.h:int msm_csiphy_subdev_init(struct camss *camss,
media/platform/qcom/camss/camss-csiphy.h:int msm_csiphy_register_entity(struct csiphy_device *csiphy,
media/platform/qcom/camss/camss-csiphy.h:void msm_csiphy_unregister_entity(struct csiphy_device *csiphy);
media/platform/qcom/camss/camss-ispif.c:#define MSM_ISPIF_NAME "msm_ispif"
media/platform/qcom/camss/camss-ispif.c: * msm_ispif_subdev_init - Initialize ISPIF device structure and resources
media/platform/qcom/camss/camss-ispif.c:int msm_ispif_subdev_init(struct ispif_device *ispif,
media/platform/qcom/camss/camss-ispif.c:			msm_csid_get_csid_id(remote->entity, &line->csid_id);
media/platform/qcom/camss/camss-ispif.c:			msm_vfe_get_vfe_id(remote->entity, &line->vfe_id);
media/platform/qcom/camss/camss-ispif.c:			msm_vfe_get_vfe_line_id(remote->entity, &id);
media/platform/qcom/camss/camss-ispif.c: * msm_ispif_register_entities - Register subdev node for ISPIF module
media/platform/qcom/camss/camss-ispif.c:int msm_ispif_register_entities(struct ispif_device *ispif,
media/platform/qcom/camss/camss-ispif.c: * msm_ispif_unregister_entities - Unregister ISPIF module subdev node
media/platform/qcom/camss/camss-ispif.c:void msm_ispif_unregister_entities(struct ispif_device *ispif)
media/platform/qcom/camss/camss-ispif.h:int msm_ispif_subdev_init(struct ispif_device *ispif,
media/platform/qcom/camss/camss-ispif.h:int msm_ispif_register_entities(struct ispif_device *ispif,
media/platform/qcom/camss/camss-ispif.h:void msm_ispif_unregister_entities(struct ispif_device *ispif);
media/platform/qcom/camss/camss-vfe.c:#define MSM_VFE_NAME "msm_vfe"
media/platform/qcom/camss/camss-vfe.c: * msm_vfe_subdev_init - Initialize VFE device structure and resources
media/platform/qcom/camss/camss-vfe.c:int msm_vfe_subdev_init(struct camss *camss, struct vfe_device *vfe,
media/platform/qcom/camss/camss-vfe.c: * msm_vfe_get_vfe_id - Get VFE HW module id
media/platform/qcom/camss/camss-vfe.c:void msm_vfe_get_vfe_id(struct media_entity *entity, u8 *id)
media/platform/qcom/camss/camss-vfe.c: * msm_vfe_get_vfe_line_id - Get VFE line id by media entity
media/platform/qcom/camss/camss-vfe.c:void msm_vfe_get_vfe_line_id(struct media_entity *entity, enum vfe_line_id *id)
media/platform/qcom/camss/camss-vfe.c:void msm_vfe_stop_streaming(struct vfe_device *vfe)
media/platform/qcom/camss/camss-vfe.c:		msm_video_stop_streaming(&vfe->line[i].video_out);
media/platform/qcom/camss/camss-vfe.c: * msm_vfe_register_entities - Register subdev node for VFE module
media/platform/qcom/camss/camss-vfe.c: * call msm_video_register() to register the video device node which
media/platform/qcom/camss/camss-vfe.c:int msm_vfe_register_entities(struct vfe_device *vfe,
media/platform/qcom/camss/camss-vfe.c:		ret = msm_video_register(video_out, v4l2_dev, name,
media/platform/qcom/camss/camss-vfe.c:	msm_video_unregister(video_out);
media/platform/qcom/camss/camss-vfe.c:		msm_video_unregister(video_out);
media/platform/qcom/camss/camss-vfe.c: * msm_vfe_unregister_entities - Unregister VFE module subdev node
media/platform/qcom/camss/camss-vfe.c:void msm_vfe_unregister_entities(struct vfe_device *vfe)
media/platform/qcom/camss/camss-vfe.c:		msm_video_unregister(video_out);
media/platform/qcom/camss/camss-vfe.h:int msm_vfe_subdev_init(struct camss *camss, struct vfe_device *vfe,
media/platform/qcom/camss/camss-vfe.h:int msm_vfe_register_entities(struct vfe_device *vfe,
media/platform/qcom/camss/camss-vfe.h:void msm_vfe_unregister_entities(struct vfe_device *vfe);
media/platform/qcom/camss/camss-vfe.h:void msm_vfe_get_vfe_id(struct media_entity *entity, u8 *id);
media/platform/qcom/camss/camss-vfe.h:void msm_vfe_get_vfe_line_id(struct media_entity *entity, enum vfe_line_id *id);
media/platform/qcom/camss/camss-vfe.h:void msm_vfe_stop_streaming(struct vfe_device *vfe);
media/platform/qcom/camss/camss-video.c:static const struct vb2_ops msm_video_vb2_q_ops = {
media/platform/qcom/camss/camss-video.c:static const struct v4l2_ioctl_ops msm_vid_ioctl_ops = {
media/platform/qcom/camss/camss-video.c:static const struct v4l2_file_operations msm_vid_fops = {
media/platform/qcom/camss/camss-video.c:static void msm_video_release(struct video_device *vdev)
media/platform/qcom/camss/camss-video.c: * msm_video_init_format - Helper function to initialize format
media/platform/qcom/camss/camss-video.c:static int msm_video_init_format(struct camss_video *video)
media/platform/qcom/camss/camss-video.c: * msm_video_register - Register a video device node
media/platform/qcom/camss/camss-video.c:int msm_video_register(struct camss_video *video, struct v4l2_device *v4l2_dev,
media/platform/qcom/camss/camss-video.c:	q->ops = &msm_video_vb2_q_ops;
media/platform/qcom/camss/camss-video.c:	ret = msm_video_init_format(video);
media/platform/qcom/camss/camss-video.c:	vdev->fops = &msm_vid_fops;
media/platform/qcom/camss/camss-video.c:	vdev->ioctl_ops = &msm_vid_ioctl_ops;
media/platform/qcom/camss/camss-video.c:	vdev->release = msm_video_release;
media/platform/qcom/camss/camss-video.c:void msm_video_stop_streaming(struct camss_video *video)
media/platform/qcom/camss/camss-video.c:void msm_video_unregister(struct camss_video *video)
media/platform/qcom/camss/camss-video.h:void msm_video_stop_streaming(struct camss_video *video);
media/platform/qcom/camss/camss-video.h:int msm_video_register(struct camss_video *video, struct v4l2_device *v4l2_dev,
media/platform/qcom/camss/camss-video.h:void msm_video_unregister(struct camss_video *video);
media/platform/qcom/camss/camss.c:		ret = msm_csiphy_subdev_init(camss, &camss->csiphy[i],
media/platform/qcom/camss/camss.c:		ret = msm_csid_subdev_init(camss, &camss->csid[i],
media/platform/qcom/camss/camss.c:	ret = msm_ispif_subdev_init(&camss->ispif, ispif_res);
media/platform/qcom/camss/camss.c:		ret = msm_vfe_subdev_init(camss, &camss->vfe[i],
media/platform/qcom/camss/camss.c:		ret = msm_csiphy_register_entity(&camss->csiphy[i],
media/platform/qcom/camss/camss.c:		ret = msm_csid_register_entity(&camss->csid[i],
media/platform/qcom/camss/camss.c:	ret = msm_ispif_register_entities(&camss->ispif, &camss->v4l2_dev);
media/platform/qcom/camss/camss.c:		ret = msm_vfe_register_entities(&camss->vfe[i],
media/platform/qcom/camss/camss.c:		msm_vfe_unregister_entities(&camss->vfe[i]);
media/platform/qcom/camss/camss.c:	msm_ispif_unregister_entities(&camss->ispif);
media/platform/qcom/camss/camss.c:		msm_csid_unregister_entity(&camss->csid[i]);
media/platform/qcom/camss/camss.c:		msm_csiphy_unregister_entity(&camss->csiphy[i]);
media/platform/qcom/camss/camss.c:		msm_csiphy_unregister_entity(&camss->csiphy[i]);
media/platform/qcom/camss/camss.c:		msm_csid_unregister_entity(&camss->csid[i]);
media/platform/qcom/camss/camss.c:	msm_ispif_unregister_entities(&camss->ispif);
media/platform/qcom/camss/camss.c:		msm_vfe_unregister_entities(&camss->vfe[i]);
media/platform/qcom/camss/camss.c:	if (of_device_is_compatible(dev->of_node, "qcom,msm8916-camss")) {
media/platform/qcom/camss/camss.c:					   "qcom,msm8996-camss")) {
media/platform/qcom/camss/camss.c:		msm_vfe_stop_streaming(&camss->vfe[i]);
media/platform/qcom/camss/camss.c:	{ .compatible = "qcom,msm8916-camss" },
media/platform/qcom/camss/camss.c:	{ .compatible = "qcom,msm8996-camss" },
media/platform/qcom/venus/core.c:static const struct freq_tbl msm8916_freq_table[] = {
media/platform/qcom/venus/core.c:static const struct reg_val msm8916_reg_preset[] = {
media/platform/qcom/venus/core.c:static const struct venus_resources msm8916_res = {
media/platform/qcom/venus/core.c:	.freq_tbl = msm8916_freq_table,
media/platform/qcom/venus/core.c:	.freq_tbl_size = ARRAY_SIZE(msm8916_freq_table),
media/platform/qcom/venus/core.c:	.reg_tbl = msm8916_reg_preset,
media/platform/qcom/venus/core.c:	.reg_tbl_size = ARRAY_SIZE(msm8916_reg_preset),
media/platform/qcom/venus/core.c:static const struct freq_tbl msm8996_freq_table[] = {
media/platform/qcom/venus/core.c:static const struct reg_val msm8996_reg_preset[] = {
media/platform/qcom/venus/core.c:static const struct venus_resources msm8996_res = {
media/platform/qcom/venus/core.c:	.freq_tbl = msm8996_freq_table,
media/platform/qcom/venus/core.c:	.freq_tbl_size = ARRAY_SIZE(msm8996_freq_table),
media/platform/qcom/venus/core.c:	.reg_tbl = msm8996_reg_preset,
media/platform/qcom/venus/core.c:	.reg_tbl_size = ARRAY_SIZE(msm8996_reg_preset),
media/platform/qcom/venus/core.c:	{ .compatible = "qcom,msm8916-venus", .data = &msm8916_res, },
media/platform/qcom/venus/core.c:	{ .compatible = "qcom,msm8996-venus", .data = &msm8996_res, },
media/radio/radio-iris-transport.c:static int fmsmd_set;
media/radio/radio-iris-transport.c:module_param_call(fmsmd_set, hcismd_fm_set_enable, NULL, &fmsmd_set, 0644);
media/radio/radio-iris-transport.c:	fmsmd_set = 0;
media/radio/radio-iris-transport.c:	switch (fmsmd_set) {
mfd/qcom_rpm.c:static const struct qcom_rpm_resource msm8660_rpm_resource_table[] = {
mfd/qcom_rpm.c:static const struct qcom_rpm_data msm8660_template = {
mfd/qcom_rpm.c:	.resource_table = msm8660_rpm_resource_table,
mfd/qcom_rpm.c:	.n_resources = ARRAY_SIZE(msm8660_rpm_resource_table),
mfd/qcom_rpm.c:static const struct qcom_rpm_resource msm8960_rpm_resource_table[] = {
mfd/qcom_rpm.c:static const struct qcom_rpm_data msm8960_template = {
mfd/qcom_rpm.c:	.resource_table = msm8960_rpm_resource_table,
mfd/qcom_rpm.c:	.n_resources = ARRAY_SIZE(msm8960_rpm_resource_table),
mfd/qcom_rpm.c:	{ .compatible = "qcom,rpm-msm8660", .data = &msm8660_template },
mfd/qcom_rpm.c:	{ .compatible = "qcom,rpm-msm8960", .data = &msm8960_template },
mihw/gpu_pcost.c:#include <linux/msm_adreno_devfreq.h>
misc/Makefile:obj-$(CONFIG_HDCP_QSEECOM)	+= msm_hdcp.o
misc/kprofiles/Kconfig:	bool "Auto Kprofiles using msm_drm_notifier"
misc/kprofiles/Kconfig:	  Select this to enable Kprofile's automatic mode changer via msm_drm_notifier.
misc/kprofiles/main.c:#include <linux/msm_drm_notify.h>
misc/kprofiles/main.c:#define kprofiles_events msm_drm_notifier
misc/kprofiles/main.c:	ret = msm_drm_register_client(&kp_notifier_block);
misc/kprofiles/main.c:	msm_drm_unregister_client(&kp_notifier_block);
misc/msm_hdcp.c:#define pr_fmt(fmt)	"[msm-hdcp] %s: " fmt, __func__
misc/msm_hdcp.c:#include <linux/msm_hdcp.h>
misc/msm_hdcp.c:#define DRIVER_NAME "msm_hdcp"
misc/msm_hdcp.c:struct msm_hdcp {
misc/msm_hdcp.c:void msm_hdcp_register_cb(struct device *dev, void *ctx,
misc/msm_hdcp.c:	struct msm_hdcp *hdcp = NULL;
misc/msm_hdcp.c:void msm_hdcp_notify_topology(struct device *dev)
misc/msm_hdcp.c:	struct msm_hdcp *hdcp = NULL;
misc/msm_hdcp.c:void msm_hdcp_cache_repeater_topology(struct device *dev,
misc/msm_hdcp.c:	struct msm_hdcp *hdcp = NULL;
misc/msm_hdcp.c:	struct msm_hdcp *hdcp = NULL;
misc/msm_hdcp.c:	struct msm_hdcp *hdcp = NULL;
misc/msm_hdcp.c:	struct msm_hdcp *hdcp = NULL;
misc/msm_hdcp.c:static struct attribute *msm_hdcp_fs_attrs[] = {
misc/msm_hdcp.c:static struct attribute_group msm_hdcp_fs_attr_group = {
misc/msm_hdcp.c:	.attrs = msm_hdcp_fs_attrs
misc/msm_hdcp.c:static int msm_hdcp_open(struct inode *inode, struct file *file)
misc/msm_hdcp.c:static int msm_hdcp_close(struct inode *inode, struct file *file)
misc/msm_hdcp.c:static const struct file_operations msm_hdcp_fops = {
misc/msm_hdcp.c:	.open = msm_hdcp_open,
misc/msm_hdcp.c:	.release = msm_hdcp_close,
misc/msm_hdcp.c:static const struct of_device_id msm_hdcp_dt_match[] = {
misc/msm_hdcp.c:	{ .compatible = "qcom,msm-hdcp",},
misc/msm_hdcp.c:MODULE_DEVICE_TABLE(of, msm_hdcp_dt_match);
misc/msm_hdcp.c:static int msm_hdcp_probe(struct platform_device *pdev)
misc/msm_hdcp.c:	struct msm_hdcp *hdcp;
misc/msm_hdcp.c:	hdcp = devm_kzalloc(&pdev->dev, sizeof(struct msm_hdcp), GFP_KERNEL);
misc/msm_hdcp.c:	cdev_init(&hdcp->cdev, &msm_hdcp_fops);
misc/msm_hdcp.c:	ret = sysfs_create_group(&hdcp->device->kobj, &msm_hdcp_fs_attr_group);
misc/msm_hdcp.c:		pr_err("unable to register msm_hdcp sysfs nodes\n");
misc/msm_hdcp.c:static int msm_hdcp_remove(struct platform_device *pdev)
misc/msm_hdcp.c:	struct msm_hdcp *hdcp;
misc/msm_hdcp.c:	&msm_hdcp_fs_attr_group);
misc/msm_hdcp.c:static struct platform_driver msm_hdcp_driver = {
misc/msm_hdcp.c:	.probe = msm_hdcp_probe,
misc/msm_hdcp.c:	.remove = msm_hdcp_remove,
misc/msm_hdcp.c:		.name = "msm_hdcp",
misc/msm_hdcp.c:		.of_match_table = msm_hdcp_dt_match,
misc/msm_hdcp.c:static int __init msm_hdcp_init(void)
misc/msm_hdcp.c:	return platform_driver_register(&msm_hdcp_driver);
misc/msm_hdcp.c:static void __exit msm_hdcp_exit(void)
misc/msm_hdcp.c:	return platform_driver_unregister(&msm_hdcp_driver);
misc/msm_hdcp.c:module_init(msm_hdcp_init);
misc/msm_hdcp.c:module_exit(msm_hdcp_exit);
misc/qseecom.c:#include <linux/msm_ion.h>
misc/qseecom.c:#include <linux/msm-bus.h>
misc/qseecom.c:#include <linux/msm-bus-board.h>
misc/qseecom.c:		perms_list[i] = msm_secure_get_vmid_perms(vmid_list[i]);
misc/qseecom.c:static int __qseecom_set_msm_bus_request(uint32_t mode)
misc/qseecom.c:		ret = msm_bus_scale_client_update_request(
misc/qseecom.c:		__qseecom_set_msm_bus_request(INACTIVE);
misc/qseecom.c:	ret = __qseecom_set_msm_bus_request(request_mode);
misc/qseecom.c:		pr_err("set msm bus request failed (%d),request_mode (%d)\n",
misc/qseecom.c:				ret = msm_bus_scale_client_update_request(
misc/qseecom.c:					msm_bus_scale_client_update_request(
misc/qseecom.c:				ret = msm_bus_scale_client_update_request(
misc/qseecom.c:					msm_bus_scale_client_update_request(
misc/qseecom.c:				ret = msm_bus_scale_client_update_request(
misc/qseecom.c:				ret = msm_bus_scale_client_update_request(
misc/qseecom.c:				ret = msm_bus_scale_client_update_request(
misc/qseecom.c:				ret = msm_bus_scale_client_update_request(
misc/qseecom.c:				__qseecom_set_msm_bus_request(INACTIVE);
misc/qseecom.c:	qseecom.qsee_perf_client = msm_bus_scale_register_client(
misc/qseecom.c:					msm_bus_cl_get_pdata(pdev));
misc/qseecom.c:	msm_bus_scale_client_update_request(qseecom.qsee_perf_client, 0);
misc/qseecom.c:	msm_bus_scale_unregister_client(qseecom.qsee_perf_client);
misc/qseecom.c:	ion_node = of_find_compatible_node(NULL, NULL, "qcom,msm-ion");
misc/qseecom.c:		pr_err("Failed to get qcom,msm-ion node\n");
misc/qseecom.c:		ret = msm_bus_scale_client_update_request(
misc/qseecom.c:		ret = msm_bus_scale_client_update_request(
mmc/core/host.c:	 * This is handled properly in sdhci-msm.c from msm-5.4 onwards.
mmc/host/Makefile:obj-$(CONFIG_MMC_SDHCI_MSM)		+= sdhci-msm.o
mmc/host/cqhci-crypto-qti.c:#include "sdhci-msm.h"
mmc/host/cqhci-crypto-qti.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/cqhci-crypto-qti.c:	if (!IS_ERR(msm_host->pclk) && !IS_ERR(msm_host->ice_clk)) {
mmc/host/cqhci-crypto-qti.c:		err = clk_prepare_enable(msm_host->pclk);
mmc/host/cqhci-crypto-qti.c:		err = clk_prepare_enable(msm_host->ice_clk);
mmc/host/cqhci-crypto-qti.c:	clk_disable_unprepare(msm_host->pclk);
mmc/host/cqhci-crypto-qti.c:	clk_disable_unprepare(msm_host->ice_clk);
mmc/host/cqhci-crypto-qti.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/cqhci-crypto-qti.c:	if (!IS_ERR(msm_host->pclk) && !IS_ERR(msm_host->ice_clk)) {
mmc/host/cqhci-crypto-qti.c:		err = clk_prepare_enable(msm_host->pclk);
mmc/host/cqhci-crypto-qti.c:		err = clk_prepare_enable(msm_host->ice_clk);
mmc/host/cqhci-crypto-qti.c:	clk_disable_unprepare(msm_host->pclk);
mmc/host/cqhci-crypto-qti.c:	clk_disable_unprepare(msm_host->ice_clk);
mmc/host/cqhci-crypto-qti.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/cqhci-crypto-qti.c:	cqhci_ice_memres = platform_get_resource_byname(msm_host->pdev,
mmc/host/cqhci-crypto-qti.c:	host->icemmio = devm_ioremap(&msm_host->pdev->dev,
mmc/host/cqhci-crypto-qti.c:	err = crypto_qti_init_crypto(&msm_host->pdev->dev,
mmc/host/cqhci.c:#include "sdhci-msm.h"
mmc/host/cqhci.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/cqhci.c:	sdhci_msm_pm_qos_cpu_vote(host,
mmc/host/cqhci.c:		msm_host->pdata->pm_qos_data.cmdq_latency, req->cpu);
mmc/host/cqhci.c:	sdhci_msm_pm_qos_cpu_unvote(host, req->cpu, true);
mmc/host/cqhci.c:		sdhci_msm_pm_qos_irq_unvote(sdhci_host, true);
mmc/host/cqhci.c:		sdhci_msm_pm_qos_irq_vote(host);
mmc/host/sdhci-msm.c: * drivers/mmc/host/sdhci-msm.c - Qualcomm Technologies, Inc. MSM SDHCI Platform
mmc/host/sdhci-msm.c:#include <linux/msm-bus.h>
mmc/host/sdhci-msm.c:#include "sdhci-msm.h"
mmc/host/sdhci-msm.c:struct sdhci_msm_offset {
mmc/host/sdhci-msm.c:struct sdhci_msm_offset sdhci_msm_offset_mci_removed = {
mmc/host/sdhci-msm.c:struct sdhci_msm_offset sdhci_msm_offset_mci_present = {
mmc/host/sdhci-msm.c:u8 sdhci_msm_readb_relaxed(struct sdhci_host *host, u32 offset)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (msm_host->mci_removed)
mmc/host/sdhci-msm.c:		base_addr = msm_host->core_mem;
mmc/host/sdhci-msm.c:u32 sdhci_msm_readl_relaxed(struct sdhci_host *host, u32 offset)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (msm_host->mci_removed)
mmc/host/sdhci-msm.c:		base_addr = msm_host->core_mem;
mmc/host/sdhci-msm.c:void sdhci_msm_writeb_relaxed(u8 val, struct sdhci_host *host, u32 offset)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (msm_host->mci_removed)
mmc/host/sdhci-msm.c:		base_addr = msm_host->core_mem;
mmc/host/sdhci-msm.c:void sdhci_msm_writel_relaxed(u32 val, struct sdhci_host *host, u32 offset)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (msm_host->mci_removed)
mmc/host/sdhci-msm.c:		base_addr = msm_host->core_mem;
mmc/host/sdhci-msm.c:static struct sdhci_msm_host *sdhci_slot[2];
mmc/host/sdhci-msm.c:	 * sdhci_msm_set_vdd_io_vol() function.
mmc/host/sdhci-msm.c:static unsigned int sdhci_msm_get_sup_clk_rate(struct sdhci_host *host,
mmc/host/sdhci-msm.c:static inline int msm_dll_poll_ck_out_en(struct sdhci_host *host,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG) & CORE_CK_OUT_EN);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG) & CORE_CK_OUT_EN);
mmc/host/sdhci-msm.c:static int msm_enable_cdr_cm_sdc4_dll(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:	rc = msm_dll_poll_ck_out_en(host, 0);
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG) | CORE_CK_OUT_EN),
mmc/host/sdhci-msm.c:		host->ioaddr + msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:	rc = msm_dll_poll_ck_out_en(host, 1);
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:		msm_host->en_auto_cmd21 = !!tmp;
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	return snprintf(buf, PAGE_SIZE, "%d\n", msm_host->en_auto_cmd21);
mmc/host/sdhci-msm.c:static int sdhci_msm_config_auto_tuning_cmd(struct sdhci_host *host,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:	if (!msm_host->en_auto_cmd21)
mmc/host/sdhci-msm.c:		rc = msm_enable_cdr_cm_sdc4_dll(host);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC) | val,
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC) & ~val,
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:static int msm_config_cm_dll_phase(struct sdhci_host *host, u8 phase)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:	rc = msm_dll_poll_ck_out_en(host, 0);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG)
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG) | CORE_CK_OUT_EN),
mmc/host/sdhci-msm.c:		host->ioaddr + msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:	rc = msm_dll_poll_ck_out_en(host, 1);
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:static int msm_find_most_appropriate_phase(struct sdhci_host *host,
mmc/host/sdhci-msm.c:static inline void msm_cm_dll_set_freq(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG)
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:static int msm_init_cm_dll(struct sdhci_host *host,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_VENDOR_SPEC) & CORE_CLK_PWRSAVE);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC)
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:	if (msm_host->use_updated_dll_reset) {
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG)
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG_2)
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG_2);
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG) | CORE_DLL_RST),
mmc/host/sdhci-msm.c:		host->ioaddr + msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG) | CORE_DLL_PDN),
mmc/host/sdhci-msm.c:		host->ioaddr + msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:	if (msm_host->use_updated_dll_reset) {
mmc/host/sdhci-msm.c:		u32 actual_clk = sdhci_msm_get_sup_clk_rate(host, host->clock);
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG_2)
mmc/host/sdhci-msm.c:			   msm_host_offset->CORE_DLL_CONFIG_2)
mmc/host/sdhci-msm.c:			   host->ioaddr + msm_host_offset->CORE_DLL_CONFIG_2);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG) & ~CORE_DLL_RST),
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG) & ~CORE_DLL_PDN),
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:	if (msm_host->use_updated_dll_reset) {
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG_2)
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG_2);
mmc/host/sdhci-msm.c:	if (msm_host->use_7nm_dll) {
mmc/host/sdhci-msm.c:		if (msm_host->dll_hsr) {
mmc/host/sdhci-msm.c:			writel_relaxed(msm_host->dll_hsr->dll_usr_ctl,
mmc/host/sdhci-msm.c:					msm_host_offset->CORE_DLL_USR_CTL);
mmc/host/sdhci-msm.c:			writel_relaxed(msm_host->dll_hsr->dll_config_3,
mmc/host/sdhci-msm.c:					msm_host_offset->CORE_DLL_CONFIG_3);
mmc/host/sdhci-msm.c:					msm_host_offset->CORE_DLL_USR_CTL);
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG_3);
mmc/host/sdhci-msm.c:	if (msm_host->dll_hsr) {
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG) |
mmc/host/sdhci-msm.c:			(msm_host->dll_hsr->dll_config & 0xffff)),
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG) | CORE_DLL_EN),
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG)
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:	if (msm_host->mmc->card
mmc/host/sdhci-msm.c:			&& !(msm_host->enhanced_strobe &&
mmc/host/sdhci-msm.c:				mmc_card_strobe(msm_host->mmc->card))) {
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_STATUS) & CORE_DLL_LOCK)) {
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:static int sdhci_msm_cdclp533_calibration(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DDR_200_CFG)
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DDR_200_CFG);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DDR_200_CFG)
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DDR_200_CFG);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DDR_200_CFG)
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DDR_200_CFG);
mmc/host/sdhci-msm.c:static int sdhci_msm_cm_dll_sdc4_calibration(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:	if (msm_host->dll_hsr && msm_host->dll_hsr->ddr_config) {
mmc/host/sdhci-msm.c:		writel_relaxed(msm_host->dll_hsr->ddr_config, host->ioaddr +
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DDR_CONFIG);
mmc/host/sdhci-msm.c:	} else if (msm_host->rclk_delay_fix) {
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DDR_CONFIG);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DDR_CONFIG_OLD);
mmc/host/sdhci-msm.c:	if (msm_host->enhanced_strobe && mmc_card_strobe(msm_host->mmc->card))
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DDR_200_CFG)
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DDR_200_CFG);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG_2)
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DLL_CONFIG_2);
mmc/host/sdhci-msm.c:		 msm_host_offset->CORE_DLL_STATUS,
mmc/host/sdhci-msm.c:	if (!msm_host->use_14lpp_dll)
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC3)
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC3);
mmc/host/sdhci-msm.c:static int sdhci_msm_enhanced_strobe(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (!msm_host->enhanced_strobe || !mmc_card_strobe(mmc->card)) {
mmc/host/sdhci-msm.c:	if (msm_host->calibration_done ||
mmc/host/sdhci-msm.c:	ret = msm_init_cm_dll(host, DLL_INIT_NORMAL);
mmc/host/sdhci-msm.c:	ret = sdhci_msm_cm_dll_sdc4_calibration(host);
mmc/host/sdhci-msm.c:		msm_host->calibration_done = true;
mmc/host/sdhci-msm.c:static int sdhci_msm_hs400_dll_calibration(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:	ret = msm_init_cm_dll(host, DLL_INIT_NORMAL);
mmc/host/sdhci-msm.c:	ret = msm_config_cm_dll_phase(host, msm_host->saved_tuning_phase);
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG)
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:	if (msm_host->use_cdclp533)
mmc/host/sdhci-msm.c:		ret = sdhci_msm_cdclp533_calibration(host);
mmc/host/sdhci-msm.c:		ret = sdhci_msm_cm_dll_sdc4_calibration(host);
mmc/host/sdhci-msm.c:static void sdhci_msm_set_mmc_drv_type(struct sdhci_host *host, u32 opcode,
mmc/host/sdhci-msm.c:void sdhci_msm_mm_dbg_configure(struct sdhci_host *host, u32 mask,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	struct platform_device *pdev = msm_host->pdev;
mmc/host/sdhci-msm.c:	sdhci_msm_mm_dbg_configure(host, mask, match, bit_shift, testbus);
mmc/host/sdhci-msm.c:void sdhci_msm_enter_dbg_mode(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	struct platform_device *pdev = msm_host->pdev;
mmc/host/sdhci-msm.c:	if (msm_host->minor < 2 || msm_host->debug_mode_enabled)
mmc/host/sdhci-msm.c:	if (msm_host->minor >= 2)
mmc/host/sdhci-msm.c:	msm_host->debug_mode_enabled = true;
mmc/host/sdhci-msm.c:void sdhci_msm_exit_dbg_mode(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	struct platform_device *pdev = msm_host->pdev;
mmc/host/sdhci-msm.c:	if (msm_host->minor  < 2 || !msm_host->debug_mode_enabled)
mmc/host/sdhci-msm.c:	msm_host->debug_mode_enabled = false;
mmc/host/sdhci-msm.c:int sdhci_msm_execute_tuning(struct sdhci_host *host, u32 opcode)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (msm_host->tuning_in_progress)
mmc/host/sdhci-msm.c:	sdhci_msm_exit_dbg_mode(host);
mmc/host/sdhci-msm.c:	msm_host->tuning_in_progress = true;
mmc/host/sdhci-msm.c:	if (msm_host->tuning_done && !msm_host->calibration_done &&
mmc/host/sdhci-msm.c:		rc = sdhci_msm_hs400_dll_calibration(host);
mmc/host/sdhci-msm.c:			msm_host->calibration_done = true;
mmc/host/sdhci-msm.c:	rc = msm_init_cm_dll(host, DLL_INIT_NORMAL);
mmc/host/sdhci-msm.c:		rc = msm_config_cm_dll_phase(host, phase);
mmc/host/sdhci-msm.c:			else if (msm_host->saved_tuning_phase !=
mmc/host/sdhci-msm.c:				last_good_phase = msm_host->saved_tuning_phase;
mmc/host/sdhci-msm.c:			rc = msm_config_cm_dll_phase(host, last_good_phase);
mmc/host/sdhci-msm.c:				sdhci_msm_set_mmc_drv_type(host, opcode,
mmc/host/sdhci-msm.c:		sdhci_msm_set_mmc_drv_type(host, opcode, 0);
mmc/host/sdhci-msm.c:		rc = msm_find_most_appropriate_phase(host, tuned_phases,
mmc/host/sdhci-msm.c:		rc = msm_config_cm_dll_phase(host, phase);
mmc/host/sdhci-msm.c:		msm_host->saved_tuning_phase = phase;
mmc/host/sdhci-msm.c:	sdhci_msm_enter_dbg_mode(host);
mmc/host/sdhci-msm.c:		msm_host->tuning_done = true;
mmc/host/sdhci-msm.c:	msm_host->tuning_in_progress = false;
mmc/host/sdhci-msm.c:static int sdhci_msm_setup_gpio(struct sdhci_msm_pltfm_data *pdata, bool enable)
mmc/host/sdhci-msm.c:	struct sdhci_msm_gpio_data *curr;
mmc/host/sdhci-msm.c:static int sdhci_msm_config_pinctrl_drv_type(struct sdhci_msm_pltfm_data *pdata,
mmc/host/sdhci-msm.c:static int sdhci_msm_setup_pinctrl(struct sdhci_msm_pltfm_data *pdata,
mmc/host/sdhci-msm.c:static int sdhci_msm_setup_pins(struct sdhci_msm_pltfm_data *pdata, bool enable)
mmc/host/sdhci-msm.c:		ret = sdhci_msm_setup_pinctrl(pdata, enable);
mmc/host/sdhci-msm.c:		ret = sdhci_msm_setup_gpio(pdata, enable);
mmc/host/sdhci-msm.c:static int sdhci_msm_dt_get_array(struct device *dev, const char *prop_name,
mmc/host/sdhci-msm.c:static int sdhci_msm_dt_parse_vreg_info(struct device *dev,
mmc/host/sdhci-msm.c:		struct sdhci_msm_reg_data **vreg_data, const char *vreg_name)
mmc/host/sdhci-msm.c:	struct sdhci_msm_reg_data *vreg;
mmc/host/sdhci-msm.c:static int sdhci_msm_parse_pinctrl_info(struct device *dev,
mmc/host/sdhci-msm.c:		struct sdhci_msm_pltfm_data *pdata)
mmc/host/sdhci-msm.c:static int sdhci_msm_dt_parse_gpio_info(struct device *dev,
mmc/host/sdhci-msm.c:		struct sdhci_msm_pltfm_data *pdata)
mmc/host/sdhci-msm.c:	struct sdhci_msm_pin_data *pin_data;
mmc/host/sdhci-msm.c:	ret = sdhci_msm_parse_pinctrl_info(dev, pdata);
mmc/host/sdhci-msm.c:				sizeof(struct sdhci_msm_gpio_data), GFP_KERNEL);
mmc/host/sdhci-msm.c:				sizeof(struct sdhci_msm_gpio), GFP_KERNEL);
mmc/host/sdhci-msm.c:static inline void parse_affine_irq(struct sdhci_msm_pltfm_data *pdata)
mmc/host/sdhci-msm.c:static inline void parse_affine_irq(struct sdhci_msm_pltfm_data *pdata) { }
mmc/host/sdhci-msm.c:static int sdhci_msm_pm_qos_parse_irq(struct device *dev,
mmc/host/sdhci-msm.c:		struct sdhci_msm_pltfm_data *pdata)
mmc/host/sdhci-msm.c:static int sdhci_msm_pm_qos_parse_cpu_groups(struct device *dev,
mmc/host/sdhci-msm.c:		struct sdhci_msm_pltfm_data *pdata)
mmc/host/sdhci-msm.c:static int sdhci_msm_pm_qos_parse_latency(struct device *dev, const char *name,
mmc/host/sdhci-msm.c:		int nr_groups, struct sdhci_msm_pm_qos_latency **latency)
mmc/host/sdhci-msm.c:	struct sdhci_msm_pm_qos_latency *values;
mmc/host/sdhci-msm.c:	values = kcalloc(nr_groups, sizeof(struct sdhci_msm_pm_qos_latency),
mmc/host/sdhci-msm.c:static void sdhci_msm_pm_qos_parse(struct device *dev,
mmc/host/sdhci-msm.c:				struct sdhci_msm_pltfm_data *pdata)
mmc/host/sdhci-msm.c:	if (sdhci_msm_pm_qos_parse_irq(dev, pdata))
mmc/host/sdhci-msm.c:	if (!sdhci_msm_pm_qos_parse_cpu_groups(dev, pdata)) {
mmc/host/sdhci-msm.c:			!sdhci_msm_pm_qos_parse_latency(dev,
mmc/host/sdhci-msm.c:			!sdhci_msm_pm_qos_parse_latency(dev,
mmc/host/sdhci-msm.c:static int sdhci_msm_dt_parse_hsr_info(struct device *dev,
mmc/host/sdhci-msm.c:		struct sdhci_msm_host *msm_host)
mmc/host/sdhci-msm.c:	if (sdhci_msm_dt_get_array(dev, "qcom,dll-hsr-list",
mmc/host/sdhci-msm.c:	dll_hsr_reg_count = sizeof(struct sdhci_msm_dll_hsr) / sizeof(u32);
mmc/host/sdhci-msm.c:		msm_host->dll_hsr = (struct sdhci_msm_dll_hsr *)dll_hsr_table;
mmc/host/sdhci-msm.c:	if (!msm_host->dll_hsr)
mmc/host/sdhci-msm.c:int sdhci_msm_parse_reset_data(struct device *dev,
mmc/host/sdhci-msm.c:			struct sdhci_msm_host *msm_host)
mmc/host/sdhci-msm.c:	msm_host->core_reset = devm_reset_control_get(dev,
mmc/host/sdhci-msm.c:	if (IS_ERR(msm_host->core_reset)) {
mmc/host/sdhci-msm.c:		ret = PTR_ERR(msm_host->core_reset);
mmc/host/sdhci-msm.c:		msm_host->core_reset = NULL;
mmc/host/sdhci-msm.c:static int sdhci_msm_parse_regulator_info(struct device *dev,
mmc/host/sdhci-msm.c:					struct sdhci_msm_pltfm_data *pdata)
mmc/host/sdhci-msm.c:						    sdhci_msm_slot_reg_data),
mmc/host/sdhci-msm.c:	if (sdhci_msm_dt_parse_vreg_info(dev, &pdata->vreg_data->vdd_data,
mmc/host/sdhci-msm.c:	if (sdhci_msm_dt_parse_vreg_info(dev,
mmc/host/sdhci-msm.c:struct sdhci_msm_pltfm_data *sdhci_msm_populate_pdata(struct device *dev,
mmc/host/sdhci-msm.c:						struct sdhci_msm_host *msm_host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_pltfm_data *pdata = NULL;
mmc/host/sdhci-msm.c:	if (sdhci_msm_dt_get_array(dev, "qcom,clk-rates",
mmc/host/sdhci-msm.c:	if (!sdhci_msm_dt_get_array(dev, "qcom,bus-aggr-clk-rates",
mmc/host/sdhci-msm.c:	if (!sdhci_msm_dt_get_array(dev, "qcom,ice-clk-rates",
mmc/host/sdhci-msm.c:	if (sdhci_msm_dt_get_array(dev, "qcom,devfreq,freq-table",
mmc/host/sdhci-msm.c:			&msm_host->mmc->clk_scaling.pltfm_freq_table,
mmc/host/sdhci-msm.c:			&msm_host->mmc->clk_scaling.pltfm_freq_table_sz, 0))
mmc/host/sdhci-msm.c:	else if (!msm_host->mmc->clk_scaling.pltfm_freq_table ||
mmc/host/sdhci-msm.c:			!msm_host->mmc->clk_scaling.pltfm_freq_table_sz)
mmc/host/sdhci-msm.c:			msm_host->mmc->clk_scaling.lower_bus_speed_mode |=
mmc/host/sdhci-msm.c:	if (sdhci_msm_parse_regulator_info(dev, pdata))
mmc/host/sdhci-msm.c:	if (sdhci_msm_dt_parse_gpio_info(dev, pdata)) {
mmc/host/sdhci-msm.c:	msm_host->vbias_skip_wa =
mmc/host/sdhci-msm.c:	sdhci_msm_pm_qos_parse(dev, pdata);
mmc/host/sdhci-msm.c:		msm_host->core_3_0v_support = true;
mmc/host/sdhci-msm.c:	msm_host->regs_restore.is_supported =
mmc/host/sdhci-msm.c:	if (sdhci_msm_dt_parse_hsr_info(dev, msm_host))
mmc/host/sdhci-msm.c:	ret = sdhci_msm_parse_reset_data(dev, msm_host);
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	bw = msm_host->clk_rate;
mmc/host/sdhci-msm.c:static int sdhci_msm_bus_get_vote_for_bw(struct sdhci_msm_host *host,
mmc/host/sdhci-msm.c:	if (host->msm_bus_vote.is_max_bw_needed && bw)
mmc/host/sdhci-msm.c:		return host->msm_bus_vote.max_bw_vote;
mmc/host/sdhci-msm.c: * Caller of this function should also ensure that msm bus client
mmc/host/sdhci-msm.c:static inline int sdhci_msm_bus_set_vote(struct sdhci_msm_host *msm_host,
mmc/host/sdhci-msm.c:	struct sdhci_host *host =  platform_get_drvdata(msm_host->pdev);
mmc/host/sdhci-msm.c:	if (vote != msm_host->msm_bus_vote.curr_vote) {
mmc/host/sdhci-msm.c:		rc = msm_bus_scale_client_update_request(
mmc/host/sdhci-msm.c:				msm_host->msm_bus_vote.client_handle, vote);
mmc/host/sdhci-msm.c:			pr_err("%s: msm_bus_scale_client_update_request() failed: bus_client_handle=0x%x, vote=%d, err=%d\n",
mmc/host/sdhci-msm.c:				msm_host->msm_bus_vote.client_handle, vote, rc);
mmc/host/sdhci-msm.c:		msm_host->msm_bus_vote.curr_vote = vote;
mmc/host/sdhci-msm.c:static u32 sdhci_msm_cqe_irq(struct sdhci_host *host, u32 intmask)
mmc/host/sdhci-msm.c:void sdhci_msm_cqe_enable(struct mmc_host *mmc)
mmc/host/sdhci-msm.c:void sdhci_msm_cqe_disable(struct mmc_host *mmc, bool recovery)
mmc/host/sdhci-msm.c:void sdhci_msm_cqe_sdhci_dumpregs(struct mmc_host *mmc)
mmc/host/sdhci-msm.c: * sdhci_msm_enhanced_strobe_mask :-
mmc/host/sdhci-msm.c:static void sdhci_msm_enhanced_strobe_mask(struct mmc_host *mmc, bool set)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:	if (!msm_host->enhanced_strobe ||
mmc/host/sdhci-msm.c:			!mmc_card_strobe(msm_host->mmc->card)) {
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC3)
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_VENDOR_SPEC3);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC3)
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_VENDOR_SPEC3);
mmc/host/sdhci-msm.c:static const struct cqhci_host_ops sdhci_msm_cqhci_ops = {
mmc/host/sdhci-msm.c:	.enable		= sdhci_msm_cqe_enable,
mmc/host/sdhci-msm.c:	.disable	= sdhci_msm_cqe_disable,
mmc/host/sdhci-msm.c:	.dumpregs		= sdhci_msm_cqe_sdhci_dumpregs,
mmc/host/sdhci-msm.c:	.enhanced_strobe_mask = sdhci_msm_enhanced_strobe_mask,
mmc/host/sdhci-msm.c:static int sdhci_msm_cqe_add_host(struct sdhci_host *host,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	msm_host->mmc->caps2 |= MMC_CAP2_CQE;
mmc/host/sdhci-msm.c:	cq_host->ops = &sdhci_msm_cqhci_ops;
mmc/host/sdhci-msm.c:	msm_host->cq_host = cq_host;
mmc/host/sdhci-msm.c:static void sdhci_msm_cqe_add_host(struct sdhci_host *host,
mmc/host/sdhci-msm.c:static void sdhci_msm_bus_get_and_set_vote(struct sdhci_host *host,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	vote = sdhci_msm_bus_get_vote_for_bw(msm_host, bw);
mmc/host/sdhci-msm.c:	sdhci_msm_bus_set_vote(msm_host, vote, &flags);
mmc/host/sdhci-msm.c:static int sdhci_msm_bus_register(struct sdhci_msm_host *host,
mmc/host/sdhci-msm.c:	struct msm_bus_scale_pdata *bus_pdata;
mmc/host/sdhci-msm.c:	struct sdhci_msm_bus_voting_data *data;
mmc/host/sdhci-msm.c:		sizeof(struct sdhci_msm_bus_voting_data), GFP_KERNEL);
mmc/host/sdhci-msm.c:	data->bus_pdata = msm_bus_cl_get_pdata(pdev);
mmc/host/sdhci-msm.c:		rc = sdhci_msm_dt_get_array(dev, "qcom,bus-bw-vectors-bps",
mmc/host/sdhci-msm.c:		host->msm_bus_vote.client_handle =
mmc/host/sdhci-msm.c:				msm_bus_scale_register_client(bus_pdata);
mmc/host/sdhci-msm.c:		if (!host->msm_bus_vote.client_handle) {
mmc/host/sdhci-msm.c:			dev_err(&pdev->dev, "msm_bus_scale_register_client()\n");
mmc/host/sdhci-msm.c:		host->msm_bus_vote.min_bw_vote =
mmc/host/sdhci-msm.c:				sdhci_msm_bus_get_vote_for_bw(host, 0);
mmc/host/sdhci-msm.c:		host->msm_bus_vote.max_bw_vote =
mmc/host/sdhci-msm.c:				sdhci_msm_bus_get_vote_for_bw(host, UINT_MAX);
mmc/host/sdhci-msm.c:static void sdhci_msm_bus_unregister(struct sdhci_msm_host *host)
mmc/host/sdhci-msm.c:	if (host->msm_bus_vote.client_handle)
mmc/host/sdhci-msm.c:		msm_bus_scale_unregister_client(
mmc/host/sdhci-msm.c:			host->msm_bus_vote.client_handle);
mmc/host/sdhci-msm.c:static void sdhci_msm_bus_voting(struct sdhci_host *host, u32 enable)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (!msm_host->msm_bus_vote.client_handle)
mmc/host/sdhci-msm.c:		sdhci_msm_bus_get_and_set_vote(host, bw);
mmc/host/sdhci-msm.c:		sdhci_msm_bus_get_and_set_vote(host, 0);
mmc/host/sdhci-msm.c:static int sdhci_msm_vreg_init_reg(struct device *dev,
mmc/host/sdhci-msm.c:					struct sdhci_msm_reg_data *vreg)
mmc/host/sdhci-msm.c:static void sdhci_msm_vreg_deinit_reg(struct sdhci_msm_reg_data *vreg)
mmc/host/sdhci-msm.c:static int sdhci_msm_vreg_set_optimum_mode(struct sdhci_msm_reg_data
mmc/host/sdhci-msm.c:static int sdhci_msm_vreg_set_voltage(struct sdhci_msm_reg_data *vreg,
mmc/host/sdhci-msm.c:static int sdhci_msm_vreg_enable(struct sdhci_msm_reg_data *vreg)
mmc/host/sdhci-msm.c:	ret = sdhci_msm_vreg_set_optimum_mode(vreg, vreg->hpm_uA);
mmc/host/sdhci-msm.c:		ret = sdhci_msm_vreg_set_voltage(vreg, vreg->low_vol_level,
mmc/host/sdhci-msm.c:static int sdhci_msm_vreg_disable(struct sdhci_msm_reg_data *vreg)
mmc/host/sdhci-msm.c:		ret = sdhci_msm_vreg_set_optimum_mode(vreg, 0);
mmc/host/sdhci-msm.c:		ret = sdhci_msm_vreg_set_voltage(vreg, 0, vreg->high_vol_level);
mmc/host/sdhci-msm.c:			ret = sdhci_msm_vreg_set_optimum_mode(vreg,
mmc/host/sdhci-msm.c:static int sdhci_msm_setup_vreg(struct sdhci_msm_pltfm_data *pdata,
mmc/host/sdhci-msm.c:	struct sdhci_msm_slot_reg_data *curr_slot;
mmc/host/sdhci-msm.c:	struct sdhci_msm_reg_data *vreg_table[2];
mmc/host/sdhci-msm.c:				ret = sdhci_msm_vreg_enable(vreg_table[i]);
mmc/host/sdhci-msm.c:				ret = sdhci_msm_vreg_disable(vreg_table[i]);
mmc/host/sdhci-msm.c:static int sdhci_msm_vreg_init(struct device *dev,
mmc/host/sdhci-msm.c:				struct sdhci_msm_pltfm_data *pdata,
mmc/host/sdhci-msm.c:	struct sdhci_msm_slot_reg_data *curr_slot;
mmc/host/sdhci-msm.c:	struct sdhci_msm_reg_data *curr_vdd_reg, *curr_vdd_io_reg;
mmc/host/sdhci-msm.c:		ret = sdhci_msm_vreg_init_reg(dev, curr_vdd_reg);
mmc/host/sdhci-msm.c:		ret = sdhci_msm_vreg_init_reg(dev, curr_vdd_io_reg);
mmc/host/sdhci-msm.c:		sdhci_msm_vreg_deinit_reg(curr_vdd_io_reg);
mmc/host/sdhci-msm.c:		sdhci_msm_vreg_deinit_reg(curr_vdd_reg);
mmc/host/sdhci-msm.c:static int sdhci_msm_set_vdd_io_vol(struct sdhci_msm_pltfm_data *pdata,
mmc/host/sdhci-msm.c:	struct sdhci_msm_reg_data *vdd_io_reg;
mmc/host/sdhci-msm.c:		ret = sdhci_msm_vreg_set_voltage(vdd_io_reg, set_level,
mmc/host/sdhci-msm.c:static void sdhci_msm_cfg_sdiowakeup_gpio_irq(struct sdhci_host *host,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (enable && !msm_host->is_sdiowakeup_enabled)
mmc/host/sdhci-msm.c:		enable_irq(msm_host->pdata->sdiowakeup_irq);
mmc/host/sdhci-msm.c:	else if (!enable && msm_host->is_sdiowakeup_enabled)
mmc/host/sdhci-msm.c:		disable_irq_nosync(msm_host->pdata->sdiowakeup_irq);
mmc/host/sdhci-msm.c:		dev_warn(&msm_host->pdev->dev, "%s: wakeup to config: %d curr: %d\n",
mmc/host/sdhci-msm.c:			__func__, enable, msm_host->is_sdiowakeup_enabled);
mmc/host/sdhci-msm.c:	msm_host->is_sdiowakeup_enabled = enable;
mmc/host/sdhci-msm.c:static irqreturn_t sdhci_msm_testbus_trigger_irq(int irq, void *data)
mmc/host/sdhci-msm.c:static irqreturn_t sdhci_msm_sdiowakeup_irq(int irq, void *data)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	sdhci_msm_cfg_sdiowakeup_gpio_irq(host, false);
mmc/host/sdhci-msm.c:	msm_host->sdio_pending_processing = true;
mmc/host/sdhci-msm.c:void sdhci_msm_dump_pwr_ctrl_regs(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:	struct irq_desc *pwr_irq_desc = irq_to_desc(msm_host->pwr_irq);
mmc/host/sdhci-msm.c:		sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_PWRCTL_STATUS),
mmc/host/sdhci-msm.c:		sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_PWRCTL_MASK),
mmc/host/sdhci-msm.c:		sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_PWRCTL_CTL), irq_flags);
mmc/host/sdhci-msm.c:		sdhci_msm_readb_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_PWRCTL_STATUS),
mmc/host/sdhci-msm.c:		sdhci_msm_readb_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_PWRCTL_MASK),
mmc/host/sdhci-msm.c:		sdhci_msm_readb_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_PWRCTL_CTL), irq_flags);
mmc/host/sdhci-msm.c:static int sdhci_msm_clear_pwrctl_status(struct sdhci_host *host, u8 value)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset = msm_host->offset;
mmc/host/sdhci-msm.c:			sdhci_msm_dump_pwr_ctrl_regs(host);
mmc/host/sdhci-msm.c:		sdhci_msm_writeb_relaxed(value, host,
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_PWRCTL_CLEAR);
mmc/host/sdhci-msm.c:	} while (value & sdhci_msm_readb_relaxed(host,
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_PWRCTL_STATUS));
mmc/host/sdhci-msm.c:static void sdhci_msm_vbias_bypass_wa(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:static irqreturn_t sdhci_msm_pwr_irq(int irq, void *data)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:	irq_status = sdhci_msm_readb_relaxed(host,
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_PWRCTL_STATUS);
mmc/host/sdhci-msm.c:		mmc_hostname(msm_host->mmc), irq, irq_status);
mmc/host/sdhci-msm.c:	sdhci_msm_clear_pwrctl_status(host, irq_status);
mmc/host/sdhci-msm.c:		sdhci_msm_writeb_relaxed(irq_ack, host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_PWRCTL_CTL);
mmc/host/sdhci-msm.c:		complete(&msm_host->pwr_irq_completion);
mmc/host/sdhci-msm.c:		ret = sdhci_msm_setup_vreg(msm_host->pdata, true, false);
mmc/host/sdhci-msm.c:			ret = sdhci_msm_setup_pins(msm_host->pdata, true);
mmc/host/sdhci-msm.c:			ret |= sdhci_msm_set_vdd_io_vol(msm_host->pdata,
mmc/host/sdhci-msm.c:		if (msm_host->pltfm_init_done)
mmc/host/sdhci-msm.c:			ret = sdhci_msm_setup_vreg(msm_host->pdata,
mmc/host/sdhci-msm.c:			ret = sdhci_msm_setup_pins(msm_host->pdata, false);
mmc/host/sdhci-msm.c:			ret |= sdhci_msm_set_vdd_io_vol(msm_host->pdata,
mmc/host/sdhci-msm.c:		ret = sdhci_msm_set_vdd_io_vol(msm_host->pdata, VDD_IO_LOW, 0);
mmc/host/sdhci-msm.c:		ret = sdhci_msm_set_vdd_io_vol(msm_host->pdata, VDD_IO_HIGH, 0);
mmc/host/sdhci-msm.c:	sdhci_msm_writeb_relaxed(irq_ack, host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_PWRCTL_CTL);
mmc/host/sdhci-msm.c:			(msm_host->caps_0 & CORE_3_0V_SUPPORT) &&
mmc/host/sdhci-msm.c:			!msm_host->core_3_0v_support) {
mmc/host/sdhci-msm.c:		if (msm_host->vbias_skip_wa)
mmc/host/sdhci-msm.c:			sdhci_msm_vbias_bypass_wa(host);
mmc/host/sdhci-msm.c:					msm_host_offset->CORE_VENDOR_SPEC) &
mmc/host/sdhci-msm.c:					msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:			(msm_host->caps_0 & CORE_1_8V_SUPPORT)) {
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC) |
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:		mmc_hostname(msm_host->mmc), irq, ret, irq_ack);
mmc/host/sdhci-msm.c:		msm_host->curr_pwr_state = pwr_state;
mmc/host/sdhci-msm.c:		msm_host->curr_io_level = io_level;
mmc/host/sdhci-msm.c:	complete(&msm_host->pwr_irq_completion);
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:			msm_host->msm_bus_vote.is_max_bw_needed);
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:		msm_host->msm_bus_vote.is_max_bw_needed = !!value;
mmc/host/sdhci-msm.c:static void sdhci_msm_check_power_status(struct sdhci_host *host, u32 req_type)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:			msm_host->curr_pwr_state, msm_host->curr_io_level);
mmc/host/sdhci-msm.c:	if (!msm_host->mci_removed)
mmc/host/sdhci-msm.c:		io_sig_sts = sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_GENERICS);
mmc/host/sdhci-msm.c:	if ((req_type & msm_host->curr_pwr_state) ||
mmc/host/sdhci-msm.c:			(req_type & msm_host->curr_io_level))
mmc/host/sdhci-msm.c:		init_completion(&msm_host->pwr_irq_completion);
mmc/host/sdhci-msm.c:	else if (!wait_for_completion_timeout(&msm_host->pwr_irq_completion,
mmc/host/sdhci-msm.c:		sdhci_msm_dump_pwr_ctrl_regs(host);
mmc/host/sdhci-msm.c:static void sdhci_msm_toggle_cdr(struct sdhci_host *host, bool enable)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:static unsigned int sdhci_msm_max_segs(void)
mmc/host/sdhci-msm.c:static unsigned int sdhci_msm_get_min_clock(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	return msm_host->pdata->sup_clk_table[0];
mmc/host/sdhci-msm.c:static unsigned int sdhci_msm_get_max_clock(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	int max_clk_index = msm_host->pdata->sup_clk_cnt;
mmc/host/sdhci-msm.c:	return msm_host->pdata->sup_clk_table[max_clk_index - 1];
mmc/host/sdhci-msm.c:static unsigned int sdhci_msm_get_sup_clk_rate(struct sdhci_host *host,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (req_clk < sdhci_msm_get_min_clock(host)) {
mmc/host/sdhci-msm.c:		sel_clk = sdhci_msm_get_min_clock(host);
mmc/host/sdhci-msm.c:	for (cnt = 0; cnt < msm_host->pdata->sup_clk_cnt; cnt++) {
mmc/host/sdhci-msm.c:		if (msm_host->pdata->sup_clk_table[cnt] > req_clk) {
mmc/host/sdhci-msm.c:		} else if (msm_host->pdata->sup_clk_table[cnt] == req_clk) {
mmc/host/sdhci-msm.c:			sel_clk = msm_host->pdata->sup_clk_table[cnt];
mmc/host/sdhci-msm.c:		sel_clk = msm_host->pdata->sup_clk_table[cnt];
mmc/host/sdhci-msm.c:static long sdhci_msm_get_bus_aggr_clk_rate(struct sdhci_host *host,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (msm_host->pdata->bus_clk_cnt != msm_host->pdata->sup_clk_cnt) {
mmc/host/sdhci-msm.c:				(unsigned int)msm_host->pdata->bus_clk_cnt,
mmc/host/sdhci-msm.c:				(unsigned int)msm_host->pdata->sup_clk_cnt);
mmc/host/sdhci-msm.c:		return msm_host->pdata->bus_clk_table[0];
mmc/host/sdhci-msm.c:	if (apps_clk == sdhci_msm_get_min_clock(host)) {
mmc/host/sdhci-msm.c:		sel_clk = msm_host->pdata->bus_clk_table[0];
mmc/host/sdhci-msm.c:	for (cnt = 0; cnt < msm_host->pdata->bus_clk_cnt; cnt++) {
mmc/host/sdhci-msm.c:		if (msm_host->pdata->sup_clk_table[cnt] > apps_clk)
mmc/host/sdhci-msm.c:		sel_clk = msm_host->pdata->bus_clk_table[cnt];
mmc/host/sdhci-msm.c:static void sdhci_msm_registers_save(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:	if (!msm_host->regs_restore.is_supported &&
mmc/host/sdhci-msm.c:			!msm_host->reg_store)
mmc/host/sdhci-msm.c:	msm_host->regs_restore.vendor_func = readl_relaxed(host->ioaddr +
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.vendor_pwrctl_mask =
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_PWRCTL_MASK);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.vendor_func2 =
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_VENDOR_SPEC_FUNC2);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.vendor_func3 =
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_VENDOR_SPEC3);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.hc_2c_2e =
mmc/host/sdhci-msm.c:	msm_host->regs_restore.hc_3c_3e =
mmc/host/sdhci-msm.c:	msm_host->regs_restore.vendor_pwrctl_ctl =
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_PWRCTL_CTL);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.hc_38_3a =
mmc/host/sdhci-msm.c:	msm_host->regs_restore.hc_34_36 =
mmc/host/sdhci-msm.c:	msm_host->regs_restore.hc_28_2a =
mmc/host/sdhci-msm.c:	msm_host->regs_restore.vendor_caps_0 =
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_VENDOR_SPEC_CAPABILITIES0);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.hc_caps_1 =
mmc/host/sdhci-msm.c:	msm_host->regs_restore.testbus_config = readl_relaxed(host->ioaddr +
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_TESTBUS_CONFIG);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.dll_config = readl_relaxed(host->ioaddr +
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.dll_config2 = readl_relaxed(host->ioaddr +
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG_2);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.dll_config = readl_relaxed(host->ioaddr +
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.dll_config2 = readl_relaxed(host->ioaddr +
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG_2);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.dll_config3 = readl_relaxed(host->ioaddr +
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_CONFIG_3);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.dll_usr_ctl = readl_relaxed(host->ioaddr +
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_DLL_USR_CTL);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.is_valid = true;
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_PWRCTL_MASK));
mmc/host/sdhci-msm.c:static void sdhci_msm_registers_restore(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:	if ((!msm_host->regs_restore.is_supported ||
mmc/host/sdhci-msm.c:		!msm_host->regs_restore.is_valid) &&
mmc/host/sdhci-msm.c:		!msm_host->reg_store)
mmc/host/sdhci-msm.c:	writel_relaxed(0, host->ioaddr + msm_host_offset->CORE_PWRCTL_MASK);
mmc/host/sdhci-msm.c:	writel_relaxed(msm_host->regs_restore.vendor_func, host->ioaddr +
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:	writel_relaxed(msm_host->regs_restore.vendor_func2,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC_FUNC2);
mmc/host/sdhci-msm.c:	writel_relaxed(msm_host->regs_restore.vendor_func3,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC3);
mmc/host/sdhci-msm.c:	sdhci_writel(host, msm_host->regs_restore.hc_2c_2e,
mmc/host/sdhci-msm.c:	sdhci_writel(host, msm_host->regs_restore.hc_3c_3e,
mmc/host/sdhci-msm.c:	sdhci_writel(host, msm_host->regs_restore.hc_38_3a,
mmc/host/sdhci-msm.c:	sdhci_writel(host, msm_host->regs_restore.hc_34_36,
mmc/host/sdhci-msm.c:	sdhci_writel(host, msm_host->regs_restore.hc_28_2a,
mmc/host/sdhci-msm.c:	writel_relaxed(msm_host->regs_restore.vendor_caps_0,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC_CAPABILITIES0);
mmc/host/sdhci-msm.c:	sdhci_writel(host, msm_host->regs_restore.hc_caps_1,
mmc/host/sdhci-msm.c:	writel_relaxed(msm_host->regs_restore.testbus_config, host->ioaddr +
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_TESTBUS_CONFIG);
mmc/host/sdhci-msm.c:	msm_host->regs_restore.is_valid = false;
mmc/host/sdhci-msm.c:	irq_status = sdhci_msm_readb_relaxed(host,
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_PWRCTL_STATUS);
mmc/host/sdhci-msm.c:	sdhci_msm_clear_pwrctl_status(host, irq_status);
mmc/host/sdhci-msm.c:	writel_relaxed(msm_host->regs_restore.vendor_pwrctl_ctl,
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_PWRCTL_CTL);
mmc/host/sdhci-msm.c:	writel_relaxed(msm_host->regs_restore.vendor_pwrctl_mask,
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_PWRCTL_MASK);
mmc/host/sdhci-msm.c:		writel_relaxed(msm_host->regs_restore.dll_config2,
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DLL_CONFIG_2);
mmc/host/sdhci-msm.c:		writel_relaxed(msm_host->regs_restore.dll_config3,
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DLL_CONFIG_3);
mmc/host/sdhci-msm.c:		writel_relaxed(msm_host->regs_restore.dll_usr_ctl,
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DLL_USR_CTL);
mmc/host/sdhci-msm.c:		writel_relaxed(msm_host->regs_restore.dll_config &
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:		msm_init_cm_dll(host, DLL_INIT_FROM_CX_COLLAPSE_EXIT);
mmc/host/sdhci-msm.c:		msm_config_cm_dll_phase(host, msm_host->saved_tuning_phase);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_PWRCTL_MASK));
mmc/host/sdhci-msm.c:static int sdhci_msm_enable_controller_clock(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (atomic_read(&msm_host->controller_clock))
mmc/host/sdhci-msm.c:	sdhci_msm_bus_voting(host, 1);
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->pclk)) {
mmc/host/sdhci-msm.c:		rc = clk_prepare_enable(msm_host->pclk);
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->bus_aggr_clk)) {
mmc/host/sdhci-msm.c:		rc = clk_prepare_enable(msm_host->bus_aggr_clk);
mmc/host/sdhci-msm.c:	rc = clk_prepare_enable(msm_host->clk);
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->ice_clk)) {
mmc/host/sdhci-msm.c:		rc = clk_prepare_enable(msm_host->ice_clk);
mmc/host/sdhci-msm.c:	atomic_set(&msm_host->controller_clock, 1);
mmc/host/sdhci-msm.c:	sdhci_msm_registers_restore(host);
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->clk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->clk);
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->bus_aggr_clk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->bus_aggr_clk);
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->pclk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->pclk);
mmc/host/sdhci-msm.c:	sdhci_msm_bus_voting(host, 0);
mmc/host/sdhci-msm.c:static void sdhci_msm_disable_controller_clock(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (atomic_read(&msm_host->controller_clock)) {
mmc/host/sdhci-msm.c:		sdhci_msm_registers_save(host);
mmc/host/sdhci-msm.c:		if (!IS_ERR(msm_host->clk))
mmc/host/sdhci-msm.c:			clk_disable_unprepare(msm_host->clk);
mmc/host/sdhci-msm.c:		if (!IS_ERR(msm_host->bus_aggr_clk))
mmc/host/sdhci-msm.c:			clk_disable_unprepare(msm_host->bus_aggr_clk);
mmc/host/sdhci-msm.c:		if (!IS_ERR(msm_host->pclk))
mmc/host/sdhci-msm.c:			clk_disable_unprepare(msm_host->pclk);
mmc/host/sdhci-msm.c:		if (!IS_ERR(msm_host->ice_clk))
mmc/host/sdhci-msm.c:			clk_disable_unprepare(msm_host->ice_clk);
mmc/host/sdhci-msm.c:		sdhci_msm_bus_voting(host, 0);
mmc/host/sdhci-msm.c:		atomic_set(&msm_host->controller_clock, 0);
mmc/host/sdhci-msm.c:static int sdhci_msm_prepare_clocks(struct sdhci_host *host, bool enable)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (enable && !atomic_read(&msm_host->clks_on)) {
mmc/host/sdhci-msm.c:		if (atomic_read(&msm_host->controller_clock))
mmc/host/sdhci-msm.c:			sdhci_msm_bus_voting(host, 1);
mmc/host/sdhci-msm.c:		rc = sdhci_msm_enable_controller_clock(host);
mmc/host/sdhci-msm.c:		if (!IS_ERR_OR_NULL(msm_host->bus_clk)) {
mmc/host/sdhci-msm.c:			rc = clk_prepare_enable(msm_host->bus_clk);
mmc/host/sdhci-msm.c:		if (!IS_ERR(msm_host->ff_clk)) {
mmc/host/sdhci-msm.c:			rc = clk_prepare_enable(msm_host->ff_clk);
mmc/host/sdhci-msm.c:		if (!IS_ERR(msm_host->sleep_clk)) {
mmc/host/sdhci-msm.c:			rc = clk_prepare_enable(msm_host->sleep_clk);
mmc/host/sdhci-msm.c:	} else if (!enable && atomic_read(&msm_host->clks_on)) {
mmc/host/sdhci-msm.c:		if (!IS_ERR_OR_NULL(msm_host->sleep_clk))
mmc/host/sdhci-msm.c:			clk_disable_unprepare(msm_host->sleep_clk);
mmc/host/sdhci-msm.c:		if (!IS_ERR_OR_NULL(msm_host->ff_clk))
mmc/host/sdhci-msm.c:			clk_disable_unprepare(msm_host->ff_clk);
mmc/host/sdhci-msm.c:		if (!IS_ERR_OR_NULL(msm_host->bus_clk))
mmc/host/sdhci-msm.c:			clk_disable_unprepare(msm_host->bus_clk);
mmc/host/sdhci-msm.c:		sdhci_msm_disable_controller_clock(host);
mmc/host/sdhci-msm.c:	atomic_set(&msm_host->clks_on, enable);
mmc/host/sdhci-msm.c:	if (!IS_ERR_OR_NULL(msm_host->ff_clk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->ff_clk);
mmc/host/sdhci-msm.c:	if (!IS_ERR_OR_NULL(msm_host->bus_clk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->bus_clk);
mmc/host/sdhci-msm.c:	if (!IS_ERR_OR_NULL(msm_host->clk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->clk);
mmc/host/sdhci-msm.c:	if (!IS_ERR_OR_NULL(msm_host->bus_aggr_clk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->bus_aggr_clk);
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->ice_clk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->ice_clk);
mmc/host/sdhci-msm.c:	if (!IS_ERR_OR_NULL(msm_host->pclk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->pclk);
mmc/host/sdhci-msm.c:	atomic_set(&msm_host->controller_clock, 0);
mmc/host/sdhci-msm.c:		sdhci_msm_bus_voting(host, 0);
mmc/host/sdhci-msm.c:static void sdhci_msm_toggle_fifo_write_clk(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:	if (msm_host->tuning_done ||
mmc/host/sdhci-msm.c:			msm_host->enhanced_strobe)) {
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG_3))
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG_3);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG_3))
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG_3);
mmc/host/sdhci-msm.c:static void sdhci_msm_set_clock(struct sdhci_host *host, unsigned int clock)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC) &
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:		sdhci_msm_prepare_clocks(host, false);
mmc/host/sdhci-msm.c:	rc = sdhci_msm_prepare_clocks(host, true);
mmc/host/sdhci-msm.c:	msm_host_offset->CORE_VENDOR_SPEC) & CORE_CLK_PWRSAVE);
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC)
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC)
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:	sup_clock = sdhci_msm_get_sup_clk_rate(host, clock);
mmc/host/sdhci-msm.c:		sup_clock = sdhci_msm_get_sup_clk_rate(host,
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC)
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:		if ((msm_host->tuning_done ||
mmc/host/sdhci-msm.c:				 msm_host->enhanced_strobe)) &&
mmc/host/sdhci-msm.c:				!msm_host->calibration_done) {
mmc/host/sdhci-msm.c:					msm_host_offset->CORE_VENDOR_SPEC)
mmc/host/sdhci-msm.c:					msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:		sdhci_msm_toggle_fifo_write_clk(host);
mmc/host/sdhci-msm.c:		if (!host->mmc->ios.old_rate && !msm_host->use_cdclp533) {
mmc/host/sdhci-msm.c:						msm_host->enhanced_strobe) {
mmc/host/sdhci-msm.c:					msm_host_offset->CORE_DLL_STATUS,
mmc/host/sdhci-msm.c:					msm_host_offset->CORE_DLL_STATUS,
mmc/host/sdhci-msm.c:		if (!msm_host->use_cdclp533)
mmc/host/sdhci-msm.c:					msm_host_offset->CORE_VENDOR_SPEC3)
mmc/host/sdhci-msm.c:					msm_host_offset->CORE_VENDOR_SPEC3);
mmc/host/sdhci-msm.c:					msm_host_offset->CORE_VENDOR_SPEC)
mmc/host/sdhci-msm.c:					msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC)
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:	if (sup_clock != msm_host->clk_rate) {
mmc/host/sdhci-msm.c:		rc = clk_set_rate(msm_host->clk, sup_clock);
mmc/host/sdhci-msm.c:		msm_host->clk_rate = sup_clock;
mmc/host/sdhci-msm.c:		if (!IS_ERR(msm_host->bus_aggr_clk) &&
mmc/host/sdhci-msm.c:				msm_host->pdata->bus_clk_cnt) {
mmc/host/sdhci-msm.c:			bus_clk_rate = sdhci_msm_get_bus_aggr_clk_rate(host,
mmc/host/sdhci-msm.c:				rc = clk_set_rate(msm_host->bus_aggr_clk,
mmc/host/sdhci-msm.c:		rc = sdhci_msm_config_pinctrl_drv_type(msm_host->pdata, clock);
mmc/host/sdhci-msm.c:		sdhci_msm_bus_voting(host, 1);
mmc/host/sdhci-msm.c:static void sdhci_msm_set_uhs_signaling(struct sdhci_host *host,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG)
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG)
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_DLL_CONFIG);
mmc/host/sdhci-msm.c:		msm_host->calibration_done = false;
mmc/host/sdhci-msm.c:static void sdhci_msm_cache_debug_data(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	struct sdhci_msm_debug_data *cached_data = &msm_host->cached_data;
mmc/host/sdhci-msm.c:	memcpy(&cached_data->copy_mmc, msm_host->mmc,
mmc/host/sdhci-msm.c:	if (msm_host->mmc->card)
mmc/host/sdhci-msm.c:		memcpy(&cached_data->copy_card, msm_host->mmc->card,
mmc/host/sdhci-msm.c:static void sdhci_msm_cqe_dump_debug_ram(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:	if (msm_host->cq_host)
mmc/host/sdhci-msm.c:		cq_host = msm_host->cq_host;
mmc/host/sdhci-msm.c:	version = sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_MCI_VERSION);
mmc/host/sdhci-msm.c:void sdhci_msm_dump_fsm_history(struct sdhci_host *host)
mmc/host/sdhci-msm.c:void sdhci_msm_dump_desc_history(struct sdhci_host *host)
mmc/host/sdhci-msm.c:void sdhci_msm_dump_iib(struct sdhci_host *host)
mmc/host/sdhci-msm.c:void sdhci_msm_dump_vendor_regs(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:	sdhci_msm_cache_debug_data(host);
mmc/host/sdhci-msm.c:	if (msm_host->cq_host)
mmc/host/sdhci-msm.c:		sdhci_msm_cqe_dump_debug_ram(host);
mmc/host/sdhci-msm.c:		sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_MCI_DATA_CNT),
mmc/host/sdhci-msm.c:		sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_MCI_FIFO_CNT));
mmc/host/sdhci-msm.c:		sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_MCI_DATA_CNT),
mmc/host/sdhci-msm.c:		sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_MCI_FIFO_CNT),
mmc/host/sdhci-msm.c:		sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_MCI_STATUS));
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_STATUS),
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG),
mmc/host/sdhci-msm.c:		sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG_2));
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_CONFIG_3),
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DLL_USR_CTL),
mmc/host/sdhci-msm.c:		sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_DDR_CONFIG));
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_MCI_VERSION),
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC_ADMA_ERR_ADDR0),
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC_ADMA_ERR_ADDR1));
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC),
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC_FUNC2),
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC3));
mmc/host/sdhci-msm.c:	if (msm_host->debug_mode_enabled) {
mmc/host/sdhci-msm.c:		sdhci_msm_dump_fsm_history(host);
mmc/host/sdhci-msm.c:		sdhci_msm_dump_desc_history(host);
mmc/host/sdhci-msm.c:	sdhci_msm_dump_iib(host);
mmc/host/sdhci-msm.c:			(tbsel2 << msm_host_offset->CORE_TESTBUS_SEL2_BIT) |
mmc/host/sdhci-msm.c:				tbsel | msm_host_offset->CORE_TESTBUS_ENA;
mmc/host/sdhci-msm.c:			sdhci_msm_writel_relaxed(test_bus_val, host,
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_TESTBUS_CONFIG);
mmc/host/sdhci-msm.c:			debug_reg[index++] = sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_SDCC_DEBUG_REG);
mmc/host/sdhci-msm.c:static void sdhci_msm_reset(struct sdhci_host *host, u8 mask)
mmc/host/sdhci-msm.c:static void sdhci_msm_clear_set_dumpregs(struct sdhci_host *host, bool set)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:		sdhci_msm_writel_relaxed(msm_host_offset->CORE_TESTBUS_ENA,
mmc/host/sdhci-msm.c:			host, msm_host_offset->CORE_TESTBUS_CONFIG);
mmc/host/sdhci-msm.c:		value = sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_TESTBUS_CONFIG);
mmc/host/sdhci-msm.c:		value &= ~(msm_host_offset->CORE_TESTBUS_ENA);
mmc/host/sdhci-msm.c:		sdhci_msm_writel_relaxed(value, host,
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_TESTBUS_CONFIG);
mmc/host/sdhci-msm.c:void sdhci_msm_reset_workaround(struct sdhci_host *host, u32 enable)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_VENDOR_SPEC_FUNC2);
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC_FUNC2);
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_VENDOR_SPEC_FUNC2) & HC_SW_RST_REQ) {
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC_FUNC2);
mmc/host/sdhci-msm.c:				msm_host_offset->CORE_VENDOR_SPEC_FUNC2);
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_VENDOR_SPEC_FUNC2);
mmc/host/sdhci-msm.c:static void sdhci_msm_pm_qos_irq_unvote_work(struct work_struct *work)
mmc/host/sdhci-msm.c:	struct sdhci_msm_pm_qos_irq *pm_qos_irq =
mmc/host/sdhci-msm.c:		container_of(work, struct sdhci_msm_pm_qos_irq,
mmc/host/sdhci-msm.c:void sdhci_msm_pm_qos_irq_vote(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	struct sdhci_msm_pm_qos_latency *latency =
mmc/host/sdhci-msm.c:		&msm_host->pdata->pm_qos_data.irq_latency;
mmc/host/sdhci-msm.c:	if (!msm_host->pm_qos_irq.enabled)
mmc/host/sdhci-msm.c:	counter = atomic_inc_return(&msm_host->pm_qos_irq.counter);
mmc/host/sdhci-msm.c:	if (msm_host->pm_qos_irq.latency == latency->latency[host->power_policy]
mmc/host/sdhci-msm.c:	cancel_delayed_work_sync(&msm_host->pm_qos_irq.unvote_work);
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.latency = latency->latency[host->power_policy];
mmc/host/sdhci-msm.c:	pm_qos_update_request(&msm_host->pm_qos_irq.req,
mmc/host/sdhci-msm.c:				msm_host->pm_qos_irq.latency);
mmc/host/sdhci-msm.c:void sdhci_msm_pm_qos_irq_unvote(struct sdhci_host *host, bool async)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (!msm_host->pm_qos_irq.enabled)
mmc/host/sdhci-msm.c:	if (atomic_read(&msm_host->pm_qos_irq.counter)) {
mmc/host/sdhci-msm.c:		counter = atomic_dec_return(&msm_host->pm_qos_irq.counter);
mmc/host/sdhci-msm.c:		queue_delayed_work(msm_host->pm_qos_wq,
mmc/host/sdhci-msm.c:				&msm_host->pm_qos_irq.unvote_work,
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.latency = PM_QOS_DEFAULT_VALUE;
mmc/host/sdhci-msm.c:	pm_qos_update_request(&msm_host->pm_qos_irq.req,
mmc/host/sdhci-msm.c:			msm_host->pm_qos_irq.latency);
mmc/host/sdhci-msm.c:sdhci_msm_pm_qos_irq_show(struct device *dev,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	struct sdhci_msm_pm_qos_irq *irq = &msm_host->pm_qos_irq;
mmc/host/sdhci-msm.c:sdhci_msm_pm_qos_irq_enable_show(struct device *dev,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	return snprintf(buf, PAGE_SIZE, "%u\n", msm_host->pm_qos_irq.enabled);
mmc/host/sdhci-msm.c:sdhci_msm_pm_qos_irq_enable_store(struct device *dev,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (enable == msm_host->pm_qos_irq.enabled)
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.enabled = enable;
mmc/host/sdhci-msm.c:		cancel_delayed_work_sync(&msm_host->pm_qos_irq.unvote_work);
mmc/host/sdhci-msm.c:		atomic_set(&msm_host->pm_qos_irq.counter, 0);
mmc/host/sdhci-msm.c:		msm_host->pm_qos_irq.latency = PM_QOS_DEFAULT_VALUE;
mmc/host/sdhci-msm.c:		pm_qos_update_request(&msm_host->pm_qos_irq.req,
mmc/host/sdhci-msm.c:				msm_host->pm_qos_irq.latency);
mmc/host/sdhci-msm.c:static inline void set_affine_irq(struct sdhci_msm_host *msm_host,
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.req.irq = host->irq;
mmc/host/sdhci-msm.c:static inline void set_affine_irq(struct sdhci_msm_host *msm_host,
mmc/host/sdhci-msm.c:static bool sdhci_msm_pm_qos_wq_init(struct sdhci_msm_host *msm_host)
mmc/host/sdhci-msm.c:	wq = kasprintf(GFP_KERNEL, "sdhci_msm_pm_qos/%s",
mmc/host/sdhci-msm.c:			dev_name(&msm_host->pdev->dev));
mmc/host/sdhci-msm.c:	msm_host->pm_qos_wq = create_workqueue(wq);
mmc/host/sdhci-msm.c:	if (!msm_host->pm_qos_wq) {
mmc/host/sdhci-msm.c:		dev_err(&msm_host->pdev->dev,
mmc/host/sdhci-msm.c:void sdhci_msm_pm_qos_irq_init(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	struct sdhci_msm_pm_qos_latency *irq_latency;
mmc/host/sdhci-msm.c:	if (!msm_host->pdata->pm_qos_data.irq_valid)
mmc/host/sdhci-msm.c:	if (msm_host->pm_qos_irq.enabled)
mmc/host/sdhci-msm.c:	atomic_set(&msm_host->pm_qos_irq.counter, 0);
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.req.type =
mmc/host/sdhci-msm.c:			msm_host->pdata->pm_qos_data.irq_req_type;
mmc/host/sdhci-msm.c:	if ((msm_host->pm_qos_irq.req.type != PM_QOS_REQ_AFFINE_CORES) &&
mmc/host/sdhci-msm.c:		(msm_host->pm_qos_irq.req.type != PM_QOS_REQ_ALL_CORES))
mmc/host/sdhci-msm.c:		set_affine_irq(msm_host, host);
mmc/host/sdhci-msm.c:		msm_host->pm_qos_irq.req.cpus_affine =
mmc/host/sdhci-msm.c:			msm_host->pdata->pm_qos_data.irq_cpu;
mmc/host/sdhci-msm.c:	sdhci_msm_pm_qos_wq_init(msm_host);
mmc/host/sdhci-msm.c:	INIT_DELAYED_WORK(&msm_host->pm_qos_irq.unvote_work,
mmc/host/sdhci-msm.c:		sdhci_msm_pm_qos_irq_unvote_work);
mmc/host/sdhci-msm.c:	irq_latency = &msm_host->pdata->pm_qos_data.irq_latency;
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.latency =
mmc/host/sdhci-msm.c:	pm_qos_add_request(&msm_host->pm_qos_irq.req, PM_QOS_CPU_DMA_LATENCY,
mmc/host/sdhci-msm.c:			msm_host->pm_qos_irq.latency);
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.enabled = true;
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.enable_attr.show =
mmc/host/sdhci-msm.c:		sdhci_msm_pm_qos_irq_enable_show;
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.enable_attr.store =
mmc/host/sdhci-msm.c:		sdhci_msm_pm_qos_irq_enable_store;
mmc/host/sdhci-msm.c:	sysfs_attr_init(&msm_host->pm_qos_irq.enable_attr.attr);
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.enable_attr.attr.name = "pm_qos_irq_enable";
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.enable_attr.attr.mode = 0644;
mmc/host/sdhci-msm.c:	ret = device_create_file(&msm_host->pdev->dev,
mmc/host/sdhci-msm.c:		&msm_host->pm_qos_irq.enable_attr);
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.status_attr.show = sdhci_msm_pm_qos_irq_show;
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.status_attr.store = NULL;
mmc/host/sdhci-msm.c:	sysfs_attr_init(&msm_host->pm_qos_irq.status_attr.attr);
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.status_attr.attr.name = "pm_qos_irq_status";
mmc/host/sdhci-msm.c:	msm_host->pm_qos_irq.status_attr.attr.mode = 0444;
mmc/host/sdhci-msm.c:	ret = device_create_file(&msm_host->pdev->dev,
mmc/host/sdhci-msm.c:			&msm_host->pm_qos_irq.status_attr);
mmc/host/sdhci-msm.c:static ssize_t sdhci_msm_pm_qos_group_show(struct device *dev,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	struct sdhci_msm_pm_qos_group *group;
mmc/host/sdhci-msm.c:	int nr_groups = msm_host->pdata->pm_qos_data.cpu_group_map.nr_groups;
mmc/host/sdhci-msm.c:		group = &msm_host->pm_qos[i];
mmc/host/sdhci-msm.c:			msm_host->pm_qos_group_enable,
mmc/host/sdhci-msm.c:static ssize_t sdhci_msm_pm_qos_group_enable_show(struct device *dev,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:		msm_host->pm_qos_group_enable ? "enabled" : "disabled");
mmc/host/sdhci-msm.c:static ssize_t sdhci_msm_pm_qos_group_enable_store(struct device *dev,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	int nr_groups = msm_host->pdata->pm_qos_data.cpu_group_map.nr_groups;
mmc/host/sdhci-msm.c:	if (enable == msm_host->pm_qos_group_enable)
mmc/host/sdhci-msm.c:	msm_host->pm_qos_group_enable = enable;
mmc/host/sdhci-msm.c:				&msm_host->pm_qos[i].unvote_work);
mmc/host/sdhci-msm.c:			atomic_set(&msm_host->pm_qos[i].counter, 0);
mmc/host/sdhci-msm.c:			msm_host->pm_qos[i].latency = PM_QOS_DEFAULT_VALUE;
mmc/host/sdhci-msm.c:			pm_qos_update_request(&msm_host->pm_qos[i].req,
mmc/host/sdhci-msm.c:				msm_host->pm_qos[i].latency);
mmc/host/sdhci-msm.c:static int sdhci_msm_get_cpu_group(struct sdhci_msm_host *msm_host, int cpu)
mmc/host/sdhci-msm.c:	struct sdhci_msm_cpu_group_map *map =
mmc/host/sdhci-msm.c:			&msm_host->pdata->pm_qos_data.cpu_group_map;
mmc/host/sdhci-msm.c:void sdhci_msm_pm_qos_cpu_vote(struct sdhci_host *host,
mmc/host/sdhci-msm.c:		struct sdhci_msm_pm_qos_latency *latency, int cpu)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	int group = sdhci_msm_get_cpu_group(msm_host, cpu);
mmc/host/sdhci-msm.c:	struct sdhci_msm_pm_qos_group *pm_qos_group;
mmc/host/sdhci-msm.c:	if (!msm_host->pm_qos_group_enable || group < 0)
mmc/host/sdhci-msm.c:	pm_qos_group = &msm_host->pm_qos[group];
mmc/host/sdhci-msm.c:static void sdhci_msm_pm_qos_cpu_unvote_work(struct work_struct *work)
mmc/host/sdhci-msm.c:	struct sdhci_msm_pm_qos_group *group =
mmc/host/sdhci-msm.c:		container_of(work, struct sdhci_msm_pm_qos_group,
mmc/host/sdhci-msm.c:bool sdhci_msm_pm_qos_cpu_unvote(struct sdhci_host *host, int cpu, bool async)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	int group = sdhci_msm_get_cpu_group(msm_host, cpu);
mmc/host/sdhci-msm.c:	if (!msm_host->pm_qos_group_enable || group < 0 ||
mmc/host/sdhci-msm.c:		atomic_dec_return(&msm_host->pm_qos[group].counter))
mmc/host/sdhci-msm.c:		queue_delayed_work(msm_host->pm_qos_wq,
mmc/host/sdhci-msm.c:				&msm_host->pm_qos[group].unvote_work,
mmc/host/sdhci-msm.c:	msm_host->pm_qos[group].latency = PM_QOS_DEFAULT_VALUE;
mmc/host/sdhci-msm.c:	pm_qos_update_request(&msm_host->pm_qos[group].req,
mmc/host/sdhci-msm.c:				msm_host->pm_qos[group].latency);
mmc/host/sdhci-msm.c:void sdhci_msm_pm_qos_cpu_init(struct sdhci_host *host,
mmc/host/sdhci-msm.c:		struct sdhci_msm_pm_qos_latency *latency)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	int nr_groups = msm_host->pdata->pm_qos_data.cpu_group_map.nr_groups;
mmc/host/sdhci-msm.c:	struct sdhci_msm_pm_qos_group *group;
mmc/host/sdhci-msm.c:	if (msm_host->pm_qos_group_enable)
mmc/host/sdhci-msm.c:	msm_host->pm_qos = kcalloc(nr_groups, sizeof(*msm_host->pm_qos),
mmc/host/sdhci-msm.c:	if (!msm_host->pm_qos)
mmc/host/sdhci-msm.c:		group = &msm_host->pm_qos[i];
mmc/host/sdhci-msm.c:			sdhci_msm_pm_qos_cpu_unvote_work);
mmc/host/sdhci-msm.c:			*cpumask_bits(&msm_host->pdata->pm_qos_data.cpu_group_map.mask[i]);
mmc/host/sdhci-msm.c:	msm_host->pm_qos_prev_cpu = -1;
mmc/host/sdhci-msm.c:	msm_host->pm_qos_group_enable = true;
mmc/host/sdhci-msm.c:	msm_host->pm_qos_group_status_attr.show = sdhci_msm_pm_qos_group_show;
mmc/host/sdhci-msm.c:	msm_host->pm_qos_group_status_attr.store = NULL;
mmc/host/sdhci-msm.c:	sysfs_attr_init(&msm_host->pm_qos_group_status_attr.attr);
mmc/host/sdhci-msm.c:	msm_host->pm_qos_group_status_attr.attr.name =
mmc/host/sdhci-msm.c:	msm_host->pm_qos_group_status_attr.attr.mode = 0444;
mmc/host/sdhci-msm.c:	ret = device_create_file(&msm_host->pdev->dev,
mmc/host/sdhci-msm.c:			&msm_host->pm_qos_group_status_attr);
mmc/host/sdhci-msm.c:		dev_err(&msm_host->pdev->dev, "%s: fail to create pm_qos_group_status_attr (%d)\n",
mmc/host/sdhci-msm.c:	msm_host->pm_qos_group_enable_attr.show =
mmc/host/sdhci-msm.c:			sdhci_msm_pm_qos_group_enable_show;
mmc/host/sdhci-msm.c:	msm_host->pm_qos_group_enable_attr.store =
mmc/host/sdhci-msm.c:			sdhci_msm_pm_qos_group_enable_store;
mmc/host/sdhci-msm.c:	sysfs_attr_init(&msm_host->pm_qos_group_enable_attr.attr);
mmc/host/sdhci-msm.c:	msm_host->pm_qos_group_enable_attr.attr.name =
mmc/host/sdhci-msm.c:	msm_host->pm_qos_group_enable_attr.attr.mode = 0444;
mmc/host/sdhci-msm.c:	ret = device_create_file(&msm_host->pdev->dev,
mmc/host/sdhci-msm.c:			&msm_host->pm_qos_group_enable_attr);
mmc/host/sdhci-msm.c:		dev_err(&msm_host->pdev->dev, "%s: fail to create pm_qos_group_enable_attr (%d)\n",
mmc/host/sdhci-msm.c:static void sdhci_msm_pre_req(struct sdhci_host *host,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	int prev_group = sdhci_msm_get_cpu_group(msm_host,
mmc/host/sdhci-msm.c:			msm_host->pm_qos_prev_cpu);
mmc/host/sdhci-msm.c:	sdhci_msm_pm_qos_irq_vote(host);
mmc/host/sdhci-msm.c:	group = sdhci_msm_get_cpu_group(msm_host, cpu);
mmc/host/sdhci-msm.c:		sdhci_msm_pm_qos_cpu_unvote(host,
mmc/host/sdhci-msm.c:				msm_host->pm_qos_prev_cpu, false);
mmc/host/sdhci-msm.c:		sdhci_msm_pm_qos_cpu_vote(host,
mmc/host/sdhci-msm.c:				msm_host->pdata->pm_qos_data.latency, cpu);
mmc/host/sdhci-msm.c:		msm_host->pm_qos_prev_cpu = cpu;
mmc/host/sdhci-msm.c:static void sdhci_msm_post_req(struct sdhci_host *host,
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	sdhci_msm_pm_qos_irq_unvote(host, false);
mmc/host/sdhci-msm.c:	if (sdhci_msm_pm_qos_cpu_unvote(host, msm_host->pm_qos_prev_cpu, false))
mmc/host/sdhci-msm.c:		msm_host->pm_qos_prev_cpu = -1;
mmc/host/sdhci-msm.c:static void sdhci_msm_init(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	sdhci_msm_pm_qos_irq_init(host);
mmc/host/sdhci-msm.c:	if (msm_host->pdata->pm_qos_data.legacy_valid)
mmc/host/sdhci-msm.c:		sdhci_msm_pm_qos_cpu_init(host,
mmc/host/sdhci-msm.c:				msm_host->pdata->pm_qos_data.latency);
mmc/host/sdhci-msm.c:static unsigned int sdhci_msm_get_current_limit(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	struct sdhci_msm_slot_reg_data *curr_slot = msm_host->pdata->vreg_data;
mmc/host/sdhci-msm.c:static int sdhci_msm_notify_load(struct sdhci_host *host, enum mmc_load state)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->ice_clk)) {
mmc/host/sdhci-msm.c:			msm_host->pdata->ice_clk_min :
mmc/host/sdhci-msm.c:			msm_host->pdata->ice_clk_max;
mmc/host/sdhci-msm.c:		if (msm_host->ice_clk_rate == clk_rate)
mmc/host/sdhci-msm.c:		ret = clk_set_rate(msm_host->ice_clk, clk_rate);
mmc/host/sdhci-msm.c:		msm_host->ice_clk_rate = clk_rate;
mmc/host/sdhci-msm.c:static void sdhci_msm_hw_reset(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	struct platform_device *pdev = msm_host->pdev;
mmc/host/sdhci-msm.c:	if (!msm_host->core_reset) {
mmc/host/sdhci-msm.c:	msm_host->reg_store = true;
mmc/host/sdhci-msm.c:	sdhci_msm_exit_dbg_mode(host);
mmc/host/sdhci-msm.c:	sdhci_msm_registers_save(host);
mmc/host/sdhci-msm.c:	ret = reset_control_assert(msm_host->core_reset);
mmc/host/sdhci-msm.c:	ret = reset_control_deassert(msm_host->core_reset);
mmc/host/sdhci-msm.c:	sdhci_msm_registers_restore(host);
mmc/host/sdhci-msm.c:	msm_host->reg_store = false;
mmc/host/sdhci-msm.c:static struct sdhci_ops sdhci_msm_ops = {
mmc/host/sdhci-msm.c:	.set_uhs_signaling = sdhci_msm_set_uhs_signaling,
mmc/host/sdhci-msm.c:	.check_power_status = sdhci_msm_check_power_status,
mmc/host/sdhci-msm.c:	.platform_execute_tuning = sdhci_msm_execute_tuning,
mmc/host/sdhci-msm.c:	.enhanced_strobe = sdhci_msm_enhanced_strobe,
mmc/host/sdhci-msm.c:	.toggle_cdr = sdhci_msm_toggle_cdr,
mmc/host/sdhci-msm.c:	.get_max_segments = sdhci_msm_max_segs,
mmc/host/sdhci-msm.c:	.set_clock = sdhci_msm_set_clock,
mmc/host/sdhci-msm.c:	.get_min_clock = sdhci_msm_get_min_clock,
mmc/host/sdhci-msm.c:	.get_max_clock = sdhci_msm_get_max_clock,
mmc/host/sdhci-msm.c:	.dump_vendor_regs = sdhci_msm_dump_vendor_regs,
mmc/host/sdhci-msm.c:	.config_auto_tuning_cmd = sdhci_msm_config_auto_tuning_cmd,
mmc/host/sdhci-msm.c:	.enable_controller_clock = sdhci_msm_enable_controller_clock,
mmc/host/sdhci-msm.c:	.reset = sdhci_msm_reset,
mmc/host/sdhci-msm.c:	.clear_set_dumpregs = sdhci_msm_clear_set_dumpregs,
mmc/host/sdhci-msm.c:	.reset_workaround = sdhci_msm_reset_workaround,
mmc/host/sdhci-msm.c:	.init = sdhci_msm_init,
mmc/host/sdhci-msm.c:	.pre_req = sdhci_msm_pre_req,
mmc/host/sdhci-msm.c:	.post_req = sdhci_msm_post_req,
mmc/host/sdhci-msm.c:	.get_current_limit = sdhci_msm_get_current_limit,
mmc/host/sdhci-msm.c:	.notify_load = sdhci_msm_notify_load,
mmc/host/sdhci-msm.c:	.irq = sdhci_msm_cqe_irq,
mmc/host/sdhci-msm.c:	.enter_dbg_mode = sdhci_msm_enter_dbg_mode,
mmc/host/sdhci-msm.c:	.exit_dbg_mode = sdhci_msm_exit_dbg_mode,
mmc/host/sdhci-msm.c:	.hw_reset = sdhci_msm_hw_reset,
mmc/host/sdhci-msm.c:static void sdhci_set_default_hw_caps(struct sdhci_msm_host *msm_host,
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset =
mmc/host/sdhci-msm.c:					msm_host->offset;
mmc/host/sdhci-msm.c:	version = sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_MCI_VERSION);
mmc/host/sdhci-msm.c:		struct sdhci_msm_reg_data *vdd_io_reg;
mmc/host/sdhci-msm.c:		vdd_io_reg = msm_host->pdata->vreg_data->vdd_io_data;
mmc/host/sdhci-msm.c:		if (msm_host->pdata->mmc_bus_width == MMC_CAP_8_BIT_DATA)
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC_FUNC2);
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_VENDOR_SPEC_FUNC2);
mmc/host/sdhci-msm.c:		msm_host->use_cdclp533 = true;
mmc/host/sdhci-msm.c:		msm_host->use_updated_dll_reset = true;
mmc/host/sdhci-msm.c:		msm_host->enhanced_strobe = true;
mmc/host/sdhci-msm.c:		msm_host->pdata->caps2 |= MMC_CAP2_HS400_ES;
mmc/host/sdhci-msm.c:		msm_host->use_14lpp_dll = true;
mmc/host/sdhci-msm.c:	if (msm_host->core_3_0v_support) {
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC_CAPABILITIES0);
mmc/host/sdhci-msm.c:		msm_host->rclk_delay_fix = true;
mmc/host/sdhci-msm.c:	if (!msm_host->pdata->largeaddressbus)
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_VENDOR_SPEC_CAPABILITIES0);
mmc/host/sdhci-msm.c:	msm_host->caps_0 = caps;
mmc/host/sdhci-msm.c:		msm_host->use_7nm_dll = true;
mmc/host/sdhci-msm.c:static bool sdhci_msm_is_bootdevice(struct device *dev)
mmc/host/sdhci-msm.c:static int sdhci_msm_setup_ice_clk(struct sdhci_msm_host *msm_host,
mmc/host/sdhci-msm.c:	msm_host->ice_clk = devm_clk_get(&pdev->dev, "ice_core_clk");
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->ice_clk)) {
mmc/host/sdhci-msm.c:		ret = clk_set_rate(msm_host->ice_clk,
mmc/host/sdhci-msm.c:				msm_host->pdata->ice_clk_max);
mmc/host/sdhci-msm.c:				msm_host->pdata->ice_clk_max);
mmc/host/sdhci-msm.c:		ret = clk_prepare_enable(msm_host->ice_clk);
mmc/host/sdhci-msm.c:		msm_host->ice_clk_rate =
mmc/host/sdhci-msm.c:			msm_host->pdata->ice_clk_max;
mmc/host/sdhci-msm.c:static void sdhci_msm_select_bus_mode(struct sdhci_host *host)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:			msm_host->enhanced_strobe = false;
mmc/host/sdhci-msm.c:			msm_host->pdata->caps2 &= ~(MMC_CAP2_HS400_ES);
mmc/host/sdhci-msm.c:			msm_host->pdata->caps2 &= ~(MMC_CAP2_HS400_ES);
mmc/host/sdhci-msm.c:			msm_host->pdata->caps2 &= ~(MMC_CAP2_HS400);
mmc/host/sdhci-msm.c:			msm_host->pdata->caps2 &= ~(MMC_CAP2_HS400_ES);
mmc/host/sdhci-msm.c:			msm_host->pdata->caps2 &= ~(MMC_CAP2_HS400);
mmc/host/sdhci-msm.c:			msm_host->pdata->caps2 &= ~(MMC_CAP2_HS200);
mmc/host/sdhci-msm.c:			msm_host->pdata->caps2 &= ~(MMC_CAP2_HS400_ES);
mmc/host/sdhci-msm.c:			msm_host->pdata->caps2 &= ~(MMC_CAP2_HS400);
mmc/host/sdhci-msm.c:			msm_host->pdata->caps2 &= ~(MMC_CAP2_HS200);
mmc/host/sdhci-msm.c:			msm_host->pdata->caps &= ~(MMC_CAP_3_3V_DDR |
mmc/host/sdhci-msm.c:			msm_host->mmc->clk_scaling.lower_bus_speed_mode &=
mmc/host/sdhci-msm.c:static int sdhci_msm_probe(struct platform_device *pdev)
mmc/host/sdhci-msm.c:	const struct sdhci_msm_offset *msm_host_offset;
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host;
mmc/host/sdhci-msm.c:	msm_host = devm_kzalloc(&pdev->dev, sizeof(struct sdhci_msm_host),
mmc/host/sdhci-msm.c:	if (!msm_host) {
mmc/host/sdhci-msm.c:	if (of_find_compatible_node(NULL, NULL, "qcom,sdhci-msm-v5")) {
mmc/host/sdhci-msm.c:		msm_host->mci_removed = true;
mmc/host/sdhci-msm.c:		msm_host->offset = &sdhci_msm_offset_mci_removed;
mmc/host/sdhci-msm.c:		msm_host->mci_removed = false;
mmc/host/sdhci-msm.c:		msm_host->offset = &sdhci_msm_offset_mci_present;
mmc/host/sdhci-msm.c:	msm_host_offset = msm_host->offset;
mmc/host/sdhci-msm.c:	msm_host->sdhci_msm_pdata.ops = &sdhci_msm_ops;
mmc/host/sdhci-msm.c:	host = sdhci_pltfm_init(pdev, &msm_host->sdhci_msm_pdata, 0);
mmc/host/sdhci-msm.c:	pltfm_host->priv = msm_host;
mmc/host/sdhci-msm.c:	msm_host->mmc = host->mmc;
mmc/host/sdhci-msm.c:	msm_host->pdev = pdev;
mmc/host/sdhci-msm.c:		if ((ret == 1) && !sdhci_msm_is_bootdevice(&pdev->dev)
mmc/host/sdhci-msm.c:			msm_host->clk = devm_clk_get(&pdev->dev, "core_clk");
mmc/host/sdhci-msm.c:			if (!IS_ERR(msm_host->clk)) {
mmc/host/sdhci-msm.c:				ret = clk_set_flags(msm_host->clk,
mmc/host/sdhci-msm.c:			sdhci_slot[ret-1] = msm_host;
mmc/host/sdhci-msm.c:		msm_host->pdata = sdhci_msm_populate_pdata(&pdev->dev,
mmc/host/sdhci-msm.c:							   msm_host);
mmc/host/sdhci-msm.c:		if (!msm_host->pdata) {
mmc/host/sdhci-msm.c:	msm_host->bus_clk = devm_clk_get(&pdev->dev, "bus_clk");
mmc/host/sdhci-msm.c:	if (!IS_ERR_OR_NULL(msm_host->bus_clk)) {
mmc/host/sdhci-msm.c:		ret = clk_set_rate(msm_host->bus_clk, INT_MAX);
mmc/host/sdhci-msm.c:		ret = clk_prepare_enable(msm_host->bus_clk);
mmc/host/sdhci-msm.c:	msm_host->pclk = devm_clk_get(&pdev->dev, "iface_clk");
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->pclk)) {
mmc/host/sdhci-msm.c:		ret = clk_prepare_enable(msm_host->pclk);
mmc/host/sdhci-msm.c:		ret = PTR_ERR(msm_host->pclk);
mmc/host/sdhci-msm.c:	atomic_set(&msm_host->controller_clock, 1);
mmc/host/sdhci-msm.c:	msm_host->bus_aggr_clk = devm_clk_get(&pdev->dev, "bus_aggr_clk");
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->bus_aggr_clk)) {
mmc/host/sdhci-msm.c:		ret = clk_prepare_enable(msm_host->bus_aggr_clk);
mmc/host/sdhci-msm.c:	ret = sdhci_msm_setup_ice_clk(msm_host, pdev);
mmc/host/sdhci-msm.c:	msm_host->clk = devm_clk_get(&pdev->dev, "core_clk");
mmc/host/sdhci-msm.c:	if (IS_ERR(msm_host->clk)) {
mmc/host/sdhci-msm.c:		ret = PTR_ERR(msm_host->clk);
mmc/host/sdhci-msm.c:	ret = clk_set_rate(msm_host->clk, sdhci_msm_get_min_clock(host));
mmc/host/sdhci-msm.c:	ret = clk_prepare_enable(msm_host->clk);
mmc/host/sdhci-msm.c:	ret = clk_set_flags(msm_host->clk, CLKFLAG_NORETAIN_MEM);
mmc/host/sdhci-msm.c:	msm_host->clk_rate = sdhci_msm_get_min_clock(host);
mmc/host/sdhci-msm.c:	atomic_set(&msm_host->clks_on, 1);
mmc/host/sdhci-msm.c:	msm_host->ff_clk = devm_clk_get(&pdev->dev, "cal_clk");
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->ff_clk)) {
mmc/host/sdhci-msm.c:		ret = clk_prepare_enable(msm_host->ff_clk);
mmc/host/sdhci-msm.c:	msm_host->sleep_clk = devm_clk_get(&pdev->dev, "sleep_clk");
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->sleep_clk)) {
mmc/host/sdhci-msm.c:		ret = clk_prepare_enable(msm_host->sleep_clk);
mmc/host/sdhci-msm.c:	msm_host->saved_tuning_phase = INVALID_TUNING_PHASE;
mmc/host/sdhci-msm.c:	ret = sdhci_msm_bus_register(msm_host, pdev);
mmc/host/sdhci-msm.c:	sdhci_msm_bus_voting(host, 1);
mmc/host/sdhci-msm.c:	ret = sdhci_msm_vreg_init(&pdev->dev, msm_host->pdata, true);
mmc/host/sdhci-msm.c:	if (!msm_host->mci_removed) {
mmc/host/sdhci-msm.c:		msm_host->core_mem = devm_ioremap(&pdev->dev,
mmc/host/sdhci-msm.c:		if (!msm_host->core_mem) {
mmc/host/sdhci-msm.c:	host->ioaddr + msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC) |
mmc/host/sdhci-msm.c:			host->ioaddr + msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC3) &
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC3);
mmc/host/sdhci-msm.c:	if (!msm_host->mci_removed) {
mmc/host/sdhci-msm.c:		writel_relaxed(HC_MODE_EN, (msm_host->core_mem + CORE_HC_MODE));
mmc/host/sdhci-msm.c:		writel_relaxed(readl_relaxed(msm_host->core_mem +
mmc/host/sdhci-msm.c:				msm_host->core_mem + CORE_HC_MODE);
mmc/host/sdhci-msm.c:	sdhci_set_default_hw_caps(msm_host, host);
mmc/host/sdhci-msm.c:	sdhci_msm_select_bus_mode(host);
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC) |
mmc/host/sdhci-msm.c:			msm_host_offset->CORE_VENDOR_SPEC);
mmc/host/sdhci-msm.c:	irq_status = sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_PWRCTL_STATUS);
mmc/host/sdhci-msm.c:	sdhci_msm_writel_relaxed(irq_status, host,
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_PWRCTL_CLEAR);
mmc/host/sdhci-msm.c:	irq_ctl = sdhci_msm_readl_relaxed(host,
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_PWRCTL_CTL);
mmc/host/sdhci-msm.c:	sdhci_msm_writel_relaxed(irq_ctl, host,
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_PWRCTL_CTL);
mmc/host/sdhci-msm.c:	msm_host->minor = IPCAT_MINOR_MASK(readl_relaxed(host->ioaddr +
mmc/host/sdhci-msm.c:	msm_host->pwr_irq = platform_get_irq_byname(pdev, "pwr_irq");
mmc/host/sdhci-msm.c:	if (msm_host->pwr_irq < 0) {
mmc/host/sdhci-msm.c:				msm_host->pwr_irq);
mmc/host/sdhci-msm.c:	ret = devm_request_threaded_irq(&pdev->dev, msm_host->pwr_irq, NULL,
mmc/host/sdhci-msm.c:					sdhci_msm_pwr_irq, IRQF_ONESHOT,
mmc/host/sdhci-msm.c:				msm_host->pwr_irq, ret);
mmc/host/sdhci-msm.c:	sdhci_msm_writel_relaxed(INT_MASK, host,
mmc/host/sdhci-msm.c:		msm_host_offset->CORE_PWRCTL_MASK);
mmc/host/sdhci-msm.c:	msm_host->mmc->caps |= msm_host->pdata->mmc_bus_width;
mmc/host/sdhci-msm.c:	msm_host->mmc->caps |= msm_host->pdata->caps;
mmc/host/sdhci-msm.c:	msm_host->mmc->caps |= MMC_CAP_AGGRESSIVE_PM;
mmc/host/sdhci-msm.c:	msm_host->mmc->caps |= MMC_CAP_WAIT_WHILE_BUSY;
mmc/host/sdhci-msm.c:	msm_host->mmc->caps2 |= msm_host->pdata->caps2;
mmc/host/sdhci-msm.c:	msm_host->mmc->caps2 |= MMC_CAP2_BOOTPART_NOACC;
mmc/host/sdhci-msm.c:	msm_host->mmc->caps2 |= MMC_CAP2_HS400_POST_TUNING;
mmc/host/sdhci-msm.c:	msm_host->mmc->caps2 |= MMC_CAP2_CLK_SCALE;
mmc/host/sdhci-msm.c:	msm_host->mmc->caps2 |= MMC_CAP2_SANITIZE;
mmc/host/sdhci-msm.c:	msm_host->mmc->caps2 |= MMC_CAP2_MAX_DISCARD_SIZE;
mmc/host/sdhci-msm.c:	msm_host->mmc->caps2 |= MMC_CAP2_SLEEP_AWAKE;
mmc/host/sdhci-msm.c:	msm_host->mmc->pm_caps |= MMC_PM_KEEP_POWER | MMC_PM_WAKE_SDIO_IRQ;
mmc/host/sdhci-msm.c:	if (msm_host->core_reset)
mmc/host/sdhci-msm.c:		msm_host->mmc->caps |= MMC_CAP_HW_RESET;
mmc/host/sdhci-msm.c:	if (msm_host->pdata->nonremovable)
mmc/host/sdhci-msm.c:		msm_host->mmc->caps |= MMC_CAP_NONREMOVABLE;
mmc/host/sdhci-msm.c:	if (msm_host->pdata->nonhotplug)
mmc/host/sdhci-msm.c:		msm_host->mmc->caps2 |= MMC_CAP2_NONHOTPLUG;
mmc/host/sdhci-msm.c:	init_completion(&msm_host->pwr_irq_completion);
mmc/host/sdhci-msm.c:	if (gpio_is_valid(msm_host->pdata->status_gpio)) {
mmc/host/sdhci-msm.c:		sdhci_msm_setup_pins(msm_host->pdata, true);
mmc/host/sdhci-msm.c:		ret = mmc_gpio_request_cd(msm_host->mmc,
mmc/host/sdhci-msm.c:				msm_host->pdata->status_gpio, 0);
mmc/host/sdhci-msm.c:	msm_host->pdata->sdiowakeup_irq = platform_get_irq_byname(pdev,
mmc/host/sdhci-msm.c:	if (sdhci_is_valid_gpio_wakeup_int(msm_host)) {
mmc/host/sdhci-msm.c:				msm_host->pdata->sdiowakeup_irq);
mmc/host/sdhci-msm.c:		msm_host->is_sdiowakeup_enabled = true;
mmc/host/sdhci-msm.c:		ret = request_irq(msm_host->pdata->sdiowakeup_irq,
mmc/host/sdhci-msm.c:				  sdhci_msm_sdiowakeup_irq,
mmc/host/sdhci-msm.c:				  "sdhci-msm sdiowakeup", host);
mmc/host/sdhci-msm.c:				__func__, msm_host->pdata->sdiowakeup_irq, ret);
mmc/host/sdhci-msm.c:			msm_host->pdata->sdiowakeup_irq = -1;
mmc/host/sdhci-msm.c:			msm_host->is_sdiowakeup_enabled = false;
mmc/host/sdhci-msm.c:			sdhci_msm_cfg_sdiowakeup_gpio_irq(host, false);
mmc/host/sdhci-msm.c:			msm_host->sdio_pending_processing = false;
mmc/host/sdhci-msm.c:	msm_host->pdata->testbus_trigger_irq = platform_get_irq_byname(pdev,
mmc/host/sdhci-msm.c:	if (sdhci_is_valid_gpio_testbus_trigger_int(msm_host)) {
mmc/host/sdhci-msm.c:				msm_host->pdata->testbus_trigger_irq);
mmc/host/sdhci-msm.c:		ret = request_irq(msm_host->pdata->testbus_trigger_irq,
mmc/host/sdhci-msm.c:				  sdhci_msm_testbus_trigger_irq,
mmc/host/sdhci-msm.c:				  "sdhci-msm tb_trig", host);
mmc/host/sdhci-msm.c:				__func__, msm_host->pdata->testbus_trigger_irq,
mmc/host/sdhci-msm.c:	if (of_device_is_compatible(node, "qcom,sdhci-msm-cqe")) {
mmc/host/sdhci-msm.c:		dev_dbg(&pdev->dev, "node with qcom,sdhci-msm-cqe\n");
mmc/host/sdhci-msm.c:		ret = sdhci_msm_cqe_add_host(host, pdev);
mmc/host/sdhci-msm.c:	msm_host->pltfm_init_done = true;
mmc/host/sdhci-msm.c:	msm_host->mmc->caps |= MMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_NEED_RSP_BUSY;
mmc/host/sdhci-msm.c:	msm_host->msm_bus_vote.max_bus_bw.show = show_sdhci_max_bus_bw;
mmc/host/sdhci-msm.c:	msm_host->msm_bus_vote.max_bus_bw.store = store_sdhci_max_bus_bw;
mmc/host/sdhci-msm.c:	sysfs_attr_init(&msm_host->msm_bus_vote.max_bus_bw.attr);
mmc/host/sdhci-msm.c:	msm_host->msm_bus_vote.max_bus_bw.attr.name = "max_bus_bw";
mmc/host/sdhci-msm.c:	msm_host->msm_bus_vote.max_bus_bw.attr.mode = 0644;
mmc/host/sdhci-msm.c:			&msm_host->msm_bus_vote.max_bus_bw);
mmc/host/sdhci-msm.c:	if (!gpio_is_valid(msm_host->pdata->status_gpio)) {
mmc/host/sdhci-msm.c:		msm_host->polling.show = show_polling;
mmc/host/sdhci-msm.c:		msm_host->polling.store = store_polling;
mmc/host/sdhci-msm.c:		sysfs_attr_init(&msm_host->polling.attr);
mmc/host/sdhci-msm.c:		msm_host->polling.attr.name = "polling";
mmc/host/sdhci-msm.c:		msm_host->polling.attr.mode = 0644;
mmc/host/sdhci-msm.c:		ret = device_create_file(&pdev->dev, &msm_host->polling);
mmc/host/sdhci-msm.c:	msm_host->auto_cmd21_attr.show = show_auto_cmd21;
mmc/host/sdhci-msm.c:	msm_host->auto_cmd21_attr.store = store_auto_cmd21;
mmc/host/sdhci-msm.c:	sysfs_attr_init(&msm_host->auto_cmd21_attr.attr);
mmc/host/sdhci-msm.c:	msm_host->auto_cmd21_attr.attr.name = "enable_auto_cmd21";
mmc/host/sdhci-msm.c:	msm_host->auto_cmd21_attr.attr.mode = 0644;
mmc/host/sdhci-msm.c:	ret = device_create_file(&pdev->dev, &msm_host->auto_cmd21_attr);
mmc/host/sdhci-msm.c:		device_remove_file(&pdev->dev, &msm_host->auto_cmd21_attr);
mmc/host/sdhci-msm.c:	if (msm_host->minor >= 2) {
mmc/host/sdhci-msm.c:		msm_host->mask_and_match.show = show_mask_and_match;
mmc/host/sdhci-msm.c:		msm_host->mask_and_match.store = store_mask_and_match;
mmc/host/sdhci-msm.c:		sysfs_attr_init(&msm_host->mask_and_match.attr);
mmc/host/sdhci-msm.c:		msm_host->mask_and_match.attr.name = "mask_and_match";
mmc/host/sdhci-msm.c:		msm_host->mask_and_match.attr.mode = 0644;
mmc/host/sdhci-msm.c:					&msm_host->mask_and_match);
mmc/host/sdhci-msm.c:	if (sdhci_msm_is_bootdevice(&pdev->dev))
mmc/host/sdhci-msm.c:	device_remove_file(&pdev->dev, &msm_host->msm_bus_vote.max_bus_bw);
mmc/host/sdhci-msm.c:	sdhci_msm_vreg_init(&pdev->dev, msm_host->pdata, false);
mmc/host/sdhci-msm.c:	sdhci_msm_bus_voting(host, 0);
mmc/host/sdhci-msm.c:	sdhci_msm_bus_unregister(msm_host);
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->sleep_clk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->sleep_clk);
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->ff_clk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->ff_clk);
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->clk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->clk);
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->bus_aggr_clk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->bus_aggr_clk);
mmc/host/sdhci-msm.c:	if (!IS_ERR(msm_host->pclk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->pclk);
mmc/host/sdhci-msm.c:	if (!IS_ERR_OR_NULL(msm_host->bus_clk))
mmc/host/sdhci-msm.c:		clk_disable_unprepare(msm_host->bus_clk);
mmc/host/sdhci-msm.c:	devm_kfree(&pdev->dev, msm_host);
mmc/host/sdhci-msm.c:static int sdhci_msm_remove(struct platform_device *pdev)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	struct sdhci_msm_pltfm_data *pdata = msm_host->pdata;
mmc/host/sdhci-msm.c:	int nr_groups = msm_host->pdata->pm_qos_data.cpu_group_map.nr_groups;
mmc/host/sdhci-msm.c:	if (!gpio_is_valid(msm_host->pdata->status_gpio))
mmc/host/sdhci-msm.c:		device_remove_file(&pdev->dev, &msm_host->polling);
mmc/host/sdhci-msm.c:	device_remove_file(&pdev->dev, &msm_host->auto_cmd21_attr);
mmc/host/sdhci-msm.c:	device_remove_file(&pdev->dev, &msm_host->msm_bus_vote.max_bus_bw);
mmc/host/sdhci-msm.c:	if (msm_host->pm_qos_group_enable) {
mmc/host/sdhci-msm.c:		struct sdhci_msm_pm_qos_group *group;
mmc/host/sdhci-msm.c:					&msm_host->pm_qos[i].unvote_work);
mmc/host/sdhci-msm.c:		device_remove_file(&msm_host->pdev->dev,
mmc/host/sdhci-msm.c:			&msm_host->pm_qos_group_enable_attr);
mmc/host/sdhci-msm.c:		device_remove_file(&msm_host->pdev->dev,
mmc/host/sdhci-msm.c:			&msm_host->pm_qos_group_status_attr);
mmc/host/sdhci-msm.c:			group = &msm_host->pm_qos[i];
mmc/host/sdhci-msm.c:	if (msm_host->pm_qos_irq.enabled) {
mmc/host/sdhci-msm.c:		cancel_delayed_work_sync(&msm_host->pm_qos_irq.unvote_work);
mmc/host/sdhci-msm.c:				&msm_host->pm_qos_irq.enable_attr);
mmc/host/sdhci-msm.c:				&msm_host->pm_qos_irq.status_attr);
mmc/host/sdhci-msm.c:		pm_qos_remove_request(&msm_host->pm_qos_irq.req);
mmc/host/sdhci-msm.c:	if (msm_host->pm_qos_wq)
mmc/host/sdhci-msm.c:		destroy_workqueue(msm_host->pm_qos_wq);
mmc/host/sdhci-msm.c:	sdhci_msm_vreg_init(&pdev->dev, msm_host->pdata, false);
mmc/host/sdhci-msm.c:	sdhci_msm_setup_pins(pdata, true);
mmc/host/sdhci-msm.c:	sdhci_msm_setup_pins(pdata, false);
mmc/host/sdhci-msm.c:	sdhci_msm_bus_voting(host, 0);
mmc/host/sdhci-msm.c:	if (msm_host->msm_bus_vote.client_handle)
mmc/host/sdhci-msm.c:		sdhci_msm_bus_unregister(msm_host);
mmc/host/sdhci-msm.c:static int sdhci_msm_cfg_sdio_wakeup(struct sdhci_host *host, bool enable)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	      sdhci_is_valid_gpio_wakeup_int(msm_host) &&
mmc/host/sdhci-msm.c:		msm_host->sdio_pending_processing = false;
mmc/host/sdhci-msm.c:		if (sdhci_is_valid_gpio_wakeup_int(msm_host)) {
mmc/host/sdhci-msm.c:			msm_host->sdio_pending_processing = false;
mmc/host/sdhci-msm.c:			ret = enable_irq_wake(msm_host->pdata->sdiowakeup_irq);
mmc/host/sdhci-msm.c:				sdhci_msm_cfg_sdiowakeup_gpio_irq(host, true);
mmc/host/sdhci-msm.c:		if (sdhci_is_valid_gpio_wakeup_int(msm_host)) {
mmc/host/sdhci-msm.c:			ret = disable_irq_wake(msm_host->pdata->sdiowakeup_irq);
mmc/host/sdhci-msm.c:			sdhci_msm_cfg_sdiowakeup_gpio_irq(host, false);
mmc/host/sdhci-msm.c:			msm_host->sdio_pending_processing = false;
mmc/host/sdhci-msm.c:		       ret, msm_host->pdata->sdiowakeup_irq);
mmc/host/sdhci-msm.c:static int sdhci_msm_runtime_suspend(struct device *dev)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	disable_irq(msm_host->pwr_irq);
mmc/host/sdhci-msm.c:	sdhci_msm_disable_controller_clock(host);
mmc/host/sdhci-msm.c:	trace_sdhci_msm_runtime_suspend(mmc_hostname(host->mmc), 0,
mmc/host/sdhci-msm.c:static int sdhci_msm_runtime_resume(struct device *dev)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	ret = sdhci_msm_enable_controller_clock(host);
mmc/host/sdhci-msm.c:		sdhci_msm_toggle_fifo_write_clk(host);
mmc/host/sdhci-msm.c:	enable_irq(msm_host->pwr_irq);
mmc/host/sdhci-msm.c:	trace_sdhci_msm_runtime_resume(mmc_hostname(host->mmc), 0,
mmc/host/sdhci-msm.c:static int sdhci_msm_suspend(struct device *dev)
mmc/host/sdhci-msm.c:	ret = sdhci_msm_runtime_suspend(dev);
mmc/host/sdhci-msm.c:		sdio_cfg = sdhci_msm_cfg_sdio_wakeup(host, true);
mmc/host/sdhci-msm.c:	trace_sdhci_msm_suspend(mmc_hostname(host->mmc), ret,
mmc/host/sdhci-msm.c:static int sdhci_msm_resume(struct device *dev)
mmc/host/sdhci-msm.c:	ret = sdhci_msm_runtime_resume(dev);
mmc/host/sdhci-msm.c:		sdio_cfg = sdhci_msm_cfg_sdio_wakeup(host, false);
mmc/host/sdhci-msm.c:	trace_sdhci_msm_resume(mmc_hostname(host->mmc), ret,
mmc/host/sdhci-msm.c:static int sdhci_msm_suspend_noirq(struct device *dev)
mmc/host/sdhci-msm.c:	struct sdhci_msm_host *msm_host = pltfm_host->priv;
mmc/host/sdhci-msm.c:	if (atomic_read(&msm_host->clks_on)) {
mmc/host/sdhci-msm.c:		if (msm_host->sdio_pending_processing)
mmc/host/sdhci-msm.c:static const struct dev_pm_ops sdhci_msm_pmops = {
mmc/host/sdhci-msm.c:	SET_LATE_SYSTEM_SLEEP_PM_OPS(sdhci_msm_suspend, sdhci_msm_resume)
mmc/host/sdhci-msm.c:	SET_RUNTIME_PM_OPS(sdhci_msm_runtime_suspend, sdhci_msm_runtime_resume,
mmc/host/sdhci-msm.c:	.suspend_noirq = sdhci_msm_suspend_noirq,
mmc/host/sdhci-msm.c:#define SDHCI_MSM_PMOPS (&sdhci_msm_pmops)
mmc/host/sdhci-msm.c:static const struct of_device_id sdhci_msm_dt_match[] = {
mmc/host/sdhci-msm.c:	{.compatible = "qcom,sdhci-msm"},
mmc/host/sdhci-msm.c:	{.compatible = "qcom,sdhci-msm-v5"},
mmc/host/sdhci-msm.c:	{.compatible = "qcom,sdhci-msm-cqe"},
mmc/host/sdhci-msm.c:MODULE_DEVICE_TABLE(of, sdhci_msm_dt_match);
mmc/host/sdhci-msm.c:static struct platform_driver sdhci_msm_driver = {
mmc/host/sdhci-msm.c:	.probe		= sdhci_msm_probe,
mmc/host/sdhci-msm.c:	.remove		= sdhci_msm_remove,
mmc/host/sdhci-msm.c:		.name	= "sdhci_msm",
mmc/host/sdhci-msm.c:		.of_match_table = sdhci_msm_dt_match,
mmc/host/sdhci-msm.c:module_platform_driver(sdhci_msm_driver);
mmc/host/sdhci-msm.h:struct sdhci_msm_reg_data {
mmc/host/sdhci-msm.h:struct sdhci_msm_slot_reg_data {
mmc/host/sdhci-msm.h:	struct sdhci_msm_reg_data *vdd_data;
mmc/host/sdhci-msm.h:	struct sdhci_msm_reg_data *vdd_io_data;
mmc/host/sdhci-msm.h:struct sdhci_msm_gpio {
mmc/host/sdhci-msm.h:struct sdhci_msm_gpio_data {
mmc/host/sdhci-msm.h:	struct sdhci_msm_gpio *gpio;
mmc/host/sdhci-msm.h:struct sdhci_msm_pin_data {
mmc/host/sdhci-msm.h:	struct sdhci_msm_gpio_data *gpio_data;
mmc/host/sdhci-msm.h:struct sdhci_msm_bus_voting_data {
mmc/host/sdhci-msm.h:	struct msm_bus_scale_pdata *bus_pdata;
mmc/host/sdhci-msm.h:struct sdhci_msm_cpu_group_map {
mmc/host/sdhci-msm.h:struct sdhci_msm_pm_qos_latency {
mmc/host/sdhci-msm.h:struct sdhci_msm_pm_qos_data {
mmc/host/sdhci-msm.h:	struct sdhci_msm_cpu_group_map cpu_group_map;
mmc/host/sdhci-msm.h:	struct sdhci_msm_pm_qos_latency irq_latency;
mmc/host/sdhci-msm.h:	struct sdhci_msm_pm_qos_latency *cmdq_latency;
mmc/host/sdhci-msm.h:	struct sdhci_msm_pm_qos_latency *latency;
mmc/host/sdhci-msm.h:struct sdhci_msm_pm_qos_group {
mmc/host/sdhci-msm.h:struct sdhci_msm_pm_qos_irq {
mmc/host/sdhci-msm.h:struct sdhci_msm_pltfm_data {
mmc/host/sdhci-msm.h:	struct sdhci_msm_slot_reg_data *vreg_data;
mmc/host/sdhci-msm.h:	struct sdhci_msm_pin_data *pin_data;
mmc/host/sdhci-msm.h:	struct sdhci_msm_bus_voting_data *voting_data;
mmc/host/sdhci-msm.h:	struct sdhci_msm_pm_qos_data pm_qos_data;
mmc/host/sdhci-msm.h:struct sdhci_msm_bus_vote {
mmc/host/sdhci-msm.h:struct sdhci_msm_regs_restore {
mmc/host/sdhci-msm.h:struct sdhci_msm_dll_hsr {
mmc/host/sdhci-msm.h:struct sdhci_msm_debug_data {
mmc/host/sdhci-msm.h:struct sdhci_msm_host {
mmc/host/sdhci-msm.h:	struct sdhci_msm_pltfm_data *pdata;
mmc/host/sdhci-msm.h:	struct sdhci_msm_debug_data cached_data;
mmc/host/sdhci-msm.h:	struct sdhci_pltfm_data sdhci_msm_pdata;
mmc/host/sdhci-msm.h:	struct sdhci_msm_bus_vote msm_bus_vote;
mmc/host/sdhci-msm.h:	struct sdhci_msm_pm_qos_group *pm_qos;
mmc/host/sdhci-msm.h:	struct sdhci_msm_pm_qos_irq pm_qos_irq;
mmc/host/sdhci-msm.h:	const struct sdhci_msm_offset *offset;
mmc/host/sdhci-msm.h:	struct sdhci_msm_regs_restore regs_restore;
mmc/host/sdhci-msm.h:	struct sdhci_msm_dll_hsr *dll_hsr;
mmc/host/sdhci-msm.h:void sdhci_msm_pm_qos_irq_init(struct sdhci_host *host);
mmc/host/sdhci-msm.h:void sdhci_msm_pm_qos_irq_vote(struct sdhci_host *host);
mmc/host/sdhci-msm.h:void sdhci_msm_pm_qos_irq_unvote(struct sdhci_host *host, bool async);
mmc/host/sdhci-msm.h:void sdhci_msm_pm_qos_cpu_init(struct sdhci_host *host,
mmc/host/sdhci-msm.h:		struct sdhci_msm_pm_qos_latency *latency);
mmc/host/sdhci-msm.h:void sdhci_msm_pm_qos_cpu_vote(struct sdhci_host *host,
mmc/host/sdhci-msm.h:		struct sdhci_msm_pm_qos_latency *latency, int cpu);
mmc/host/sdhci-msm.h:bool sdhci_msm_pm_qos_cpu_unvote(struct sdhci_host *host, int cpu, bool async);
net/can/rcar/rcar_can.c:	u8 msmr;	/* Mailbox Search Mode Register */
net/ethernet/aquantia/atlantic-fwd/atl_common.h:int __atl_msm_read(struct atl_hw *hw, uint32_t addr, uint32_t *val);
net/ethernet/aquantia/atlantic-fwd/atl_common.h:int atl_msm_read(struct atl_hw *hw, uint32_t addr, uint32_t *val);
net/ethernet/aquantia/atlantic-fwd/atl_common.h:int __atl_msm_write(struct atl_hw *hw, uint32_t addr, uint32_t val);
net/ethernet/aquantia/atlantic-fwd/atl_common.h:int atl_msm_write(struct atl_hw *hw, uint32_t addr, uint32_t val);
net/ethernet/aquantia/atlantic-fwd/atl_drviface.h:    uint32_t msmReg054;
net/ethernet/aquantia/atlantic-fwd/atl_drviface.h:    uint32_t msmReg058;
net/ethernet/aquantia/atlantic-fwd/atl_drviface.h:    uint32_t msmReg05c;
net/ethernet/aquantia/atlantic-fwd/atl_drviface.h:    uint32_t msmReg060;
net/ethernet/aquantia/atlantic-fwd/atl_drviface.h:    uint32_t msmReg064;
net/ethernet/aquantia/atlantic-fwd/atl_drviface.h:    uint32_t msmReg068;
net/ethernet/aquantia/atlantic-fwd/atl_drviface.h:    uint32_t msmReg06c;
net/ethernet/aquantia/atlantic-fwd/atl_drviface.h:    uint32_t msmReg070;
net/ethernet/aquantia/atlantic-fwd/atl_ethtool.c:	ret = atl_msm_read(&nic->hw, ATL_MSM_GEN_STS, &val);
net/ethernet/aquantia/atlantic-fwd/atl_ethtool.c:	ret = __atl_msm_read(hw, ATL_MSM_GEN_CTRL, &ctrl);
net/ethernet/aquantia/atlantic-fwd/atl_ethtool.c:	ret = __atl_msm_write(hw, ATL_MSM_GEN_CTRL, ctrl);
net/ethernet/aquantia/atlantic-fwd/atl_hw.c:static int atl_msm_wait(struct atl_hw *hw)
net/ethernet/aquantia/atlantic-fwd/atl_hw.c:int __atl_msm_read(struct atl_hw *hw, uint32_t addr, uint32_t *val)
net/ethernet/aquantia/atlantic-fwd/atl_hw.c:	ret = atl_msm_wait(hw);
net/ethernet/aquantia/atlantic-fwd/atl_hw.c:	ret = atl_msm_wait(hw);
net/ethernet/aquantia/atlantic-fwd/atl_hw.c:int atl_msm_read(struct atl_hw *hw, uint32_t addr, uint32_t *val)
net/ethernet/aquantia/atlantic-fwd/atl_hw.c:	ret = __atl_msm_read(hw, addr, val);
net/ethernet/aquantia/atlantic-fwd/atl_hw.c:int __atl_msm_write(struct atl_hw *hw, uint32_t addr, uint32_t val)
net/ethernet/aquantia/atlantic-fwd/atl_hw.c:	ret = atl_msm_wait(hw);
net/ethernet/aquantia/atlantic-fwd/atl_hw.c:	ret = atl_msm_wait(hw);
net/ethernet/aquantia/atlantic-fwd/atl_hw.c:int atl_msm_write(struct atl_hw *hw, uint32_t addr, uint32_t val)
net/ethernet/aquantia/atlantic-fwd/atl_hw.c:	ret = __atl_msm_write(hw, addr, val);
net/ethernet/aquantia/atlantic-fwd/atl_hw.c:	RET = __atl_msm_read(HW, REGISTER, PVARIABLE); \
net/ethernet/aquantia/atlantic-fwd/atl_hw.c:	ret = atl_msm_read(hw, ATL_MSM_TX_LPI_DELAY, &lpi);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c:/* msm */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c:u32 hw_atl_msm_reg_access_status_get(struct aq_hw_s *aq_hw)
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c:void hw_atl_msm_reg_addr_for_indirect_addr_set(struct aq_hw_s *aq_hw,
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c:void hw_atl_msm_reg_rd_strobe_set(struct aq_hw_s *aq_hw, u32 reg_rd_strobe)
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c:u32 hw_atl_msm_reg_rd_data_get(struct aq_hw_s *aq_hw)
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c:void hw_atl_msm_reg_wr_data_set(struct aq_hw_s *aq_hw, u32 reg_wr_data)
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.c:void hw_atl_msm_reg_wr_strobe_set(struct aq_hw_s *aq_hw, u32 reg_wr_strobe)
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* get msm rx errors counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_reg_mac_msm_rx_errs_cnt_get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* get msm rx unicast frames counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_reg_mac_msm_rx_ucst_frm_cnt_get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* get msm rx multicast frames counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_reg_mac_msm_rx_mcst_frm_cnt_get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* get msm rx broadcast frames counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_reg_mac_msm_rx_bcst_frm_cnt_get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* get msm rx broadcast octets counter register 1 */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_reg_mac_msm_rx_bcst_octets_counter1get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* get msm rx unicast octets counter register 0 */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_reg_mac_msm_rx_ucst_octets_counter0get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* get msm tx errors counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_reg_mac_msm_tx_errs_cnt_get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* get msm tx unicast frames counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_reg_mac_msm_tx_ucst_frm_cnt_get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* get msm tx multicast frames counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_reg_mac_msm_tx_mcst_frm_cnt_get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* get msm tx broadcast frames counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_reg_mac_msm_tx_bcst_frm_cnt_get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* get msm tx multicast octets counter register 1 */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_reg_mac_msm_tx_mcst_octets_counter1get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* get msm tx broadcast octets counter register 1 */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_reg_mac_msm_tx_bcst_octets_counter1get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* get msm tx unicast octets counter register 0 */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_reg_mac_msm_tx_ucst_octets_counter0get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:/* msm */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_msm_reg_access_status_get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:void hw_atl_msm_reg_addr_for_indirect_addr_set(struct aq_hw_s *aq_hw,
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:void hw_atl_msm_reg_rd_strobe_set(struct aq_hw_s *aq_hw, u32 reg_rd_strobe);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:u32 hw_atl_msm_reg_rd_data_get(struct aq_hw_s *aq_hw);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:void hw_atl_msm_reg_wr_data_set(struct aq_hw_s *aq_hw, u32 reg_wr_data);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh.h:void hw_atl_msm_reg_wr_strobe_set(struct aq_hw_s *aq_hw, u32 reg_wr_strobe);
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* preprocessor definitions for msm rx errors counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* preprocessor definitions for msm rx unicast frames counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* preprocessor definitions for msm rx multicast frames counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* preprocessor definitions for msm rx broadcast frames counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* preprocessor definitions for msm rx broadcast octets counter register 1 */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* preprocessor definitions for msm rx broadcast octets counter register 2 */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* preprocessor definitions for msm rx unicast octets counter register 0 */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* preprocessor definitions for msm tx unicast frames counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* preprocessor definitions for msm tx multicast frames counter register */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h: * port="msm_pif_reg_busy_o"
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* mac_phy msm register address[7:0] bitfield definitions
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h: * preprocessor definitions for the bitfield "msm register address[7:0]".
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h: * port="pif_msm_reg_addr_i[7:0]"
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* register address for bitfield msm register address[7:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* bitmask for bitfield msm register address[7:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* inverted bitmask for bitfield msm register address[7:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* lower bit position of bitfield msm register address[7:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* width of bitfield msm register address[7:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* default value of bitfield msm register address[7:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h: * port="pif_msm_reg_rden_i"
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* mac_phy msm register read data[31:0] bitfield definitions
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h: * preprocessor definitions for the bitfield "msm register read data[31:0]".
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h: * port="msm_pif_reg_rd_data_o[31:0]"
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* register address for bitfield msm register read data[31:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* bitmask for bitfield msm register read data[31:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* inverted bitmask for bitfield msm register read data[31:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* lower bit position of bitfield msm register read data[31:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* width of bitfield msm register read data[31:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* mac_phy msm register write data[31:0] bitfield definitions
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h: * preprocessor definitions for the bitfield "msm register write data[31:0]".
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h: * port="pif_msm_reg_wr_data_i[31:0]"
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* register address for bitfield msm register write data[31:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* bitmask for bitfield msm register write data[31:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* inverted bitmask for bitfield msm register write data[31:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* lower bit position of bitfield msm register write data[31:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* width of bitfield msm register write data[31:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h:/* default value of bitfield msm register write data[31:0] */
net/ethernet/aquantia/atlantic/hw_atl/hw_atl_llh_internal.h: * port="pif_msm_reg_wren_i"
net/ethernet/qcom/Kconfig:# msm network device configuration
net/ethernet/qcom/Makefile:# Makefile for the msm networking support.
net/ethernet/qcom/Makefile:obj-$(CONFIG_MSM_RMNET_BAM) += msm_rmnet_bam.o
net/ethernet/qcom/msm_rmnet_bam.c:#include <linux/msm_rmnet.h>
net/ethernet/qcom/msm_rmnet_bam.c:static int msm_rmnet_bam_debug_mask;
net/ethernet/qcom/msm_rmnet_bam.c:	return scnprintf(buf, PAGE_SIZE, "%d\n", msm_rmnet_bam_debug_mask);
net/ethernet/qcom/msm_rmnet_bam.c:	msm_rmnet_bam_debug_mask = val;
net/ethernet/qcom/msm_rmnet_bam.c:static unsigned long msm_rmnet_bam_headroom_check_failure;
net/ethernet/qcom/msm_rmnet_bam.c:msm_rmnet_bam_headroom_check_failure_show(struct device *dev,
net/ethernet/qcom/msm_rmnet_bam.c:			msm_rmnet_bam_headroom_check_failure);
net/ethernet/qcom/msm_rmnet_bam.c:static DEVICE_ATTR_RO(msm_rmnet_bam_headroom_check_failure);
net/ethernet/qcom/msm_rmnet_bam.c:		if (msm_rmnet_bam_debug_mask & (m)) \
net/ethernet/qcom/msm_rmnet_bam.c:		msm_rmnet_bam_headroom_check_failure++;
net/ethernet/qcom/msm_rmnet_bam.c:	bam_ret = msm_bam_dmux_write(p->ch_id, skb);
net/ethernet/qcom/msm_rmnet_bam.c:	    msm_bam_dmux_is_ch_low(p->ch_id)) {
net/ethernet/qcom/msm_rmnet_bam.c:		r = msm_bam_dmux_open(p->ch_id, dev, bam_notify);
net/ethernet/qcom/msm_rmnet_bam.c:	awake = msm_bam_dmux_ul_power_vote();
net/ethernet/qcom/msm_rmnet_bam.c:	if (msm_bam_dmux_is_ch_full(p->ch_id)) {
net/ethernet/qcom/msm_rmnet_bam.c:	msm_bam_dmux_ul_power_unvote();
net/ethernet/qcom/msm_rmnet_bam.c:			   &dev_attr_msm_rmnet_bam_headroom_check_failure);
net/ethernet/qcom/msm_rmnet_bam.c:	device_remove_file(dev, &dev_attr_msm_rmnet_bam_headroom_check_failure);
net/ethernet/qcom/msm_rmnet_bam.c:	msm_bam_dmux_close(p->ch_id);
net/wireless/ath/wil6210/Kconfig:	  Platform driver used to handle msm specific platform
net/wireless/ath/wil6210/Kconfig:	  requirement for 11ad chipset connected to msm platform
net/wireless/ath/wil6210/Makefile:MSM_11AD_PATH = drivers/platform/msm/msm_11ad
net/wireless/ath/wil6210/ipa.h:#include <linux/msm_ipa.h>
net/wireless/ath/wil6210/wil_platform.c:#include "msm_11ad.h"
net/wireless/ath/wil6210/wil_platform.c:	return msm_11ad_modinit();
net/wireless/ath/wil6210/wil_platform.c:	msm_11ad_modexit();
net/wireless/ath/wil6210/wil_platform.c:	handle = msm_11ad_dev_init(dev, ops, rops, wil_handle);
net/wireless/broadcom/b43/main.c:MODULE_PARM_DESC(allhwsupport, "Enable support for all hardware (even it if overlaps with the brcmsmac driver)");
net/wireless/broadcom/b43/phy_lcn.c:		/* brcmsmac uses outdated 0x3 for 0x038 */
net/wireless/broadcom/b43/phy_lcn.c:		/* TODO: wl operates on PHY 0x416, brcmsmac is outdated here */
net/wireless/broadcom/b43/phy_lcn.c:	/* Table is from brcmsmac, values for type 25 were outdated, probably
net/wireless/broadcom/b43/phy_lcn.c:		/* brcmsmac version { 25, { 1, 299, 1884, 51, 64, 51, 736, 1720,
net/wireless/broadcom/b43/phy_lcn.c:		/* brcmsmac uses filter_type 2, we follow wl with 25 */
net/wireless/broadcom/b43/phy_lcn.c:	/* brcmsmac uses filter_type 2, we follow wl with 0 */
net/wireless/broadcom/b43/radio_2057.c:/* Copied from brcmsmac (5.75.11): chan_info_nphyrev8_2057_rev5 */
net/wireless/broadcom/b43/tables_nphy.c:/* Copied from brcmsmac (5.75.11) */
net/wireless/broadcom/b43/tables_nphy.c:/* Copied from brcmsmac (5.75.11): nphy_tpc_txgain_ipa_2g_2057rev5 */
net/wireless/broadcom/b43/tables_phy_lcn.c:		/* brcmsmac doesn't maskset, we follow newer wl here */
net/wireless/broadcom/b43/tables_phy_lcn.c:/* Not implemented in brcmsmac, noticed in wl in MMIO dump */
net/wireless/broadcom/brcm80211/Kconfig:	  module, the driver will be called brcmsmac.ko.
net/wireless/broadcom/brcm80211/Makefile:obj-$(CONFIG_BRCMSMAC)	+= brcmsmac/
net/wireless/broadcom/brcm80211/brcmsmac/Makefile:	-Idrivers/net/wireless/broadcom/brcm80211/brcmsmac \
net/wireless/broadcom/brcm80211/brcmsmac/Makefile:	-Idrivers/net/wireless/broadcom/brcm80211/brcmsmac/phy \
net/wireless/broadcom/brcm80211/brcmsmac/Makefile:brcmsmac-y := \
net/wireless/broadcom/brcm80211/brcmsmac/Makefile:brcmsmac-$(CONFIG_BCMA_DRIVER_GPIO) += led.o
net/wireless/broadcom/brcm80211/brcmsmac/Makefile:obj-$(CONFIG_BRCMSMAC)	+= brcmsmac.o
net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac.h:#define TRACE_SYSTEM brcmsmac
net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac.h:#define TRACE_INCLUDE_FILE brcms_trace_brcmsmac
net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_msg.h:#define TRACE_SYSTEM brcmsmac_msg
net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_msg.h:#define TRACE_INCLUDE_FILE brcms_trace_brcmsmac_msg
net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_tx.h:#define TRACE_SYSTEM brcmsmac_tx
net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_tx.h:#define TRACE_INCLUDE_FILE brcms_trace_brcmsmac_tx
net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_events.h:#include "brcms_trace_brcmsmac.h"
net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_events.h:#include "brcms_trace_brcmsmac_tx.h"
net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_events.h:#include "brcms_trace_brcmsmac_msg.h"
net/wireless/broadcom/brcm80211/brcmsmac/led.c:		 "brcmsmac-%s:radio", wiphy_name(wl->wiphy));
net/wireless/broadcom/brcm80211/brcmsmac/mac80211_if.c: * This is the main entry point for the brcmsmac driver.
net/wireless/broadcom/brcm80211/brcmsmac/mac80211_if.c: * This function unloads the brcmsmac driver from the system.
net/wireless/broadcom/brcm80211/brcmsmac/mac80211_if.c: * This function unconditionally unloads the brcmsmac driver module from the
net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h:/* brcmsmac IDs */
net/wireless/cnss2/main.c:		ret = msm_bus_scale_client_update_request
net/wireless/cnss2/main.c:	struct msm_dump_entry dump_entry;
net/wireless/cnss2/main.c:	return msm_dump_data_register_nominidump(MSM_DUMP_TABLE_APPS,
net/wireless/cnss2/main.c:	struct msm_dump_entry dump_entry;
net/wireless/cnss2/main.c:	ret = msm_dump_data_register_nominidump(MSM_DUMP_TABLE_APPS,
net/wireless/cnss2/main.c:	ret = msm_minidump_add_region(&md_entry);
net/wireless/cnss2/main.c:	ret = msm_minidump_remove_region(&md_entry);
net/wireless/cnss2/main.c:		msm_bus_cl_get_pdata(plat_priv->plat_dev);
net/wireless/cnss2/main.c:			msm_bus_scale_register_client
net/wireless/cnss2/main.c:		msm_bus_scale_unregister_client(bus_bw_info->bus_client);
net/wireless/cnss2/main.h:#include <linux/msm-bus.h>
net/wireless/cnss2/main.h:	struct msm_dump_data dump_data;
net/wireless/cnss2/main.h:	struct msm_bus_scale_pdata *bus_scale_table;
net/wireless/cnss2/pci.c:	return msm_pcie_reg_dump(pci_priv->pci_dev, buf, len);
net/wireless/cnss2/pci.c:	return msm_pcie_set_link_bandwidth(pci_priv->pci_dev,
net/wireless/cnss2/pci.c:	enum msm_pcie_pm_opt pm_ops;
net/wireless/cnss2/pci.c:	ret = msm_pcie_pm_control(pm_ops, pci_dev->bus->number, pci_dev,
net/wireless/cnss2/pci.c:	return msm_pcie_prevent_l1(pci_dev);
net/wireless/cnss2/pci.c:	msm_pcie_allow_l1(pci_dev);
net/wireless/cnss2/pci.c:	ret = msm_pcie_pm_control(MSM_PCIE_HANDLE_LINKDOWN,
net/wireless/cnss2/pci.c:static void cnss_pci_event_cb(struct msm_pcie_notify *notify)
net/wireless/cnss2/pci.c:		ret = msm_pcie_pm_control(MSM_PCIE_HANDLE_LINKDOWN,
net/wireless/cnss2/pci.c:	struct msm_pcie_register_event *pci_event;
net/wireless/cnss2/pci.c:	pci_event = &pci_priv->msm_pci_event;
net/wireless/cnss2/pci.c:	ret = msm_pcie_register_event(pci_event);
net/wireless/cnss2/pci.c:	msm_pcie_deregister_event(&pci_priv->msm_pci_event);
net/wireless/cnss2/pci.c:	ret = msm_pcie_pm_control(vote ? MSM_PCIE_DISABLE_PC :
net/wireless/cnss2/pci.c:	msm_bus_scale_client_update_request(bus_bw_info->bus_client,
net/wireless/cnss2/pci.c:	msm_bus_scale_client_update_request(bus_bw_info->bus_client,
net/wireless/cnss2/pci.c:	ret = msm_pcie_set_link_bandwidth(pci_priv->pci_dev,
net/wireless/cnss2/pci.c:	ret = msm_pcie_enumerate(rc_num);
net/wireless/cnss2/pci.h:#include <linux/msm_pcie.h>
net/wireless/cnss2/pci.h:	struct msm_pcie_register_event msm_pci_event;
nfc/nq-nci.c:static const struct of_device_id msm_match_table[] = {
nfc/nq-nci.c:MODULE_DEVICE_TABLE(of, msm_match_table);
nfc/nq-nci.c:		.of_match_table = msm_match_table,
of/property.c:static struct device_node *parse_msm_bus_name(struct device_node *np,
of/property.c:	if (index || strcmp(prop_name, "qcom,msm-bus,name"))
of/property.c:						     "qcom,msm-bus-device");
of/property.c:	{ .parse_prop = parse_msm_bus_name, },
pci/controller/Makefile:obj-$(CONFIG_PCI_MSM) += pci-msm.o
pci/controller/Makefile:obj-$(CONFIG_PCI_MSM_MSI) += pci-msm-msi.o
pci/controller/dwc/pcie-qcom.c:	{ .compatible = "qcom,pcie-msm8996", .data = &ops_2_3_2 },
pci/controller/pci-msm-msi.c:struct msm_msi_irq {
pci/controller/pci-msm-msi.c:struct msm_msi {
pci/controller/pci-msm-msi.c:	struct msm_msi_irq *irqs;
pci/controller/pci-msm-msi.c:struct msm_msi_client {
pci/controller/pci-msm-msi.c:	struct msm_msi *msi;
pci/controller/pci-msm-msi.c:static void msm_msi_handler(struct irq_desc *desc)
pci/controller/pci-msm-msi.c:	struct msm_msi *msi;
pci/controller/pci-msm-msi.c:static void msm_msi_mask_irq(struct irq_data *data)
pci/controller/pci-msm-msi.c:static void msm_msi_unmask_irq(struct irq_data *data)
pci/controller/pci-msm-msi.c:static struct irq_chip msm_msi_irq_chip = {
pci/controller/pci-msm-msi.c:	.name = "msm_pci_msi",
pci/controller/pci-msm-msi.c:	.irq_enable = msm_msi_unmask_irq,
pci/controller/pci-msm-msi.c:	.irq_disable = msm_msi_mask_irq,
pci/controller/pci-msm-msi.c:	.irq_mask = msm_msi_mask_irq,
pci/controller/pci-msm-msi.c:	.irq_unmask = msm_msi_unmask_irq,
pci/controller/pci-msm-msi.c:static int msm_msi_domain_prepare(struct irq_domain *domain, struct device *dev,
pci/controller/pci-msm-msi.c:	struct msm_msi *msi = domain->parent->host_data;
pci/controller/pci-msm-msi.c:	struct msm_msi_client *client;
pci/controller/pci-msm-msi.c:void msm_msi_domain_finish(msi_alloc_info_t *arg, int retval)
pci/controller/pci-msm-msi.c:	struct msm_msi *msi = domain->parent->host_data;
pci/controller/pci-msm-msi.c:		struct msm_msi_client *tmp, *client = NULL;
pci/controller/pci-msm-msi.c:static struct msi_domain_ops msm_msi_domain_ops = {
pci/controller/pci-msm-msi.c:	.msi_prepare = msm_msi_domain_prepare,
pci/controller/pci-msm-msi.c:	.msi_finish = msm_msi_domain_finish,
pci/controller/pci-msm-msi.c:static struct msi_domain_info msm_msi_domain_info = {
pci/controller/pci-msm-msi.c:	.ops = &msm_msi_domain_ops,
pci/controller/pci-msm-msi.c:	.chip = &msm_msi_irq_chip,
pci/controller/pci-msm-msi.c:static int msm_msi_irq_set_affinity(struct irq_data *data,
pci/controller/pci-msm-msi.c:static void msm_msi_irq_compose_msi_msg(struct irq_data *data,
pci/controller/pci-msm-msi.c:	struct msm_msi_client *client = irq_data_get_irq_chip_data(data);
pci/controller/pci-msm-msi.c:static struct irq_chip msm_msi_bottom_irq_chip = {
pci/controller/pci-msm-msi.c:	.name = "msm_msi",
pci/controller/pci-msm-msi.c:	.irq_set_affinity = msm_msi_irq_set_affinity,
pci/controller/pci-msm-msi.c:	.irq_compose_msi_msg = msm_msi_irq_compose_msi_msg,
pci/controller/pci-msm-msi.c:static int msm_msi_irq_domain_alloc(struct irq_domain *domain,
pci/controller/pci-msm-msi.c:	struct msm_msi *msi = domain->host_data;
pci/controller/pci-msm-msi.c:	struct msm_msi_client *tmp, *client = NULL;
pci/controller/pci-msm-msi.c:				&msm_msi_bottom_irq_chip, client,
pci/controller/pci-msm-msi.c:static void msm_msi_irq_domain_free(struct irq_domain *domain,
pci/controller/pci-msm-msi.c:	struct msm_msi_client *client;
pci/controller/pci-msm-msi.c:	struct msm_msi *msi;
pci/controller/pci-msm-msi.c:	.alloc = msm_msi_irq_domain_alloc,
pci/controller/pci-msm-msi.c:	.free = msm_msi_irq_domain_free,
pci/controller/pci-msm-msi.c:static int msm_msi_alloc_domains(struct msm_msi *msi)
pci/controller/pci-msm-msi.c:					&msm_msi_domain_info,
pci/controller/pci-msm-msi.c:int msm_msi_init(struct device *dev)
pci/controller/pci-msm-msi.c:	struct msm_msi *msi;
pci/controller/pci-msm-msi.c:	ret = msm_msi_alloc_domains(msi);
pci/controller/pci-msm-msi.c:						msm_msi_handler, msi);
pci/controller/pci-msm-msi.c:EXPORT_SYMBOL(msm_msi_init);
pci/controller/pci-msm.c:#include <linux/msm-bus.h>
pci/controller/pci-msm.c:#include <linux/msm-bus-board.h>
pci/controller/pci-msm.c:#include <linux/msm_pcie.h>
pci/controller/pci-msm.c:	(struct msm_pcie_dev_t *)(bus->sysdata)
pci/controller/pci-msm.c:	if (msm_pcie_debug_mask) \
pci/controller/pci-msm.c:	if (msm_pcie_debug_mask)   \
pci/controller/pci-msm.c:	if (msm_pcie_debug_mask)   \
pci/controller/pci-msm.c:	if (msm_pcie_debug_mask)   \
pci/controller/pci-msm.c:enum msm_pcie_res {
pci/controller/pci-msm.c:enum msm_pcie_irq {
pci/controller/pci-msm.c:enum msm_pcie_irq_event {
pci/controller/pci-msm.c:enum msm_pcie_gpio {
pci/controller/pci-msm.c:enum msm_pcie_link_status {
pci/controller/pci-msm.c:enum msm_pcie_boot_option {
pci/controller/pci-msm.c:enum msm_pcie_ltssm {
pci/controller/pci-msm.c:static const char * const msm_pcie_ltssm_str[] = {
pci/controller/pci-msm.c:#define TO_LTSSM_STR(state) ((state) >= ARRAY_SIZE(msm_pcie_ltssm_str) ? \
pci/controller/pci-msm.c:				"LTSSM_INVALID" : msm_pcie_ltssm_str[state])
pci/controller/pci-msm.c:enum msm_pcie_debugfs_option {
pci/controller/pci-msm.c:	msm_pcie_debugfs_option_desc[MSM_PCIE_MAX_DEBUGFS_OPTION] = {
pci/controller/pci-msm.c:struct msm_pcie_gpio_info_t {
pci/controller/pci-msm.c:struct msm_pcie_vreg_info_t {
pci/controller/pci-msm.c:struct msm_pcie_reset_info_t {
pci/controller/pci-msm.c:struct msm_pcie_clk_info_t {
pci/controller/pci-msm.c:struct msm_pcie_res_info_t {
pci/controller/pci-msm.c:struct msm_pcie_irq_info_t {
pci/controller/pci-msm.c:struct msm_pcie_bw_scale_info_t {
pci/controller/pci-msm.c:struct msm_pcie_phy_info_t {
pci/controller/pci-msm.c:struct msm_pcie_sid_info_t {
pci/controller/pci-msm.c:struct msm_pcie_device_info {
pci/controller/pci-msm.c:	struct msm_pcie_register_event *event_reg;
pci/controller/pci-msm.c:enum msm_pcie_drv_cmds {
pci/controller/pci-msm.c:enum msm_pcie_drv_msg_id {
pci/controller/pci-msm.c:struct __packed msm_pcie_drv_header {
pci/controller/pci-msm.c:struct __packed msm_pcie_drv_tre {
pci/controller/pci-msm.c:struct __packed msm_pcie_drv_msg {
pci/controller/pci-msm.c:	struct msm_pcie_drv_header hdr;
pci/controller/pci-msm.c:	struct msm_pcie_drv_tre pkt;
pci/controller/pci-msm.c:struct msm_pcie_drv_info {
pci/controller/pci-msm.c:	struct msm_pcie_drv_msg drv_enable; /* hand off payload */
pci/controller/pci-msm.c:	struct msm_pcie_drv_msg drv_disable; /* payload to request back */
pci/controller/pci-msm.c:/* msm pcie device structure */
pci/controller/pci-msm.c:struct msm_pcie_dev_t {
pci/controller/pci-msm.c:	struct msm_pcie_vreg_info_t vreg[MSM_PCIE_MAX_VREG];
pci/controller/pci-msm.c:	struct msm_pcie_gpio_info_t gpio[MSM_PCIE_MAX_GPIO];
pci/controller/pci-msm.c:	struct msm_pcie_clk_info_t clk[MSM_PCIE_MAX_CLK];
pci/controller/pci-msm.c:	struct msm_pcie_clk_info_t pipeclk[MSM_PCIE_MAX_PIPE_CLK];
pci/controller/pci-msm.c:	struct msm_pcie_res_info_t res[MSM_PCIE_MAX_RES];
pci/controller/pci-msm.c:	struct msm_pcie_irq_info_t irq[MSM_PCIE_MAX_IRQ];
pci/controller/pci-msm.c:	struct msm_pcie_reset_info_t reset[MSM_PCIE_MAX_RESET];
pci/controller/pci-msm.c:	struct msm_pcie_reset_info_t pipe_reset[MSM_PCIE_MAX_PIPE_RESET];
pci/controller/pci-msm.c:	struct msm_pcie_reset_info_t linkdown_reset[MSM_PCIE_MAX_LINKDOWN_RESET];
pci/controller/pci-msm.c:	struct msm_pcie_vreg_info_t *cx_vreg;
pci/controller/pci-msm.c:	struct msm_pcie_clk_info_t *rate_change_clk;
pci/controller/pci-msm.c:	struct msm_pcie_bw_scale_info_t *bw_scale;
pci/controller/pci-msm.c:	enum msm_pcie_link_status link_status;
pci/controller/pci-msm.c:	struct msm_bus_scale_pdata *bus_scale_table;
pci/controller/pci-msm.c:	struct msm_pcie_phy_info_t *phy_sequence;
pci/controller/pci-msm.c:	struct msm_pcie_sid_info_t *sid_info;
pci/controller/pci-msm.c:	struct msm_pcie_register_event *event_reg;
pci/controller/pci-msm.c:	struct msm_pcie_device_info pcidev_table[MAX_DEVICE_NUM];
pci/controller/pci-msm.c:	struct msm_pcie_drv_info *drv_info;
pci/controller/pci-msm.c:	void (*rumi_init)(struct msm_pcie_dev_t *pcie_dev);
pci/controller/pci-msm.c:struct msm_root_dev_t {
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev;
pci/controller/pci-msm.c:static int msm_pcie_debug_mask;
pci/controller/pci-msm.c:module_param_named(debug_mask, msm_pcie_debug_mask,
pci/controller/pci-msm.c:static int msm_pcie_invert_l0s_support;
pci/controller/pci-msm.c:module_param_named(invert_l0s_support, msm_pcie_invert_l0s_support,
pci/controller/pci-msm.c:static int msm_pcie_invert_l1_support;
pci/controller/pci-msm.c:module_param_named(invert_l1_support, msm_pcie_invert_l1_support,
pci/controller/pci-msm.c:static int msm_pcie_invert_l1ss_support;
pci/controller/pci-msm.c:module_param_named(invert_l1ss_support, msm_pcie_invert_l1ss_support,
pci/controller/pci-msm.c:static int msm_pcie_invert_aer_support;
pci/controller/pci-msm.c:module_param_named(invert_aer_support, msm_pcie_invert_aer_support,
pci/controller/pci-msm.c:static int msm_pcie_keep_resources_on;
pci/controller/pci-msm.c:module_param_named(keep_resources_on, msm_pcie_keep_resources_on,
pci/controller/pci-msm.c:static int msm_pcie_force_gen1;
pci/controller/pci-msm.c:module_param_named(force_gen1, msm_pcie_force_gen1,
pci/controller/pci-msm.c:static int msm_pcie_link_check_max_count;
pci/controller/pci-msm.c:module_param_named(link_check_max_count, msm_pcie_link_check_max_count,
pci/controller/pci-msm.c:static u8 msm_pcie_crc8_table[CRC8_TABLE_SIZE];
pci/controller/pci-msm.c:static struct msm_pcie_device_info
pci/controller/pci-msm.c:	msm_pcie_dev_tbl[MAX_RC_NUM * MAX_DEVICE_NUM];
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *msm_pcie_dev;
pci/controller/pci-msm.c:/* msm pcie device data */
pci/controller/pci-msm.c:static struct msm_pcie_dev_t msm_pcie_dev[MAX_RC_NUM];
pci/controller/pci-msm.c:static struct msm_pcie_vreg_info_t msm_pcie_vreg_info[MSM_PCIE_MAX_VREG] = {
pci/controller/pci-msm.c:static struct msm_pcie_gpio_info_t msm_pcie_gpio_info[MSM_PCIE_MAX_GPIO] = {
pci/controller/pci-msm.c:static struct msm_pcie_reset_info_t
pci/controller/pci-msm.c:msm_pcie_reset_info[MAX_RC_NUM][MSM_PCIE_MAX_RESET] = {
pci/controller/pci-msm.c:static struct msm_pcie_reset_info_t
pci/controller/pci-msm.c:msm_pcie_pipe_reset_info[MAX_RC_NUM][MSM_PCIE_MAX_PIPE_RESET] = {
pci/controller/pci-msm.c:static struct msm_pcie_reset_info_t
pci/controller/pci-msm.c:msm_pcie_linkdown_reset_info[MAX_RC_NUM][MSM_PCIE_MAX_LINKDOWN_RESET] = {
pci/controller/pci-msm.c:static struct msm_pcie_clk_info_t
pci/controller/pci-msm.c:	msm_pcie_clk_info[MAX_RC_NUM][MSM_PCIE_MAX_CLK] = {
pci/controller/pci-msm.c:static struct msm_pcie_clk_info_t
pci/controller/pci-msm.c:	msm_pcie_pipe_clk_info[MAX_RC_NUM][MSM_PCIE_MAX_PIPE_CLK] = {
pci/controller/pci-msm.c:static const struct msm_pcie_res_info_t msm_pcie_res_info[MSM_PCIE_MAX_RES] = {
pci/controller/pci-msm.c:static const struct msm_pcie_irq_info_t msm_pcie_irq_info[MSM_PCIE_MAX_IRQ] = {
pci/controller/pci-msm.c:struct msm_pcie_reg_dump_t {
pci/controller/pci-msm.c:static struct msm_pcie_reg_dump_t parf_reg_dump[MSM_PCIE_PARF_REG_DUMP + 1] = {
pci/controller/pci-msm.c:static struct msm_pcie_reg_dump_t dbi_reg_dump[MSM_PCIE_DBI_REG_DUMP + 1] = {
pci/controller/pci-msm.c:static struct msm_pcie_reg_dump_t phy_reg_dump[MSM_PCIE_PHY_REG_DUMP + 1] = {
pci/controller/pci-msm.c:static void msm_pcie_config_sid(struct msm_pcie_dev_t *dev);
pci/controller/pci-msm.c:static void msm_pcie_config_l0s_disable_all(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:static void msm_pcie_config_l1_disable_all(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:static void msm_pcie_config_l1ss_disable_all(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:static void msm_pcie_config_l0s_enable_all(struct msm_pcie_dev_t *dev);
pci/controller/pci-msm.c:static void msm_pcie_config_l1_enable_all(struct msm_pcie_dev_t *dev);
pci/controller/pci-msm.c:static void msm_pcie_config_l1ss_enable_all(struct msm_pcie_dev_t *dev);
pci/controller/pci-msm.c:static void msm_pcie_check_l1ss_support_all(struct msm_pcie_dev_t *dev);
pci/controller/pci-msm.c:static void msm_pcie_config_link_pm(struct msm_pcie_dev_t *dev, bool enable);
pci/controller/pci-msm.c:static inline void msm_pcie_fixup_irqs(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static inline void msm_pcie_fixup_irqs(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static u32 msm_pcie_reg_copy(struct msm_pcie_dev_t *pcie_dev,
pci/controller/pci-msm.c:		struct msm_pcie_reg_dump_t *reg_list,
pci/controller/pci-msm.c:int msm_pcie_reg_dump(struct pci_dev *pci_dev, u8 *buff, u32 len)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev;
pci/controller/pci-msm.c:	offset = msm_pcie_reg_copy(pcie_dev, buff, len,
pci/controller/pci-msm.c:		offset = msm_pcie_reg_copy(pcie_dev, buff, len,
pci/controller/pci-msm.c:	offset = msm_pcie_reg_copy(pcie_dev, buff, len,
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_reg_dump);
pci/controller/pci-msm.c:static inline void msm_pcie_write_reg(void __iomem *base, u32 offset, u32 value)
pci/controller/pci-msm.c:static inline void msm_pcie_write_reg_field(void __iomem *base, u32 offset,
pci/controller/pci-msm.c:static inline void msm_pcie_config_clear_set_dword(struct pci_dev *pdev,
pci/controller/pci-msm.c:static inline void msm_pcie_config_clock_mem(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:	struct msm_pcie_clk_info_t *info)
pci/controller/pci-msm.c:static void msm_pcie_rumi_init(struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:	msm_pcie_write_reg(pcie_dev->rumi, phy_ctrl_offs, val);
pci/controller/pci-msm.c:	msm_pcie_write_reg(pcie_dev->rumi, reset_offs, 0x800);
pci/controller/pci-msm.c:	msm_pcie_write_reg(pcie_dev->rumi, reset_offs, 0xFFFFFFFF);
pci/controller/pci-msm.c:	msm_pcie_write_reg(pcie_dev->rumi, reset_offs, 0x800);
pci/controller/pci-msm.c:	msm_pcie_write_reg(pcie_dev->rumi, reset_offs, 0);
pci/controller/pci-msm.c:	msm_pcie_write_reg(pcie_dev->rumi, phy_ctrl_offs, val);
pci/controller/pci-msm.c:	msm_pcie_write_reg(pcie_dev->rumi, phy_ctrl_offs, val);
pci/controller/pci-msm.c:static void pcie_phy_dump(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static inline int msm_pcie_check_align(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:static bool msm_pcie_confirm_linkup(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:static void msm_pcie_cfg_recover(struct msm_pcie_dev_t *dev, bool rc)
pci/controller/pci-msm.c:			if (!msm_pcie_confirm_linkup(dev, false, true,
pci/controller/pci-msm.c:				msm_pcie_write_reg(cfg, j * 4, val);
pci/controller/pci-msm.c:static void msm_pcie_write_mask(void __iomem *addr,
pci/controller/pci-msm.c:static void pcie_parf_dump(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:		msm_pcie_write_mask(dev->parf + PCIE20_PARF_SYS_CTRL,
pci/controller/pci-msm.c:	msm_pcie_write_reg(dev->parf, PCIE20_PARF_SYS_CTRL, original);
pci/controller/pci-msm.c:static void pcie_dm_core_dump(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static void msm_pcie_show_status(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static void msm_pcie_shadow_dump(struct msm_pcie_dev_t *dev, bool rc)
pci/controller/pci-msm.c:static void msm_pcie_sel_debug_testcase(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:		msm_pcie_show_status(dev);
pci/controller/pci-msm.c:		ret = msm_pcie_pm_control(MSM_PCIE_SUSPEND, 0,
pci/controller/pci-msm.c:		ret = msm_pcie_pm_control(MSM_PCIE_RESUME, 0,
pci/controller/pci-msm.c:			msm_pcie_recover_config(dev->dev);
pci/controller/pci-msm.c:		ret = msm_pcie_pm_control(MSM_PCIE_SUSPEND, 0,
pci/controller/pci-msm.c:		ret = msm_pcie_pm_control(MSM_PCIE_RESUME, 0,
pci/controller/pci-msm.c:			msm_pcie_recover_config(dev->dev);
pci/controller/pci-msm.c:		msm_pcie_shadow_dump(dev, true);
pci/controller/pci-msm.c:		msm_pcie_shadow_dump(dev, false);
pci/controller/pci-msm.c:			msm_pcie_config_l0s_disable_all(dev, dev->dev->bus);
pci/controller/pci-msm.c:			msm_pcie_config_l0s_enable_all(dev);
pci/controller/pci-msm.c:			msm_pcie_config_l1_disable_all(dev, dev->dev->bus);
pci/controller/pci-msm.c:			msm_pcie_write_mask(dev->parf +
pci/controller/pci-msm.c:			msm_pcie_config_l1_enable_all(dev);
pci/controller/pci-msm.c:			msm_pcie_config_l1ss_disable_all(dev, dev->dev->bus);
pci/controller/pci-msm.c:			msm_pcie_check_l1ss_support_all(dev);
pci/controller/pci-msm.c:			msm_pcie_config_l1ss_enable_all(dev);
pci/controller/pci-msm.c:			if (!msm_pcie_enumerate(dev->rc_idx))
pci/controller/pci-msm.c:			msm_pcie_check_align(dev, wr_offset)) {
pci/controller/pci-msm.c:			msm_pcie_check_align(dev, wr_ofst))
pci/controller/pci-msm.c:			msm_pcie_write_reg_field(dev->res[base_sel - 1].base,
pci/controller/pci-msm.c:		msm_pcie_keep_resources_on |= BIT(dev->rc_idx);
pci/controller/pci-msm.c:int msm_pcie_debug_info(struct pci_dev *dev, u32 option, u32 base,
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_debug_info);
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = (struct msm_pcie_dev_t *)
pci/controller/pci-msm.c:		msm_pcie_enumerate(pcie_dev->rc_idx);
pci/controller/pci-msm.c:static void msm_pcie_sysfs_init(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static void msm_pcie_sysfs_exit(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static void msm_pcie_sysfs_init(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static void msm_pcie_sysfs_exit(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static struct dentry *dent_msm_pcie;
pci/controller/pci-msm.c:static int msm_pcie_debugfs_parse_input(const char __user *buf,
pci/controller/pci-msm.c:static int msm_pcie_debugfs_case_show(struct seq_file *m, void *v)
pci/controller/pci-msm.c:			msm_pcie_debugfs_option_desc[i]);
pci/controller/pci-msm.c:static int msm_pcie_debugfs_case_open(struct inode *inode, struct file *file)
pci/controller/pci-msm.c:	return single_open(file, msm_pcie_debugfs_case_show, NULL);
pci/controller/pci-msm.c:static ssize_t msm_pcie_debugfs_case_select(struct file *file,
pci/controller/pci-msm.c:	ret = msm_pcie_debugfs_parse_input(buf, count, &testcase);
pci/controller/pci-msm.c:			msm_pcie_sel_debug_testcase(&msm_pcie_dev[i], testcase);
pci/controller/pci-msm.c:static const struct file_operations msm_pcie_debugfs_case_ops = {
pci/controller/pci-msm.c:	.open = msm_pcie_debugfs_case_open,
pci/controller/pci-msm.c:	.write = msm_pcie_debugfs_case_select,
pci/controller/pci-msm.c:static ssize_t msm_pcie_debugfs_rc_select(struct file *file,
pci/controller/pci-msm.c:	ret = msm_pcie_debugfs_parse_input(buf, count, &new_rc_sel);
pci/controller/pci-msm.c:static const struct file_operations msm_pcie_debugfs_rc_select_ops = {
pci/controller/pci-msm.c:	.write = msm_pcie_debugfs_rc_select,
pci/controller/pci-msm.c:static ssize_t msm_pcie_debugfs_base_select(struct file *file,
pci/controller/pci-msm.c:	ret = msm_pcie_debugfs_parse_input(buf, count, &new_base_sel);
pci/controller/pci-msm.c:		pr_alert("%s\n", msm_pcie_res_info[base_sel - 1].name);
pci/controller/pci-msm.c:static const struct file_operations msm_pcie_debugfs_base_select_ops = {
pci/controller/pci-msm.c:	.write = msm_pcie_debugfs_base_select,
pci/controller/pci-msm.c:static ssize_t msm_pcie_debugfs_linkdown_panic(struct file *file,
pci/controller/pci-msm.c:	ret = msm_pcie_debugfs_parse_input(buf, count, &new_linkdown_panic);
pci/controller/pci-msm.c:			msm_pcie_dev[i].linkdown_panic =
pci/controller/pci-msm.c:			PCIE_DBG_FS(&msm_pcie_dev[i],
pci/controller/pci-msm.c:				i, msm_pcie_dev[i].linkdown_panic);
pci/controller/pci-msm.c:static const struct file_operations msm_pcie_debugfs_linkdown_panic_ops = {
pci/controller/pci-msm.c:	.write = msm_pcie_debugfs_linkdown_panic,
pci/controller/pci-msm.c:static ssize_t msm_pcie_debugfs_wr_offset(struct file *file,
pci/controller/pci-msm.c:	ret = msm_pcie_debugfs_parse_input(buf, count, &wr_offset);
pci/controller/pci-msm.c:static const struct file_operations msm_pcie_debugfs_wr_offset_ops = {
pci/controller/pci-msm.c:	.write = msm_pcie_debugfs_wr_offset,
pci/controller/pci-msm.c:static ssize_t msm_pcie_debugfs_wr_mask(struct file *file,
pci/controller/pci-msm.c:	ret = msm_pcie_debugfs_parse_input(buf, count, &wr_mask);
pci/controller/pci-msm.c:static const struct file_operations msm_pcie_debugfs_wr_mask_ops = {
pci/controller/pci-msm.c:	.write = msm_pcie_debugfs_wr_mask,
pci/controller/pci-msm.c:static ssize_t msm_pcie_debugfs_wr_value(struct file *file,
pci/controller/pci-msm.c:	ret = msm_pcie_debugfs_parse_input(buf, count, &wr_value);
pci/controller/pci-msm.c:static const struct file_operations msm_pcie_debugfs_wr_value_ops = {
pci/controller/pci-msm.c:	.write = msm_pcie_debugfs_wr_value,
pci/controller/pci-msm.c:static ssize_t msm_pcie_debugfs_boot_option(struct file *file,
pci/controller/pci-msm.c:	ret = msm_pcie_debugfs_parse_input(buf, count, &new_boot_option);
pci/controller/pci-msm.c:				msm_pcie_dev[i].boot_option = new_boot_option;
pci/controller/pci-msm.c:				PCIE_DBG_FS(&msm_pcie_dev[i],
pci/controller/pci-msm.c:					i, msm_pcie_dev[i].boot_option);
pci/controller/pci-msm.c:static const struct file_operations msm_pcie_debugfs_boot_option_ops = {
pci/controller/pci-msm.c:	.write = msm_pcie_debugfs_boot_option,
pci/controller/pci-msm.c:static ssize_t msm_pcie_debugfs_aer_enable(struct file *file,
pci/controller/pci-msm.c:	ret = msm_pcie_debugfs_parse_input(buf, count, &new_aer_enable);
pci/controller/pci-msm.c:			msm_pcie_dev[i].aer_enable = new_aer_enable;
pci/controller/pci-msm.c:			PCIE_DBG_FS(&msm_pcie_dev[i],
pci/controller/pci-msm.c:				i, msm_pcie_dev[i].aer_enable);
pci/controller/pci-msm.c:			msm_pcie_write_mask(msm_pcie_dev[i].dm_core +
pci/controller/pci-msm.c:			PCIE_DBG_FS(&msm_pcie_dev[i],
pci/controller/pci-msm.c:				readl_relaxed(msm_pcie_dev[i].dm_core +
pci/controller/pci-msm.c:static const struct file_operations msm_pcie_debugfs_aer_enable_ops = {
pci/controller/pci-msm.c:	.write = msm_pcie_debugfs_aer_enable,
pci/controller/pci-msm.c:static ssize_t msm_pcie_debugfs_corr_counter_limit(struct file *file,
pci/controller/pci-msm.c:	ret = msm_pcie_debugfs_parse_input(buf, count, &corr_counter_limit);
pci/controller/pci-msm.c:static const struct file_operations msm_pcie_debugfs_corr_counter_limit_ops = {
pci/controller/pci-msm.c:	.write = msm_pcie_debugfs_corr_counter_limit,
pci/controller/pci-msm.c:static void msm_pcie_debugfs_init(void)
pci/controller/pci-msm.c:	dent_msm_pcie = debugfs_create_dir("pci-msm", NULL);
pci/controller/pci-msm.c:	if (IS_ERR(dent_msm_pcie)) {
pci/controller/pci-msm.c:					dent_msm_pcie, NULL,
pci/controller/pci-msm.c:					&msm_pcie_debugfs_rc_select_ops);
pci/controller/pci-msm.c:					dent_msm_pcie, NULL,
pci/controller/pci-msm.c:					&msm_pcie_debugfs_case_ops);
pci/controller/pci-msm.c:					dent_msm_pcie, NULL,
pci/controller/pci-msm.c:					&msm_pcie_debugfs_base_select_ops);
pci/controller/pci-msm.c:					dent_msm_pcie, NULL,
pci/controller/pci-msm.c:					&msm_pcie_debugfs_linkdown_panic_ops);
pci/controller/pci-msm.c:					dent_msm_pcie, NULL,
pci/controller/pci-msm.c:					&msm_pcie_debugfs_wr_offset_ops);
pci/controller/pci-msm.c:					dent_msm_pcie, NULL,
pci/controller/pci-msm.c:					&msm_pcie_debugfs_wr_mask_ops);
pci/controller/pci-msm.c:					dent_msm_pcie, NULL,
pci/controller/pci-msm.c:					&msm_pcie_debugfs_wr_value_ops);
pci/controller/pci-msm.c:					dent_msm_pcie, NULL,
pci/controller/pci-msm.c:					&msm_pcie_debugfs_boot_option_ops);
pci/controller/pci-msm.c:					dent_msm_pcie, NULL,
pci/controller/pci-msm.c:					&msm_pcie_debugfs_aer_enable_ops);
pci/controller/pci-msm.c:				0664, dent_msm_pcie, NULL,
pci/controller/pci-msm.c:				&msm_pcie_debugfs_corr_counter_limit_ops);
pci/controller/pci-msm.c:	debugfs_remove(dent_msm_pcie);
pci/controller/pci-msm.c:static void msm_pcie_debugfs_exit(void)
pci/controller/pci-msm.c:static void msm_pcie_debugfs_init(void)
pci/controller/pci-msm.c:static void msm_pcie_debugfs_exit(void)
pci/controller/pci-msm.c:static inline int msm_pcie_is_link_up(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c: * msm_pcie_iatu_config - configure outbound address translation region
pci/controller/pci-msm.c:static void msm_pcie_iatu_config(struct msm_pcie_dev_t *dev, int nr, u8 type,
pci/controller/pci-msm.c:		msm_pcie_write_reg(iatu_base, iatu_viewport_offset, nr);
pci/controller/pci-msm.c:	msm_pcie_write_reg(iatu_base, iatu_ctrl2_offset, 0);
pci/controller/pci-msm.c:	msm_pcie_write_reg(iatu_base, iatu_ctrl1_offset, type);
pci/controller/pci-msm.c:	msm_pcie_write_reg(iatu_base, iatu_lbar_offset,
pci/controller/pci-msm.c:	msm_pcie_write_reg(iatu_base, iatu_ubar_offset,
pci/controller/pci-msm.c:	msm_pcie_write_reg(iatu_base, iatu_lar_offset, host_end);
pci/controller/pci-msm.c:	msm_pcie_write_reg(iatu_base, iatu_ltar_offset,
pci/controller/pci-msm.c:	msm_pcie_write_reg(iatu_base, iatu_utar_offset,
pci/controller/pci-msm.c:	msm_pcie_write_reg(iatu_base, iatu_ctrl2_offset, BIT(31));
pci/controller/pci-msm.c: * msm_pcie_cfg_bdf - configure for config access
pci/controller/pci-msm.c:static void msm_pcie_cfg_bdf(struct msm_pcie_dev_t *dev, u8 bus, u8 devfn)
pci/controller/pci-msm.c:	msm_pcie_iatu_config(dev, 0, type,
pci/controller/pci-msm.c:static inline void msm_pcie_save_shadow(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:					if (!msm_pcie_dev_tbl[j].bdf) {
pci/controller/pci-msm.c:						msm_pcie_dev_tbl[j].bdf = bdf;
pci/controller/pci-msm.c:static inline int msm_pcie_oper_conf(struct pci_bus *bus, u32 devfn, int oper,
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *dev;
pci/controller/pci-msm.c:	if (!rc && !msm_pcie_is_link_up(dev)) {
pci/controller/pci-msm.c:		msm_pcie_cfg_bdf(dev, bus->number, devfn);
pci/controller/pci-msm.c:		msm_pcie_write_reg(config_base, word_offset, wr_val);
pci/controller/pci-msm.c:				msm_pcie_save_shadow(dev, word_offset, wr_val,
pci/controller/pci-msm.c:static int msm_pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,
pci/controller/pci-msm.c:	int ret = msm_pcie_oper_conf(bus, devfn, RD, where, size, val);
pci/controller/pci-msm.c:static int msm_pcie_wr_conf(struct pci_bus *bus, u32 devfn,
pci/controller/pci-msm.c:	return msm_pcie_oper_conf(bus, devfn, WR, where, size, &val);
pci/controller/pci-msm.c:static struct pci_ops msm_pcie_ops = {
pci/controller/pci-msm.c:	.read = msm_pcie_rd_conf,
pci/controller/pci-msm.c:	.write = msm_pcie_wr_conf,
pci/controller/pci-msm.c:static int msm_pcie_gpio_init(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:	struct msm_pcie_gpio_info_t *info;
pci/controller/pci-msm.c:static void msm_pcie_gpio_deinit(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static int msm_pcie_vreg_init(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:	struct msm_pcie_vreg_info_t *info;
pci/controller/pci-msm.c:static void msm_pcie_vreg_deinit(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static int msm_pcie_clk_init(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:	struct msm_pcie_clk_info_t *info;
pci/controller/pci-msm.c:	struct msm_pcie_reset_info_t *reset_info;
pci/controller/pci-msm.c:		rc = msm_bus_scale_client_update_request(dev->bus_client, 1);
pci/controller/pci-msm.c:			msm_pcie_config_clock_mem(dev, info);
pci/controller/pci-msm.c:static void msm_pcie_clk_deinit(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:		rc = msm_bus_scale_client_update_request(dev->bus_client, 0);
pci/controller/pci-msm.c:static int msm_pcie_pipe_clk_init(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:	struct msm_pcie_clk_info_t *info;
pci/controller/pci-msm.c:	struct msm_pcie_reset_info_t *pipe_reset_info;
pci/controller/pci-msm.c:			msm_pcie_config_clock_mem(dev, info);
pci/controller/pci-msm.c:static void msm_pcie_pipe_clk_deinit(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static bool pcie_phy_is_ready(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static int pcie_phy_init(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:	struct msm_pcie_phy_info_t *phy_seq;
pci/controller/pci-msm.c:			msm_pcie_write_reg(dev->phy,
pci/controller/pci-msm.c:	ret = msm_pcie_pipe_clk_init(dev);
pci/controller/pci-msm.c:static void msm_pcie_iatu_config_all_ep(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:	struct msm_pcie_device_info *dev_table = dev->pcidev_table;
pci/controller/pci-msm.c:		msm_pcie_iatu_config(dev, i, type, dev_table[i].phy_address,
pci/controller/pci-msm.c:static void msm_pcie_config_controller(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:		msm_pcie_iatu_config_all_ep(dev);
pci/controller/pci-msm.c:		msm_pcie_cfg_bdf(dev, 1, 0);
pci/controller/pci-msm.c:		msm_pcie_write_mask(dev->dm_core + PCIE20_ACK_F_ASPM_CTRL_REG,
pci/controller/pci-msm.c:		msm_pcie_write_mask(dev->dm_core + PCIE20_ACK_F_ASPM_CTRL_REG,
pci/controller/pci-msm.c:		msm_pcie_write_reg(dev->dm_core, PCIE20_AUX_CLK_FREQ_REG, 0x14);
pci/controller/pci-msm.c:		msm_pcie_write_reg(dev->dm_core, PCIE20_AUX_CLK_FREQ_REG, 0x01);
pci/controller/pci-msm.c:		msm_pcie_write_reg_field(dev->dm_core,
pci/controller/pci-msm.c:		msm_pcie_write_mask(dev->dm_core + PCIE20_BRIDGE_CTRL, 0,
pci/controller/pci-msm.c:		msm_pcie_write_mask(dev->dm_core +  PCIE20_CAP_DEVCTRLSTATUS, 0,
pci/controller/pci-msm.c:static int msm_pcie_get_clk(struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:	struct msm_pcie_clk_info_t *clk_info;
pci/controller/pci-msm.c:static int msm_pcie_get_vreg(struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:		struct msm_pcie_vreg_info_t *vreg_info = &pcie_dev->vreg[i];
pci/controller/pci-msm.c:static int msm_pcie_get_reset(struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:	struct msm_pcie_reset_info_t *reset_info;
pci/controller/pci-msm.c:static int msm_pcie_get_bw_scale(struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:static int msm_pcie_get_phy(struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:static int msm_pcie_get_iommu_map(struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:static int msm_pcie_get_gpio(struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:		struct msm_pcie_gpio_info_t *gpio_info = &pcie_dev->gpio[i];
pci/controller/pci-msm.c:static int msm_pcie_get_reg(struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:	struct msm_pcie_res_info_t *res_info;
pci/controller/pci-msm.c:static int msm_pcie_get_resources(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:	struct msm_pcie_irq_info_t *irq_info;
pci/controller/pci-msm.c:	dev->bus_scale_table = msm_bus_cl_get_pdata(pdev);
pci/controller/pci-msm.c:			msm_bus_scale_register_client(dev->bus_scale_table);
pci/controller/pci-msm.c:			msm_bus_cl_clear_pdata(dev->bus_scale_table);
pci/controller/pci-msm.c:	ret = msm_pcie_get_clk(dev);
pci/controller/pci-msm.c:	ret = msm_pcie_get_vreg(dev);
pci/controller/pci-msm.c:	ret = msm_pcie_get_reset(dev);
pci/controller/pci-msm.c:	ret = msm_pcie_get_bw_scale(dev);
pci/controller/pci-msm.c:	ret = msm_pcie_get_phy(dev);
pci/controller/pci-msm.c:	ret = msm_pcie_get_iommu_map(dev);
pci/controller/pci-msm.c:	ret = msm_pcie_get_gpio(dev);
pci/controller/pci-msm.c:	ret = msm_pcie_get_reg(dev);
pci/controller/pci-msm.c:static void msm_pcie_release_resources(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static void msm_pcie_scale_link_bandwidth(struct msm_pcie_dev_t *pcie_dev,
pci/controller/pci-msm.c:	struct msm_pcie_bw_scale_info_t *bw_scale;
pci/controller/pci-msm.c:static int msm_pcie_link_train(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:	msm_pcie_write_reg_field(dev->dm_core,
pci/controller/pci-msm.c:	msm_pcie_write_mask(dev->dm_core,
pci/controller/pci-msm.c:	msm_pcie_write_mask(dev->dm_core +
pci/controller/pci-msm.c:	msm_pcie_write_reg_field(dev->dm_core,
pci/controller/pci-msm.c:	msm_pcie_write_reg(dev->dm_core,
pci/controller/pci-msm.c:	msm_pcie_write_reg_field(dev->dm_core,
pci/controller/pci-msm.c:	if (msm_pcie_force_gen1 & BIT(dev->rc_idx))
pci/controller/pci-msm.c:		msm_pcie_write_reg_field(dev->dm_core,
pci/controller/pci-msm.c:	msm_pcie_write_reg_field(dev->dm_core, PCIE20_DEVICE_CONTROL_STATUS,
pci/controller/pci-msm.c:	msm_pcie_write_mask(dev->parf + PCIE20_PARF_LTSSM, 0, BIT(8));
pci/controller/pci-msm.c:	if (msm_pcie_link_check_max_count & BIT(dev->rc_idx))
pci/controller/pci-msm.c:		dev->link_check_max_count = msm_pcie_link_check_max_count >> 4;
pci/controller/pci-msm.c:		!msm_pcie_confirm_linkup(dev, false, false, NULL))
pci/controller/pci-msm.c:		msm_pcie_confirm_linkup(dev, false, false, NULL)) {
pci/controller/pci-msm.c:		struct msm_pcie_bw_scale_info_t *bw_scale;
pci/controller/pci-msm.c:			msm_pcie_write_reg_field(dev->dm_core,
pci/controller/pci-msm.c:			msm_pcie_scale_link_bandwidth(dev, current_link_speed);
pci/controller/pci-msm.c:static int msm_pcie_enable(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:	ret = msm_pcie_vreg_init(dev);
pci/controller/pci-msm.c:	ret = msm_pcie_clk_init(dev);
pci/controller/pci-msm.c:	msm_pcie_write_reg(dev->parf, PCIE20_PARF_DEVICE_TYPE, 0x4);
pci/controller/pci-msm.c:		msm_pcie_write_mask(dev->parf + PCIE20_PARF_PM_CTRL, BIT(5), 0);
pci/controller/pci-msm.c:	msm_pcie_write_mask(dev->parf + PCIE20_PARF_PHY_CTRL, BIT(0), 0);
pci/controller/pci-msm.c:	msm_pcie_write_reg(dev->parf, PCIE20_PARF_DBI_BASE_ADDR, 0);
pci/controller/pci-msm.c:	msm_pcie_write_reg(dev->parf, PCIE20_PARF_SYS_CTRL, 0x365E);
pci/controller/pci-msm.c:	msm_pcie_write_mask(dev->parf + PCIE20_PARF_MHI_CLOCK_RESET_CTRL,
pci/controller/pci-msm.c:	msm_pcie_write_reg(dev->parf, PCIE20_PARF_INT_ALL_MASK, 0);
pci/controller/pci-msm.c:	msm_pcie_write_mask(dev->parf + PCIE20_PARF_INT_ALL_MASK, 0,
pci/controller/pci-msm.c:	msm_pcie_write_reg(dev->parf, PCIE20_PARF_SLV_ADDR_SPACE_SIZE,
pci/controller/pci-msm.c:	msm_pcie_write_reg(dev->parf, PCIE20_PARF_AXI_MSTR_WR_ADDR_HALT,
pci/controller/pci-msm.c:	ret = msm_pcie_link_train(dev);
pci/controller/pci-msm.c:	msm_pcie_config_sid(dev);
pci/controller/pci-msm.c:	msm_pcie_config_controller(dev);
pci/controller/pci-msm.c:		msm_pcie_config_link_pm(dev, true);
pci/controller/pci-msm.c:	if (msm_pcie_keep_resources_on & BIT(dev->rc_idx))
pci/controller/pci-msm.c:		msm_pcie_write_reg(dev->phy, dev->phy_power_down_offset, 0);
pci/controller/pci-msm.c:	msm_pcie_pipe_clk_deinit(dev);
pci/controller/pci-msm.c:	msm_pcie_clk_deinit(dev);
pci/controller/pci-msm.c:	msm_pcie_vreg_deinit(dev);
pci/controller/pci-msm.c:static void msm_pcie_disable(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:		msm_pcie_write_reg(dev->phy, dev->phy_power_down_offset, 0);
pci/controller/pci-msm.c:	msm_pcie_write_mask(dev->parf + PCIE20_PARF_PHY_CTRL, 0,
pci/controller/pci-msm.c:	msm_pcie_clk_deinit(dev);
pci/controller/pci-msm.c:	msm_pcie_vreg_deinit(dev);
pci/controller/pci-msm.c:	msm_pcie_pipe_clk_deinit(dev);
pci/controller/pci-msm.c:static void msm_pcie_config_ep_aer(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:				struct msm_pcie_device_info *ep_dev_info)
pci/controller/pci-msm.c:		if (msm_pcie_check_align(dev, current_offset))
pci/controller/pci-msm.c:	msm_pcie_write_mask(ep_base + ep_dev_info->dev_ctrlstts_offset, 0,
pci/controller/pci-msm.c:static int msm_pcie_config_device_table(struct device *dev, void *pdev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = (struct msm_pcie_dev_t *) pdev;
pci/controller/pci-msm.c:	struct msm_pcie_device_info *dev_table_t = pcie_dev->pcidev_table;
pci/controller/pci-msm.c:		if (msm_pcie_dev_tbl[i].bdf == bdf &&
pci/controller/pci-msm.c:			!msm_pcie_dev_tbl[i].dev) {
pci/controller/pci-msm.c:					msm_pcie_dev_tbl[i].dev = pcidev;
pci/controller/pci-msm.c:					msm_pcie_dev_tbl[i].domain = rc_idx;
pci/controller/pci-msm.c:					msm_pcie_dev_tbl[i].conf_base =
pci/controller/pci-msm.c:					msm_pcie_dev_tbl[i].phy_address =
pci/controller/pci-msm.c:					msm_pcie_iatu_config(pcie_dev, index,
pci/controller/pci-msm.c:						msm_pcie_config_ep_aer(pcie_dev,
pci/controller/pci-msm.c:		} else if (msm_pcie_dev_tbl[i].bdf == bdf &&
pci/controller/pci-msm.c:			pcidev == msm_pcie_dev_tbl[i].dev) {
pci/controller/pci-msm.c:static void msm_pcie_config_sid(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:			msm_pcie_write_reg(bdf_to_sid_base,
pci/controller/pci-msm.c:		struct msm_pcie_sid_info_t *sid_info = &dev->sid_info[i];
pci/controller/pci-msm.c:		hash = crc8(msm_pcie_crc8_table, (u8 *)&bdf_be, sizeof(bdf_be),
pci/controller/pci-msm.c:				msm_pcie_write_reg(bdf_to_sid_base,
pci/controller/pci-msm.c:		msm_pcie_write_reg(bdf_to_sid_base, hash * sizeof(u32), val);
pci/controller/pci-msm.c:int msm_pcie_enumerate(u32 rc_idx)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *dev = &msm_pcie_dev[rc_idx];
pci/controller/pci-msm.c:	ret = msm_pcie_enable(dev);
pci/controller/pci-msm.c:		ret = msm_msi_init(&dev->pdev->dev);
pci/controller/pci-msm.c:	bridge->ops = &msm_pcie_ops;
pci/controller/pci-msm.c:	msm_pcie_fixup_irqs(dev);
pci/controller/pci-msm.c:	msm_pcie_write_mask(dev->dm_core +
pci/controller/pci-msm.c:		msm_pcie_write_reg_field(dev->dm_core,
pci/controller/pci-msm.c:		if (pcidev && (dev == (struct msm_pcie_dev_t *)
pci/controller/pci-msm.c:			&msm_pcie_config_device_table);
pci/controller/pci-msm.c:	msm_pcie_check_l1ss_support_all(dev);
pci/controller/pci-msm.c:	msm_pcie_config_link_pm(dev, true);
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_enumerate);
pci/controller/pci-msm.c:static void msm_pcie_notify_client(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:					enum msm_pcie_event event)
pci/controller/pci-msm.c:		struct msm_pcie_notify *notify = &dev->event_reg->notify;
pci/controller/pci-msm.c:		struct msm_pcie_notify client_notify;
pci/controller/pci-msm.c:	struct msm_pcie_reset_info_t *reset_info;
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *dev = container_of(work, struct msm_pcie_dev_t,
pci/controller/pci-msm.c:	msm_pcie_write_mask(dev->parf + PCIE20_PARF_LTSSM, 0, LTSSM_EN);
pci/controller/pci-msm.c:		!msm_pcie_confirm_linkup(dev, false, false, NULL))
pci/controller/pci-msm.c:	     msm_pcie_confirm_linkup(dev, false, false, NULL)) {
pci/controller/pci-msm.c:	msm_pcie_write_mask(dev->dm_core + PCIE20_COMMAND_STATUS, 0, BIT(2));
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *dev = data;
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *dev = container_of(work, struct msm_pcie_dev_t,
pci/controller/pci-msm.c:		ret = msm_pcie_enumerate(dev->rc_idx);
pci/controller/pci-msm.c:					struct msm_pcie_notify *notify =
pci/controller/pci-msm.c:				struct msm_pcie_notify *notify =
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *dev = container_of(work, struct msm_pcie_dev_t,
pci/controller/pci-msm.c:	msm_pcie_notify_client(dev, MSM_PCIE_EVENT_LINK_RECOVER);
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *dev = data;
pci/controller/pci-msm.c:	msm_pcie_write_mask(dev->dm_core + PCIE20_CAP_DEVCTRLSTATUS, 0,
pci/controller/pci-msm.c:		msm_pcie_write_mask(ep_base + ep_dev_ctrlstts_offset, 0,
pci/controller/pci-msm.c:		msm_pcie_write_reg_field(ep_base,
pci/controller/pci-msm.c:		msm_pcie_write_reg_field(ep_base,
pci/controller/pci-msm.c:	msm_pcie_write_reg_field(dev->dm_core,
pci/controller/pci-msm.c:	msm_pcie_write_reg_field(dev->dm_core,
pci/controller/pci-msm.c:	msm_pcie_write_reg_field(dev->dm_core,
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *dev = data;
pci/controller/pci-msm.c:				msm_pcie_notify_client(dev,
pci/controller/pci-msm.c:			msm_pcie_notify_client(dev, MSM_PCIE_EVENT_WAKEUP);
pci/controller/pci-msm.c:static int msm_pcie_linkdown_recovery(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:	msm_pcie_write_mask(dev->parf + PCIE20_PARF_LTSSM,
pci/controller/pci-msm.c:static void msm_pcie_handle_linkdown(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:		ret = msm_pcie_linkdown_recovery(dev);
pci/controller/pci-msm.c:	if (!(msm_pcie_keep_resources_on & BIT(dev->rc_idx)))
pci/controller/pci-msm.c:			msm_pcie_notify_client(dev,
pci/controller/pci-msm.c:		msm_pcie_notify_client(dev, MSM_PCIE_EVENT_LINKDOWN);
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *dev = data;
pci/controller/pci-msm.c:		msm_pcie_handle_linkdown(dev);
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *dev = data;
pci/controller/pci-msm.c:	msm_pcie_write_mask(dev->parf + PCIE20_PARF_INT_ALL_CLEAR, 0, status);
pci/controller/pci-msm.c:				msm_pcie_notify_client(dev,
pci/controller/pci-msm.c:static int32_t msm_pcie_irq_init(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:				IRQF_TRIGGER_FALLING, "msm_pcie_wake", dev);
pci/controller/pci-msm.c:static void msm_pcie_irq_deinit(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:static bool msm_pcie_check_l0s_support(struct pci_dev *pdev,
pci/controller/pci-msm.c:					struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:static bool msm_pcie_check_l1_support(struct pci_dev *pdev,
pci/controller/pci-msm.c:					struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:static int msm_pcie_check_l1ss_support(struct pci_dev *pdev, void *dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = (struct msm_pcie_dev_t *)dev;
pci/controller/pci-msm.c:static int msm_pcie_config_common_clock_enable(struct pci_dev *pdev,
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = (struct msm_pcie_dev_t *)dev;
pci/controller/pci-msm.c:	msm_pcie_config_clear_set_dword(pdev, pdev->pcie_cap + PCI_EXP_LNKCTL,
pci/controller/pci-msm.c:static void msm_pcie_config_common_clock_enable_all(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:			msm_pcie_config_common_clock_enable, dev);
pci/controller/pci-msm.c:static int msm_pcie_config_clock_power_management_enable(struct pci_dev *pdev,
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = (struct msm_pcie_dev_t *)dev;
pci/controller/pci-msm.c:		msm_pcie_config_clear_set_dword(pdev,
pci/controller/pci-msm.c:static void msm_pcie_config_clock_power_management_enable_all(
pci/controller/pci-msm.c:						struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:			msm_pcie_config_clock_power_management_enable, dev);
pci/controller/pci-msm.c:static void msm_pcie_config_l0s(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:		ret = msm_pcie_check_l0s_support(pdev, dev);
pci/controller/pci-msm.c:		msm_pcie_config_clear_set_dword(pdev, lnkctl_offset, 0,
pci/controller/pci-msm.c:		msm_pcie_config_clear_set_dword(pdev, lnkctl_offset,
pci/controller/pci-msm.c:static void msm_pcie_config_l0s_disable_all(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:			msm_pcie_config_l0s_disable_all(dev, child);
pci/controller/pci-msm.c:		msm_pcie_config_l0s(dev, pdev, false);
pci/controller/pci-msm.c:static int msm_pcie_config_l0s_enable(struct pci_dev *pdev, void *dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = (struct msm_pcie_dev_t *)dev;
pci/controller/pci-msm.c:	msm_pcie_config_l0s(pcie_dev, pdev, true);
pci/controller/pci-msm.c:static void msm_pcie_config_l0s_enable_all(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:		pci_walk_bus(dev->dev->bus, msm_pcie_config_l0s_enable, dev);
pci/controller/pci-msm.c:static void msm_pcie_config_l1(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:		ret = msm_pcie_check_l1_support(pdev, dev);
pci/controller/pci-msm.c:		msm_pcie_config_clear_set_dword(pdev, lnkctl_offset, 0,
pci/controller/pci-msm.c:		msm_pcie_config_clear_set_dword(pdev, lnkctl_offset,
pci/controller/pci-msm.c:static void msm_pcie_config_l1_disable_all(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:			msm_pcie_config_l1_disable_all(dev, child);
pci/controller/pci-msm.c:		msm_pcie_config_l1(dev, pdev, false);
pci/controller/pci-msm.c:static int msm_pcie_config_l1_enable(struct pci_dev *pdev, void *dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = (struct msm_pcie_dev_t *)dev;
pci/controller/pci-msm.c:	msm_pcie_config_l1(pcie_dev, pdev, true);
pci/controller/pci-msm.c:static void msm_pcie_config_l1_enable_all(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:		pci_walk_bus(dev->dev->bus, msm_pcie_config_l1_enable, dev);
pci/controller/pci-msm.c:static void msm_pcie_config_l1ss(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:			msm_pcie_write_mask(dev->parf +
pci/controller/pci-msm.c:			msm_pcie_write_mask(dev->parf +
pci/controller/pci-msm.c:		msm_pcie_config_clear_set_dword(pdev, devctl2_offset, 0,
pci/controller/pci-msm.c:		msm_pcie_config_clear_set_dword(pdev, l1ss_ctl1_offset, 0,
pci/controller/pci-msm.c:		msm_pcie_config_clear_set_dword(pdev, devctl2_offset,
pci/controller/pci-msm.c:		msm_pcie_config_clear_set_dword(pdev, l1ss_ctl1_offset,
pci/controller/pci-msm.c:static int msm_pcie_config_l1ss_disable(struct pci_dev *pdev, void *dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = (struct msm_pcie_dev_t *)dev;
pci/controller/pci-msm.c:	msm_pcie_config_l1ss(pcie_dev, pdev, false);
pci/controller/pci-msm.c:static void msm_pcie_config_l1ss_disable_all(struct msm_pcie_dev_t *dev,
pci/controller/pci-msm.c:			msm_pcie_config_l1ss_disable_all(dev, child);
pci/controller/pci-msm.c:		msm_pcie_config_l1ss_disable(pdev, dev);
pci/controller/pci-msm.c:static int msm_pcie_config_l1_2_threshold(struct pci_dev *pdev, void *dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = (struct msm_pcie_dev_t *)dev;
pci/controller/pci-msm.c:	msm_pcie_config_clear_set_dword(pdev, l1ss_ctl1_offset, 0,
pci/controller/pci-msm.c:static int msm_pcie_config_l1ss_enable(struct pci_dev *pdev, void *dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = (struct msm_pcie_dev_t *)dev;
pci/controller/pci-msm.c:	msm_pcie_config_l1ss(pcie_dev, pdev, true);
pci/controller/pci-msm.c:static void msm_pcie_config_l1ss_enable_all(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:		pci_walk_bus(dev->dev->bus, msm_pcie_config_l1_2_threshold,
pci/controller/pci-msm.c:		pci_walk_bus(dev->dev->bus, msm_pcie_config_l1ss_enable, dev);
pci/controller/pci-msm.c:static void msm_pcie_config_link_pm(struct msm_pcie_dev_t *dev, bool enable)
pci/controller/pci-msm.c:		msm_pcie_config_common_clock_enable_all(dev);
pci/controller/pci-msm.c:		msm_pcie_config_clock_power_management_enable_all(dev);
pci/controller/pci-msm.c:		msm_pcie_config_l1ss_enable_all(dev);
pci/controller/pci-msm.c:		msm_pcie_config_l1_enable_all(dev);
pci/controller/pci-msm.c:		msm_pcie_config_l0s_enable_all(dev);
pci/controller/pci-msm.c:		msm_pcie_config_l0s_disable_all(dev, bus);
pci/controller/pci-msm.c:		msm_pcie_config_l1_disable_all(dev, bus);
pci/controller/pci-msm.c:		msm_pcie_config_l1ss_disable_all(dev, bus);
pci/controller/pci-msm.c:static void msm_pcie_check_l1ss_support_all(struct msm_pcie_dev_t *dev)
pci/controller/pci-msm.c:	pci_walk_bus(dev->dev->bus, msm_pcie_check_l1ss_support, dev);
pci/controller/pci-msm.c:static int msm_pcie_setup_drv(struct msm_pcie_dev_t *pcie_dev,
pci/controller/pci-msm.c:	struct msm_pcie_drv_info *drv_info;
pci/controller/pci-msm.c:	struct msm_pcie_drv_msg *msg;
pci/controller/pci-msm.c:	struct msm_pcie_drv_tre *pkt;
pci/controller/pci-msm.c:	struct msm_pcie_drv_header *hdr;
pci/controller/pci-msm.c:static int msm_pcie_probe(struct platform_device *pdev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev;
pci/controller/pci-msm.c:	pcie_dev = &msm_pcie_dev[rc_idx];
pci/controller/pci-msm.c:	if (msm_pcie_invert_l0s_support & BIT(pcie_dev->rc_idx))
pci/controller/pci-msm.c:	if (msm_pcie_invert_l1_support & BIT(pcie_dev->rc_idx))
pci/controller/pci-msm.c:	if (msm_pcie_invert_l1ss_support & BIT(pcie_dev->rc_idx))
pci/controller/pci-msm.c:	if (msm_pcie_invert_aer_support)
pci/controller/pci-msm.c:	memcpy(pcie_dev->vreg, msm_pcie_vreg_info, sizeof(msm_pcie_vreg_info));
pci/controller/pci-msm.c:	memcpy(pcie_dev->gpio, msm_pcie_gpio_info, sizeof(msm_pcie_gpio_info));
pci/controller/pci-msm.c:	memcpy(pcie_dev->clk, msm_pcie_clk_info[rc_idx],
pci/controller/pci-msm.c:		sizeof(msm_pcie_clk_info[rc_idx]));
pci/controller/pci-msm.c:	memcpy(pcie_dev->pipeclk, msm_pcie_pipe_clk_info[rc_idx],
pci/controller/pci-msm.c:		sizeof(msm_pcie_pipe_clk_info[rc_idx]));
pci/controller/pci-msm.c:	memcpy(pcie_dev->res, msm_pcie_res_info, sizeof(msm_pcie_res_info));
pci/controller/pci-msm.c:	memcpy(pcie_dev->irq, msm_pcie_irq_info, sizeof(msm_pcie_irq_info));
pci/controller/pci-msm.c:	memcpy(pcie_dev->reset, msm_pcie_reset_info[rc_idx],
pci/controller/pci-msm.c:		sizeof(msm_pcie_reset_info[rc_idx]));
pci/controller/pci-msm.c:	memcpy(pcie_dev->pipe_reset, msm_pcie_pipe_reset_info[rc_idx],
pci/controller/pci-msm.c:		sizeof(msm_pcie_pipe_reset_info[rc_idx]));
pci/controller/pci-msm.c:	memcpy(pcie_dev->linkdown_reset, msm_pcie_linkdown_reset_info[rc_idx],
pci/controller/pci-msm.c:		sizeof(msm_pcie_linkdown_reset_info[rc_idx]));
pci/controller/pci-msm.c:	ret = msm_pcie_get_resources(pcie_dev, pcie_dev->pdev);
pci/controller/pci-msm.c:		pcie_dev->rumi_init = msm_pcie_rumi_init;
pci/controller/pci-msm.c:	ret = msm_pcie_gpio_init(pcie_dev);
pci/controller/pci-msm.c:		msm_pcie_release_resources(pcie_dev);
pci/controller/pci-msm.c:	ret = msm_pcie_irq_init(pcie_dev);
pci/controller/pci-msm.c:		msm_pcie_release_resources(pcie_dev);
pci/controller/pci-msm.c:		msm_pcie_gpio_deinit(pcie_dev);
pci/controller/pci-msm.c:		ret = msm_pcie_setup_drv(pcie_dev, of_node);
pci/controller/pci-msm.c:	msm_pcie_sysfs_init(pcie_dev);
pci/controller/pci-msm.c:	ret = msm_pcie_enumerate(rc_idx);
pci/controller/pci-msm.c:static int msm_pcie_remove(struct platform_device *pdev)
pci/controller/pci-msm.c:	msm_pcie_irq_deinit(&msm_pcie_dev[rc_idx]);
pci/controller/pci-msm.c:	msm_pcie_vreg_deinit(&msm_pcie_dev[rc_idx]);
pci/controller/pci-msm.c:	msm_pcie_clk_deinit(&msm_pcie_dev[rc_idx]);
pci/controller/pci-msm.c:	msm_pcie_gpio_deinit(&msm_pcie_dev[rc_idx]);
pci/controller/pci-msm.c:	msm_pcie_release_resources(&msm_pcie_dev[rc_idx]);
pci/controller/pci-msm.c:static int msm_pcie_link_retrain(struct msm_pcie_dev_t *pcie_dev,
pci/controller/pci-msm.c:	msm_pcie_config_clear_set_dword(pci_dev,
pci/controller/pci-msm.c:static int msm_pcie_set_link_width(struct msm_pcie_dev_t *pcie_dev,
pci/controller/pci-msm.c:	msm_pcie_write_reg_field(pcie_dev->dm_core,
pci/controller/pci-msm.c:void msm_pcie_allow_l1(struct pci_dev *pci_dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev;
pci/controller/pci-msm.c:	msm_pcie_write_mask(pcie_dev->parf + PCIE20_PARF_PM_CTRL, BIT(5), 0);
pci/controller/pci-msm.c:	msm_pcie_write_mask(pcie_dev->dm_core +
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_allow_l1);
pci/controller/pci-msm.c:int msm_pcie_prevent_l1(struct pci_dev *pci_dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev;
pci/controller/pci-msm.c:	msm_pcie_write_mask(pcie_dev->dm_core +
pci/controller/pci-msm.c:	msm_pcie_write_mask(pcie_dev->parf + PCIE20_PARF_PM_CTRL, 0, BIT(5));
pci/controller/pci-msm.c:	msm_pcie_allow_l1(pci_dev);
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_prevent_l1);
pci/controller/pci-msm.c:int msm_pcie_set_target_link_speed(u32 rc_idx, u32 target_link_speed)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = &msm_pcie_dev[rc_idx];
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_set_target_link_speed);
pci/controller/pci-msm.c:int msm_pcie_set_link_bandwidth(struct pci_dev *pci_dev, u16 target_link_speed,
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev;
pci/controller/pci-msm.c:		ret = msm_pcie_set_link_width(pcie_dev, target_link_width);
pci/controller/pci-msm.c:		msm_pcie_config_clear_set_dword(root_pci_dev,
pci/controller/pci-msm.c:	ret = msm_pcie_prevent_l1(root_pci_dev);
pci/controller/pci-msm.c:		msm_pcie_scale_link_bandwidth(pcie_dev, target_link_speed);
pci/controller/pci-msm.c:	ret = msm_pcie_link_retrain(pcie_dev, root_pci_dev);
pci/controller/pci-msm.c:		msm_pcie_scale_link_bandwidth(pcie_dev, target_link_speed);
pci/controller/pci-msm.c:	msm_pcie_allow_l1(root_pci_dev);
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_set_link_bandwidth);
pci/controller/pci-msm.c:int msm_pci_probe(struct pci_dev *pci_dev,
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = PCIE_BUS_PRIV_DATA(pci_dev->bus);
pci/controller/pci-msm.c:	struct msm_root_dev_t *root_dev;
pci/controller/pci-msm.c:static struct pci_device_id msm_pci_device_id[] = {
pci/controller/pci-msm.c:static struct pci_driver msm_pci_driver = {
pci/controller/pci-msm.c:	.name = "pci-msm-rc",
pci/controller/pci-msm.c:	.id_table = msm_pci_device_id,
pci/controller/pci-msm.c:	.probe = msm_pci_probe,
pci/controller/pci-msm.c:static const struct of_device_id msm_pcie_match[] = {
pci/controller/pci-msm.c:	{	.compatible = "qcom,pci-msm",
pci/controller/pci-msm.c:static struct platform_driver msm_pcie_driver = {
pci/controller/pci-msm.c:	.probe	= msm_pcie_probe,
pci/controller/pci-msm.c:	.remove	= msm_pcie_remove,
pci/controller/pci-msm.c:		.name		= "pci-msm",
pci/controller/pci-msm.c:		.of_match_table	= msm_pcie_match,
pci/controller/pci-msm.c:static int msm_pcie_drv_rpmsg_probe(struct rpmsg_device *rpdev)
pci/controller/pci-msm.c:static void msm_pcie_drv_notify_client(struct pcie_drv_sta *pcie_drv,
pci/controller/pci-msm.c:					enum msm_pcie_event event)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = pcie_drv->msm_pcie_dev;
pci/controller/pci-msm.c:		struct msm_pcie_drv_info *drv_info = pcie_dev->drv_info;
pci/controller/pci-msm.c:		struct msm_pcie_register_event *event_reg =
pci/controller/pci-msm.c:			msm_pcie_notify_client(pcie_dev, event);
pci/controller/pci-msm.c:static void msm_pcie_drv_rpmsg_remove(struct rpmsg_device *rpdev)
pci/controller/pci-msm.c:	msm_pcie_drv_notify_client(pcie_drv, MSM_PCIE_EVENT_DRV_DISCONNECT);
pci/controller/pci-msm.c:static int msm_pcie_drv_rpmsg_cb(struct rpmsg_device *rpdev, void *data,
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev;
pci/controller/pci-msm.c:	struct msm_pcie_drv_header *drv_header;
pci/controller/pci-msm.c:	struct msm_pcie_drv_info *drv_info;
pci/controller/pci-msm.c:		pcie_dev = pcie_drv->msm_pcie_dev + drv_header->dev_id;
pci/controller/pci-msm.c:static struct rpmsg_device_id msm_pcie_drv_rpmsg_match_table[] = {
pci/controller/pci-msm.c:static struct rpmsg_driver msm_pcie_drv_rpmsg_driver = {
pci/controller/pci-msm.c:	.id_table = msm_pcie_drv_rpmsg_match_table,
pci/controller/pci-msm.c:	.probe = msm_pcie_drv_rpmsg_probe,
pci/controller/pci-msm.c:	.remove = msm_pcie_drv_rpmsg_remove,
pci/controller/pci-msm.c:	.callback = msm_pcie_drv_rpmsg_cb,
pci/controller/pci-msm.c:		.name = "pci-msm-drv",
pci/controller/pci-msm.c:static void msm_pcie_early_notifier(void *data)
pci/controller/pci-msm.c:	msm_pcie_drv_notify_client(pcie_drv, MSM_PCIE_EVENT_WAKEUP);
pci/controller/pci-msm.c:static void msm_pcie_drv_connect_worker(struct work_struct *work)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = pcie_drv->msm_pcie_dev;
pci/controller/pci-msm.c:		struct msm_pcie_drv_info *drv_info = pcie_dev->drv_info;
pci/controller/pci-msm.c:		struct msm_pcie_register_event *event_reg =
pci/controller/pci-msm.c:		msm_pcie_notify_client(pcie_dev,
pci/controller/pci-msm.c:				msm_pcie_early_notifier, pcie_drv);
pci/controller/pci-msm.c:		msm_pcie_dev[i].ipc_log =
pci/controller/pci-msm.c:		if (msm_pcie_dev[i].ipc_log == NULL)
pci/controller/pci-msm.c:			PCIE_DBG(&msm_pcie_dev[i],
pci/controller/pci-msm.c:		msm_pcie_dev[i].ipc_log_long =
pci/controller/pci-msm.c:		if (msm_pcie_dev[i].ipc_log_long == NULL)
pci/controller/pci-msm.c:			PCIE_DBG(&msm_pcie_dev[i],
pci/controller/pci-msm.c:		msm_pcie_dev[i].ipc_log_dump =
pci/controller/pci-msm.c:		if (msm_pcie_dev[i].ipc_log_dump == NULL)
pci/controller/pci-msm.c:			PCIE_DBG(&msm_pcie_dev[i],
pci/controller/pci-msm.c:		spin_lock_init(&msm_pcie_dev[i].cfg_lock);
pci/controller/pci-msm.c:		msm_pcie_dev[i].cfg_access = true;
pci/controller/pci-msm.c:		mutex_init(&msm_pcie_dev[i].enumerate_lock);
pci/controller/pci-msm.c:		mutex_init(&msm_pcie_dev[i].setup_lock);
pci/controller/pci-msm.c:		mutex_init(&msm_pcie_dev[i].clk_lock);
pci/controller/pci-msm.c:		mutex_init(&msm_pcie_dev[i].recovery_lock);
pci/controller/pci-msm.c:		mutex_init(&msm_pcie_dev[i].aspm_lock);
pci/controller/pci-msm.c:		spin_lock_init(&msm_pcie_dev[i].wakeup_lock);
pci/controller/pci-msm.c:		spin_lock_init(&msm_pcie_dev[i].irq_lock);
pci/controller/pci-msm.c:		msm_pcie_dev[i].drv_ready = false;
pci/controller/pci-msm.c:		msm_pcie_dev_tbl[i].bdf = 0;
pci/controller/pci-msm.c:		msm_pcie_dev_tbl[i].dev = NULL;
pci/controller/pci-msm.c:		msm_pcie_dev_tbl[i].short_bdf = 0;
pci/controller/pci-msm.c:		msm_pcie_dev_tbl[i].sid = 0;
pci/controller/pci-msm.c:		msm_pcie_dev_tbl[i].domain = -1;
pci/controller/pci-msm.c:		msm_pcie_dev_tbl[i].conf_base = NULL;
pci/controller/pci-msm.c:		msm_pcie_dev_tbl[i].phy_address = 0;
pci/controller/pci-msm.c:		msm_pcie_dev_tbl[i].dev_ctrlstts_offset = 0;
pci/controller/pci-msm.c:		msm_pcie_dev_tbl[i].event_reg = NULL;
pci/controller/pci-msm.c:		msm_pcie_dev_tbl[i].registered = true;
pci/controller/pci-msm.c:	crc8_populate_msb(msm_pcie_crc8_table, MSM_PCIE_CRC8_POLYNOMIAL);
pci/controller/pci-msm.c:	msm_pcie_debugfs_init();
pci/controller/pci-msm.c:	ret = pci_register_driver(&msm_pci_driver);
pci/controller/pci-msm.c:	INIT_WORK(&pcie_drv.drv_connect, msm_pcie_drv_connect_worker);
pci/controller/pci-msm.c:	pcie_drv.msm_pcie_dev = msm_pcie_dev;
pci/controller/pci-msm.c:	ret = register_rpmsg_driver(&msm_pcie_drv_rpmsg_driver);
pci/controller/pci-msm.c:	ret = platform_driver_register(&msm_pcie_driver);
pci/controller/pci-msm.c:	platform_driver_unregister(&msm_pcie_driver);
pci/controller/pci-msm.c:	msm_pcie_debugfs_exit();
pci/controller/pci-msm.c:		msm_pcie_sysfs_exit(&msm_pcie_dev[i]);
pci/controller/pci-msm.c:static void msm_pcie_fixup_early(struct pci_dev *dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = PCIE_BUS_PRIV_DATA(dev->bus);
pci/controller/pci-msm.c:			msm_pcie_fixup_early);
pci/controller/pci-msm.c:static void __msm_pcie_l1ss_timeout_disable(struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:	msm_pcie_write_mask(pcie_dev->parf + PCIE20_PARF_DEBUG_INT_EN, BIT(0),
pci/controller/pci-msm.c:	msm_pcie_write_reg(pcie_dev->parf, PCIE20_PARF_L1SUB_AHB_CLK_MAX_TIMER,
pci/controller/pci-msm.c:static void __msm_pcie_l1ss_timeout_enable(struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:	msm_pcie_write_reg(pcie_dev->parf, PCIE20_PARF_L1SUB_AHB_CLK_MAX_TIMER,
pci/controller/pci-msm.c:	msm_pcie_write_reg(pcie_dev->parf, PCIE20_PARF_L1SUB_AHB_CLK_MAX_TIMER,
pci/controller/pci-msm.c:	msm_pcie_write_reg(pcie_dev->parf, PCIE20_PARF_L1SUB_AHB_CLK_MAX_TIMER,
pci/controller/pci-msm.c:	msm_pcie_write_mask(pcie_dev->parf +
pci/controller/pci-msm.c:static int msm_pcie_pm_suspend(struct pci_dev *dev,
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = PCIE_BUS_PRIV_DATA(dev->bus);
pci/controller/pci-msm.c:		&& msm_pcie_confirm_linkup(pcie_dev, true, true,
pci/controller/pci-msm.c:	msm_pcie_disable(pcie_dev);
pci/controller/pci-msm.c:static void msm_pcie_fixup_suspend(struct pci_dev *dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = PCIE_BUS_PRIV_DATA(dev->bus);
pci/controller/pci-msm.c:	ret = msm_pcie_pm_suspend(dev, NULL, NULL, 0);
pci/controller/pci-msm.c:			  msm_pcie_fixup_suspend);
pci/controller/pci-msm.c:static int msm_pcie_pm_resume(struct pci_dev *dev,
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = PCIE_BUS_PRIV_DATA(dev->bus);
pci/controller/pci-msm.c:	ret = msm_pcie_enable(pcie_dev);
pci/controller/pci-msm.c:			msm_pcie_cfg_recover(pcie_dev, true);
pci/controller/pci-msm.c:		msm_pcie_recover_config(dev);
pci/controller/pci-msm.c:static void msm_pcie_fixup_resume(struct pci_dev *dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = PCIE_BUS_PRIV_DATA(dev->bus);
pci/controller/pci-msm.c:	ret = msm_pcie_pm_resume(dev, NULL, NULL, 0);
pci/controller/pci-msm.c:				 msm_pcie_fixup_resume);
pci/controller/pci-msm.c:static void msm_pcie_fixup_resume_early(struct pci_dev *dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = PCIE_BUS_PRIV_DATA(dev->bus);
pci/controller/pci-msm.c:	ret = msm_pcie_pm_resume(dev, NULL, NULL, 0);
pci/controller/pci-msm.c:				 msm_pcie_fixup_resume_early);
pci/controller/pci-msm.c:static int msm_pcie_drv_resume(struct msm_pcie_dev_t *pcie_dev)
pci/controller/pci-msm.c:	struct msm_pcie_drv_info *drv_info = pcie_dev->drv_info;
pci/controller/pci-msm.c:	struct msm_pcie_drv_msg *drv_disable = &drv_info->drv_disable;
pci/controller/pci-msm.c:	struct msm_pcie_clk_info_t *clk_info;
pci/controller/pci-msm.c:	msm_pcie_vreg_init(pcie_dev);
pci/controller/pci-msm.c:		ret = msm_bus_scale_client_update_request(pcie_dev->bus_client,
pci/controller/pci-msm.c:	msm_pcie_scale_link_bandwidth(pcie_dev, current_link_speed);
pci/controller/pci-msm.c:	msm_pcie_write_reg_field(pcie_dev->parf,
pci/controller/pci-msm.c:	msm_pcie_write_reg_field(pcie_dev->parf,
pci/controller/pci-msm.c:static int msm_pcie_drv_suspend(struct msm_pcie_dev_t *pcie_dev,
pci/controller/pci-msm.c:	struct msm_pcie_drv_info *drv_info = pcie_dev->drv_info;
pci/controller/pci-msm.c:	struct msm_pcie_drv_msg *drv_enable = &drv_info->drv_enable;
pci/controller/pci-msm.c:	struct msm_pcie_drv_tre *pkt = &drv_enable->pkt;
pci/controller/pci-msm.c:	struct msm_pcie_clk_info_t *clk_info;
pci/controller/pci-msm.c:		ret = msm_bus_scale_client_update_request(pcie_dev->bus_client,
pci/controller/pci-msm.c:	msm_pcie_vreg_deinit(pcie_dev);
pci/controller/pci-msm.c:int msm_pcie_pm_control(enum msm_pcie_pm_opt pm_opt, u32 busnr, void *user,
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev;
pci/controller/pci-msm.c:	dev = msm_pcie_dev[rc_idx].dev;
pci/controller/pci-msm.c:	if (!msm_pcie_dev[rc_idx].drv_ready) {
pci/controller/pci-msm.c:		PCIE_ERR(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:		ret = msm_pcie_drv_suspend(pcie_dev, options);
pci/controller/pci-msm.c:		PCIE_DBG(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:		if (msm_pcie_dev[rc_idx].link_status != MSM_PCIE_LINK_ENABLED)
pci/controller/pci-msm.c:			PCIE_DBG(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:				rc_idx, msm_pcie_dev[rc_idx].link_status);
pci/controller/pci-msm.c:		if (!msm_pcie_dev[rc_idx].power_on) {
pci/controller/pci-msm.c:			PCIE_ERR(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:				rc_idx, msm_pcie_dev[rc_idx].link_status);
pci/controller/pci-msm.c:		if (msm_pcie_dev[rc_idx].pending_ep_reg) {
pci/controller/pci-msm.c:			PCIE_DBG(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:		msm_pcie_dev[rc_idx].user_suspend = true;
pci/controller/pci-msm.c:		mutex_lock(&msm_pcie_dev[rc_idx].recovery_lock);
pci/controller/pci-msm.c:		ret = msm_pcie_pm_suspend(dev, user, data, options);
pci/controller/pci-msm.c:			PCIE_ERR(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:			msm_pcie_dev[rc_idx].user_suspend = false;
pci/controller/pci-msm.c:		mutex_unlock(&msm_pcie_dev[rc_idx].recovery_lock);
pci/controller/pci-msm.c:		PCIE_DBG(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:			ret = msm_pcie_drv_resume(pcie_dev);
pci/controller/pci-msm.c:		if (msm_pcie_dev[rc_idx].power_on) {
pci/controller/pci-msm.c:			PCIE_ERR(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:				rc_idx, msm_pcie_dev[rc_idx].num_active_ep);
pci/controller/pci-msm.c:		mutex_lock(&msm_pcie_dev[rc_idx].recovery_lock);
pci/controller/pci-msm.c:		ret = msm_pcie_pm_resume(dev, user, data, options);
pci/controller/pci-msm.c:			PCIE_ERR(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:			PCIE_DBG(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:			msm_pcie_dev[rc_idx].user_suspend = false;
pci/controller/pci-msm.c:		mutex_unlock(&msm_pcie_dev[rc_idx].recovery_lock);
pci/controller/pci-msm.c:		PCIE_DBG(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:		spin_lock_irqsave(&msm_pcie_dev[rc_idx].cfg_lock,
pci/controller/pci-msm.c:				msm_pcie_dev[rc_idx].irqsave_flags);
pci/controller/pci-msm.c:		if (msm_pcie_dev[rc_idx].suspending) {
pci/controller/pci-msm.c:			PCIE_ERR(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:			msm_pcie_dev[rc_idx].disable_pc = true;
pci/controller/pci-msm.c:		spin_unlock_irqrestore(&msm_pcie_dev[rc_idx].cfg_lock,
pci/controller/pci-msm.c:				msm_pcie_dev[rc_idx].irqsave_flags);
pci/controller/pci-msm.c:		PCIE_DBG(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:		spin_lock_irqsave(&msm_pcie_dev[rc_idx].cfg_lock,
pci/controller/pci-msm.c:				msm_pcie_dev[rc_idx].irqsave_flags);
pci/controller/pci-msm.c:		msm_pcie_dev[rc_idx].disable_pc = false;
pci/controller/pci-msm.c:		spin_unlock_irqrestore(&msm_pcie_dev[rc_idx].cfg_lock,
pci/controller/pci-msm.c:				msm_pcie_dev[rc_idx].irqsave_flags);
pci/controller/pci-msm.c:		PCIE_DBG(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:		spin_lock_irqsave(&msm_pcie_dev[rc_idx].irq_lock, flags);
pci/controller/pci-msm.c:		msm_pcie_handle_linkdown(pcie_dev);
pci/controller/pci-msm.c:		spin_unlock_irqrestore(&msm_pcie_dev[rc_idx].irq_lock, flags);
pci/controller/pci-msm.c:		PCIE_ERR(&msm_pcie_dev[rc_idx],
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_pm_control);
pci/controller/pci-msm.c:void msm_pcie_l1ss_timeout_disable(struct pci_dev *pci_dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = PCIE_BUS_PRIV_DATA(pci_dev->bus);
pci/controller/pci-msm.c:	__msm_pcie_l1ss_timeout_disable(pcie_dev);
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_l1ss_timeout_disable);
pci/controller/pci-msm.c:void msm_pcie_l1ss_timeout_enable(struct pci_dev *pci_dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev = PCIE_BUS_PRIV_DATA(pci_dev->bus);
pci/controller/pci-msm.c:	__msm_pcie_l1ss_timeout_enable(pcie_dev);
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_l1ss_timeout_enable);
pci/controller/pci-msm.c:int msm_pcie_register_event(struct msm_pcie_register_event *reg)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev;
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_register_event);
pci/controller/pci-msm.c:int msm_pcie_deregister_event(struct msm_pcie_register_event *reg)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev;
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_deregister_event);
pci/controller/pci-msm.c:int msm_pcie_recover_config(struct pci_dev *dev)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev;
pci/controller/pci-msm.c:	if (msm_pcie_confirm_linkup(pcie_dev, true, true, pcie_dev->conf)) {
pci/controller/pci-msm.c:		msm_pcie_cfg_recover(pcie_dev, true);
pci/controller/pci-msm.c:		msm_pcie_cfg_recover(pcie_dev, false);
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_recover_config);
pci/controller/pci-msm.c:int msm_pcie_shadow_control(struct pci_dev *dev, bool enable)
pci/controller/pci-msm.c:	struct msm_pcie_dev_t *pcie_dev;
pci/controller/pci-msm.c:EXPORT_SYMBOL(msm_pcie_shadow_control);
phy/qualcomm/phy-qcom-qmp.c:static const struct qmp_phy_init_tbl msm8996_pcie_serdes_tbl[] = {
phy/qualcomm/phy-qcom-qmp.c:static const struct qmp_phy_init_tbl msm8996_pcie_tx_tbl[] = {
phy/qualcomm/phy-qcom-qmp.c:static const struct qmp_phy_init_tbl msm8996_pcie_rx_tbl[] = {
phy/qualcomm/phy-qcom-qmp.c:static const struct qmp_phy_init_tbl msm8996_pcie_pcs_tbl[] = {
phy/qualcomm/phy-qcom-qmp.c:static const struct qmp_phy_init_tbl msm8996_usb3_serdes_tbl[] = {
phy/qualcomm/phy-qcom-qmp.c:static const struct qmp_phy_init_tbl msm8996_usb3_tx_tbl[] = {
phy/qualcomm/phy-qcom-qmp.c:static const struct qmp_phy_init_tbl msm8996_usb3_rx_tbl[] = {
phy/qualcomm/phy-qcom-qmp.c:static const struct qmp_phy_init_tbl msm8996_usb3_pcs_tbl[] = {
phy/qualcomm/phy-qcom-qmp.c:static const char * const msm8996_phy_clk_l[] = {
phy/qualcomm/phy-qcom-qmp.c:static const char * const msm8996_pciephy_reset_l[] = {
phy/qualcomm/phy-qcom-qmp.c:static const char * const msm8996_usb3phy_reset_l[] = {
phy/qualcomm/phy-qcom-qmp.c:static const char * const msm8996_phy_vreg_l[] = {
phy/qualcomm/phy-qcom-qmp.c:static const struct qmp_phy_cfg msm8996_pciephy_cfg = {
phy/qualcomm/phy-qcom-qmp.c:	.serdes_tbl		= msm8996_pcie_serdes_tbl,
phy/qualcomm/phy-qcom-qmp.c:	.serdes_tbl_num		= ARRAY_SIZE(msm8996_pcie_serdes_tbl),
phy/qualcomm/phy-qcom-qmp.c:	.tx_tbl			= msm8996_pcie_tx_tbl,
phy/qualcomm/phy-qcom-qmp.c:	.tx_tbl_num		= ARRAY_SIZE(msm8996_pcie_tx_tbl),
phy/qualcomm/phy-qcom-qmp.c:	.rx_tbl			= msm8996_pcie_rx_tbl,
phy/qualcomm/phy-qcom-qmp.c:	.rx_tbl_num		= ARRAY_SIZE(msm8996_pcie_rx_tbl),
phy/qualcomm/phy-qcom-qmp.c:	.pcs_tbl		= msm8996_pcie_pcs_tbl,
phy/qualcomm/phy-qcom-qmp.c:	.pcs_tbl_num		= ARRAY_SIZE(msm8996_pcie_pcs_tbl),
phy/qualcomm/phy-qcom-qmp.c:	.clk_list		= msm8996_phy_clk_l,
phy/qualcomm/phy-qcom-qmp.c:	.num_clks		= ARRAY_SIZE(msm8996_phy_clk_l),
phy/qualcomm/phy-qcom-qmp.c:	.reset_list		= msm8996_pciephy_reset_l,
phy/qualcomm/phy-qcom-qmp.c:	.num_resets		= ARRAY_SIZE(msm8996_pciephy_reset_l),
phy/qualcomm/phy-qcom-qmp.c:	.vreg_list		= msm8996_phy_vreg_l,
phy/qualcomm/phy-qcom-qmp.c:	.num_vregs		= ARRAY_SIZE(msm8996_phy_vreg_l),
phy/qualcomm/phy-qcom-qmp.c:static const struct qmp_phy_cfg msm8996_usb3phy_cfg = {
phy/qualcomm/phy-qcom-qmp.c:	.serdes_tbl		= msm8996_usb3_serdes_tbl,
phy/qualcomm/phy-qcom-qmp.c:	.serdes_tbl_num		= ARRAY_SIZE(msm8996_usb3_serdes_tbl),
phy/qualcomm/phy-qcom-qmp.c:	.tx_tbl			= msm8996_usb3_tx_tbl,
phy/qualcomm/phy-qcom-qmp.c:	.tx_tbl_num		= ARRAY_SIZE(msm8996_usb3_tx_tbl),
phy/qualcomm/phy-qcom-qmp.c:	.rx_tbl			= msm8996_usb3_rx_tbl,
phy/qualcomm/phy-qcom-qmp.c:	.rx_tbl_num		= ARRAY_SIZE(msm8996_usb3_rx_tbl),
phy/qualcomm/phy-qcom-qmp.c:	.pcs_tbl		= msm8996_usb3_pcs_tbl,
phy/qualcomm/phy-qcom-qmp.c:	.pcs_tbl_num		= ARRAY_SIZE(msm8996_usb3_pcs_tbl),
phy/qualcomm/phy-qcom-qmp.c:	.clk_list		= msm8996_phy_clk_l,
phy/qualcomm/phy-qcom-qmp.c:	.num_clks		= ARRAY_SIZE(msm8996_phy_clk_l),
phy/qualcomm/phy-qcom-qmp.c:	.reset_list		= msm8996_usb3phy_reset_l,
phy/qualcomm/phy-qcom-qmp.c:	.num_resets		= ARRAY_SIZE(msm8996_usb3phy_reset_l),
phy/qualcomm/phy-qcom-qmp.c:	.vreg_list		= msm8996_phy_vreg_l,
phy/qualcomm/phy-qcom-qmp.c:	.num_vregs		= ARRAY_SIZE(msm8996_phy_vreg_l),
phy/qualcomm/phy-qcom-qmp.c:	.reset_list		= msm8996_usb3phy_reset_l,
phy/qualcomm/phy-qcom-qmp.c:	.num_resets		= ARRAY_SIZE(msm8996_usb3phy_reset_l),
phy/qualcomm/phy-qcom-qmp.c:	.vreg_list		= msm8996_phy_vreg_l,
phy/qualcomm/phy-qcom-qmp.c:	.num_vregs		= ARRAY_SIZE(msm8996_phy_vreg_l),
phy/qualcomm/phy-qcom-qmp.c:	.reset_list		= msm8996_usb3phy_reset_l,
phy/qualcomm/phy-qcom-qmp.c:	.num_resets		= ARRAY_SIZE(msm8996_usb3phy_reset_l),
phy/qualcomm/phy-qcom-qmp.c:	.vreg_list		= msm8996_phy_vreg_l,
phy/qualcomm/phy-qcom-qmp.c:	.num_vregs		= ARRAY_SIZE(msm8996_phy_vreg_l),
phy/qualcomm/phy-qcom-qmp.c:		.compatible = "qcom,msm8996-qmp-pcie-phy",
phy/qualcomm/phy-qcom-qmp.c:		.data = &msm8996_pciephy_cfg,
phy/qualcomm/phy-qcom-qmp.c:		.compatible = "qcom,msm8996-qmp-usb3-phy",
phy/qualcomm/phy-qcom-qmp.c:		.data = &msm8996_usb3phy_cfg,
phy/qualcomm/phy-qcom-qusb2.c:static const unsigned int msm8996_regs_layout[] = {
phy/qualcomm/phy-qcom-qusb2.c:static const struct qusb2_phy_init_tbl msm8996_init_tbl[] = {
phy/qualcomm/phy-qcom-qusb2.c:static const struct qusb2_phy_cfg msm8996_phy_cfg = {
phy/qualcomm/phy-qcom-qusb2.c:	.tbl		= msm8996_init_tbl,
phy/qualcomm/phy-qcom-qusb2.c:	.tbl_num	= ARRAY_SIZE(msm8996_init_tbl),
phy/qualcomm/phy-qcom-qusb2.c:	.regs		= msm8996_regs_layout,
phy/qualcomm/phy-qcom-qusb2.c:	/* Default is single-ended clock on msm8996 */
phy/qualcomm/phy-qcom-qusb2.c:		.compatible	= "qcom,msm8996-qusb2-phy",
phy/qualcomm/phy-qcom-qusb2.c:		.data		= &msm8996_phy_cfg,
phy/qualcomm/phy-qcom-ufs.c:				"qcom,msm8996-ufs-phy-qmp-14nm"))
pinctrl/qcom/Makefile:obj-$(CONFIG_PINCTRL_MSM)	+= pinctrl-msm.o
pinctrl/qcom/Makefile:obj-$(CONFIG_PINCTRL_MSM8660)	+= pinctrl-msm8660.o
pinctrl/qcom/Makefile:obj-$(CONFIG_PINCTRL_MSM8960)	+= pinctrl-msm8960.o
pinctrl/qcom/Makefile:obj-$(CONFIG_PINCTRL_MSM8X74)	+= pinctrl-msm8x74.o
pinctrl/qcom/Makefile:obj-$(CONFIG_PINCTRL_MSM8916)	+= pinctrl-msm8916.o
pinctrl/qcom/Makefile:obj-$(CONFIG_PINCTRL_MSM8994)   += pinctrl-msm8994.o
pinctrl/qcom/Makefile:obj-$(CONFIG_PINCTRL_MSM8996)   += pinctrl-msm8996.o
pinctrl/qcom/Makefile:obj-$(CONFIG_PINCTRL_MSM8998)   += pinctrl-msm8998.o
pinctrl/qcom/Makefile:obj-$(CONFIG_PINCTRL_MSM8937)   += pinctrl-msm8937.o
pinctrl/qcom/Makefile:obj-$(CONFIG_PINCTRL_MSM8917)   += pinctrl-msm8917.o
pinctrl/qcom/pinctrl-apq8064.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-apq8064.c:static const struct msm_function apq8064_functions[] = {
pinctrl/qcom/pinctrl-apq8064.c:static const struct msm_pingroup apq8064_groups[] = {
pinctrl/qcom/pinctrl-apq8064.c:static const struct msm_pinctrl_soc_data apq8064_pinctrl = {
pinctrl/qcom/pinctrl-apq8064.c:	return msm_pinctrl_probe(pdev, &apq8064_pinctrl);
pinctrl/qcom/pinctrl-apq8064.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-apq8084.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-apq8084.c:static const struct msm_function apq8084_functions[] = {
pinctrl/qcom/pinctrl-apq8084.c:static const struct msm_pingroup apq8084_groups[] = {
pinctrl/qcom/pinctrl-apq8084.c:static const struct msm_pinctrl_soc_data apq8084_pinctrl = {
pinctrl/qcom/pinctrl-apq8084.c:	return msm_pinctrl_probe(pdev, &apq8084_pinctrl);
pinctrl/qcom/pinctrl-apq8084.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-bengal.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-bengal.c:	[msm_mux_##fname] = {				\
pinctrl/qcom/pinctrl-bengal.c:			msm_mux_gpio, /* gpio mode */	\
pinctrl/qcom/pinctrl-bengal.c:			msm_mux_##f1,			\
pinctrl/qcom/pinctrl-bengal.c:			msm_mux_##f2,			\
pinctrl/qcom/pinctrl-bengal.c:			msm_mux_##f3,			\
pinctrl/qcom/pinctrl-bengal.c:			msm_mux_##f4,			\
pinctrl/qcom/pinctrl-bengal.c:			msm_mux_##f5,			\
pinctrl/qcom/pinctrl-bengal.c:			msm_mux_##f6,			\
pinctrl/qcom/pinctrl-bengal.c:			msm_mux_##f7,			\
pinctrl/qcom/pinctrl-bengal.c:			msm_mux_##f8,			\
pinctrl/qcom/pinctrl-bengal.c:			msm_mux_##f9			\
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qup0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_gpio,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_ddr_bist,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio8,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_tsens,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_mpm_pwr,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_m_voc,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio9,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_tsens2,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag2,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio10,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_usb10,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag3,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio11,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_usb11,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qup1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_CRI_TRNG0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag4,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib2,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_usb12,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_CRI_TRNG1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag5,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib3,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_usb13,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qup2,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag6,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib4,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_usb1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qup3,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs_out,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_PLL_BIST,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_tsense_pwm,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_AGERA_PLL,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qup4,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_tgu_ch0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_tgu_ch1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qup5,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_tgu_ch2,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag7,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio4,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib5,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_tgu_ch3,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag8,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio5,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib6,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag9,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio6,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib7,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag10,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio7,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib8,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_SDC2_TB,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_CRI_TRNG,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs2,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio2,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_SDC1_TB,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs3,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio3,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_cam_mclk,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs4,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_adsp_ext,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs5,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_cci_i2c,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_prng_rosc,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs6,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag11,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib9,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_usb20,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs7,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag12,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib10,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_usb21,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_CCI_TIMER1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_GCC_GP1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs8,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag13,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib11,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_usb22,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_cci_async,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_CCI_TIMER0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs9,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag14,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib12,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_usb23,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs10,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag15,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib13,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_usb2,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_vsense_trigger,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_cti,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_CCI_TIMER2,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag16,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib14,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_char,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag17,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib15,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_char0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_GP_PDM0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag18,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib16,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_char1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_CCI_TIMER3,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_GP_PDM1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag19,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib17,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_char2,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_GP_PDM2,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag20,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib18,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_char3,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag21,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag22,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_NAV_GPIO,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag23,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag24,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag25,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs14,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio14,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_vfr_1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs15,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio15,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_PA_INDICATOR,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_gsm1_tx,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_SSBI_WTR1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pll_bypassnl,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pll_reset,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag26,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_ddr_pxi0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_gsm0_tx,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag27,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_GCC_GP2,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio12,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_ddr_pxi1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_GCC_GP3,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_qdss_gpio13,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dbg_out,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_uim2_data,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_uim2_clk,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_uim2_reset,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_uim2_present,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_uim1_data,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_uim1_clk,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_uim1_reset,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_uim1_present,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib19,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_mdp_vsync,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_mdp_vsync_out_0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_mdp_vsync_out_1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib20,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib21,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_bbrx1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs11,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_usb_phy,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_bbrx0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_mss_lte,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs12,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_pbs13,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_wlan1_adc0,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_wlan1_adc1,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_sd_write,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_JITTER_BIST,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_gpsadc_dtest0_native,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_atest_gpsadc_dtest1_native,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag28,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib22,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_ddr_pxi2,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag29,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib23,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag30,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib24,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_ddr_pxi3,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_phase_flag31,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_dac_calib25,
pinctrl/qcom/pinctrl-bengal.c:	msm_mux_NA,
pinctrl/qcom/pinctrl-bengal.c:static const struct msm_function bengal_functions[] = {
pinctrl/qcom/pinctrl-bengal.c:static const struct msm_pingroup bengal_groups[] = {
pinctrl/qcom/pinctrl-bengal.c:static const struct msm_pinctrl_soc_data bengal_pinctrl = {
pinctrl/qcom/pinctrl-bengal.c:	return msm_pinctrl_probe(pdev, &bengal_pinctrl);
pinctrl/qcom/pinctrl-bengal.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-ipq4019.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-ipq4019.c:static const struct msm_function ipq4019_functions[] = {
pinctrl/qcom/pinctrl-ipq4019.c:static const struct msm_pingroup ipq4019_groups[] = {
pinctrl/qcom/pinctrl-ipq4019.c:static const struct msm_pinctrl_soc_data ipq4019_pinctrl = {
pinctrl/qcom/pinctrl-ipq4019.c:	return msm_pinctrl_probe(pdev, &ipq4019_pinctrl);
pinctrl/qcom/pinctrl-ipq4019.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-ipq8064.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-ipq8064.c:static const struct msm_function ipq8064_functions[] = {
pinctrl/qcom/pinctrl-ipq8064.c:static const struct msm_pingroup ipq8064_groups[] = {
pinctrl/qcom/pinctrl-ipq8064.c:static const struct msm_pinctrl_soc_data ipq8064_pinctrl = {
pinctrl/qcom/pinctrl-ipq8064.c:	return msm_pinctrl_probe(pdev, &ipq8064_pinctrl);
pinctrl/qcom/pinctrl-ipq8064.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-ipq8074.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-ipq8074.c:	[msm_mux_##fname] = {		                \
pinctrl/qcom/pinctrl-ipq8074.c:			msm_mux_gpio, /* gpio mode */	\
pinctrl/qcom/pinctrl-ipq8074.c:			msm_mux_##f1,			\
pinctrl/qcom/pinctrl-ipq8074.c:			msm_mux_##f2,			\
pinctrl/qcom/pinctrl-ipq8074.c:			msm_mux_##f3,			\
pinctrl/qcom/pinctrl-ipq8074.c:			msm_mux_##f4,			\
pinctrl/qcom/pinctrl-ipq8074.c:			msm_mux_##f5,			\
pinctrl/qcom/pinctrl-ipq8074.c:			msm_mux_##f6,			\
pinctrl/qcom/pinctrl-ipq8074.c:			msm_mux_##f7,			\
pinctrl/qcom/pinctrl-ipq8074.c:			msm_mux_##f8,			\
pinctrl/qcom/pinctrl-ipq8074.c:			msm_mux_##f9			\
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_atest_char,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_atest_char0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_atest_char1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_atest_char2,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_atest_char3,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_audio_rxbclk,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_audio_rxd,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_audio_rxfsync,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_audio_rxmclk,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_audio_txbclk,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_audio_txd,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_audio_txfsync,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_audio_txmclk,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp0_i2c,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp0_spi,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp0_uart,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp1_i2c,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp1_spi,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp1_uart,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp2_i2c,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp2_spi,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp2_uart,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp3_i2c,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp3_spi,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp3_spi0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp3_spi1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp3_spi2,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp3_spi3,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp3_uart,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp4_i2c0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp4_i2c1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp4_spi0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp4_spi1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp4_uart0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp4_uart1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp5_i2c,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp5_spi,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_blsp5_uart,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_burn0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_burn1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_cri_trng,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_cri_trng0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_cri_trng1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_cxc0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_cxc1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_dbg_out,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_gcc_plltest,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_gcc_tlmm,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_gpio,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_ldo_en,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_ldo_update,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_led0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_led1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_led2,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_mac0_sa0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_mac0_sa1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_mac1_sa0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_mac1_sa1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_mac1_sa2,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_mac1_sa3,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_mac2_sa0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_mac2_sa1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_mdc,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_mdio,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pcie0_clk,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pcie0_rst,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pcie0_wake,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pcie1_clk,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pcie1_rst,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pcie1_wake,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pcm_drx,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pcm_dtx,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pcm_fsync,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pcm_pclk,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pcm_zsi0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pcm_zsi1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_prng_rosc,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pta1_0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pta1_1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pta1_2,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pta2_0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pta2_1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pta2_2,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pwm0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pwm1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pwm2,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_pwm3,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_cti_trig_in_a0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_cti_trig_in_a1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_cti_trig_in_b0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_cti_trig_in_b1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_cti_trig_out_a0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_cti_trig_out_a1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_cti_trig_out_b0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_cti_trig_out_b1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_traceclk_a,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_traceclk_b,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_tracectl_a,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_tracectl_b,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_tracedata_a,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qdss_tracedata_b,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_qpic,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_rx0,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_rx1,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_rx2,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_sd_card,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_sd_write,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_tsens_max,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_wci2a,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_wci2b,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_wci2c,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_wci2d,
pinctrl/qcom/pinctrl-ipq8074.c:	msm_mux_NA,
pinctrl/qcom/pinctrl-ipq8074.c:static const struct msm_function ipq8074_functions[] = {
pinctrl/qcom/pinctrl-ipq8074.c:static const struct msm_pingroup ipq8074_groups[] = {
pinctrl/qcom/pinctrl-ipq8074.c:static const struct msm_pinctrl_soc_data ipq8074_pinctrl = {
pinctrl/qcom/pinctrl-ipq8074.c:	return msm_pinctrl_probe(pdev, &ipq8074_pinctrl);
pinctrl/qcom/pinctrl-ipq8074.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-khaje.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-khaje.c:	[msm_mux_##fname] = {				\
pinctrl/qcom/pinctrl-khaje.c:			msm_mux_gpio, /* gpio mode */	\
pinctrl/qcom/pinctrl-khaje.c:			msm_mux_##f1,			\
pinctrl/qcom/pinctrl-khaje.c:			msm_mux_##f2,			\
pinctrl/qcom/pinctrl-khaje.c:			msm_mux_##f3,			\
pinctrl/qcom/pinctrl-khaje.c:			msm_mux_##f4,			\
pinctrl/qcom/pinctrl-khaje.c:			msm_mux_##f5,			\
pinctrl/qcom/pinctrl-khaje.c:			msm_mux_##f6,			\
pinctrl/qcom/pinctrl-khaje.c:			msm_mux_##f7,			\
pinctrl/qcom/pinctrl-khaje.c:			msm_mux_##f8,			\
pinctrl/qcom/pinctrl-khaje.c:			msm_mux_##f9			\
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_gpio,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qup0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_usb2phy_ac,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_ddr_bist,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_m_voc,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio8,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_tsens,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_mpm_pwr,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio9,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_tsens2,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag2,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio10,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_usb10,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag3,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio11,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_usb11,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qup1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_CRI_TRNG0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag4,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib2,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_usb12,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_CRI_TRNG1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag5,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib3,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_usb13,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qup2,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag6,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib4,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_usb1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qup3,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs_out,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_PLL_BIST,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_tsense_pwm,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_AGERA_PLL,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qup4,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_tgu_ch0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_tgu_ch1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qup5,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_tgu_ch2,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag7,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio4,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib5,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_tgu_ch3,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag8,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio5,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib6,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag9,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio6,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib7,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag10,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio7,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib8,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_SDC2_TB,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_CRI_TRNG,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs2,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio2,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_SDC1_TB,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs3,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio3,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_cam_mclk,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs4,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_adsp_ext,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs5,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_cci_i2c,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_prng_rosc,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs6,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag11,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib9,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_usb20,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs7,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag12,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib10,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_usb21,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_CCI_TIMER1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_GCC_GP1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs8,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag13,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib11,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_usb22,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_cci_async,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_CCI_TIMER0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs9,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag14,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib12,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_usb23,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs10,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag15,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib13,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_usb2,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_vsense_trigger,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_cti,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_CCI_TIMER2,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag16,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib14,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_char,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag17,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib15,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_char0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_GP_PDM0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag18,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib16,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_char1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_CCI_TIMER3,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_GP_PDM1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag19,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib17,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_char2,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_GP_PDM2,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag20,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib18,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_char3,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag21,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio14,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag22,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio15,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_NAV_GPIO,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag23,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag24,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag25,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs14,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_vfr_1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs15,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_PA_INDICATOR,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_gsm1_tx,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_SSBI_WTR1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pll_clk,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pll_bypassnl,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pll_reset,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag26,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_ddr_pxi0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_gsm0_tx,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag27,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_GCC_GP2,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio12,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_ddr_pxi1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_GCC_GP3,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_qdss_gpio13,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dbg_out,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_uim2_data,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_uim2_clk,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_uim2_reset,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_uim2_present,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_uim1_data,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_uim1_clk,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_uim1_reset,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_uim1_present,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib19,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_mdp_vsync,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_mdp_vsync_out_0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_mdp_vsync_out_1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib20,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib21,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_bbrx1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs11,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_usb_phy,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_bbrx0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_mss_lte,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs12,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_pbs13,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_wlan1_adc0,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_wlan1_adc1,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_sd_write,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_JITTER_BIST,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_gpsadc_dtest0_native,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_atest_gpsadc_dtest1_native,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag28,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib22,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_ddr_pxi2,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag29,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib23,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag30,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib24,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_ddr_pxi3,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_phase_flag31,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_dac_calib25,
pinctrl/qcom/pinctrl-khaje.c:	msm_mux_NA,
pinctrl/qcom/pinctrl-khaje.c:static const struct msm_function khaje_functions[] = {
pinctrl/qcom/pinctrl-khaje.c:static const struct msm_pingroup khaje_groups[] = {
pinctrl/qcom/pinctrl-khaje.c:static const struct msm_pinctrl_soc_data khaje_pinctrl = {
pinctrl/qcom/pinctrl-khaje.c:	return msm_pinctrl_probe(pdev, &khaje_pinctrl);
pinctrl/qcom/pinctrl-khaje.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-kona.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-kona.c:	[msm_mux_##fname] = {				\
pinctrl/qcom/pinctrl-kona.c:			msm_mux_gpio, /* gpio mode */	\
pinctrl/qcom/pinctrl-kona.c:			msm_mux_##f1,			\
pinctrl/qcom/pinctrl-kona.c:			msm_mux_##f2,			\
pinctrl/qcom/pinctrl-kona.c:			msm_mux_##f3,			\
pinctrl/qcom/pinctrl-kona.c:			msm_mux_##f4,			\
pinctrl/qcom/pinctrl-kona.c:			msm_mux_##f5,			\
pinctrl/qcom/pinctrl-kona.c:			msm_mux_##f6,			\
pinctrl/qcom/pinctrl-kona.c:			msm_mux_##f7,			\
pinctrl/qcom/pinctrl-kona.c:			msm_mux_##f8,			\
pinctrl/qcom/pinctrl-kona.c:			msm_mux_##f9			\
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tsif1_data,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_sdc41,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tsif1_sync,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_sdc40,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_aoss_cti,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag18,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_sd_write,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag17,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_pci_e0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag16,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag15,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag14,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_pci_e1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag13,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag12,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag11,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_pci_e2,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tgu_ch0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_char1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tgu_ch3,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_char2,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_char3,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_char,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_char0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tsif1_error,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tgu_ch1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tsif0_error,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tgu_ch2,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_cam_mclk,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_ddr_bist,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_pll_bypassnl,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio2,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_pll_reset,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio3,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio4,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio5,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio6,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_cci_i2c,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio7,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio8,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag10,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag9,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio9,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_gcc_gp1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio10,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_gcc_gp2,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio11,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_gcc_gp3,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio12,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_cci_timer0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio13,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_cci_timer1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio14,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_cci_timer2,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_gpio15,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_cci_timer3,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_cci_async,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_cci_timer4,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup2,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag8,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag7,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag6,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag5,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup3,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag4,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag3,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag2,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tsense_pwm1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tsense_pwm2,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup9,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup10,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mi2s2_sck,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mi2s2_data0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mi2s2_ws,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_pri_mi2s,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_sec_mi2s,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_audio_ref,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mi2s2_data1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mi2s0_sck,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mi2s0_data0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mi2s0_data1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mi2s0_ws,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_lpass_slimbus,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mi2s1_sck,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mi2s1_data0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mi2s1_data1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mi2s1_ws,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_cri_trng0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_cri_trng1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_cri_trng,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_sp_cmu,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_prng_rosc,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup19,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_gpio,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qdss_cti,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_ibi_i3c,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup_l4,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup_l5,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup4,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup5,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup6,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup7,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup8,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_usb13,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_usb12,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_usb11,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_usb10,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup12,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_usb03,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_usb02,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_usb01,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_usb00,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup13,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_usb1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_atest_usb0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup14,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_ddr_pxi3,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_ddr_pxi1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_vsense_trigger,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup15,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_dbg_out,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag31,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag30,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag29,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup16,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag28,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag27,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag26,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag25,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup17,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_ddr_pxi0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_jitter_bist,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_pll_bist,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_ddr_pxi2,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup18,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup11,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_usb2phy_ac,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qup_l6,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_usb_phy,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_pll_clk,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mdp_vsync,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_dp_lcd,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_dp_hot,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qspi_cs,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tsif0_clk,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag24,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qspi0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tsif0_en,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mdp_vsync0,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mdp_vsync1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mdp_vsync2,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_mdp_vsync3,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag23,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qspi1,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tsif0_data,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_sdc4_cmd,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag22,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qspi2,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tsif0_sync,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_sdc43,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag21,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qspi_clk,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tsif1_clk,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_sdc4_clk,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag20,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_qspi3,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_tsif1_en,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_sdc42,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_phase_flag19,
pinctrl/qcom/pinctrl-kona.c:	msm_mux_NA,
pinctrl/qcom/pinctrl-kona.c:static const struct msm_function kona_functions[] = {
pinctrl/qcom/pinctrl-kona.c:static const struct msm_pingroup kona_groups[] = {
pinctrl/qcom/pinctrl-kona.c:static const struct msm_pinctrl_soc_data kona_pinctrl = {
pinctrl/qcom/pinctrl-kona.c:	return msm_pinctrl_probe(pdev, &kona_pinctrl);
pinctrl/qcom/pinctrl-kona.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-lagoon.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-lagoon.c:	[msm_mux_##fname] = {		                \
pinctrl/qcom/pinctrl-lagoon.c:			msm_mux_gpio, /* gpio mode */	\
pinctrl/qcom/pinctrl-lagoon.c:			msm_mux_##f1,			\
pinctrl/qcom/pinctrl-lagoon.c:			msm_mux_##f2,			\
pinctrl/qcom/pinctrl-lagoon.c:			msm_mux_##f3,			\
pinctrl/qcom/pinctrl-lagoon.c:			msm_mux_##f4,			\
pinctrl/qcom/pinctrl-lagoon.c:			msm_mux_##f5,			\
pinctrl/qcom/pinctrl-lagoon.c:			msm_mux_##f6,			\
pinctrl/qcom/pinctrl-lagoon.c:			msm_mux_##f7,			\
pinctrl/qcom/pinctrl-lagoon.c:			msm_mux_##f8,			\
pinctrl/qcom/pinctrl-lagoon.c:			msm_mux_##f9			\
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_ibi_i3c,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_gpio,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_cri_trng,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qup00,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_CCI_I2C,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_cti,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_sp_cmu,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_dbg_out,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qup14,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_sdc1_tb,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_sdc2_tb,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_MDP_VSYNC,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_GP_PDM1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_m_voc,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_dp_hot,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag0,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qup10,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_pll_bypassnl,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_pll_reset,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qup12,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_ddr_bist,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_gcc_gp2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_gcc_gp3,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_edp_lcd,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qup13_f1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qup13_f2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qup11,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_PLL_BIST,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio14,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio15,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_CAM_MCLK0,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_CAM_MCLK1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_CAM_MCLK2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_CAM_MCLK3,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_CAM_MCLK4,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_cci_timer0,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag3,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio12,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_cci_timer1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_CCI_ASYNC,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag4,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio13,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_cci_timer2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag5,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_cci_timer3,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_GP_PDM0,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag6,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_cci_timer4,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag7,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag8,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio0,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag9,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag10,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag11,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio3,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag12,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio4,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag13,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio5,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qup02,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag14,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio6,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag15,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio7,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_mdp_vsync0,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag16,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_mdp_vsync1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_gcc_gp1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag17,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio8,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_vfr_1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag18,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio9,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag19,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio10,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag20,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qdss_gpio11,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag21,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag22,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_mdp_vsync2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag23,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_mdp_vsync3,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_GP_PDM2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag24,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_audio_ref,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_lpass_ext,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_mi2s_2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag25,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_qup01,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_tgu_ch0,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag26,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_tgu_ch1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag27,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_tgu_ch2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag28,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_tgu_ch3,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag29,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_MSS_LTE,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_btfm_slimbus,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_mi2s_1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag30,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_phase_flag31,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_UIM2_DATA,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_UIM2_CLK,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_UIM2_RESET,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_UIM2_PRESENT,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_UIM1_DATA,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_UIM1_CLK,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_UIM1_RESET,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_UIM1_PRESENT,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_usb1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_usb10,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_sd_write,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_usb11,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_usb12,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_ddr_pxi0,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_adsp_ext,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_usb13,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_ddr_pxi1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_mi2s_0,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_usb2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_ddr_pxi2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_tsense_pwm1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_tsense_pwm2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_AGERA_PLL,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_vsense_trigger,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_usb20,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_ddr_pxi3,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_JITTER_BIST,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_wlan1_adc0,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_usb21,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_wlan2_adc0,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_usb22,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_tsens,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_wlan1_adc1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_usb23,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_MCLK,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_tsens2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_wlan2_adc1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_ldo_en,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_char,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_ldo_update,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_char0,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_prng_rosc,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_char1,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_char2,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_atest_char3,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_NAV_GPIO,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_NAV_PPS,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_GPS_TX,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_QLINK0_WMSS,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_QLINK0_REQUEST,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_QLINK0_ENABLE,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_QLINK1_WMSS,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_QLINK1_REQUEST,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_QLINK1_ENABLE,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_RFFE0_DATA,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_RFFE0_CLK,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_RFFE1_DATA,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_RFFE1_CLK,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_RFFE2_DATA,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_RFFE2_CLK,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_RFFE3_DATA,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_RFFE3_CLK,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_RFFE4_DATA,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_RFFE4_CLK,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_pa_indicator,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_PCIE0_CLK,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_USB_PHY,
pinctrl/qcom/pinctrl-lagoon.c:	msm_mux_NA,
pinctrl/qcom/pinctrl-lagoon.c:static const struct msm_function lagoon_functions[] = {
pinctrl/qcom/pinctrl-lagoon.c:static const struct msm_pingroup lagoon_groups[] = {
pinctrl/qcom/pinctrl-lagoon.c:static struct msm_dir_conn lagoon_dir_conn[] = {
pinctrl/qcom/pinctrl-lagoon.c:static const struct msm_pinctrl_soc_data lagoon_pinctrl = {
pinctrl/qcom/pinctrl-lagoon.c:	return msm_pinctrl_probe(pdev, &lagoon_pinctrl);
pinctrl/qcom/pinctrl-lagoon.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-lito.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-lito.c:	[msm_mux_##fname] = {				\
pinctrl/qcom/pinctrl-lito.c:			msm_mux_gpio, /* gpio mode */	\
pinctrl/qcom/pinctrl-lito.c:			msm_mux_##f1,			\
pinctrl/qcom/pinctrl-lito.c:			msm_mux_##f2,			\
pinctrl/qcom/pinctrl-lito.c:			msm_mux_##f3,			\
pinctrl/qcom/pinctrl-lito.c:			msm_mux_##f4,			\
pinctrl/qcom/pinctrl-lito.c:			msm_mux_##f5,			\
pinctrl/qcom/pinctrl-lito.c:			msm_mux_##f6,			\
pinctrl/qcom/pinctrl-lito.c:			msm_mux_##f7,			\
pinctrl/qcom/pinctrl-lito.c:			msm_mux_##f8,			\
pinctrl/qcom/pinctrl-lito.c:			msm_mux_##f9			\
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qup01,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_gpio,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag0,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_cti,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qup11,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_ddr_bist,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag2,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_GP_PDM1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_mdp_vsync,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_edp_lcd,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_m_voc,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_cam_mclk,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_pll_bypassnl,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio0,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_pll_reset,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio2,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio3,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_cci_i2c,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio4,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio5,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio6,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio7,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_cci_timer0,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_gcc_gp2,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio8,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_cci_timer1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_gcc_gp3,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_cci_timer2,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio9,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_cci_timer3,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_cci_async,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio10,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_cci_timer4,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio11,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio12,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio13,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio14,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qup04,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag6,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qdss_gpio15,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_sd_write,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qup02,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_GP_PDM0,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qup05,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qup00,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_ibi_i3c,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag3,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_ddr_pxi0,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag4,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_tsens2,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_vsense_trigger,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_usb1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qup13,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_gcc_gp1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag5,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_pri_mi2s,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qup12,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_pri_mi2s_ws,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_ter_mi2s,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qup14,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_lpass_slimbus,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag7,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_sec_mi2s,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_GP_PDM2,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qua_mi2s,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qup10,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag21,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_usb2,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag8,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_usb22,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_tgu_ch3,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_mdp_vsync0,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_mdp_vsync1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_mdp_vsync2,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_mdp_vsync3,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_tgu_ch0,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_sdc4_cmd,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_tgu_ch1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_sdc43,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_vfr_1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_tgu_ch2,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_sdc4_clk,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_sdc42,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_sdc41,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_sdc40,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_ldo_en,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_ldo_update,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_prng_rosc,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag9,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_usb20,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_uim2_data,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_JITTER_BIST,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag10,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_uim2_clk,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_PLL_BIST,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag11,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_uim2_reset,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_PLL_CLK,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag12,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_uim2_present,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag13,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_wlan2_adc1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_usb11,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_ddr_pxi2,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_uim1_data,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag14,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_wlan2_adc0,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_usb10,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_uim1_clk,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag15,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_ddr_pxi3,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_uim1_reset,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag16,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_uim1_present,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag17,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_aud_ref,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_usb2phy_ac,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qlink1_wmss,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_uim_batt,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_aoss_cti,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag18,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_tsens,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qlink1_request,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_edp_hot,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag19,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qlink1_enable,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag20,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_wlan1_adc0,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_usb12,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_ddr_pxi1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qlink0_wmss,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qlink0_request,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qlink0_enable,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_PON_BEAMER,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_NAV_PPS_IN,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_NAV_PPS_OUT,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_GPS_TX,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_GPS_TX_MIRD,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_pa_indicator,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_dbg_out,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_nav_gpio,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_wlan1_adc1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_usb13,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag22,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag23,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_usb23,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag24,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag25,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_usb21,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag26,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag27,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag28,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag29,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag30,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_phase_flag31,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_mss_lte,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_char,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_qup15,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_char3,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_adsp_ext,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_char2,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_char1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_atest_char0,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_usb_phy,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_cri_trng0,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_cri_trng1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_cri_trng,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_tsense_pwm1,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_tsense_pwm2,
pinctrl/qcom/pinctrl-lito.c:	msm_mux_NA,
pinctrl/qcom/pinctrl-lito.c:static const struct msm_function lito_functions[] = {
pinctrl/qcom/pinctrl-lito.c:static const struct msm_pingroup lito_groups[] = {
pinctrl/qcom/pinctrl-lito.c:static const struct msm_pinctrl_soc_data lito_pinctrl = {
pinctrl/qcom/pinctrl-lito.c:	return msm_pinctrl_probe(pdev, &lito_pinctrl);
pinctrl/qcom/pinctrl-lito.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-mdm9615.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-mdm9615.c:static const struct msm_function mdm9615_functions[] = {
pinctrl/qcom/pinctrl-mdm9615.c:static const struct msm_pingroup mdm9615_groups[] = {
pinctrl/qcom/pinctrl-mdm9615.c:static const struct msm_pinctrl_soc_data mdm9615_pinctrl = {
pinctrl/qcom/pinctrl-mdm9615.c:	return msm_pinctrl_probe(pdev, &mdm9615_pinctrl);
pinctrl/qcom/pinctrl-mdm9615.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-msm.h: * struct msm_function - a pinmux function
pinctrl/qcom/pinctrl-msm.h:struct msm_function {
pinctrl/qcom/pinctrl-msm.h: * struct msm_pingroup - Qualcomm pingroup definition
pinctrl/qcom/pinctrl-msm.h: *                        struct msm_pinctrl_soc_data.
pinctrl/qcom/pinctrl-msm.h:struct msm_pingroup {
pinctrl/qcom/pinctrl-msm.h: * struct msm_dir_conn - TLMM Direct GPIO connect configuration
pinctrl/qcom/pinctrl-msm.h:struct msm_dir_conn {
pinctrl/qcom/pinctrl-msm.h: * struct msm_pinctrl_soc_data - Qualcomm pin controller driver configuration
pinctrl/qcom/pinctrl-msm.h:struct msm_pinctrl_soc_data {
pinctrl/qcom/pinctrl-msm.h:	const struct msm_function *functions;
pinctrl/qcom/pinctrl-msm.h:	const struct msm_pingroup *groups;
pinctrl/qcom/pinctrl-msm.h:	struct msm_dir_conn *dir_conn;
pinctrl/qcom/pinctrl-msm.h:int msm_pinctrl_probe(struct platform_device *pdev,
pinctrl/qcom/pinctrl-msm.h:		      const struct msm_pinctrl_soc_data *soc_data);
pinctrl/qcom/pinctrl-msm.h:int msm_pinctrl_remove(struct platform_device *pdev);
pinctrl/qcom/pinctrl-msm.h:extern int msm_show_resume_irq_mask;
pinctrl/qcom/pinctrl-msm.h:#define msm_show_resume_irq_mask 0
pinctrl/qcom/pinctrl-msm8660.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-msm8660.c:static const struct pinctrl_pin_desc msm8660_pins[] = {
pinctrl/qcom/pinctrl-msm8660.c:enum msm8660_functions {
pinctrl/qcom/pinctrl-msm8660.c:static const struct msm_function msm8660_functions[] = {
pinctrl/qcom/pinctrl-msm8660.c:static const struct msm_pingroup msm8660_groups[] = {
pinctrl/qcom/pinctrl-msm8660.c:static const struct msm_pinctrl_soc_data msm8660_pinctrl = {
pinctrl/qcom/pinctrl-msm8660.c:	.pins = msm8660_pins,
pinctrl/qcom/pinctrl-msm8660.c:	.npins = ARRAY_SIZE(msm8660_pins),
pinctrl/qcom/pinctrl-msm8660.c:	.functions = msm8660_functions,
pinctrl/qcom/pinctrl-msm8660.c:	.nfunctions = ARRAY_SIZE(msm8660_functions),
pinctrl/qcom/pinctrl-msm8660.c:	.groups = msm8660_groups,
pinctrl/qcom/pinctrl-msm8660.c:	.ngroups = ARRAY_SIZE(msm8660_groups),
pinctrl/qcom/pinctrl-msm8660.c:static int msm8660_pinctrl_probe(struct platform_device *pdev)
pinctrl/qcom/pinctrl-msm8660.c:	return msm_pinctrl_probe(pdev, &msm8660_pinctrl);
pinctrl/qcom/pinctrl-msm8660.c:static const struct of_device_id msm8660_pinctrl_of_match[] = {
pinctrl/qcom/pinctrl-msm8660.c:	{ .compatible = "qcom,msm8660-pinctrl", },
pinctrl/qcom/pinctrl-msm8660.c:static struct platform_driver msm8660_pinctrl_driver = {
pinctrl/qcom/pinctrl-msm8660.c:		.name = "msm8660-pinctrl",
pinctrl/qcom/pinctrl-msm8660.c:		.of_match_table = msm8660_pinctrl_of_match,
pinctrl/qcom/pinctrl-msm8660.c:	.probe = msm8660_pinctrl_probe,
pinctrl/qcom/pinctrl-msm8660.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-msm8660.c:static int __init msm8660_pinctrl_init(void)
pinctrl/qcom/pinctrl-msm8660.c:	return platform_driver_register(&msm8660_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8660.c:arch_initcall(msm8660_pinctrl_init);
pinctrl/qcom/pinctrl-msm8660.c:static void __exit msm8660_pinctrl_exit(void)
pinctrl/qcom/pinctrl-msm8660.c:	platform_driver_unregister(&msm8660_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8660.c:module_exit(msm8660_pinctrl_exit);
pinctrl/qcom/pinctrl-msm8660.c:MODULE_DEVICE_TABLE(of, msm8660_pinctrl_of_match);
pinctrl/qcom/pinctrl-msm8916.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-msm8916.c:static const struct pinctrl_pin_desc msm8916_pins[] = {
pinctrl/qcom/pinctrl-msm8916.c:enum msm8916_functions {
pinctrl/qcom/pinctrl-msm8916.c:static const struct msm_function msm8916_functions[] = {
pinctrl/qcom/pinctrl-msm8916.c:static const struct msm_pingroup msm8916_groups[] = {
pinctrl/qcom/pinctrl-msm8916.c:static const struct msm_pinctrl_soc_data msm8916_pinctrl = {
pinctrl/qcom/pinctrl-msm8916.c:	.pins = msm8916_pins,
pinctrl/qcom/pinctrl-msm8916.c:	.npins = ARRAY_SIZE(msm8916_pins),
pinctrl/qcom/pinctrl-msm8916.c:	.functions = msm8916_functions,
pinctrl/qcom/pinctrl-msm8916.c:	.nfunctions = ARRAY_SIZE(msm8916_functions),
pinctrl/qcom/pinctrl-msm8916.c:	.groups = msm8916_groups,
pinctrl/qcom/pinctrl-msm8916.c:	.ngroups = ARRAY_SIZE(msm8916_groups),
pinctrl/qcom/pinctrl-msm8916.c:static int msm8916_pinctrl_probe(struct platform_device *pdev)
pinctrl/qcom/pinctrl-msm8916.c:	return msm_pinctrl_probe(pdev, &msm8916_pinctrl);
pinctrl/qcom/pinctrl-msm8916.c:static const struct of_device_id msm8916_pinctrl_of_match[] = {
pinctrl/qcom/pinctrl-msm8916.c:	{ .compatible = "qcom,msm8916-pinctrl", },
pinctrl/qcom/pinctrl-msm8916.c:static struct platform_driver msm8916_pinctrl_driver = {
pinctrl/qcom/pinctrl-msm8916.c:		.name = "msm8916-pinctrl",
pinctrl/qcom/pinctrl-msm8916.c:		.of_match_table = msm8916_pinctrl_of_match,
pinctrl/qcom/pinctrl-msm8916.c:	.probe = msm8916_pinctrl_probe,
pinctrl/qcom/pinctrl-msm8916.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-msm8916.c:static int __init msm8916_pinctrl_init(void)
pinctrl/qcom/pinctrl-msm8916.c:	return platform_driver_register(&msm8916_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8916.c:arch_initcall(msm8916_pinctrl_init);
pinctrl/qcom/pinctrl-msm8916.c:static void __exit msm8916_pinctrl_exit(void)
pinctrl/qcom/pinctrl-msm8916.c:	platform_driver_unregister(&msm8916_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8916.c:module_exit(msm8916_pinctrl_exit);
pinctrl/qcom/pinctrl-msm8916.c:MODULE_DESCRIPTION("Qualcomm msm8916 pinctrl driver");
pinctrl/qcom/pinctrl-msm8916.c:MODULE_DEVICE_TABLE(of, msm8916_pinctrl_of_match);
pinctrl/qcom/pinctrl-msm8917.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-msm8917.c:	[msm_mux_##fname] = {		                \
pinctrl/qcom/pinctrl-msm8917.c:			msm_mux_gpio, /* gpio mode */	\
pinctrl/qcom/pinctrl-msm8917.c:			msm_mux_##f1,			\
pinctrl/qcom/pinctrl-msm8917.c:			msm_mux_##f2,			\
pinctrl/qcom/pinctrl-msm8917.c:			msm_mux_##f3,			\
pinctrl/qcom/pinctrl-msm8917.c:			msm_mux_##f4,			\
pinctrl/qcom/pinctrl-msm8917.c:			msm_mux_##f5,			\
pinctrl/qcom/pinctrl-msm8917.c:			msm_mux_##f6,			\
pinctrl/qcom/pinctrl-msm8917.c:			msm_mux_##f7,			\
pinctrl/qcom/pinctrl-msm8917.c:			msm_mux_##f8,			\
pinctrl/qcom/pinctrl-msm8917.c:			msm_mux_##f9			\
pinctrl/qcom/pinctrl-msm8917.c:static const struct pinctrl_pin_desc msm8917_pins[] = {
pinctrl/qcom/pinctrl-msm8917.c:enum msm8917_functions {
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_tracedata_b,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_uart1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_gpio,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_spi1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_adsp_ext,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_i2c1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_prng_rosc,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_cti_trig_out_b0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_spi2,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_uart2,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_uart3,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pbs0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pbs1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pwr_modem_enabled_b,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_i2c3,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_gcc_gp2_clk_b,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_ldo_update,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_atest_combodac_to_gpio_native,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_ldo_en,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_i2c2,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_gcc_gp1_clk_b,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pbs2,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_atest_gpsadc_dtest0_native,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_spi3,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_gcc_gp3_clk_b,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_spi4,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_uart4,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_sec_mi2s,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pwr_nav_enabled_b,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_codec_mad,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pwr_crypto_enabled_b,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_i2c4,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_spi5,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_uart5,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_traceclk_a,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_atest_bbrx1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_m_voc,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_cti_trig_in_a0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_cti_trig_in_b0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_i2c6,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_traceclk_b,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_atest_wlan0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_atest_bbrx0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_i2c5,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_tracectl_a,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_atest_gpsadc_dtest1_native,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_tracedata_a,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_spi6,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_uart6,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_tracectl_b,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_atest_wlan1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_mdp_vsync,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pri_mi2s_mclk_a,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_sec_mi2s_mclk_a,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cam_mclk,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cci_i2c,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pwr_modem_enabled_a,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cci_timer0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cci_timer1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cam1_standby,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pwr_nav_enabled_a,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cam1_rst,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pwr_crypto_enabled_a,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_forced_usb,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_cti_trig_out_b1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cam2_rst,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_webcam_standby,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cci_async,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_webcam_rst,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_ov_ldo,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_sd_write,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_accel_int,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_gcc_gp1_clk_a,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_alsp_int,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_gcc_gp2_clk_a,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_mag_int,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_gcc_gp3_clk_a,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp6_spi,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_fp_int,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_cti_trig_in_b1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_uim_batt,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cam2_standby,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_uim1_data,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_uim1_clk,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_uim1_reset,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_uim1_present,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_uim2_data,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_uim2_clk,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_uim2_reset,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_uim2_present,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_sensor_rst,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_mipi_dsi0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_smb_int,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cam0_ldo,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_us_euro,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_atest_char3,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_dbg_out,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_bimc_dte0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_ts_resout,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_ts_sample,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_sec_mi2s_mclk_b,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pri_mi2s,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_sdcard_det,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_atest_char1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_ebi_cdc,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_audio_reset,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_atest_char0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_audio_ref,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cdc_pdm0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pri_mi2s_mclk_b,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_lpass_slimbus,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_lpass_slimbus0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_lpass_slimbus1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_codec_int1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_codec_int2,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_wcss_bt,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_atest_char2,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_ebi_ch0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_wcss_wlan2,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_wcss_wlan1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_wcss_wlan0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_wcss_wlan,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_wcss_fm,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_ext_lpass,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cri_trng,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cri_trng1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_cri_trng0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_spi7,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_uart7,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pri_mi2s_ws,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_i2c7,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_gcc_tlmm,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_dmic0_clk,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_dmic0_data,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_key_volp,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_cti_trig_in_a1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_us_emitter,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_wsa_irq,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_wsa_io,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_spi8,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_uart8,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp_i2c8,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_gcc_plltest,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_nav_pps_in_a,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_pa_indicator,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_modem_tsync,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_nav_tsync,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_nav_pps_in_b,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_nav_pps,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_gsm0_tx,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_atest_char,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_atest_tsens,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_bimc_dte1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_ssbi_wtr1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_fp_gpio,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_coex_uart,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_key_snapshot,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_key_focus,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_nfc_pwr,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_blsp8_spi,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_cti_trig_out_a0,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_qdss_cti_trig_out_a1,
pinctrl/qcom/pinctrl-msm8917.c:	msm_mux_NA,
pinctrl/qcom/pinctrl-msm8917.c:static const struct msm_function msm8917_functions[] = {
pinctrl/qcom/pinctrl-msm8917.c:static const struct msm_pingroup msm8917_groups[] = {
pinctrl/qcom/pinctrl-msm8917.c:static const struct msm_pinctrl_soc_data msm8917_pinctrl = {
pinctrl/qcom/pinctrl-msm8917.c:	.pins = msm8917_pins,
pinctrl/qcom/pinctrl-msm8917.c:	.npins = ARRAY_SIZE(msm8917_pins),
pinctrl/qcom/pinctrl-msm8917.c:	.functions = msm8917_functions,
pinctrl/qcom/pinctrl-msm8917.c:	.nfunctions = ARRAY_SIZE(msm8917_functions),
pinctrl/qcom/pinctrl-msm8917.c:	.groups = msm8917_groups,
pinctrl/qcom/pinctrl-msm8917.c:	.ngroups = ARRAY_SIZE(msm8917_groups),
pinctrl/qcom/pinctrl-msm8917.c:static int msm8917_pinctrl_probe(struct platform_device *pdev)
pinctrl/qcom/pinctrl-msm8917.c:	return msm_pinctrl_probe(pdev, &msm8917_pinctrl);
pinctrl/qcom/pinctrl-msm8917.c:static const struct of_device_id msm8917_pinctrl_of_match[] = {
pinctrl/qcom/pinctrl-msm8917.c:	{ .compatible = "qcom,msm8917-pinctrl", },
pinctrl/qcom/pinctrl-msm8917.c:static struct platform_driver msm8917_pinctrl_driver = {
pinctrl/qcom/pinctrl-msm8917.c:		.name = "msm8917-pinctrl",
pinctrl/qcom/pinctrl-msm8917.c:		.of_match_table = msm8917_pinctrl_of_match,
pinctrl/qcom/pinctrl-msm8917.c:	.probe = msm8917_pinctrl_probe,
pinctrl/qcom/pinctrl-msm8917.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-msm8917.c:static int __init msm8917_pinctrl_init(void)
pinctrl/qcom/pinctrl-msm8917.c:	return platform_driver_register(&msm8917_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8917.c:arch_initcall(msm8917_pinctrl_init);
pinctrl/qcom/pinctrl-msm8917.c:static void __exit msm8917_pinctrl_exit(void)
pinctrl/qcom/pinctrl-msm8917.c:	platform_driver_unregister(&msm8917_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8917.c:module_exit(msm8917_pinctrl_exit);
pinctrl/qcom/pinctrl-msm8917.c:MODULE_DESCRIPTION("QTI msm8917 pinctrl driver");
pinctrl/qcom/pinctrl-msm8917.c:MODULE_DEVICE_TABLE(of, msm8917_pinctrl_of_match);
pinctrl/qcom/pinctrl-msm8937.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-msm8937.c:	[msm_mux_##fname] = {		                \
pinctrl/qcom/pinctrl-msm8937.c:			msm_mux_gpio, /* gpio mode */	\
pinctrl/qcom/pinctrl-msm8937.c:			msm_mux_##f1,			\
pinctrl/qcom/pinctrl-msm8937.c:			msm_mux_##f2,			\
pinctrl/qcom/pinctrl-msm8937.c:			msm_mux_##f3,			\
pinctrl/qcom/pinctrl-msm8937.c:			msm_mux_##f4,			\
pinctrl/qcom/pinctrl-msm8937.c:			msm_mux_##f5,			\
pinctrl/qcom/pinctrl-msm8937.c:			msm_mux_##f6,			\
pinctrl/qcom/pinctrl-msm8937.c:			msm_mux_##f7,			\
pinctrl/qcom/pinctrl-msm8937.c:			msm_mux_##f8,			\
pinctrl/qcom/pinctrl-msm8937.c:			msm_mux_##f9			\
pinctrl/qcom/pinctrl-msm8937.c:static const struct pinctrl_pin_desc msm8937_pins[] = {
pinctrl/qcom/pinctrl-msm8937.c:enum msm8937_functions {
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_tracedata_b,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_uart1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_gpio,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_spi1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_adsp_ext,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_i2c1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_prng_rosc,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_cti_trig_out_b0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_spi2,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_uart2,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_uart3,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pbs0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pbs1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pwr_modem_enabled_b,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_i2c3,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_gcc_gp2_clk_b,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_ldo_update,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_atest_combodac_to_gpio_native,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_ldo_en,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_i2c2,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_gcc_gp1_clk_b,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pbs2,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_atest_gpsadc_dtest0_native,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_spi3,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_gcc_gp3_clk_b,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_spi4,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_uart4,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_sec_mi2s,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pwr_nav_enabled_b,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_codec_mad,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pwr_crypto_enabled_b,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_i2c4,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_spi5,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_uart5,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_traceclk_a,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_atest_bbrx1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_m_voc,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_cti_trig_in_a0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_cti_trig_in_b0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_i2c6,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_traceclk_b,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_atest_wlan0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_atest_wlan1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_atest_bbrx0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_i2c5,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_tracectl_a,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_atest_gpsadc_dtest1_native,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_tracedata_a,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_spi6,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_uart6,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_tracectl_b,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_mdp_vsync,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pri_mi2s_mclk_a,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_sec_mi2s_mclk_a,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cam_mclk,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cci_i2c,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pwr_modem_enabled_a,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cci_timer0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cci_timer1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cam1_standby,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pwr_nav_enabled_a,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cam1_rst,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pwr_crypto_enabled_a,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_forced_usb,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_cti_trig_out_b1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cam2_rst,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_webcam_standby,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cci_async,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_webcam_rst,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_ov_ldo,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_sd_write,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_accel_int,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_gcc_gp1_clk_a,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_alsp_int,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_gcc_gp2_clk_a,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_mag_int,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_gcc_gp3_clk_a,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp6_spi,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_fp_int,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_cti_trig_in_b1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_uim_batt,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cam2_standby,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_uim1_data,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_uim1_clk,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_uim1_reset,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_uim1_present,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_uim2_data,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_uim2_clk,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_uim2_reset,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_uim2_present,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_sensor_rst,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_mipi_dsi0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_smb_int,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cam0_ldo,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_us_euro,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_atest_char3,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_dbg_out,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_bimc_dte0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_ts_resout,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_ts_sample,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_sec_mi2s_mclk_b,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pri_mi2s,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_sdcard_det,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_atest_char1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_ebi_cdc,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_audio_reset,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_atest_char0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_audio_ref,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cdc_pdm0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pri_mi2s_mclk_b,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_lpass_slimbus,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_lpass_slimbus0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_lpass_slimbus1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_codec_int1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_codec_int2,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_wcss_bt,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_atest_char2,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_ebi_ch0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_wcss_wlan2,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_wcss_wlan1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_wcss_wlan0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_wcss_wlan,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_wcss_fm,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_ext_lpass,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cri_trng,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cri_trng1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_cri_trng0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_spi7,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_uart7,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pri_mi2s_ws,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_i2c7,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_gcc_tlmm,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_dmic0_clk,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_dmic0_data,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_key_volp,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_cti_trig_in_a1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_us_emitter,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_wsa_irq,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_wsa_io,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_wsa_reset,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_spi8,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_uart8,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp_i2c8,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_gcc_plltest,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_nav_pps_in_a,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_pa_indicator,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_modem_tsync,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_nav_tsync,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_nav_pps_in_b,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_nav_pps,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_gsm0_tx,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_atest_char,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_atest_tsens,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_bimc_dte1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_ssbi_wtr1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_fp_gpio,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_coex_uart,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_key_snapshot,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_key_focus,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_nfc_pwr,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_blsp8_spi,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_cti_trig_out_a0,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_qdss_cti_trig_out_a1,
pinctrl/qcom/pinctrl-msm8937.c:	msm_mux_NA,
pinctrl/qcom/pinctrl-msm8937.c:static const struct msm_function msm8937_functions[] = {
pinctrl/qcom/pinctrl-msm8937.c:static const struct msm_pingroup msm8937_groups[] = {
pinctrl/qcom/pinctrl-msm8937.c:static const struct msm_pinctrl_soc_data msm8937_pinctrl = {
pinctrl/qcom/pinctrl-msm8937.c:	.pins = msm8937_pins,
pinctrl/qcom/pinctrl-msm8937.c:	.npins = ARRAY_SIZE(msm8937_pins),
pinctrl/qcom/pinctrl-msm8937.c:	.functions = msm8937_functions,
pinctrl/qcom/pinctrl-msm8937.c:	.nfunctions = ARRAY_SIZE(msm8937_functions),
pinctrl/qcom/pinctrl-msm8937.c:	.groups = msm8937_groups,
pinctrl/qcom/pinctrl-msm8937.c:	.ngroups = ARRAY_SIZE(msm8937_groups),
pinctrl/qcom/pinctrl-msm8937.c:static int msm8937_pinctrl_probe(struct platform_device *pdev)
pinctrl/qcom/pinctrl-msm8937.c:	return msm_pinctrl_probe(pdev, &msm8937_pinctrl);
pinctrl/qcom/pinctrl-msm8937.c:static const struct of_device_id msm8937_pinctrl_of_match[] = {
pinctrl/qcom/pinctrl-msm8937.c:	{ .compatible = "qcom,msm8937-pinctrl", },
pinctrl/qcom/pinctrl-msm8937.c:static struct platform_driver msm8937_pinctrl_driver = {
pinctrl/qcom/pinctrl-msm8937.c:		.name = "msm8937-pinctrl",
pinctrl/qcom/pinctrl-msm8937.c:		.of_match_table = msm8937_pinctrl_of_match,
pinctrl/qcom/pinctrl-msm8937.c:	.probe = msm8937_pinctrl_probe,
pinctrl/qcom/pinctrl-msm8937.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-msm8937.c:static int __init msm8937_pinctrl_init(void)
pinctrl/qcom/pinctrl-msm8937.c:	return platform_driver_register(&msm8937_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8937.c:arch_initcall(msm8937_pinctrl_init);
pinctrl/qcom/pinctrl-msm8937.c:static void __exit msm8937_pinctrl_exit(void)
pinctrl/qcom/pinctrl-msm8937.c:	platform_driver_unregister(&msm8937_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8937.c:module_exit(msm8937_pinctrl_exit);
pinctrl/qcom/pinctrl-msm8937.c:MODULE_DESCRIPTION("QTI msm8937 pinctrl driver");
pinctrl/qcom/pinctrl-msm8937.c:MODULE_DEVICE_TABLE(of, msm8937_pinctrl_of_match);
pinctrl/qcom/pinctrl-msm8960.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-msm8960.c:static const struct pinctrl_pin_desc msm8960_pins[] = {
pinctrl/qcom/pinctrl-msm8960.c:enum msm8960_functions {
pinctrl/qcom/pinctrl-msm8960.c:static const struct msm_function msm8960_functions[] = {
pinctrl/qcom/pinctrl-msm8960.c:static const struct msm_pingroup msm8960_groups[] = {
pinctrl/qcom/pinctrl-msm8960.c:static const struct msm_pinctrl_soc_data msm8960_pinctrl = {
pinctrl/qcom/pinctrl-msm8960.c:	.pins = msm8960_pins,
pinctrl/qcom/pinctrl-msm8960.c:	.npins = ARRAY_SIZE(msm8960_pins),
pinctrl/qcom/pinctrl-msm8960.c:	.functions = msm8960_functions,
pinctrl/qcom/pinctrl-msm8960.c:	.nfunctions = ARRAY_SIZE(msm8960_functions),
pinctrl/qcom/pinctrl-msm8960.c:	.groups = msm8960_groups,
pinctrl/qcom/pinctrl-msm8960.c:	.ngroups = ARRAY_SIZE(msm8960_groups),
pinctrl/qcom/pinctrl-msm8960.c:static int msm8960_pinctrl_probe(struct platform_device *pdev)
pinctrl/qcom/pinctrl-msm8960.c:	return msm_pinctrl_probe(pdev, &msm8960_pinctrl);
pinctrl/qcom/pinctrl-msm8960.c:static const struct of_device_id msm8960_pinctrl_of_match[] = {
pinctrl/qcom/pinctrl-msm8960.c:	{ .compatible = "qcom,msm8960-pinctrl", },
pinctrl/qcom/pinctrl-msm8960.c:static struct platform_driver msm8960_pinctrl_driver = {
pinctrl/qcom/pinctrl-msm8960.c:		.name = "msm8960-pinctrl",
pinctrl/qcom/pinctrl-msm8960.c:		.of_match_table = msm8960_pinctrl_of_match,
pinctrl/qcom/pinctrl-msm8960.c:	.probe = msm8960_pinctrl_probe,
pinctrl/qcom/pinctrl-msm8960.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-msm8960.c:static int __init msm8960_pinctrl_init(void)
pinctrl/qcom/pinctrl-msm8960.c:	return platform_driver_register(&msm8960_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8960.c:arch_initcall(msm8960_pinctrl_init);
pinctrl/qcom/pinctrl-msm8960.c:static void __exit msm8960_pinctrl_exit(void)
pinctrl/qcom/pinctrl-msm8960.c:	platform_driver_unregister(&msm8960_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8960.c:module_exit(msm8960_pinctrl_exit);
pinctrl/qcom/pinctrl-msm8960.c:MODULE_DEVICE_TABLE(of, msm8960_pinctrl_of_match);
pinctrl/qcom/pinctrl-msm8994.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-msm8994.c:static const struct pinctrl_pin_desc msm8994_pins[] = {
pinctrl/qcom/pinctrl-msm8994.c:enum msm8994_functions {
pinctrl/qcom/pinctrl-msm8994.c:static const struct msm_function msm8994_functions[] = {
pinctrl/qcom/pinctrl-msm8994.c:static const struct msm_pingroup msm8994_groups[] = {
pinctrl/qcom/pinctrl-msm8994.c:static const struct msm_pinctrl_soc_data msm8994_pinctrl = {
pinctrl/qcom/pinctrl-msm8994.c:	.pins = msm8994_pins,
pinctrl/qcom/pinctrl-msm8994.c:	.npins = ARRAY_SIZE(msm8994_pins),
pinctrl/qcom/pinctrl-msm8994.c:	.functions = msm8994_functions,
pinctrl/qcom/pinctrl-msm8994.c:	.nfunctions = ARRAY_SIZE(msm8994_functions),
pinctrl/qcom/pinctrl-msm8994.c:	.groups = msm8994_groups,
pinctrl/qcom/pinctrl-msm8994.c:	.ngroups = ARRAY_SIZE(msm8994_groups),
pinctrl/qcom/pinctrl-msm8994.c:static int msm8994_pinctrl_probe(struct platform_device *pdev)
pinctrl/qcom/pinctrl-msm8994.c:	return msm_pinctrl_probe(pdev, &msm8994_pinctrl);
pinctrl/qcom/pinctrl-msm8994.c:static const struct of_device_id msm8994_pinctrl_of_match[] = {
pinctrl/qcom/pinctrl-msm8994.c:	{ .compatible = "qcom,msm8992-pinctrl", },
pinctrl/qcom/pinctrl-msm8994.c:	{ .compatible = "qcom,msm8994-pinctrl", },
pinctrl/qcom/pinctrl-msm8994.c:static struct platform_driver msm8994_pinctrl_driver = {
pinctrl/qcom/pinctrl-msm8994.c:		.name = "msm8994-pinctrl",
pinctrl/qcom/pinctrl-msm8994.c:		.of_match_table = msm8994_pinctrl_of_match,
pinctrl/qcom/pinctrl-msm8994.c:	.probe = msm8994_pinctrl_probe,
pinctrl/qcom/pinctrl-msm8994.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-msm8994.c:static int __init msm8994_pinctrl_init(void)
pinctrl/qcom/pinctrl-msm8994.c:	return platform_driver_register(&msm8994_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8994.c:arch_initcall(msm8994_pinctrl_init);
pinctrl/qcom/pinctrl-msm8994.c:static void __exit msm8994_pinctrl_exit(void)
pinctrl/qcom/pinctrl-msm8994.c:	platform_driver_unregister(&msm8994_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8994.c:module_exit(msm8994_pinctrl_exit);
pinctrl/qcom/pinctrl-msm8994.c:MODULE_DEVICE_TABLE(of, msm8994_pinctrl_of_match);
pinctrl/qcom/pinctrl-msm8996.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-msm8996.c:	[msm_mux_##fname] = {		                \
pinctrl/qcom/pinctrl-msm8996.c:			msm_mux_gpio, /* gpio mode */	\
pinctrl/qcom/pinctrl-msm8996.c:			msm_mux_##f1,			\
pinctrl/qcom/pinctrl-msm8996.c:			msm_mux_##f2,			\
pinctrl/qcom/pinctrl-msm8996.c:			msm_mux_##f3,			\
pinctrl/qcom/pinctrl-msm8996.c:			msm_mux_##f4,			\
pinctrl/qcom/pinctrl-msm8996.c:			msm_mux_##f5,			\
pinctrl/qcom/pinctrl-msm8996.c:			msm_mux_##f6,			\
pinctrl/qcom/pinctrl-msm8996.c:			msm_mux_##f7,			\
pinctrl/qcom/pinctrl-msm8996.c:			msm_mux_##f8,			\
pinctrl/qcom/pinctrl-msm8996.c:			msm_mux_##f9			\
pinctrl/qcom/pinctrl-msm8996.c:static const struct pinctrl_pin_desc msm8996_pins[] = {
pinctrl/qcom/pinctrl-msm8996.c:enum msm8996_functions {
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_adsp_ext,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_bbrx0,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_bbrx1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_char,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_char0,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_char1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_char2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_char3,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_gpsadc0,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_gpsadc1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_tsens,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_tsens2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_usb1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_usb10,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_usb11,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_usb12,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_usb13,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_usb2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_usb20,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_usb21,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_usb22,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_atest_usb23,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_audio_ref,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_bimc_dte0,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_bimc_dte1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp10_spi,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp11_i2c_scl_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp11_i2c_sda_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp11_uart_rx_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp11_uart_tx_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp1_spi,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp2_spi,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_i2c1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_i2c10,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_i2c11,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_i2c12,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_i2c2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_i2c3,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_i2c4,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_i2c5,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_i2c6,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_i2c7,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_i2c8,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_i2c9,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_spi1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_spi10,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_spi11,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_spi12,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_spi2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_spi3,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_spi4,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_spi5,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_spi6,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_spi7,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_spi8,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_spi9,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uart1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uart10,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uart11,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uart12,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uart2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uart3,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uart4,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uart5,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uart6,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uart7,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uart8,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uart9,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uim1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uim10,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uim11,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uim12,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uim2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uim3,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uim4,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uim5,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uim6,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uim7,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uim8,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_blsp_uim9,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_btfm_slimbus,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_cam_mclk,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_cci_async,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_cci_i2c,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_cci_timer0,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_cci_timer1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_cci_timer2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_cci_timer3,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_cci_timer4,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_cri_trng,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_cri_trng0,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_cri_trng1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib0,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib10,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib11,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib12,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib13,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib14,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib15,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib16,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib17,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib18,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib19,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib20,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib21,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib22,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib23,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib24,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib25,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib26,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib3,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib4,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib5,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib6,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib7,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib8,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_calib9,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dac_gpio,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_dbg_out,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_ddr_bist,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_edp_hot,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_edp_lcd,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_gcc_gp1_clk_a,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_gcc_gp1_clk_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_gcc_gp2_clk_a,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_gcc_gp2_clk_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_gcc_gp3_clk_a,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_gcc_gp3_clk_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_gsm_tx,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_hdmi_cec,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_hdmi_ddc,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_hdmi_hot,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_hdmi_rcv,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_isense_dbg,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_ldo_en,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_ldo_update,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_lpass_slimbus,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_m_voc,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_mdp_vsync,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_mdp_vsync_p_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_mdp_vsync_s_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_modem_tsync,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_mss_lte,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_nav_dr,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_nav_pps,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_pa_indicator,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_pci_e0,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_pci_e1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_pci_e2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_pll_bypassnl,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_pll_reset,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_pri_mi2s,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_prng_rosc,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_pwr_crypto,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_pwr_modem,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_pwr_nav,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_cti,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_cti_trig_in_a,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_cti_trig_in_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_cti_trig_out_a,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_cti_trig_out_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm0,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm10,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm11,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm12,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm13,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm14,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm15,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm16,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm17,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm18,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm19,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm20,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm21,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm22,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm23,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm24,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm25,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm26,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm27,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm28,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm29,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm3,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm30,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm31,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm4,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm5,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm6,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm7,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm8,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_stm9,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_traceclk_a,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_traceclk_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_tracectl_a,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_tracectl_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_tracedata_11,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_tracedata_12,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_tracedata_a,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qdss_tracedata_b,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qspi0,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qspi1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qspi2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qspi3,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qspi_clk,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qspi_cs,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_qua_mi2s,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_sd_card,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_sd_write,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_sdc40,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_sdc41,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_sdc42,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_sdc43,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_sdc4_clk,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_sdc4_cmd,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_sec_mi2s,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_spkr_i2s,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_ssbi1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_ssbi2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_ssc_irq,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_ter_mi2s,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_tsense_pwm1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_tsense_pwm2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_tsif1_clk,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_tsif1_data,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_tsif1_en,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_tsif1_error,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_tsif1_sync,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_tsif2_clk,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_tsif2_data,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_tsif2_en,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_tsif2_error,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_tsif2_sync,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_uim1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_uim2,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_uim3,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_uim4,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_uim_batt,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_vfr_1,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_gpio,
pinctrl/qcom/pinctrl-msm8996.c:	msm_mux_NA,
pinctrl/qcom/pinctrl-msm8996.c:static const struct msm_function msm8996_functions[] = {
pinctrl/qcom/pinctrl-msm8996.c:static const struct msm_pingroup msm8996_groups[] = {
pinctrl/qcom/pinctrl-msm8996.c:static const struct msm_pinctrl_soc_data msm8996_pinctrl = {
pinctrl/qcom/pinctrl-msm8996.c:	.pins = msm8996_pins,
pinctrl/qcom/pinctrl-msm8996.c:	.npins = ARRAY_SIZE(msm8996_pins),
pinctrl/qcom/pinctrl-msm8996.c:	.functions = msm8996_functions,
pinctrl/qcom/pinctrl-msm8996.c:	.nfunctions = ARRAY_SIZE(msm8996_functions),
pinctrl/qcom/pinctrl-msm8996.c:	.groups = msm8996_groups,
pinctrl/qcom/pinctrl-msm8996.c:	.ngroups = ARRAY_SIZE(msm8996_groups),
pinctrl/qcom/pinctrl-msm8996.c:static int msm8996_pinctrl_probe(struct platform_device *pdev)
pinctrl/qcom/pinctrl-msm8996.c:	return msm_pinctrl_probe(pdev, &msm8996_pinctrl);
pinctrl/qcom/pinctrl-msm8996.c:static const struct of_device_id msm8996_pinctrl_of_match[] = {
pinctrl/qcom/pinctrl-msm8996.c:	{ .compatible = "qcom,msm8996-pinctrl", },
pinctrl/qcom/pinctrl-msm8996.c:static struct platform_driver msm8996_pinctrl_driver = {
pinctrl/qcom/pinctrl-msm8996.c:		.name = "msm8996-pinctrl",
pinctrl/qcom/pinctrl-msm8996.c:		.of_match_table = msm8996_pinctrl_of_match,
pinctrl/qcom/pinctrl-msm8996.c:	.probe = msm8996_pinctrl_probe,
pinctrl/qcom/pinctrl-msm8996.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-msm8996.c:static int __init msm8996_pinctrl_init(void)
pinctrl/qcom/pinctrl-msm8996.c:	return platform_driver_register(&msm8996_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8996.c:arch_initcall(msm8996_pinctrl_init);
pinctrl/qcom/pinctrl-msm8996.c:static void __exit msm8996_pinctrl_exit(void)
pinctrl/qcom/pinctrl-msm8996.c:	platform_driver_unregister(&msm8996_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8996.c:module_exit(msm8996_pinctrl_exit);
pinctrl/qcom/pinctrl-msm8996.c:MODULE_DESCRIPTION("Qualcomm msm8996 pinctrl driver");
pinctrl/qcom/pinctrl-msm8996.c:MODULE_DEVICE_TABLE(of, msm8996_pinctrl_of_match);
pinctrl/qcom/pinctrl-msm8998.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-msm8998.c:	[msm_mux_##fname] = {				\
pinctrl/qcom/pinctrl-msm8998.c:			msm_mux_gpio, /* gpio mode */	\
pinctrl/qcom/pinctrl-msm8998.c:			msm_mux_##f1,			\
pinctrl/qcom/pinctrl-msm8998.c:			msm_mux_##f2,			\
pinctrl/qcom/pinctrl-msm8998.c:			msm_mux_##f3,			\
pinctrl/qcom/pinctrl-msm8998.c:			msm_mux_##f4,			\
pinctrl/qcom/pinctrl-msm8998.c:			msm_mux_##f5,			\
pinctrl/qcom/pinctrl-msm8998.c:			msm_mux_##f6,			\
pinctrl/qcom/pinctrl-msm8998.c:			msm_mux_##f7,			\
pinctrl/qcom/pinctrl-msm8998.c:			msm_mux_##f8,			\
pinctrl/qcom/pinctrl-msm8998.c:			msm_mux_##f9			\
pinctrl/qcom/pinctrl-msm8998.c:static const struct pinctrl_pin_desc msm8998_pins[] = {
pinctrl/qcom/pinctrl-msm8998.c:enum msm8998_functions {
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_adsp_ext,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_agera_pll,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_atest_char,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_atest_gpsadc0,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_atest_gpsadc1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_atest_tsens,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_atest_tsens2,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_atest_usb1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_atest_usb10,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_atest_usb11,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_atest_usb12,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_atest_usb13,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_audio_ref,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_bimc_dte0,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_bimc_dte1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp10_spi,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp10_spi_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp10_spi_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp11_i2c,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp1_spi,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp1_spi_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp1_spi_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp2_spi,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp9_spi,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_i2c1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_i2c10,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_i2c11,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_i2c12,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_i2c2,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_i2c3,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_i2c4,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_i2c5,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_i2c6,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_i2c7,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_i2c8,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_i2c9,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_spi1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_spi10,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_spi11,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_spi12,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_spi2,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_spi3,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_spi4,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_spi5,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_spi6,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_spi7,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_spi8,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_spi9,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uart1_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uart1_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uart2_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uart2_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uart3_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uart3_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uart7_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uart7_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uart8,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uart8_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uart8_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uart9_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uart9_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uim1_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uim1_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uim2_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uim2_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uim3_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uim3_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uim7_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uim7_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uim8_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uim8_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uim9_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_blsp_uim9_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_bt_reset,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_btfm_slimbus,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_cam_mclk,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_cci_async,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_cci_i2c,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_cci_timer0,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_cci_timer1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_cci_timer2,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_cci_timer3,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_cci_timer4,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_cri_trng,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_cri_trng0,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_cri_trng1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_dbg_out,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_ddr_bist,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_edp_hot,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_edp_lcd,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_gcc_gp1_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_gcc_gp1_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_gcc_gp2_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_gcc_gp2_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_gcc_gp3_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_gcc_gp3_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_gpio,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_hdmi_cec,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_hdmi_ddc,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_hdmi_hot,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_hdmi_rcv,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_isense_dbg,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_jitter_bist,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_ldo_en,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_ldo_update,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_lpass_slimbus,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_m_voc,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_mdp_vsync,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_mdp_vsync0,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_mdp_vsync1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_mdp_vsync2,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_mdp_vsync3,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_mdp_vsync_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_mdp_vsync_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_modem_tsync,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_mss_lte,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_nav_dr,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_nav_pps,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_pa_indicator,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_pci_e0,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_phase_flag,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_pll_bypassnl,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_pll_reset,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_pri_mi2s,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_pri_mi2s_ws,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_prng_rosc,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_pwr_crypto,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_pwr_modem,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_pwr_nav,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_qdss_cti0_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_qdss_cti0_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_qdss_cti1_a,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_qdss_cti1_b,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_qdss,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_qlink_enable,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_qlink_request,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_qua_mi2s,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_sd_card,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_sd_write,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_sdc40,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_sdc41,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_sdc42,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_sdc43,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_sdc4_clk,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_sdc4_cmd,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_sec_mi2s,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_sp_cmu,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_spkr_i2s,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_ssbi1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_ssc_irq,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_ter_mi2s,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tgu_ch0,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tgu_ch1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tsense_pwm1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tsense_pwm2,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tsif1_clk,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tsif1_data,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tsif1_en,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tsif1_error,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tsif1_sync,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tsif2_clk,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tsif2_data,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tsif2_en,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tsif2_error,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_tsif2_sync,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_uim1_clk,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_uim1_data,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_uim1_present,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_uim1_reset,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_uim2_clk,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_uim2_data,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_uim2_present,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_uim2_reset,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_uim_batt,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_usb_phy,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_vfr_1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_vsense_clkout,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_vsense_data0,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_vsense_data1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_vsense_mode,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_wlan1_adc0,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_wlan1_adc1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_wlan2_adc0,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux_wlan2_adc1,
pinctrl/qcom/pinctrl-msm8998.c:	msm_mux__,
pinctrl/qcom/pinctrl-msm8998.c:static const struct msm_function msm8998_functions[] = {
pinctrl/qcom/pinctrl-msm8998.c:static const struct msm_pingroup msm8998_groups[] = {
pinctrl/qcom/pinctrl-msm8998.c:static const struct msm_pinctrl_soc_data msm8998_pinctrl = {
pinctrl/qcom/pinctrl-msm8998.c:	.pins = msm8998_pins,
pinctrl/qcom/pinctrl-msm8998.c:	.npins = ARRAY_SIZE(msm8998_pins),
pinctrl/qcom/pinctrl-msm8998.c:	.functions = msm8998_functions,
pinctrl/qcom/pinctrl-msm8998.c:	.nfunctions = ARRAY_SIZE(msm8998_functions),
pinctrl/qcom/pinctrl-msm8998.c:	.groups = msm8998_groups,
pinctrl/qcom/pinctrl-msm8998.c:	.ngroups = ARRAY_SIZE(msm8998_groups),
pinctrl/qcom/pinctrl-msm8998.c:static int msm8998_pinctrl_probe(struct platform_device *pdev)
pinctrl/qcom/pinctrl-msm8998.c:	return msm_pinctrl_probe(pdev, &msm8998_pinctrl);
pinctrl/qcom/pinctrl-msm8998.c:static const struct of_device_id msm8998_pinctrl_of_match[] = {
pinctrl/qcom/pinctrl-msm8998.c:	{ .compatible = "qcom,msm8998-pinctrl", },
pinctrl/qcom/pinctrl-msm8998.c:static struct platform_driver msm8998_pinctrl_driver = {
pinctrl/qcom/pinctrl-msm8998.c:		.name = "msm8998-pinctrl",
pinctrl/qcom/pinctrl-msm8998.c:		.of_match_table = msm8998_pinctrl_of_match,
pinctrl/qcom/pinctrl-msm8998.c:	.probe = msm8998_pinctrl_probe,
pinctrl/qcom/pinctrl-msm8998.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-msm8998.c:static int __init msm8998_pinctrl_init(void)
pinctrl/qcom/pinctrl-msm8998.c:	return platform_driver_register(&msm8998_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8998.c:arch_initcall(msm8998_pinctrl_init);
pinctrl/qcom/pinctrl-msm8998.c:static void __exit msm8998_pinctrl_exit(void)
pinctrl/qcom/pinctrl-msm8998.c:	platform_driver_unregister(&msm8998_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8998.c:module_exit(msm8998_pinctrl_exit);
pinctrl/qcom/pinctrl-msm8998.c:MODULE_DESCRIPTION("QTI msm8998 pinctrl driver");
pinctrl/qcom/pinctrl-msm8998.c:MODULE_DEVICE_TABLE(of, msm8998_pinctrl_of_match);
pinctrl/qcom/pinctrl-msm8x74.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-msm8x74.c:static const struct pinctrl_pin_desc msm8x74_pins[] = {
pinctrl/qcom/pinctrl-msm8x74.c:enum msm8x74_functions {
pinctrl/qcom/pinctrl-msm8x74.c:static const struct msm_function msm8x74_functions[] = {
pinctrl/qcom/pinctrl-msm8x74.c:static const struct msm_pingroup msm8x74_groups[] = {
pinctrl/qcom/pinctrl-msm8x74.c:static const struct msm_pinctrl_soc_data msm8x74_pinctrl = {
pinctrl/qcom/pinctrl-msm8x74.c:	.pins = msm8x74_pins,
pinctrl/qcom/pinctrl-msm8x74.c:	.npins = ARRAY_SIZE(msm8x74_pins),
pinctrl/qcom/pinctrl-msm8x74.c:	.functions = msm8x74_functions,
pinctrl/qcom/pinctrl-msm8x74.c:	.nfunctions = ARRAY_SIZE(msm8x74_functions),
pinctrl/qcom/pinctrl-msm8x74.c:	.groups = msm8x74_groups,
pinctrl/qcom/pinctrl-msm8x74.c:	.ngroups = ARRAY_SIZE(msm8x74_groups),
pinctrl/qcom/pinctrl-msm8x74.c:static int msm8x74_pinctrl_probe(struct platform_device *pdev)
pinctrl/qcom/pinctrl-msm8x74.c:	return msm_pinctrl_probe(pdev, &msm8x74_pinctrl);
pinctrl/qcom/pinctrl-msm8x74.c:static const struct of_device_id msm8x74_pinctrl_of_match[] = {
pinctrl/qcom/pinctrl-msm8x74.c:	{ .compatible = "qcom,msm8974-pinctrl", },
pinctrl/qcom/pinctrl-msm8x74.c:static struct platform_driver msm8x74_pinctrl_driver = {
pinctrl/qcom/pinctrl-msm8x74.c:		.name = "msm8x74-pinctrl",
pinctrl/qcom/pinctrl-msm8x74.c:		.of_match_table = msm8x74_pinctrl_of_match,
pinctrl/qcom/pinctrl-msm8x74.c:	.probe = msm8x74_pinctrl_probe,
pinctrl/qcom/pinctrl-msm8x74.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-msm8x74.c:static int __init msm8x74_pinctrl_init(void)
pinctrl/qcom/pinctrl-msm8x74.c:	return platform_driver_register(&msm8x74_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8x74.c:arch_initcall(msm8x74_pinctrl_init);
pinctrl/qcom/pinctrl-msm8x74.c:static void __exit msm8x74_pinctrl_exit(void)
pinctrl/qcom/pinctrl-msm8x74.c:	platform_driver_unregister(&msm8x74_pinctrl_driver);
pinctrl/qcom/pinctrl-msm8x74.c:module_exit(msm8x74_pinctrl_exit);
pinctrl/qcom/pinctrl-msm8x74.c:MODULE_DEVICE_TABLE(of, msm8x74_pinctrl_of_match);
pinctrl/qcom/pinctrl-qdf2xxx.c: * device.  The driver which controls this device is pinctrl-msm.c.  Each
pinctrl/qcom/pinctrl-qdf2xxx.c: * with pinctrl-msm.c.  This means that all TLMM drivers are pin control
pinctrl/qcom/pinctrl-qdf2xxx.c: * pinctrl-msm.c into another driver.
pinctrl/qcom/pinctrl-qdf2xxx.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-qdf2xxx.c:	struct msm_pinctrl_soc_data *pinctrl;
pinctrl/qcom/pinctrl-qdf2xxx.c:	struct msm_pingroup *groups;
pinctrl/qcom/pinctrl-qdf2xxx.c:		sizeof(struct msm_pingroup), GFP_KERNEL);
pinctrl/qcom/pinctrl-qdf2xxx.c:	return msm_pinctrl_probe(pdev, pinctrl);
pinctrl/qcom/pinctrl-qdf2xxx.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-scuba.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-scuba.c:	[msm_mux_##fname] = {		                \
pinctrl/qcom/pinctrl-scuba.c:			msm_mux_gpio, /* gpio mode */	\
pinctrl/qcom/pinctrl-scuba.c:			msm_mux_##f1,			\
pinctrl/qcom/pinctrl-scuba.c:			msm_mux_##f2,			\
pinctrl/qcom/pinctrl-scuba.c:			msm_mux_##f3,			\
pinctrl/qcom/pinctrl-scuba.c:			msm_mux_##f4,			\
pinctrl/qcom/pinctrl-scuba.c:			msm_mux_##f5,			\
pinctrl/qcom/pinctrl-scuba.c:			msm_mux_##f6,			\
pinctrl/qcom/pinctrl-scuba.c:			msm_mux_##f7,			\
pinctrl/qcom/pinctrl-scuba.c:			msm_mux_##f8,			\
pinctrl/qcom/pinctrl-scuba.c:			msm_mux_##f9			\
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qup0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_gpio,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_ddr_bist,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio8,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_tsens,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_mpm_pwr,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_m_voc,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio9,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_tsens2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio10,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_usb10,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag3,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio11,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_usb11,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qup1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_CRI_TRNG0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag4,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_usb12,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_CRI_TRNG1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag5,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib3,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_usb13,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qup2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag6,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib4,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_usb1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qup3,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs_out,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_PLL_BIST,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_tsense_pwm,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_AGERA_PLL,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qup4,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_tgu_ch0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_tgu_ch1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qup5,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_tgu_ch2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag7,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio4,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib5,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_tgu_ch3,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag8,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio5,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib6,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag9,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio6,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib7,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag10,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio7,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib8,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_SDC2_TB,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_CRI_TRNG,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pwm_0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_SDC1_TB,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs3,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio3,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_cam_mclk,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs4,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_adsp_ext,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs5,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_cci_i2c,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_prng_rosc,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs6,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag11,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib9,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_usb20,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs7,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag12,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib10,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_usb21,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_CCI_TIMER1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_GCC_GP1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs8,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag13,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib11,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_usb22,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_cci_async,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_CCI_TIMER0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs9,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag14,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib12,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_usb23,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs10,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag15,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib13,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_usb2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_vsense_trigger,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_cti,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_CCI_TIMER2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pwm_1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag16,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib14,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_char,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag17,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib15,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_char0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_GP_PDM0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag18,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib16,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_char1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_CCI_TIMER3,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_GP_PDM1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag19,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib17,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_char2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_GP_PDM2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag20,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib18,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_char3,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag21,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag22,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_char_exec,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_NAV_GPIO,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag23,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag24,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag25,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs14,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio14,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_vfr_1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs15,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio15,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_PA_INDICATOR,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pwm_2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_gsm1_tx,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_SSBI_WTR1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pll_bypassnl,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pll_reset,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag26,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_ddr_pxi0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_gsm0_tx,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag27,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_GCC_GP2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio12,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_ddr_pxi1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_GCC_GP3,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_qdss_gpio13,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dbg_out,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_uim2_data,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pwm_3,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_uim2_clk,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_uim2_reset,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pwm_4,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_uim2_present,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pwm_5,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_uim1_data,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_uim1_clk,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_uim1_reset,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_uim1_present,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib19,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_mdp_vsync,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_mdp_vsync_out_0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_mdp_vsync_out_1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib20,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib21,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pwm_6,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_bbrx1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs11,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_usb_phy,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_bbrx0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pwm_7,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_mss_lte,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs12,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pbs13,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_wlan1_adc0,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_wlan1_adc1,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_sd_write,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_JITTER_BIST,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_gpsadc_dtest0_native,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_atest_gpsadc_dtest1_native,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag28,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib22,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_ddr_pxi2,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag29,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib23,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag30,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib24,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_ddr_pxi3,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pwm_8,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_phase_flag31,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_dac_calib25,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_pwm_9,
pinctrl/qcom/pinctrl-scuba.c:	msm_mux_NA,
pinctrl/qcom/pinctrl-scuba.c:static const struct msm_function scuba_functions[] = {
pinctrl/qcom/pinctrl-scuba.c:static const struct msm_pingroup scuba_groups[] = {
pinctrl/qcom/pinctrl-scuba.c:static const struct msm_pinctrl_soc_data scuba_pinctrl = {
pinctrl/qcom/pinctrl-scuba.c:	return msm_pinctrl_probe(pdev, &scuba_pinctrl);
pinctrl/qcom/pinctrl-scuba.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-sdm660.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-sdm660.c:	[msm_mux_##fname] = {		                \
pinctrl/qcom/pinctrl-sdm660.c:			msm_mux_gpio, /* gpio mode */	\
pinctrl/qcom/pinctrl-sdm660.c:			msm_mux_##f1,			\
pinctrl/qcom/pinctrl-sdm660.c:			msm_mux_##f2,			\
pinctrl/qcom/pinctrl-sdm660.c:			msm_mux_##f3,			\
pinctrl/qcom/pinctrl-sdm660.c:			msm_mux_##f4,			\
pinctrl/qcom/pinctrl-sdm660.c:			msm_mux_##f5,			\
pinctrl/qcom/pinctrl-sdm660.c:			msm_mux_##f6,			\
pinctrl/qcom/pinctrl-sdm660.c:			msm_mux_##f7,			\
pinctrl/qcom/pinctrl-sdm660.c:			msm_mux_##f8,			\
pinctrl/qcom/pinctrl-sdm660.c:			msm_mux_##f9			\
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_spi1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_gpio,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_uim1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_tgu_ch0,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio4,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_gpsadc1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_uart1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_SMB_STAT,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag14,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_i2c2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag31,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_spi3,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_spi3_cs1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_spi3_cs2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_wlan1_adc1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_usb13,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_tgu_ch1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio5,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_gpsadc0,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_i2c1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_ddr_bist,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_tsens2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_usb1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_spi2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_uim2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag3,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_bimc_dte1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_wlan1_adc0,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_usb12,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_bimc_dte0,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_i2c3,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_wlan2_adc1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_usb11,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_dbg_out,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_wlan2_adc0,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_usb10,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_RCM_MARKER,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_spi4,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_pri_mi2s,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag26,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_cti0_a,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_cti0_b,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_cti1_a,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_cti1_b,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_DP_HOT,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_pri_mi2s_ws,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag27,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_i2c4,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag28,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_uart5,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_spi5,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_uim5,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag5,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_i2c5,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_spi6,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_uart2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_uim6,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag11,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_vsense_data0,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_i2c6,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag12,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_vsense_data1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag13,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_vsense_mode,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_spi7,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_uart6_a,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_uart6_b,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_sec_mi2s,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_sndwire_clk,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag17,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_vsense_clkout,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_sndwire_data,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag18,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_WSA_SPKR,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_i2c7,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag19,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_vfr_1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag20,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_NFC_INT,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_spi8_cs1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_spi8_cs2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_m_voc,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag21,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_NFC_EN,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag22,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_NFC_DWL,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_i2c8_a,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_i2c8_b,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag23,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_NFC_ESE,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_pwr_modem,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag24,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_cam_mclk,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_pwr_nav,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio0,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qspi_data0,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_pwr_crypto,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qspi_data1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_agera_pll,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qspi_data2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_jitter_bist,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio3,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio7,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_FL_R3LED,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CCI_TIMER0,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_FL_STROBE,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CCI_TIMER1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CAM_LDO1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_mdss_vsync0,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_mdss_vsync1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_mdss_vsync2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_mdss_vsync3,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio9,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CAM_IRQ,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_usb2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_cci_i2c,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_pll_bypassnl,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_tsens,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_usb21,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_pll_reset,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_usb23,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio6,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CCI_TIMER3,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CCI_ASYNC,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qspi_cs,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio10,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CAM3_STANDBY,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CCI_TIMER4,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio11,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CAM_LDO2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_cci_async,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio12,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CAM0_RST,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio13,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CAM1_RST,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qspi_clk,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag30,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio14,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qspi_resetn,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio15,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CAM0_STANDBY,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CAM1_STANDBY,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag9,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CAM2_STANDBY,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qspi_data3,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag15,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qdss_gpio8,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CAM3_RST,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_CCI_TIMER2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag16,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_LCD0_RESET,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag6,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_SD_CARD,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag29,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_DP_EN,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag25,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_USBC_ORIENTATION,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag10,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_usb20,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_gcc_gp1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag4,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_usb22,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_USB_PHY,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_gcc_gp2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_char,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_mdp_vsync,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_gcc_gp3,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_char3,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_FORCE_TOUCH,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_cri_trng0,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_char2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_cri_trng1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_char1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_AUDIO_USBC,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_audio_ref,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_MDP_VSYNC,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_cri_trng,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_atest_char0,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_US_EURO,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_LCD_BACKLIGHT,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_spi8_a,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_blsp_spi8_b,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_sp_cmu,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_nav_pps_a,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_nav_pps_b,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_nav_pps_c,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_gps_tx_a,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_gps_tx_b,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_gps_tx_c,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_adsp_ext,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_TS_RESET,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_ssc_irq,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_isense_dbg,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag0,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag7,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_phase_flag8,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_tsense_pwm1,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_tsense_pwm2,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_SENSOR_RST,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_WMSS_RESETN,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_HAPTICS_PWM,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_GPS_eLNA,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_mss_lte,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_uim2_data,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_uim2_clk,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_uim2_reset,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_uim2_present,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_uim1_data,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_uim1_clk,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_uim1_reset,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_uim1_present,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_uim_batt,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_pa_indicator,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_ldo_en,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_ldo_update,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qlink_request,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_qlink_enable,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_prng_rosc,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_LCD_PWR,
pinctrl/qcom/pinctrl-sdm660.c:	msm_mux_NA,
pinctrl/qcom/pinctrl-sdm660.c:static const struct msm_function sdm660_functions[] = {
pinctrl/qcom/pinctrl-sdm660.c:static const struct msm_pingroup sdm660_groups[] = {
pinctrl/qcom/pinctrl-sdm660.c:static const struct msm_pinctrl_soc_data sdm660_pinctrl = {
pinctrl/qcom/pinctrl-sdm660.c:	return msm_pinctrl_probe(pdev, &sdm660_pinctrl);
pinctrl/qcom/pinctrl-sdm660.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-sdm845.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-sdm845.c:	[msm_mux_##fname] = {				\
pinctrl/qcom/pinctrl-sdm845.c:			msm_mux_gpio, /* gpio mode */	\
pinctrl/qcom/pinctrl-sdm845.c:			msm_mux_##f1,			\
pinctrl/qcom/pinctrl-sdm845.c:			msm_mux_##f2,			\
pinctrl/qcom/pinctrl-sdm845.c:			msm_mux_##f3,			\
pinctrl/qcom/pinctrl-sdm845.c:			msm_mux_##f4,			\
pinctrl/qcom/pinctrl-sdm845.c:			msm_mux_##f5,			\
pinctrl/qcom/pinctrl-sdm845.c:			msm_mux_##f6,			\
pinctrl/qcom/pinctrl-sdm845.c:			msm_mux_##f7,			\
pinctrl/qcom/pinctrl-sdm845.c:			msm_mux_##f8,			\
pinctrl/qcom/pinctrl-sdm845.c:			msm_mux_##f9,			\
pinctrl/qcom/pinctrl-sdm845.c:			msm_mux_##f10			\
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_gpio,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_adsp_ext,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_agera_pll,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_atest_char,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_atest_tsens,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_atest_tsens2,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_atest_usb1,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_atest_usb10,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_atest_usb11,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_atest_usb12,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_atest_usb13,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_atest_usb2,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_atest_usb20,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_atest_usb21,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_atest_usb22,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_atest_usb23,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_audio_ref,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_btfm_slimbus,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_cam_mclk,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_cci_async,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_cci_i2c,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_cci_timer0,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_cci_timer1,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_cci_timer2,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_cci_timer3,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_cci_timer4,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_cri_trng,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_cri_trng0,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_cri_trng1,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_dbg_out,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_ddr_bist,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_ddr_pxi0,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_ddr_pxi1,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_ddr_pxi2,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_ddr_pxi3,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_edp_hot,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_edp_lcd,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_gcc_gp1,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_gcc_gp2,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_gcc_gp3,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_jitter_bist,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_ldo_en,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_ldo_update,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_lpass_slimbus,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_m_voc,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_mdp_vsync,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_mdp_vsync0,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_mdp_vsync1,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_mdp_vsync2,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_mdp_vsync3,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_mss_lte,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_nav_pps,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_pa_indicator,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_pci_e0,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_pci_e1,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_phase_flag,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_pll_bist,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_pll_bypassnl,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_pll_reset,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_pri_mi2s,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_pri_mi2s_ws,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_prng_rosc,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qdss_cti,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qdss,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qlink_enable,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qlink_request,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qspi_clk,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qspi_cs,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qspi_data,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qua_mi2s,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup0,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup1,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup10,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup11,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup12,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup13,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup14,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup15,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup2,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup3,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup4,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup5,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup6,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup7,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup8,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup9,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup_l4,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup_l5,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_qup_l6,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_sd_write,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_sdc4_clk,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_sdc4_cmd,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_sdc4_data,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_sec_mi2s,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_sp_cmu,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_spkr_i2s,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_ter_mi2s,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tgu_ch0,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tgu_ch1,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tgu_ch2,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tgu_ch3,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tsense_pwm1,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tsense_pwm2,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tsif1_clk,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tsif1_data,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tsif1_en,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tsif1_error,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tsif1_sync,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tsif2_clk,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tsif2_data,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tsif2_en,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tsif2_error,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_tsif2_sync,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_uim1_clk,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_uim1_data,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_uim1_present,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_uim1_reset,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_uim2_clk,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_uim2_data,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_uim2_present,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_uim2_reset,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_uim_batt,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_usb_phy,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_vfr_1,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_vsense_trigger,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_wlan1_adc0,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_wlan1_adc1,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_wlan2_adc0,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux_wlan2_adc1,
pinctrl/qcom/pinctrl-sdm845.c:	msm_mux__,
pinctrl/qcom/pinctrl-sdm845.c:static const struct msm_function sdm845_functions[] = {
pinctrl/qcom/pinctrl-sdm845.c:static const struct msm_pingroup sdm845_groups[] = {
pinctrl/qcom/pinctrl-sdm845.c:static const struct msm_pinctrl_soc_data sdm845_pinctrl = {
pinctrl/qcom/pinctrl-sdm845.c:	return msm_pinctrl_probe(pdev, &sdm845_pinctrl);
pinctrl/qcom/pinctrl-sdm845.c:	.remove = msm_pinctrl_remove,
pinctrl/qcom/pinctrl-msm.c:#include "pinctrl-msm.h"
pinctrl/qcom/pinctrl-msm.c: * struct msm_pinctrl - state for a pinctrl-msm device
pinctrl/qcom/pinctrl-msm.c: *                  as msm_pinctrl data structures.
pinctrl/qcom/pinctrl-msm.c:struct msm_pinctrl {
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pinctrl_soc_data *soc;
pinctrl/qcom/pinctrl-msm.c:static struct msm_pinctrl *msm_pinctrl_data;
pinctrl/qcom/pinctrl-msm.c:static int msm_get_groups_count(struct pinctrl_dev *pctldev)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
pinctrl/qcom/pinctrl-msm.c:static const char *msm_get_group_name(struct pinctrl_dev *pctldev,
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
pinctrl/qcom/pinctrl-msm.c:static int msm_get_group_pins(struct pinctrl_dev *pctldev,
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
pinctrl/qcom/pinctrl-msm.c:static const struct pinctrl_ops msm_pinctrl_ops = {
pinctrl/qcom/pinctrl-msm.c:	.get_groups_count	= msm_get_groups_count,
pinctrl/qcom/pinctrl-msm.c:	.get_group_name		= msm_get_group_name,
pinctrl/qcom/pinctrl-msm.c:	.get_group_pins		= msm_get_group_pins,
pinctrl/qcom/pinctrl-msm.c:static int msm_pinmux_request(struct pinctrl_dev *pctldev, unsigned offset)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
pinctrl/qcom/pinctrl-msm.c:static int msm_get_functions_count(struct pinctrl_dev *pctldev)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
pinctrl/qcom/pinctrl-msm.c:static const char *msm_get_function_name(struct pinctrl_dev *pctldev,
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
pinctrl/qcom/pinctrl-msm.c:static int msm_get_function_groups(struct pinctrl_dev *pctldev,
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
pinctrl/qcom/pinctrl-msm.c:static int msm_pinmux_set_mux(struct pinctrl_dev *pctldev,
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:static const struct pinmux_ops msm_pinmux_ops = {
pinctrl/qcom/pinctrl-msm.c:	.request		= msm_pinmux_request,
pinctrl/qcom/pinctrl-msm.c:	.get_functions_count	= msm_get_functions_count,
pinctrl/qcom/pinctrl-msm.c:	.get_function_name	= msm_get_function_name,
pinctrl/qcom/pinctrl-msm.c:	.get_function_groups	= msm_get_function_groups,
pinctrl/qcom/pinctrl-msm.c:	.set_mux		= msm_pinmux_set_mux,
pinctrl/qcom/pinctrl-msm.c:static int msm_config_reg(struct msm_pinctrl *pctrl,
pinctrl/qcom/pinctrl-msm.c:			  const struct msm_pingroup *g,
pinctrl/qcom/pinctrl-msm.c:static unsigned msm_regval_to_drive(u32 val)
pinctrl/qcom/pinctrl-msm.c:static int msm_config_group_get(struct pinctrl_dev *pctldev,
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
pinctrl/qcom/pinctrl-msm.c:	ret = msm_config_reg(pctrl, g, param, &mask, &bit);
pinctrl/qcom/pinctrl-msm.c:		arg = msm_regval_to_drive(arg);
pinctrl/qcom/pinctrl-msm.c:static int msm_config_group_set(struct pinctrl_dev *pctldev,
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
pinctrl/qcom/pinctrl-msm.c:		ret = msm_config_reg(pctrl, g, param, &mask, &bit);
pinctrl/qcom/pinctrl-msm.c:static const struct pinconf_ops msm_pinconf_ops = {
pinctrl/qcom/pinctrl-msm.c:	.pin_config_group_get	= msm_config_group_get,
pinctrl/qcom/pinctrl-msm.c:	.pin_config_group_set	= msm_config_group_set,
pinctrl/qcom/pinctrl-msm.c:static int msm_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(chip);
pinctrl/qcom/pinctrl-msm.c:static int msm_gpio_direction_output(struct gpio_chip *chip, unsigned offset, int value)
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(chip);
pinctrl/qcom/pinctrl-msm.c:static int msm_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(chip);
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:static int msm_gpio_get(struct gpio_chip *chip, unsigned offset)
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(chip);
pinctrl/qcom/pinctrl-msm.c:void __iomem *msm_gpio_regadd_get(unsigned offset)
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(&msm_pinctrl_data->chip);
pinctrl/qcom/pinctrl-msm.c:EXPORT_SYMBOL(msm_gpio_regadd_get);
pinctrl/qcom/pinctrl-msm.c:static void msm_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(chip);
pinctrl/qcom/pinctrl-msm.c:static void msm_gpio_dbg_show_one(struct seq_file *s,
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(chip);
pinctrl/qcom/pinctrl-msm.c:	seq_printf(s, " %dmA", msm_regval_to_drive(drive));
pinctrl/qcom/pinctrl-msm.c:static void msm_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
pinctrl/qcom/pinctrl-msm.c:		msm_gpio_dbg_show_one(s, NULL, chip, i, gpio);
pinctrl/qcom/pinctrl-msm.c:#define msm_gpio_dbg_show NULL
pinctrl/qcom/pinctrl-msm.c:static const struct gpio_chip msm_gpio_template = {
pinctrl/qcom/pinctrl-msm.c:	.direction_input  = msm_gpio_direction_input,
pinctrl/qcom/pinctrl-msm.c:	.direction_output = msm_gpio_direction_output,
pinctrl/qcom/pinctrl-msm.c:	.get_direction    = msm_gpio_get_direction,
pinctrl/qcom/pinctrl-msm.c:	.get              = msm_gpio_get,
pinctrl/qcom/pinctrl-msm.c:	.set              = msm_gpio_set,
pinctrl/qcom/pinctrl-msm.c:	.dbg_show         = msm_gpio_dbg_show,
pinctrl/qcom/pinctrl-msm.c: * Algorithm comes from Google's msmgpio driver.
pinctrl/qcom/pinctrl-msm.c:static void msm_gpio_update_dual_edge_pos(struct msm_pinctrl *pctrl,
pinctrl/qcom/pinctrl-msm.c:					  const struct msm_pingroup *g,
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:	struct msm_dir_conn *dc;
pinctrl/qcom/pinctrl-msm.c:static void _msm_gpio_irq_mask(struct irq_data *d)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:static void _msm_gpio_irq_unmask(struct irq_data *d, bool status_clear)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:static void msm_gpio_irq_mask(struct irq_data *d)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:	_msm_gpio_irq_mask(d);
pinctrl/qcom/pinctrl-msm.c:static void msm_gpio_irq_unmask(struct irq_data *d)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:	_msm_gpio_irq_unmask(d, false);
pinctrl/qcom/pinctrl-msm.c:static void msm_gpio_irq_disable(struct irq_data *d)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:	_msm_gpio_irq_mask(d);
pinctrl/qcom/pinctrl-msm.c:static void msm_gpio_irq_enable(struct irq_data *d)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:	_msm_gpio_irq_unmask(d, true);
pinctrl/qcom/pinctrl-msm.c:static void msm_gpio_irq_ack(struct irq_data *d)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:		msm_gpio_update_dual_edge_pos(pctrl, g, d);
pinctrl/qcom/pinctrl-msm.c:static void msm_dirconn_cfg_reg(struct irq_data *d, u32 offset)
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:static void msm_dirconn_uncfg_reg(struct irq_data *d, u32 offset)
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:	struct msm_dir_conn *dc = NULL;
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:static void msm_gpio_dirconn_handler(struct irq_desc *desc)
pinctrl/qcom/pinctrl-msm.c:static void add_dirconn_tlmm(struct irq_data *d, struct msm_pinctrl *pctrl)
pinctrl/qcom/pinctrl-msm.c:	msm_dirconn_cfg_reg(d, offset);
pinctrl/qcom/pinctrl-msm.c:	msm_dirconn_uncfg_reg(d, offset);
pinctrl/qcom/pinctrl-msm.c:static int msm_gpio_irq_set_type(struct irq_data *d, unsigned int type)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:		msm_gpio_update_dual_edge_pos(pctrl, g, d);
pinctrl/qcom/pinctrl-msm.c:static int msm_gpio_irq_set_wake(struct irq_data *d, unsigned int on)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:static int msm_gpio_irq_set_affinity(struct irq_data *d,
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:static int msm_gpio_irq_set_vcpu_affinity(struct irq_data *d, void *vcpu_info)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:static void msm_gpio_irq_handler(struct irq_desc *desc)
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:static int msm_gpio_init_valid_mask(struct gpio_chip *chip,
pinctrl/qcom/pinctrl-msm.c:				    struct msm_pinctrl *pctrl)
pinctrl/qcom/pinctrl-msm.c:static bool msm_gpio_needs_valid_mask(struct msm_pinctrl *pctrl)
pinctrl/qcom/pinctrl-msm.c:static int msm_gpio_domain_translate(struct irq_domain *d,
pinctrl/qcom/pinctrl-msm.c:static int msm_gpio_domain_alloc(struct irq_domain *domain, unsigned int virq,
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
pinctrl/qcom/pinctrl-msm.c:	ret = msm_gpio_domain_translate(domain, fwspec, &hwirq, &type);
pinctrl/qcom/pinctrl-msm.c:static int msm_gpio_to_irq(struct gpio_chip *chip, unsigned int offset)
pinctrl/qcom/pinctrl-msm.c:static const struct irq_domain_ops msm_gpio_domain_ops = {
pinctrl/qcom/pinctrl-msm.c:	.translate = msm_gpio_domain_translate,
pinctrl/qcom/pinctrl-msm.c:	.alloc     = msm_gpio_domain_alloc,
pinctrl/qcom/pinctrl-msm.c:static int msm_gpio_init(struct msm_pinctrl *pctrl)
pinctrl/qcom/pinctrl-msm.c:	chip->need_valid_mask = msm_gpio_needs_valid_mask(pctrl);
pinctrl/qcom/pinctrl-msm.c:	pctrl->irq_chip.name = "msmgpio";
pinctrl/qcom/pinctrl-msm.c:	pctrl->irq_chip.irq_enable = msm_gpio_irq_enable;
pinctrl/qcom/pinctrl-msm.c:	pctrl->irq_chip.irq_disable = msm_gpio_irq_disable;
pinctrl/qcom/pinctrl-msm.c:	pctrl->irq_chip.irq_mask = msm_gpio_irq_mask;
pinctrl/qcom/pinctrl-msm.c:	pctrl->irq_chip.irq_unmask = msm_gpio_irq_unmask;
pinctrl/qcom/pinctrl-msm.c:	pctrl->irq_chip.irq_ack = msm_gpio_irq_ack;
pinctrl/qcom/pinctrl-msm.c:	pctrl->irq_chip.irq_set_type = msm_gpio_irq_set_type;
pinctrl/qcom/pinctrl-msm.c:	pctrl->irq_chip.irq_set_wake = msm_gpio_irq_set_wake;
pinctrl/qcom/pinctrl-msm.c:	pctrl->irq_chip.irq_set_affinity = msm_gpio_irq_set_affinity;
pinctrl/qcom/pinctrl-msm.c:	pctrl->irq_chip.irq_set_vcpu_affinity = msm_gpio_irq_set_vcpu_affinity;
pinctrl/qcom/pinctrl-msm.c:		chip->to_irq = msm_gpio_to_irq;
pinctrl/qcom/pinctrl-msm.c:		chip->irq.domain_ops = &msm_gpio_domain_ops;
pinctrl/qcom/pinctrl-msm.c:	ret = msm_gpio_init_valid_mask(chip, pctrl);
pinctrl/qcom/pinctrl-msm.c:				     msm_gpio_irq_handler);
pinctrl/qcom/pinctrl-msm.c:static int msm_ps_hold_restart(struct notifier_block *nb, unsigned long action,
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = container_of(nb, struct msm_pinctrl, restart_nb);
pinctrl/qcom/pinctrl-msm.c:static struct msm_pinctrl *poweroff_pctrl;
pinctrl/qcom/pinctrl-msm.c:static void msm_ps_hold_poweroff(void)
pinctrl/qcom/pinctrl-msm.c:	msm_ps_hold_restart(&poweroff_pctrl->restart_nb, 0, NULL);
pinctrl/qcom/pinctrl-msm.c:static void msm_pinctrl_setup_pm_reset(struct msm_pinctrl *pctrl)
pinctrl/qcom/pinctrl-msm.c:	const struct msm_function *func = pctrl->soc->functions;
pinctrl/qcom/pinctrl-msm.c:			pctrl->restart_nb.notifier_call = msm_ps_hold_restart;
pinctrl/qcom/pinctrl-msm.c:			pm_power_off = msm_ps_hold_poweroff;
pinctrl/qcom/pinctrl-msm.c:static int msm_pinctrl_suspend(void)
pinctrl/qcom/pinctrl-msm.c:static void msm_pinctrl_resume(void)
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = msm_pinctrl_data;
pinctrl/qcom/pinctrl-msm.c:	if (!msm_show_resume_irq_mask)
pinctrl/qcom/pinctrl-msm.c:#define msm_pinctrl_suspend NULL
pinctrl/qcom/pinctrl-msm.c:#define msm_pinctrl_resume NULL
pinctrl/qcom/pinctrl-msm.c:static struct syscore_ops msm_pinctrl_pm_ops = {
pinctrl/qcom/pinctrl-msm.c:	.suspend = msm_pinctrl_suspend,
pinctrl/qcom/pinctrl-msm.c:	.resume = msm_pinctrl_resume,
pinctrl/qcom/pinctrl-msm.c:int msm_qup_write(u32 mode, u32 val)
pinctrl/qcom/pinctrl-msm.c:	struct pinctrl_qup *regs = msm_pinctrl_data->soc->qup_regs;
pinctrl/qcom/pinctrl-msm.c:	int num_regs =  msm_pinctrl_data->soc->nqup_regs;
pinctrl/qcom/pinctrl-msm.c:				 msm_pinctrl_data->regs + regs[i].offset);
pinctrl/qcom/pinctrl-msm.c:int msm_qup_read(unsigned int mode)
pinctrl/qcom/pinctrl-msm.c:	struct pinctrl_qup *regs = msm_pinctrl_data->soc->qup_regs;
pinctrl/qcom/pinctrl-msm.c:	int num_regs =  msm_pinctrl_data->soc->nqup_regs;
pinctrl/qcom/pinctrl-msm.c:			val = readl_relaxed(msm_pinctrl_data->regs +
pinctrl/qcom/pinctrl-msm.c: * msm_gpio_mpm_wake_set - API to make interrupt wakeup capable
pinctrl/qcom/pinctrl-msm.c:int msm_gpio_mpm_wake_set(unsigned int gpio, bool enable)
pinctrl/qcom/pinctrl-msm.c:	const struct msm_pingroup *g;
pinctrl/qcom/pinctrl-msm.c:	g = &msm_pinctrl_data->soc->groups[gpio];
pinctrl/qcom/pinctrl-msm.c:	raw_spin_lock_irqsave(&msm_pinctrl_data->lock, flags);
pinctrl/qcom/pinctrl-msm.c:	val = readl_relaxed(msm_pinctrl_data->regs + g->wake_reg);
pinctrl/qcom/pinctrl-msm.c:	writel_relaxed(val, msm_pinctrl_data->regs + g->wake_reg);
pinctrl/qcom/pinctrl-msm.c:	raw_spin_unlock_irqrestore(&msm_pinctrl_data->lock, flags);
pinctrl/qcom/pinctrl-msm.c:EXPORT_SYMBOL(msm_gpio_mpm_wake_set);
pinctrl/qcom/pinctrl-msm.c:int msm_pinctrl_probe(struct platform_device *pdev,
pinctrl/qcom/pinctrl-msm.c:		      const struct msm_pinctrl_soc_data *soc_data)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl;
pinctrl/qcom/pinctrl-msm.c:	msm_pinctrl_data = pctrl = devm_kzalloc(&pdev->dev,
pinctrl/qcom/pinctrl-msm.c:		dev_err(&pdev->dev, "Can't allocate msm_pinctrl\n");
pinctrl/qcom/pinctrl-msm.c:	pctrl->chip = msm_gpio_template;
pinctrl/qcom/pinctrl-msm.c:	msm_pinctrl_setup_pm_reset(pctrl);
pinctrl/qcom/pinctrl-msm.c:		dev_err(&pdev->dev, "No interrupt defined for msmgpio\n");
pinctrl/qcom/pinctrl-msm.c:	pctrl->desc.pctlops = &msm_pinctrl_ops;
pinctrl/qcom/pinctrl-msm.c:	pctrl->desc.pmxops = &msm_pinmux_ops;
pinctrl/qcom/pinctrl-msm.c:	pctrl->desc.confops = &msm_pinconf_ops;
pinctrl/qcom/pinctrl-msm.c:	ret = msm_gpio_init(pctrl);
pinctrl/qcom/pinctrl-msm.c:		struct msm_dir_conn *dc = &soc_data->dir_conn[i];
pinctrl/qcom/pinctrl-msm.c:		__irq_set_handler(irq, msm_gpio_dirconn_handler, false, NULL);
pinctrl/qcom/pinctrl-msm.c:	register_syscore_ops(&msm_pinctrl_pm_ops);
pinctrl/qcom/pinctrl-msm.c:EXPORT_SYMBOL(msm_pinctrl_probe);
pinctrl/qcom/pinctrl-msm.c:int msm_pinctrl_remove(struct platform_device *pdev)
pinctrl/qcom/pinctrl-msm.c:	struct msm_pinctrl *pctrl = platform_get_drvdata(pdev);
pinctrl/qcom/pinctrl-msm.c:	unregister_syscore_ops(&msm_pinctrl_pm_ops);
pinctrl/qcom/pinctrl-msm.c:EXPORT_SYMBOL(msm_pinctrl_remove);
platform/Kconfig:source "drivers/platform/msm/Kconfig"
platform/Makefile:obj-$(CONFIG_ARCH_QCOM)		+= msm/
platform/msm/Makefile:obj-$(CONFIG_MSM_EXT_DISPLAY) += msm_ext_display.o
platform/msm/Makefile:obj-$(CONFIG_MSM_11AD) += msm_11ad/
platform/msm/gsi/gsi.c:#include <linux/msm_gsi.h>
platform/msm/gsi/gsi.c:static const struct of_device_id msm_gsi_match[] = {
platform/msm/gsi/gsi.c:	{ .compatible = "qcom,msm_gsi", },
platform/msm/gsi/gsi.c:static int msm_gsi_probe(struct platform_device *pdev)
platform/msm/gsi/gsi.c:static struct platform_driver msm_gsi_driver = {
platform/msm/gsi/gsi.c:	.probe          = msm_gsi_probe,
platform/msm/gsi/gsi.c:		.of_match_table = msm_gsi_match,
platform/msm/gsi/gsi.c:	ret = platform_driver_register(&msm_gsi_driver);
platform/msm/gsi/gsi.c:			platform_driver_unregister(&msm_gsi_driver);
platform/msm/gsi/gsi.c:	platform_driver_unregister(&msm_gsi_driver);
platform/msm/gsi/gsi.h:#include <linux/msm_gsi.h>
platform/msm/gsi/gsi_dbg.c:#include <linux/msm_gsi.h>
platform/msm/ipa/ipa_clients/ipa_gsb.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_clients/ipa_mhi_client.c:#include <linux/msm_gsi.h>
platform/msm/ipa/ipa_clients/ipa_uc_offload.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_clients/ipa_wdi3.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_clients/odu_bridge.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_clients/rndis_ipa_trace.h:#define TRACE_INCLUDE_PATH ../../drivers/platform/msm/ipa/ipa_clients
platform/msm/ipa/ipa_clients/rndis_ipa.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_v2/ipa_dma.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_v2/ipa_intf.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_v2/ipa_qmi_service.h:#include <uapi/linux/msm_rmnet.h>
platform/msm/ipa/ipa_v2/ipa_utils.c:#include <linux/msm-bus.h>
platform/msm/ipa/ipa_v2/ipa_utils.c:#include <linux/msm-bus-board.h>
platform/msm/ipa/ipa_v2/ipa_utils.c:static struct msm_bus_vectors ipa_init_vectors_v1_1[]  = {
platform/msm/ipa/ipa_v2/ipa_utils.c:static struct msm_bus_vectors ipa_init_vectors_v2_0[]  = {
platform/msm/ipa/ipa_v2/ipa_utils.c:static struct msm_bus_vectors ipa_max_perf_vectors_v1_1[]  = {
platform/msm/ipa/ipa_v2/ipa_utils.c:static struct msm_bus_vectors ipa_nominal_perf_vectors_v2_0[]  = {
platform/msm/ipa/ipa_v2/ipa_utils.c:static struct msm_bus_paths ipa_usecases_v1_1[]  = {
platform/msm/ipa/ipa_v2/ipa_utils.c:static struct msm_bus_paths ipa_usecases_v2_0[]  = {
platform/msm/ipa/ipa_v2/ipa_utils.c:static struct msm_bus_scale_pdata ipa_bus_client_pdata_v1_1 = {
platform/msm/ipa/ipa_v2/ipa_utils.c:static struct msm_bus_scale_pdata ipa_bus_client_pdata_v2_0 = {
platform/msm/ipa/ipa_v2/ipa_utils.c:	ctrl->msm_bus_data_ptr = &ipa_bus_client_pdata_v2_0;
platform/msm/ipa/ipa_v2/ipa_utils.c:		ctrl->msm_bus_data_ptr = &ipa_bus_client_pdata_v1_1;
platform/msm/ipa/ipa_v2/rmnet_ipa.c:#include <uapi/linux/msm_rmnet.h>
platform/msm/ipa/ipa_v2/teth_bridge.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_v2/ipa.c:#include <linux/msm-bus.h>
platform/msm/ipa/ipa_v2/ipa.c:#include <linux/msm-bus-board.h>
platform/msm/ipa/ipa_v2/ipa.c:static struct msm_bus_scale_pdata *bus_scale_table;
platform/msm/ipa/ipa_v2/ipa.c:		if (ipa_ctx->ctrl->msm_bus_data_ptr->num_usecases <= 2)
platform/msm/ipa/ipa_v2/ipa.c:		idx = ipa_ctx->ctrl->msm_bus_data_ptr->num_usecases - 1;
platform/msm/ipa/ipa_v2/ipa.c:		if (msm_bus_scale_client_update_request(ipa_ctx->ipa_bus_hdl,
platform/msm/ipa/ipa_v2/ipa.c:		if (msm_bus_scale_client_update_request(ipa_ctx->ipa_bus_hdl,
platform/msm/ipa/ipa_v2/ipa.c:			if (msm_bus_scale_client_update_request(
platform/msm/ipa/ipa_v2/ipa.c:		ipa_ctx->ctrl->msm_bus_data_ptr = bus_scale_table;
platform/msm/ipa/ipa_v2/ipa.c:				msm_bus_scale_register_client(
platform/msm/ipa/ipa_v2/ipa.c:					ipa_ctx->ctrl->msm_bus_data_ptr);
platform/msm/ipa/ipa_v2/ipa.c:	msm_bus_scale_unregister_client(ipa_ctx->ipa_bus_hdl);
platform/msm/ipa/ipa_v2/ipa.c:		msm_bus_cl_clear_pdata(bus_scale_table);
platform/msm/ipa/ipa_v2/ipa.c:		bus_scale_table = msm_bus_cl_get_pdata(ipa_pdev);
platform/msm/ipa/ipa_v2/ipa.c:	 * Due to late initialization of msm_bus in kernel >= 4.14, add
platform/msm/ipa/ipa_v2/ipa.c:	 * mechanism to defer IPA probing until msm_bus is initialized
platform/msm/ipa/ipa_v2/ipa.c:			bus_scale_table = msm_bus_cl_get_pdata(ipa_pdev);
platform/msm/ipa/ipa_v2/ipa.c:			 * Register with bus client to check if msm_bus
platform/msm/ipa/ipa_v2/ipa.c:				msm_bus_scale_register_client(
platform/msm/ipa/ipa_v2/ipa.c:			bus_scale_table = msm_bus_cl_get_pdata(pdev_p);
platform/msm/ipa/ipa_v2/ipa_i.h:#include <linux/msm-sps.h>
platform/msm/ipa/ipa_v2/ipa_i.h: * @ipa_bus_hdl: msm driver handle for the data path bus
platform/msm/ipa/ipa_v2/ipa_i.h:	struct msm_bus_scale_pdata *msm_bus_data_ptr;
platform/msm/ipa/ipa_v3/Makefile:ccflags-$(CONFIG_IPA3_REGDUMP) += -Idrivers/platform/msm/ipa/ipa_v3/dump
platform/msm/ipa/ipa_v3/Makefile:ccflags-$(CONFIG_IPA3_REGDUMP_IPA_4_5) += -Idrivers/platform/msm/ipa/ipa_v3/dump/ipa4.5
platform/msm/ipa/ipa_v3/ipa.c:#include <linux/msm-bus.h>
platform/msm/ipa/ipa_v3/ipa.c:#include <linux/msm-bus-board.h>
platform/msm/ipa/ipa_v3/ipa.c:#include <linux/msm_gsi.h>
platform/msm/ipa/ipa_v3/ipa.c:		idx = ipa3_ctx->ctrl->msm_bus_data_ptr->num_usecases - 1;
platform/msm/ipa/ipa_v3/ipa.c:	if (msm_bus_scale_client_update_request(ipa3_ctx->ipa_bus_hdl,
platform/msm/ipa/ipa_v3/ipa.c:	if (msm_bus_scale_client_update_request(ipa3_ctx->ipa_bus_hdl, 0))
platform/msm/ipa/ipa_v3/ipa.c: * ipa3_active_clks_status() - update the current msm bus clock vote
platform/msm/ipa/ipa_v3/ipa.c:	if (idx <= 0 || idx >= ipa3_ctx->ctrl->msm_bus_data_ptr->num_usecases) {
platform/msm/ipa/ipa_v3/ipa.c:		if (msm_bus_scale_client_update_request(ipa3_ctx->ipa_bus_hdl,
platform/msm/ipa/ipa_v3/ipa.c:		if (msm_bus_scale_client_update_request(ipa3_ctx->ipa_bus_hdl,
platform/msm/ipa/ipa_v3/ipa.c:		ipa3_ctx->ctrl->msm_bus_data_ptr =
platform/msm/ipa/ipa_v3/ipa.c:			msm_bus_cl_get_pdata(ipa3_ctx->master_pdev);
platform/msm/ipa/ipa_v3/ipa.c:		if (ipa3_ctx->ctrl->msm_bus_data_ptr == NULL) {
platform/msm/ipa/ipa_v3/ipa.c:			ipa3_ctx->ctrl->msm_bus_data_ptr->num_usecases);
platform/msm/ipa/ipa_v3/ipa.c:			msm_bus_scale_register_client(
platform/msm/ipa/ipa_v3/ipa.c:				ipa3_ctx->ctrl->msm_bus_data_ptr);
platform/msm/ipa/ipa_v3/ipa.c:			ipa3_ctx->ctrl->msm_bus_data_ptr = NULL;
platform/msm/ipa/ipa_v3/ipa.c:		msm_bus_scale_unregister_client(ipa3_ctx->ipa_bus_hdl);
platform/msm/ipa/ipa_v3/ipa.c:	if (ipa3_ctx->ctrl->msm_bus_data_ptr)
platform/msm/ipa/ipa_v3/ipa.c:		msm_bus_cl_clear_pdata(ipa3_ctx->ctrl->msm_bus_data_ptr);
platform/msm/ipa/ipa_v3/ipa.c:		"qcom,msm-bus,num-cases",
platform/msm/ipa/ipa_v3/ipa.c:		IPAERR("invalid property qcom,msm-bus,num-cases %d\n",
platform/msm/ipa/ipa_v3/ipa_client.c:#include "linux/msm_gsi.h"
platform/msm/ipa/ipa_v3/ipa_dma.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_v3/ipa_dma.c:#include "linux/msm_gsi.h"
platform/msm/ipa/ipa_v3/ipa_dp.c:#include <linux/msm_gsi.h>
platform/msm/ipa/ipa_v3/ipa_dt_replacement.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_v3/ipa_dt_replacement.c:	{"qcom,msm-bus,num-cases",              5},
platform/msm/ipa/ipa_v3/ipa_i.h: * @ipa_bus_hdl: msm driver handle for the data path bus
platform/msm/ipa/ipa_v3/ipa_i.h:	struct msm_bus_scale_pdata *msm_bus_data_ptr;
platform/msm/ipa/ipa_v3/ipa_intf.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_v3/ipa_mhi.c:#include <linux/msm_gsi.h>
platform/msm/ipa/ipa_v3/ipa_mpm.c:#include <linux/msm_gsi.h>
platform/msm/ipa/ipa_v3/ipa_odl.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_v3/ipa_pm.h:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_v3/ipa_qmi_service.h:#include <uapi/linux/msm_rmnet.h>
platform/msm/ipa/ipa_v3/ipa_trace.h:#define TRACE_INCLUDE_PATH ../../drivers/platform/msm/ipa/ipa_v3
platform/msm/ipa/ipa_v3/ipa_utils.c:#include <linux/msm-bus.h>
platform/msm/ipa/ipa_v3/ipa_utils.c:#include <linux/msm-bus-board.h>
platform/msm/ipa/ipa_v3/ipa_utils.c:#include <linux/msm_gsi.h>
platform/msm/ipa/ipa_v3/ipahal/ipahal_nat_i.h:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_v3/ipahal/ipahal_reg.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_v3/teth_bridge.c:#include <linux/msm_ipa.h>
platform/msm/ipa/ipa_v3/rmnet_ipa.c:#include <uapi/linux/msm_rmnet.h>
platform/msm/msm_11ad/Makefile:obj-$(CONFIG_MSM_11AD) += msm_11ad_proxy.o
platform/msm/msm_11ad/Makefile:msm_11ad_proxy-y := msm_11ad.o
platform/msm/msm_11ad/msm_11ad.c:#include <linux/msm_pcie.h>
platform/msm/msm_11ad/msm_11ad.c:#include <linux/msm-bus.h>
platform/msm/msm_11ad/msm_11ad.c:#include "msm_11ad.h"
platform/msm/msm_11ad/msm_11ad.c:struct msm11ad_vreg {
platform/msm/msm_11ad/msm_11ad.c:struct msm11ad_clk {
platform/msm/msm_11ad/msm_11ad.c:struct msm11ad_ctx {
platform/msm/msm_11ad/msm_11ad.c:	struct msm_pcie_register_event pci_event;
platform/msm/msm_11ad/msm_11ad.c:	struct msm_bus_scale_pdata *bus_scale;
platform/msm/msm_11ad/msm_11ad.c:	u32 msm_bus_handle;
platform/msm/msm_11ad/msm_11ad.c:	struct msm_dump_data dump_data;
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_vreg vdd;
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_vreg vddio;
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_vreg vdd_ldo;
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_clk rf_clk;
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_clk rf_clk_pin;
platform/msm/msm_11ad/msm_11ad.c:static struct msm11ad_ctx *pcidev2ctx(struct pci_dev *pcidev)
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx;
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_init_vreg(struct device *dev,
platform/msm/msm_11ad/msm_11ad.c:			      struct msm11ad_vreg *vreg, const char *name)
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_release_vreg(struct device *dev, struct msm11ad_vreg *vreg)
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_init_clk(struct device *dev, struct msm11ad_clk *clk,
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_release_clk(struct device *dev, struct msm11ad_clk *clk)
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_init_vregs(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_init_vreg(dev, &ctx->vdd, "vdd");
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_init_vreg(dev, &ctx->vddio, "vddio");
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_init_vreg(dev, &ctx->vdd_ldo, "vdd-ldo");
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_release_vreg(dev, &ctx->vddio);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_release_vreg(dev, &ctx->vdd);
platform/msm/msm_11ad/msm_11ad.c:static void msm_11ad_release_vregs(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_release_vreg(ctx->dev, &ctx->vdd_ldo);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_release_vreg(ctx->dev, &ctx->vdd);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_release_vreg(ctx->dev, &ctx->vddio);
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_cfg_vreg(struct device *dev,
platform/msm/msm_11ad/msm_11ad.c:			     struct msm11ad_vreg *vreg, bool on)
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_enable_vreg(struct msm11ad_ctx *ctx,
platform/msm/msm_11ad/msm_11ad.c:				struct msm11ad_vreg *vreg)
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_cfg_vreg(dev, vreg, true);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_cfg_vreg(dev, vreg, false);
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_disable_vreg(struct msm11ad_ctx *ctx,
platform/msm/msm_11ad/msm_11ad.c:				 struct msm11ad_vreg *vreg)
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_cfg_vreg(dev, vreg, false);
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_enable_vregs(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_enable_vreg(ctx, &ctx->vdd);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_enable_vreg(ctx, &ctx->vddio);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_enable_vreg(ctx, &ctx->vdd_ldo);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_vreg(ctx, &ctx->vddio);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_vreg(ctx, &ctx->vdd);
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_disable_vregs(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_vreg(ctx, &ctx->vdd_ldo);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_vreg(ctx, &ctx->vdd);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_vreg(ctx, &ctx->vddio);
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_enable_clk(struct msm11ad_ctx *ctx,
platform/msm/msm_11ad/msm_11ad.c:				struct msm11ad_clk *clk)
platform/msm/msm_11ad/msm_11ad.c:static void msm_11ad_disable_clk(struct msm11ad_ctx *ctx,
platform/msm/msm_11ad/msm_11ad.c:				struct msm11ad_clk *clk)
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_enable_clocks(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_enable_clk(ctx, &ctx->rf_clk);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_enable_clk(ctx, &ctx->rf_clk_pin);
platform/msm/msm_11ad/msm_11ad.c:		msm_11ad_disable_clk(ctx, &ctx->rf_clk);
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_init_clocks(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_init_clk(dev, &ctx->rf_clk, "rf_clk");
platform/msm/msm_11ad/msm_11ad.c:		rc = msm_11ad_init_clk(dev, &ctx->rf_clk_pin,
platform/msm/msm_11ad/msm_11ad.c:			msm_11ad_release_clk(ctx->dev, &ctx->rf_clk);
platform/msm/msm_11ad/msm_11ad.c:static void msm_11ad_release_clocks(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_release_clk(ctx->dev, &ctx->rf_clk_pin);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_release_clk(ctx->dev, &ctx->rf_clk);
platform/msm/msm_11ad/msm_11ad.c:static void msm_11ad_disable_clocks(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_clk(ctx, &ctx->rf_clk_pin);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_clk(ctx, &ctx->rf_clk);
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_turn_device_power_off(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_clocks(ctx);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_vregs(ctx);
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_turn_device_power_on(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_enable_vregs(ctx);
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_11ad_enable_vregs failed :%d\n",
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_enable_clocks(ctx);
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_11ad_enable_clocks failed :%d\n", rc);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_vregs(ctx);
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_suspend_power_off(void *handle)
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = handle;
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_pcie_pm_control(MSM_PCIE_SUSPEND, pcidev->bus->number,
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_pcie_pm_control(SUSPEND) failed :%d\n",
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_turn_device_power_off(ctx);
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = handle;
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_pcie_pm_control(MSM_PCIE_SUSPEND, pcidev->bus->number,
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_pcie_pm_control(SUSPEND) failed: %d\n",
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_turn_device_power_off(ctx);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_turn_device_power_on(ctx);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_pcie_pm_control(MSM_PCIE_RESUME, pcidev->bus->number,
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_pcie_pm_control(RESUME) failed: %d\n",
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_turn_device_power_off(ctx);
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = handle;
platform/msm/msm_11ad/msm_11ad.c:		return msm_11ad_suspend_power_off(handle);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_pcie_pm_control(MSM_PCIE_SUSPEND, pcidev->bus->number,
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_pcie_pm_control(SUSPEND) failed :%d\n",
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_resume_power_on(void *handle)
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = handle;
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_turn_device_power_on(ctx);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_pcie_pm_control(MSM_PCIE_RESUME, pcidev->bus->number,
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_pcie_pm_control(RESUME) failed :%d\n",
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_turn_device_power_off(ctx);
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = handle;
platform/msm/msm_11ad/msm_11ad.c:		return msm_11ad_resume_power_on(handle);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_pcie_pm_control(MSM_PCIE_RESUME, pcidev->bus->number,
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_pcie_pm_control(RESUME) failed :%d\n",
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_ssr_shutdown(const struct subsys_desc *subsys,
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_ssr_powerup(const struct subsys_desc *subsys)
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx;
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_ssr_copy_ramdump(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_ssr_ramdump(int enable, const struct subsys_desc *subsys)
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx;
platform/msm/msm_11ad/msm_11ad.c:		rc = msm_11ad_ssr_copy_ramdump(ctx);
platform/msm/msm_11ad/msm_11ad.c:static void msm_11ad_ssr_crash_shutdown(const struct subsys_desc *subsys)
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx;
platform/msm/msm_11ad/msm_11ad.c:		(void)msm_11ad_ssr_copy_ramdump(ctx);
platform/msm/msm_11ad/msm_11ad.c:static void msm_11ad_ssr_deinit(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_ssr_init(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:	struct msm_dump_entry dump_entry;
platform/msm/msm_11ad/msm_11ad.c:	ctx->subsysdesc.shutdown = msm_11ad_ssr_shutdown;
platform/msm/msm_11ad/msm_11ad.c:	ctx->subsysdesc.powerup = msm_11ad_ssr_powerup;
platform/msm/msm_11ad/msm_11ad.c:	ctx->subsysdesc.ramdump = msm_11ad_ssr_ramdump;
platform/msm/msm_11ad/msm_11ad.c:	ctx->subsysdesc.crash_shutdown = msm_11ad_ssr_crash_shutdown;
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_dump_data_register(MSM_DUMP_TABLE_APPS, &dump_entry);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_ssr_deinit(ctx);
platform/msm/msm_11ad/msm_11ad.c:static void msm_11ad_init_cpu_boost(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:static void msm_11ad_pci_event_cb(struct msm_pcie_notify *notify)
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = pcidev2ctx(pcidev);
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_probe(struct platform_device *pdev)
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx;
platform/msm/msm_11ad/msm_11ad.c:	struct msm_pcie_register_event *pci_event;
platform/msm/msm_11ad/msm_11ad.c:	 *	qcom,msm-bus,name = "wil6210";
platform/msm/msm_11ad/msm_11ad.c:	 *	qcom,msm-bus,num-cases = <2>;
platform/msm/msm_11ad/msm_11ad.c:	 *	qcom,msm-bus,num-paths = <1>;
platform/msm/msm_11ad/msm_11ad.c:	 *	qcom,msm-bus,vectors-KBps =
platform/msm/msm_11ad/msm_11ad.c:	ctx->bus_scale = msm_bus_cl_get_pdata(pdev);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_init_vregs(ctx);
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_11ad_init_vregs failed: %d\n", rc);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_enable_vregs(ctx);
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_11ad_enable_vregs failed: %d\n", rc);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_init_clocks(ctx);
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_11ad_init_clocks failed: %d\n", rc);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_enable_clocks(ctx);
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_11ad_enable_clocks failed: %d\n", rc);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_pcie_enumerate(ctx->rc_index);
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_pcie_pm_control(MSM_PCIE_RESUME, pcidev->bus->number,
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_pcie_pm_control(RESUME) failed:%d\n",
platform/msm/msm_11ad/msm_11ad.c:		rc = gpio_request(ctx->sleep_clk_en, "msm_11ad");
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_11ad_ssr_init(ctx);
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "msm_11ad_ssr_init failed: %d\n", rc);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_init_cpu_boost(ctx);
platform/msm/msm_11ad/msm_11ad.c:	dev_info(ctx->dev, "msm_11ad discovered. %pK {\n"
platform/msm/msm_11ad/msm_11ad.c:	pci_event->callback = msm_11ad_pci_event_cb;
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_pcie_register_event(pci_event);
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "failed to register msm pcie event: %d\n",
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_suspend_power_off(ctx);
platform/msm/msm_11ad/msm_11ad.c:	msm_pcie_pm_control(MSM_PCIE_SUSPEND, pcidev->bus->number,
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_clocks(ctx);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_release_clocks(ctx);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_vregs(ctx);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_release_vregs(ctx);
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_remove(struct platform_device *pdev)
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = platform_get_drvdata(pdev);
platform/msm/msm_11ad/msm_11ad.c:	msm_pcie_deregister_event(&ctx->pci_event);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_ssr_deinit(ctx);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_clocks(ctx);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_release_clocks(ctx);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_disable_vregs(ctx);
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_release_vregs(ctx);
platform/msm/msm_11ad/msm_11ad.c:static const struct of_device_id msm_11ad_of_match[] = {
platform/msm/msm_11ad/msm_11ad.c:static struct platform_driver msm_11ad_driver = {
platform/msm/msm_11ad/msm_11ad.c:		.name = "msm_11ad",
platform/msm/msm_11ad/msm_11ad.c:		.of_match_table = msm_11ad_of_match,
platform/msm/msm_11ad/msm_11ad.c:	.probe = msm_11ad_probe,
platform/msm/msm_11ad/msm_11ad.c:	.remove = msm_11ad_remove,
platform/msm/msm_11ad/msm_11ad.c:module_platform_driver(msm_11ad_driver);
platform/msm/msm_11ad/msm_11ad.c:static void msm_11ad_set_affinity_hint(struct msm11ad_ctx *ctx, uint irq,
platform/msm/msm_11ad/msm_11ad.c:static void msm_11ad_set_boost_affinity(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_set_affinity_hint(ctx, ctx->pcidev->irq, &ctx->boost_cpu_0);
platform/msm/msm_11ad/msm_11ad.c:		msm_11ad_set_affinity_hint(ctx, ctx->pcidev->irq + 1,
platform/msm/msm_11ad/msm_11ad.c:static void msm_11ad_clear_affinity_hint(struct msm11ad_ctx *ctx, uint irq)
platform/msm/msm_11ad/msm_11ad.c:static void msm_11ad_clear_boost_affinity(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_clear_affinity_hint(ctx, ctx->pcidev->irq);
platform/msm/msm_11ad/msm_11ad.c:		msm_11ad_clear_affinity_hint(ctx, ctx->pcidev->irq + 1);
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = (struct msm11ad_ctx *)handle;
platform/msm/msm_11ad/msm_11ad.c:	struct msm_bus_paths *usecase;
platform/msm/msm_11ad/msm_11ad.c:	rc = msm_bus_scale_client_update_request(ctx->msm_bus_handle, vote);
platform/msm/msm_11ad/msm_11ad.c:			"Failed msm_bus voting. kbps=%d vote=%d, rc=%d\n",
platform/msm/msm_11ad/msm_11ad.c:				msm_11ad_set_boost_affinity(ctx);
platform/msm/msm_11ad/msm_11ad.c:				msm_11ad_clear_boost_affinity(ctx);
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = (struct msm11ad_ctx *)handle;
platform/msm/msm_11ad/msm_11ad.c:	if (ctx->msm_bus_handle) {
platform/msm/msm_11ad/msm_11ad.c:		msm_bus_scale_unregister_client(ctx->msm_bus_handle);
platform/msm/msm_11ad/msm_11ad.c:		ctx->msm_bus_handle = 0;
platform/msm/msm_11ad/msm_11ad.c:	msm_11ad_suspend_power_off(ctx);
platform/msm/msm_11ad/msm_11ad.c:static int msm_11ad_notify_crash(struct msm11ad_ctx *ctx)
platform/msm/msm_11ad/msm_11ad.c:		(void)msm_11ad_ssr_copy_ramdump(ctx);
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = (struct msm11ad_ctx *)handle;
platform/msm/msm_11ad/msm_11ad.c:		rc = msm_11ad_notify_crash(ctx);
platform/msm/msm_11ad/msm_11ad.c:			rc = msm_11ad_enable_clk(ctx, &ctx->rf_clk);
platform/msm/msm_11ad/msm_11ad.c:			msm_11ad_disable_clk(ctx, &ctx->rf_clk);
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = (struct msm11ad_ctx *)handle;
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = (struct msm11ad_ctx *)handle;
platform/msm/msm_11ad/msm_11ad.c:void *msm_11ad_dev_init(struct device *dev, struct wil_platform_ops *ops,
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = pcidev2ctx(pcidev);
platform/msm/msm_11ad/msm_11ad.c:	ctx->msm_bus_handle =
platform/msm/msm_11ad/msm_11ad.c:		msm_bus_scale_register_client(ctx->bus_scale);
platform/msm/msm_11ad/msm_11ad.c:	if (!ctx->msm_bus_handle) {
platform/msm/msm_11ad/msm_11ad.c:		dev_err(ctx->dev, "Failed msm_bus registration\n");
platform/msm/msm_11ad/msm_11ad.c:	dev_info(ctx->dev, "msm_bus handle 0x%x\n", ctx->msm_bus_handle);
platform/msm/msm_11ad/msm_11ad.c:EXPORT_SYMBOL(msm_11ad_dev_init);
platform/msm/msm_11ad/msm_11ad.c:int msm_11ad_modinit(void)
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = list_first_entry_or_null(&dev_list,
platform/msm/msm_11ad/msm_11ad.c:							   struct msm11ad_ctx,
platform/msm/msm_11ad/msm_11ad.c:	return msm_11ad_resume_power_on(ctx);
platform/msm/msm_11ad/msm_11ad.c:EXPORT_SYMBOL(msm_11ad_modinit);
platform/msm/msm_11ad/msm_11ad.c:void msm_11ad_modexit(void)
platform/msm/msm_11ad/msm_11ad.c:	struct msm11ad_ctx *ctx = list_first_entry_or_null(&dev_list,
platform/msm/msm_11ad/msm_11ad.c:							   struct msm11ad_ctx,
platform/msm/msm_11ad/msm_11ad.c:EXPORT_SYMBOL(msm_11ad_modexit);
platform/msm/msm_11ad/msm_11ad.h:/*	msm_11ad_dev_init - call when binding to device, during probe()
platform/msm/msm_11ad/msm_11ad.h:void *msm_11ad_dev_init(struct device *dev, struct wil_platform_ops *ops,
platform/msm/msm_11ad/msm_11ad.h:int msm_11ad_modinit(void);
platform/msm/msm_11ad/msm_11ad.h:void msm_11ad_modexit(void);
platform/msm/msm_ext_display.c:#include <linux/msm_ext_display.h>
platform/msm/msm_ext_display.c:struct msm_ext_disp_list {
platform/msm/msm_ext_display.c:	struct msm_ext_disp_init_data *data;
platform/msm/msm_ext_display.c:struct msm_ext_disp {
platform/msm/msm_ext_display.c:	struct msm_ext_disp_data ext_disp_data;
platform/msm/msm_ext_display.c:	struct msm_ext_disp_codec_id current_codec;
platform/msm/msm_ext_display.c:	struct msm_ext_disp_audio_codec_ops *ops;
platform/msm/msm_ext_display.c:static const unsigned int msm_ext_disp_supported_cable[] = {
platform/msm/msm_ext_display.c:static int msm_ext_disp_extcon_register(struct msm_ext_disp *ext_disp, int id)
platform/msm/msm_ext_display.c:			msm_ext_disp_supported_cable);
platform/msm/msm_ext_display.c:static void msm_ext_disp_extcon_unregister(struct msm_ext_disp *ext_disp,
platform/msm/msm_ext_display.c:static const char *msm_ext_disp_name(enum msm_ext_disp_type type)
platform/msm/msm_ext_display.c:static int msm_ext_disp_add_intf_data(struct msm_ext_disp *ext_disp,
platform/msm/msm_ext_display.c:		struct msm_ext_disp_init_data *data)
platform/msm/msm_ext_display.c:	struct msm_ext_disp_list *node;
platform/msm/msm_ext_display.c:		msm_ext_disp_name(data->codec.type),
platform/msm/msm_ext_display.c:static int msm_ext_disp_remove_intf_data(struct msm_ext_disp *ext_disp,
platform/msm/msm_ext_display.c:		struct msm_ext_disp_init_data *data)
platform/msm/msm_ext_display.c:	struct msm_ext_disp_list *node;
platform/msm/msm_ext_display.c:		node = list_entry(pos, struct msm_ext_disp_list, list);
platform/msm/msm_ext_display.c:static int msm_ext_disp_get_intf_data(struct msm_ext_disp *ext_disp,
platform/msm/msm_ext_display.c:		struct msm_ext_disp_codec_id *codec,
platform/msm/msm_ext_display.c:		struct msm_ext_disp_init_data **data)
platform/msm/msm_ext_display.c:	struct msm_ext_disp_list *node;
platform/msm/msm_ext_display.c:		node = list_entry(position, struct msm_ext_disp_list, list);
platform/msm/msm_ext_display.c:static int msm_ext_disp_process_audio(struct msm_ext_disp *ext_disp,
platform/msm/msm_ext_display.c:		struct msm_ext_disp_codec_id *codec,
platform/msm/msm_ext_display.c:		enum msm_ext_disp_cable_state new_state)
platform/msm/msm_ext_display.c:static struct msm_ext_disp *msm_ext_disp_validate_and_get(
platform/msm/msm_ext_display.c:		struct msm_ext_disp_codec_id *codec,
platform/msm/msm_ext_display.c:		enum msm_ext_disp_cable_state state)
platform/msm/msm_ext_display.c:	struct msm_ext_disp_data *ext_disp_data;
platform/msm/msm_ext_display.c:	struct msm_ext_disp *ext_disp;
platform/msm/msm_ext_display.c:			struct msm_ext_disp, ext_disp_data);
platform/msm/msm_ext_display.c:static int msm_ext_disp_update_audio_ops(struct msm_ext_disp *ext_disp,
platform/msm/msm_ext_display.c:		struct msm_ext_disp_codec_id *codec)
platform/msm/msm_ext_display.c:	struct msm_ext_disp_init_data *data = NULL;
platform/msm/msm_ext_display.c:	ret = msm_ext_disp_get_intf_data(ext_disp, codec, &data);
platform/msm/msm_ext_display.c:			msm_ext_disp_name(codec->type),
platform/msm/msm_ext_display.c:static int msm_ext_disp_audio_config(struct platform_device *pdev,
platform/msm/msm_ext_display.c:		struct msm_ext_disp_codec_id *codec,
platform/msm/msm_ext_display.c:		enum msm_ext_disp_cable_state state)
platform/msm/msm_ext_display.c:	struct msm_ext_disp *ext_disp;
platform/msm/msm_ext_display.c:	ext_disp = msm_ext_disp_validate_and_get(pdev, codec, state);
platform/msm/msm_ext_display.c:		ret = msm_ext_disp_select_audio_codec(pdev, codec);
platform/msm/msm_ext_display.c:			msm_ext_disp_name(ext_disp->current_codec.type));
platform/msm/msm_ext_display.c:static int msm_ext_disp_audio_notify(struct platform_device *pdev,
platform/msm/msm_ext_display.c:		struct msm_ext_disp_codec_id *codec,
platform/msm/msm_ext_display.c:		enum msm_ext_disp_cable_state state)
platform/msm/msm_ext_display.c:	struct msm_ext_disp *ext_disp;
platform/msm/msm_ext_display.c:	ext_disp = msm_ext_disp_validate_and_get(pdev, codec, state);
platform/msm/msm_ext_display.c:	ret = msm_ext_disp_process_audio(ext_disp, codec, state);
platform/msm/msm_ext_display.c:static void msm_ext_disp_ready_for_display(struct msm_ext_disp *ext_disp)
platform/msm/msm_ext_display.c:	struct msm_ext_disp_init_data *data = NULL;
platform/msm/msm_ext_display.c:	ret = msm_ext_disp_get_intf_data(ext_disp,
platform/msm/msm_ext_display.c:			msm_ext_disp_name(ext_disp->current_codec.type));
platform/msm/msm_ext_display.c:int msm_hdmi_register_audio_codec(struct platform_device *pdev,
platform/msm/msm_ext_display.c:		struct msm_ext_disp_audio_codec_ops *ops)
platform/msm/msm_ext_display.c:	return msm_ext_disp_register_audio_codec(pdev, ops);
platform/msm/msm_ext_display.c:int msm_ext_disp_register_audio_codec(struct platform_device *pdev,
platform/msm/msm_ext_display.c:		struct msm_ext_disp_audio_codec_ops *ops)
platform/msm/msm_ext_display.c:	struct msm_ext_disp *ext_disp = NULL;
platform/msm/msm_ext_display.c:	struct msm_ext_disp_data *ext_disp_data = NULL;
platform/msm/msm_ext_display.c:	ext_disp = container_of(ext_disp_data, struct msm_ext_disp,
platform/msm/msm_ext_display.c:		msm_ext_disp_ready_for_display(ext_disp);
platform/msm/msm_ext_display.c:EXPORT_SYMBOL(msm_ext_disp_register_audio_codec);
platform/msm/msm_ext_display.c:int msm_ext_disp_select_audio_codec(struct platform_device *pdev,
platform/msm/msm_ext_display.c:		struct msm_ext_disp_codec_id *codec)
platform/msm/msm_ext_display.c:	struct msm_ext_disp *ext_disp = NULL;
platform/msm/msm_ext_display.c:	struct msm_ext_disp_data *ext_disp_data = NULL;
platform/msm/msm_ext_display.c:	ext_disp = container_of(ext_disp_data, struct msm_ext_disp,
platform/msm/msm_ext_display.c:	ret = msm_ext_disp_update_audio_ops(ext_disp, codec);
platform/msm/msm_ext_display.c:EXPORT_SYMBOL(msm_ext_disp_select_audio_codec);
platform/msm/msm_ext_display.c:static int msm_ext_disp_validate_intf(struct msm_ext_disp_init_data *init_data)
platform/msm/msm_ext_display.c:	struct msm_ext_disp_audio_codec_ops *ops;
platform/msm/msm_ext_display.c:int msm_ext_disp_register_intf(struct platform_device *pdev,
platform/msm/msm_ext_display.c:		struct msm_ext_disp_init_data *init_data)
platform/msm/msm_ext_display.c:	struct msm_ext_disp_init_data *data = NULL;
platform/msm/msm_ext_display.c:	struct msm_ext_disp *ext_disp = NULL;
platform/msm/msm_ext_display.c:	struct msm_ext_disp_data *ext_disp_data = NULL;
platform/msm/msm_ext_display.c:	ext_disp = container_of(ext_disp_data, struct msm_ext_disp,
platform/msm/msm_ext_display.c:	ret = msm_ext_disp_validate_intf(init_data);
platform/msm/msm_ext_display.c:	ret = msm_ext_disp_get_intf_data(ext_disp, &init_data->codec, &data);
platform/msm/msm_ext_display.c:			msm_ext_disp_name(init_data->codec.type),
platform/msm/msm_ext_display.c:	ret = msm_ext_disp_add_intf_data(ext_disp, init_data);
platform/msm/msm_ext_display.c:	init_data->intf_ops.audio_config = msm_ext_disp_audio_config;
platform/msm/msm_ext_display.c:	init_data->intf_ops.audio_notify = msm_ext_disp_audio_notify;
platform/msm/msm_ext_display.c:			msm_ext_disp_name(init_data->codec.type),
platform/msm/msm_ext_display.c:int msm_ext_disp_deregister_intf(struct platform_device *pdev,
platform/msm/msm_ext_display.c:		struct msm_ext_disp_init_data *init_data)
platform/msm/msm_ext_display.c:	struct msm_ext_disp *ext_disp = NULL;
platform/msm/msm_ext_display.c:	struct msm_ext_disp_data *ext_disp_data = NULL;
platform/msm/msm_ext_display.c:	ext_disp = container_of(ext_disp_data, struct msm_ext_disp,
platform/msm/msm_ext_display.c:	ret = msm_ext_disp_remove_intf_data(ext_disp, init_data);
platform/msm/msm_ext_display.c:			msm_ext_disp_name(init_data->codec.type));
platform/msm/msm_ext_display.c:static int msm_ext_disp_probe(struct platform_device *pdev)
platform/msm/msm_ext_display.c:	struct msm_ext_disp *ext_disp = NULL;
platform/msm/msm_ext_display.c:		ret = msm_ext_disp_extcon_register(ext_disp, id);
platform/msm/msm_ext_display.c:		msm_ext_disp_extcon_unregister(ext_disp, id);
platform/msm/msm_ext_display.c:static int msm_ext_disp_remove(struct platform_device *pdev)
platform/msm/msm_ext_display.c:	struct msm_ext_disp *ext_disp = NULL;
platform/msm/msm_ext_display.c:	struct msm_ext_disp_data *ext_disp_data = NULL;
platform/msm/msm_ext_display.c:	ext_disp = container_of(ext_disp_data, struct msm_ext_disp,
platform/msm/msm_ext_display.c:		msm_ext_disp_extcon_unregister(ext_disp, id);
platform/msm/msm_ext_display.c:static const struct of_device_id msm_ext_dt_match[] = {
platform/msm/msm_ext_display.c:	{.compatible = "qcom,msm-ext-disp",},
platform/msm/msm_ext_display.c:MODULE_DEVICE_TABLE(of, msm_ext_dt_match);
platform/msm/msm_ext_display.c:	.probe = msm_ext_disp_probe,
platform/msm/msm_ext_display.c:	.remove = msm_ext_disp_remove,
platform/msm/msm_ext_display.c:		.name = "msm-ext-disp",
platform/msm/msm_ext_display.c:		.of_match_table = msm_ext_dt_match,
platform/msm/msm_ext_display.c:static int __init msm_ext_disp_init(void)
platform/msm/msm_ext_display.c:static void __exit msm_ext_disp_exit(void)
platform/msm/msm_ext_display.c:subsys_initcall(msm_ext_disp_init);
platform/msm/msm_ext_display.c:module_exit(msm_ext_disp_exit);
platform/msm/qcom-geni-se.c:#include <linux/msm-bus.h>
platform/msm/qcom-geni-se.c:#include <linux/msm-bus-board.h>
platform/msm/qcom-geni-se.c:	struct msm_bus_client_handle *bus_bw;
platform/msm/qcom-geni-se.c:	struct msm_bus_scale_pdata *pdata;
platform/msm/qcom-geni-se.c:		ret = msm_bus_scale_update_bw(geni_se_dev->bus_bw,
platform/msm/qcom-geni-se.c:			ret = msm_bus_scale_client_update_request
platform/msm/qcom-geni-se.c:		ret = msm_bus_scale_update_bw(geni_se_dev->bus_bw,
platform/msm/qcom-geni-se.c:			ret = msm_bus_scale_client_update_request
platform/msm/qcom-geni-se.c:			msm_bus_scale_register_client(geni_se_dev->pdata);
platform/msm/qcom-geni-se.c:			geni_se_dev->bus_bw = msm_bus_scale_register(
platform/msm/qcom-geni-se.c:static struct msm_bus_scale_pdata *ab_ib_register(struct platform_device *pdev,
platform/msm/qcom-geni-se.c:	struct msm_bus_scale_pdata *pdata = NULL;
platform/msm/qcom-geni-se.c:	struct msm_bus_paths *usecase = NULL;
platform/msm/qcom-geni-se.c:			"qcom,msm-bus,vectors-bus-ids", &len);
platform/msm/qcom-geni-se.c:	pdata = devm_kzalloc(dev, sizeof(struct msm_bus_scale_pdata),
platform/msm/qcom-geni-se.c:	usecase = devm_kzalloc(dev, (sizeof(struct msm_bus_paths) *
platform/msm/qcom-geni-se.c:			sizeof(struct msm_bus_vectors), GFP_KERNEL);
platform/msm/qcom-geni-se.c:	ret = of_property_read_u32(dev->of_node, "qcom,msm-bus,num-paths",
platform/msm/sps/sps.c:#define SPS_DRV_NAME "msm_sps"	/* must match the platform_device name */
platform/msm/sps/sps.c:	struct msm_sps_platform_data *pdata;
platform/msm/sps/sps.c:static const struct of_device_id msm_sps_match[] = {
platform/msm/sps/sps.c:	{	.compatible = "qcom,msm-sps",
platform/msm/sps/sps.c:	{	.compatible = "qcom,msm-sps-4k",
platform/msm/sps/sps.c:static int msm_sps_probe(struct platform_device *pdev)
platform/msm/sps/sps.c:		match = of_match_device(msm_sps_match, &pdev->dev);
platform/msm/sps/sps.c:static int msm_sps_remove(struct platform_device *pdev)
platform/msm/sps/sps.c:static struct platform_driver msm_sps_driver = {
platform/msm/sps/sps.c:	.probe          = msm_sps_probe,
platform/msm/sps/sps.c:		.of_match_table = msm_sps_match,
platform/msm/sps/sps.c:	.remove		= msm_sps_remove,
platform/msm/sps/sps.c:	ret = platform_driver_register(&msm_sps_driver);
platform/msm/sps/sps.c:	platform_driver_unregister(&msm_sps_driver);
platform/msm/sps/spsi.h:#include <linux/msm-sps.h>
platform/msm/Kconfig:	  msm_11ad_proxy.
platform/msm/usb_bam.c:#include <linux/msm-sps.h>
platform/msm/usb_bam.c:#include <linux/usb/msm_hsusb.h>
platform/msm/usb_bam.c: * struct msm_usb_bam_data: pipe connection information
platform/msm/usb_bam.c:struct msm_usb_bam_data {
platform/msm/usb_bam.c:	struct msm_usb_bam_data *usb_bam_data;
platform/msm/usb_bam.c:static struct usb_bam_ctx_type msm_usb_bam[MAX_BAMS];
platform/msm/usb_bam.c:void msm_bam_set_hsic_host_dev(struct device *dev)
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam];
platform/msm/usb_bam.c:void msm_bam_set_usb_host_dev(struct device *dev)
platform/msm/usb_bam.c:static void _msm_bam_host_notify_on_resume(enum usb_ctrl bam_type)
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c: * msm_bam_hsic_host_pipe_empty - Check all HSIC host BAM pipe state
platform/msm/usb_bam.c:bool msm_bam_hsic_host_pipe_empty(void)
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam];
platform/msm/usb_bam.c:EXPORT_SYMBOL(msm_bam_hsic_host_pipe_empty);
platform/msm/usb_bam.c:static bool msm_bam_host_lpm_ok(enum usb_ctrl bam_type)
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:	if (!msm_bam_hsic_host_pipe_empty()) {
platform/msm/usb_bam.c:bool msm_bam_hsic_lpm_ok(void)
platform/msm/usb_bam.c:	return msm_bam_host_lpm_ok(HSIC_CTRL);
platform/msm/usb_bam.c:EXPORT_SYMBOL(msm_bam_hsic_lpm_ok);
platform/msm/usb_bam.c:void msm_bam_hsic_host_notify_on_resume(void)
platform/msm/usb_bam.c:	_msm_bam_host_notify_on_resume(HSIC_CTRL);
platform/msm/usb_bam.c:		strnstr(name, "ci13xxx_msm_hsic", USB_BAM_MAX_STR_LEN))
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[pipe_connect->bam_type];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:static void _msm_bam_wait_for_host_prod_granted(enum usb_ctrl bam_type)
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:void msm_bam_wait_for_hsic_host_prod_granted(void)
platform/msm/usb_bam.c:	_msm_bam_wait_for_host_prod_granted(HSIC_CTRL);
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:			msm_hw_bam_disable(1);
platform/msm/usb_bam.c:			msm_hw_bam_disable(0);
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[pipe_connect->bam_type];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[cur_bam];
platform/msm/usb_bam.c:static struct msm_usb_bam_data *usb_bam_dt_to_data(
platform/msm/usb_bam.c:	struct msm_usb_bam_data *usb_bam_data;
platform/msm/usb_bam.c:	msm_usb_bam[bam].usb_bam_connections = usb_bam_connections;
platform/msm/usb_bam.c:	msm_usb_bam[bam].max_connections = max_connections;
platform/msm/usb_bam.c:static void msm_usb_bam_update_props(struct sps_bam_props *props,
platform/msm/usb_bam.c:	props.user = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:		ctx = &msm_usb_bam[i];
platform/msm/usb_bam.c:	struct msm_usb_bam_data *usb_bam_data;
platform/msm/usb_bam.c:	ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[qdss_usb_bam_type];
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam_type];
platform/msm/usb_bam.c:bool msm_usb_bam_enable(enum usb_ctrl bam, bool bam_enable)
platform/msm/usb_bam.c:	struct msm_usb_bam_data *usb_bam_data;
platform/msm/usb_bam.c:	struct usb_bam_ctx_type *ctx = &msm_usb_bam[bam];
platform/msm/usb_bam.c:		msm_usb_bam_update_props(&props, ctx->usb_bam_pdev);
platform/msm/usb_bam.c:		msm_hw_bam_disable(1);
platform/msm/usb_bam.c:		msm_hw_bam_disable(0);
platform/msm/usb_bam.c:		msm_hw_soft_reset();
platform/msm/usb_bam.c:		msm_hw_bam_disable(1);
platform/msm/usb_bam.c:EXPORT_SYMBOL(msm_usb_bam_enable);
platform/msm/usb_bam.c:	{ .compatible = "qcom,usb-bam-msm",
power/reset/Makefile:obj-$(CONFIG_POWER_RESET_MSM) += msm-poweroff.o
power/reset/Makefile:obj-$(CONFIG_POWER_RESET_QCOM) += msm-poweroff.o
power/reset/msm-poweroff.c:#define DL_MODE_PROP "qcom,msm-imem-download_mode"
power/reset/msm-poweroff.c:#define EDL_MODE_PROP "qcom,msm-imem-emergency_download_mode"
power/reset/msm-poweroff.c:#define IMEM_DL_TYPE_PROP "qcom,msm-imem-dload-type"
power/reset/msm-poweroff.c:#define KASLR_OFFSET_PROP "qcom,msm-imem-kaslr_offset"
power/reset/msm-poweroff.c:#define DISPLAY_CONFIG_OFFSET_PROP "qcom,msm-imem-display_config_offset"
power/reset/msm-poweroff.c:static void __iomem *msm_ps_hold;
power/reset/msm-poweroff.c:		if (!msm_minidump_enabled()) {
power/reset/msm-poweroff.c:		if (!msm_minidump_enabled()) {
power/reset/msm-poweroff.c:void msm_set_restart_mode(int mode)
power/reset/msm-poweroff.c:EXPORT_SYMBOL(msm_set_restart_mode);
power/reset/msm-poweroff.c:static void msm_restart_prepare(const char *cmd)
power/reset/msm-poweroff.c:	__raw_writel(0, msm_ps_hold);
power/reset/msm-poweroff.c:static void do_msm_restart(enum reboot_mode reboot_mode, const char *cmd)
power/reset/msm-poweroff.c:	msm_restart_prepare(cmd);
power/reset/msm-poweroff.c:		msm_trigger_wdog_bite();
power/reset/msm-poweroff.c:static void do_msm_poweroff(void)
power/reset/msm-poweroff.c:static int msm_restart_probe(struct platform_device *pdev)
power/reset/msm-poweroff.c:				"qcom,msm-imem-restart_reason");
power/reset/msm-poweroff.c:	msm_ps_hold = devm_ioremap_resource(dev, mem);
power/reset/msm-poweroff.c:	if (IS_ERR(msm_ps_hold))
power/reset/msm-poweroff.c:		return PTR_ERR(msm_ps_hold);
power/reset/msm-poweroff.c:	pm_power_off = do_msm_poweroff;
power/reset/msm-poweroff.c:	arm_pm_restart = do_msm_restart;
power/reset/msm-poweroff.c:static const struct of_device_id of_msm_restart_match[] = {
power/reset/msm-poweroff.c:MODULE_DEVICE_TABLE(of, of_msm_restart_match);
power/reset/msm-poweroff.c:static struct platform_driver msm_restart_driver = {
power/reset/msm-poweroff.c:	.probe = msm_restart_probe,
power/reset/msm-poweroff.c:		.name = "msm-restart",
power/reset/msm-poweroff.c:		.of_match_table = of_match_ptr(of_msm_restart_match),
power/reset/msm-poweroff.c:static int __init msm_restart_init(void)
power/reset/msm-poweroff.c:	return platform_driver_register(&msm_restart_driver);
power/reset/msm-poweroff.c:pure_initcall(msm_restart_init);
power/supply/qcom/qpnp-linear-charger.c:static enum power_supply_property msm_batt_power_props[] = {
power/supply/qcom/qpnp-linear-charger.c:		chip->batt_psy_d.properties = msm_batt_power_props;
power/supply/qcom/qpnp-linear-charger.c:			ARRAY_SIZE(msm_batt_power_props);
regulator/Makefile:obj-$(CONFIG_REGULATOR_MSM_GFX_LDO) += msm_gfx_ldo.o
regulator/cpr3-regulator.c:#include <linux/regulator/msm-ldo-regulator.h>
regulator/cpr3-regulator.c:				rc = msm_spm_avs_enable_irq(0,
regulator/cpr3-regulator.c:	enum msm_ldo_supply_mode mode;
regulator/cpr3-regulator.c:	enum msm_apm_supply apm_mode;
regulator/cpr3-regulator.c:	apm_mode = msm_apm_get_supply(ctrl->apm);
regulator/cpr3-regulator.c:	enum msm_apm_supply apm_mode;
regulator/cpr3-regulator.c:	apm_mode = msm_apm_get_supply(ctrl->apm);
regulator/cpr3-regulator.c:	enum msm_apm_supply apm_mode;
regulator/cpr3-regulator.c:		apm_mode = msm_apm_get_supply(ctrl->apm);
regulator/cpr3-regulator.c:	rc = msm_apm_set_supply(ctrl->apm, new_volt >= apm_volt
regulator/cpr3-regulator.c:	rc = msm_spm_avs_clear_irq(0, MSM_SPM_AVS_IRQ_MAX);
regulator/cpr3-regulator.c:		rc = msm_spm_avs_enable_irq(0, MSM_SPM_AVS_IRQ_MAX);
regulator/cpr3-regulator.c:		rc = msm_spm_avs_disable_irq(0, MSM_SPM_AVS_IRQ_MAX);
regulator/cpr3-regulator.c:		rc = msm_spm_probe_done();
regulator/cpr3-regulator.c:			msm_spm_avs_disable_irq(0, MSM_SPM_AVS_IRQ_MAX);
regulator/cpr3-regulator.h:#include <linux/regulator/msm-ldo-regulator.h>
regulator/cpr3-regulator.h:	enum msm_ldo_supply_mode ldo_regulator_bypass;
regulator/cpr3-regulator.h:	struct msm_apm_ctrl_dev *apm;
regulator/cpr3-regulator.h:	enum msm_apm_supply	apm_high_supply;
regulator/cpr3-regulator.h:	enum msm_apm_supply	apm_low_supply;
regulator/cpr3-util.c:	ctrl->apm = msm_apm_ctrl_dev_get(ctrl->dev);
regulator/cpr4-mmss-ldo-regulator.c:#include <linux/regulator/msm-ldo-regulator.h>
regulator/cprh-kbss-regulator.c:enum cprh_msm8998_kbss_fuse_corner {
regulator/cprh-kbss-regulator.c:static const char * const cprh_msm8998_kbss_fuse_corner_name[] = {
regulator/cprh-kbss-regulator.c:msm8998_kbss_ro_sel_param[2][MSM8998_KBSS_FUSE_CORNERS][2] = {
regulator/cprh-kbss-regulator.c:msm8998_kbss_init_voltage_param[2][MSM8998_KBSS_FUSE_CORNERS][2] = {
regulator/cprh-kbss-regulator.c:msm8998_kbss_target_quot_param[2][MSM8998_KBSS_FUSE_CORNERS][3] = {
regulator/cprh-kbss-regulator.c:msm8998_kbss_quot_offset_param[2][MSM8998_KBSS_FUSE_CORNERS][3] = {
regulator/cprh-kbss-regulator.c:static const struct cpr3_fuse_param msm8998_cpr_fusing_rev_param[] = {
regulator/cprh-kbss-regulator.c:msm8998_cpr_force_highest_corner_param[] = {
regulator/cprh-kbss-regulator.c:msm8998_kbss_aging_init_quot_diff_param[2][2] = {
regulator/cprh-kbss-regulator.c:msm8998_v1_kbss_fuse_ref_volt[MSM8998_KBSS_FUSE_CORNERS] = {
regulator/cprh-kbss-regulator.c:msm8998_v2_kbss_fuse_ref_volt[2][MSM8998_KBSS_FUSE_CORNERS] = {
regulator/cprh-kbss-regulator.c: * msm8998 configuration
regulator/cprh-kbss-regulator.c: * cprh_msm8998_kbss_read_fuse_data() - load msm8998 KBSS specific fuse
regulator/cprh-kbss-regulator.c:static int cprh_msm8998_kbss_read_fuse_data(struct cpr3_regulator *vreg,
regulator/cprh-kbss-regulator.c:	rc = cpr3_read_fuse_param(base, msm8998_cpr_fusing_rev_param,
regulator/cprh-kbss-regulator.c:				msm8998_kbss_init_voltage_param[id][i],
regulator/cprh-kbss-regulator.c:				msm8998_kbss_target_quot_param[id][i],
regulator/cprh-kbss-regulator.c:				msm8998_kbss_ro_sel_param[id][i],
regulator/cprh-kbss-regulator.c:				msm8998_kbss_quot_offset_param[id][i],
regulator/cprh-kbss-regulator.c:				msm8998_kbss_aging_init_quot_diff_param[id],
regulator/cprh-kbss-regulator.c:			  msm8998_cpr_force_highest_corner_param,
regulator/cprh-kbss-regulator.c:		rc = cprh_msm8998_kbss_read_fuse_data(vreg, fuse);
regulator/cprh-kbss-regulator.c:			cpr3_err(vreg, "msm8998 kbss fuse data read failed, rc=%d\n",
regulator/cprh-kbss-regulator.c:		ref_volt = msm8998_v1_kbss_fuse_ref_volt;
regulator/cprh-kbss-regulator.c:		corner_name = cprh_msm8998_kbss_fuse_corner_name;
regulator/cprh-kbss-regulator.c:		ref_volt = msm8998_v2_kbss_fuse_ref_volt[id];
regulator/cprh-kbss-regulator.c:		corner_name = cprh_msm8998_kbss_fuse_corner_name;
regulator/cprh-kbss-regulator.c: * cprh_msm8998_partial_binning_override() - override the voltage and quotient
regulator/cprh-kbss-regulator.c:static int cprh_msm8998_partial_binning_override(struct cpr3_regulator *vreg)
regulator/cprh-kbss-regulator.c:		corner_name = cprh_msm8998_kbss_fuse_corner_name;
regulator/cprh-kbss-regulator.c:	rc = cprh_msm8998_partial_binning_override(vreg);
regulator/cprh-kbss-regulator.c:		.compatible =  "qcom,cprh-msm8998-v1-kbss-regulator",
regulator/cprh-kbss-regulator.c:		.compatible = "qcom,cprh-msm8998-v2-kbss-regulator",
regulator/cprh-kbss-regulator.c:		.compatible = "qcom,cprh-msm8998-kbss-regulator",
regulator/msm_gfx_ldo.c:#include <linux/regulator/msm-ldo-regulator.h>
regulator/msm_gfx_ldo.c:struct msm_gfx_ldo {
regulator/msm_gfx_ldo.c:	enum msm_ldo_supply_mode mode;
regulator/msm_gfx_ldo.c:static struct ldo_config msm8953_ldo_config[] = {
regulator/msm_gfx_ldo.c:static struct fuse_param msm8953_ldo_enable_param[] = {
regulator/msm_gfx_ldo.c:msm8953_init_voltage_param[MSM8953_LDO_FUSE_CORNERS][2] = {
regulator/msm_gfx_ldo.c:static const int msm8953_fuse_ref_volt[MSM8953_LDO_FUSE_CORNERS] = {
regulator/msm_gfx_ldo.c:static enum msm_ldo_supply_mode get_operating_mode(struct msm_gfx_ldo *ldo_vreg,
regulator/msm_gfx_ldo.c:static void dump_registers(struct msm_gfx_ldo *ldo_vreg, char *func)
regulator/msm_gfx_ldo.c:static void configure_ldo_voltage(struct msm_gfx_ldo *ldo_vreg, int new_uv)
regulator/msm_gfx_ldo.c:static int ldo_update_voltage(struct msm_gfx_ldo *ldo_vreg, int new_uv)
regulator/msm_gfx_ldo.c:static int enable_ldo_mode(struct msm_gfx_ldo *ldo_vreg, int new_uv)
regulator/msm_gfx_ldo.c:static int enable_bhs_mode(struct msm_gfx_ldo *ldo_vreg)
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_corner_enable(struct regulator_dev *rdev)
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg  = rdev_get_drvdata(rdev);
regulator/msm_gfx_ldo.c:	enum msm_ldo_supply_mode enable_mode;
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_disable(struct regulator_dev *rdev)
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg  = rdev_get_drvdata(rdev);
regulator/msm_gfx_ldo.c:static int switch_mode_to_ldo(struct msm_gfx_ldo *ldo_vreg, int new_uv)
regulator/msm_gfx_ldo.c:static int switch_mode_to_bhs(struct msm_gfx_ldo *ldo_vreg)
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_set_corner(struct regulator_dev *rdev,
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg  = rdev_get_drvdata(rdev);
regulator/msm_gfx_ldo.c:	enum msm_ldo_supply_mode new_mode;
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_get_corner(struct regulator_dev *rdev)
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg  = rdev_get_drvdata(rdev);
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_is_enabled(struct regulator_dev *rdev)
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg  = rdev_get_drvdata(rdev);
regulator/msm_gfx_ldo.c:static struct regulator_ops msm_gfx_ldo_corner_ops = {
regulator/msm_gfx_ldo.c:	.enable		= msm_gfx_ldo_corner_enable,
regulator/msm_gfx_ldo.c:	.disable	= msm_gfx_ldo_disable,
regulator/msm_gfx_ldo.c:	.is_enabled	= msm_gfx_ldo_is_enabled,
regulator/msm_gfx_ldo.c:	.set_voltage	= msm_gfx_ldo_set_corner,
regulator/msm_gfx_ldo.c:	.get_voltage	= msm_gfx_ldo_get_corner,
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_get_bypass(struct regulator_dev *rdev,
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg = rdev_get_drvdata(rdev);
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_set_bypass(struct regulator_dev *rdev,
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg = rdev_get_drvdata(rdev);
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_voltage_enable(struct regulator_dev *rdev)
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg = rdev_get_drvdata(rdev);
regulator/msm_gfx_ldo.c:	enum msm_ldo_supply_mode enable_mode;
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_set_voltage(struct regulator_dev *rdev,
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg = rdev_get_drvdata(rdev);
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_get_voltage(struct regulator_dev *rdev)
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg = rdev_get_drvdata(rdev);
regulator/msm_gfx_ldo.c:static struct regulator_ops msm_gfx_ldo_voltage_ops = {
regulator/msm_gfx_ldo.c:	.enable		= msm_gfx_ldo_voltage_enable,
regulator/msm_gfx_ldo.c:	.disable	= msm_gfx_ldo_disable,
regulator/msm_gfx_ldo.c:	.is_enabled	= msm_gfx_ldo_is_enabled,
regulator/msm_gfx_ldo.c:	.set_voltage	= msm_gfx_ldo_set_voltage,
regulator/msm_gfx_ldo.c:	.get_voltage	= msm_gfx_ldo_get_voltage,
regulator/msm_gfx_ldo.c:	.set_bypass	= msm_gfx_ldo_set_bypass,
regulator/msm_gfx_ldo.c:	.get_bypass	= msm_gfx_ldo_get_bypass,
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_adjust_init_voltage(struct msm_gfx_ldo *ldo_vreg)
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_voltage_init(struct msm_gfx_ldo *ldo_vreg)
regulator/msm_gfx_ldo.c:	rc = msm_gfx_ldo_adjust_init_voltage(ldo_vreg);
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_efuse_init(struct platform_device *pdev,
regulator/msm_gfx_ldo.c:				struct msm_gfx_ldo *ldo_vreg)
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_mem_acc_init(struct msm_gfx_ldo *ldo_vreg)
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_init(struct platform_device *pdev,
regulator/msm_gfx_ldo.c:				struct msm_gfx_ldo *ldo_vreg)
regulator/msm_gfx_ldo.c:static int ldo_parse_cx_parameters(struct msm_gfx_ldo *ldo_vreg)
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_parse_dt(struct msm_gfx_ldo *ldo_vreg)
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_target_init(struct msm_gfx_ldo *ldo_vreg)
regulator/msm_gfx_ldo.c:				msm8953_init_voltage_param[i];
regulator/msm_gfx_ldo.c:	ldo_vreg->ref_volt = msm8953_fuse_ref_volt;
regulator/msm_gfx_ldo.c:	ldo_vreg->ldo_enable_param = msm8953_ldo_enable_param;
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg = data;
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg = data;
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg = data;
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg = data;
regulator/msm_gfx_ldo.c:static ssize_t msm_gfx_ldo_debug_info_read(struct file *file, char __user *buff,
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg = file->private_data;
regulator/msm_gfx_ldo.c:static const struct file_operations msm_gfx_ldo_debug_info_fops = {
regulator/msm_gfx_ldo.c:	.read = msm_gfx_ldo_debug_info_read,
regulator/msm_gfx_ldo.c:static void msm_gfx_ldo_debugfs_init(struct msm_gfx_ldo *ldo_vreg)
regulator/msm_gfx_ldo.c:	ldo_vreg->debugfs = debugfs_create_dir("msm_gfx_ldo", NULL);
regulator/msm_gfx_ldo.c:					ldo_vreg, &msm_gfx_ldo_debug_info_fops);
regulator/msm_gfx_ldo.c:static void msm_gfx_ldo_debugfs_remove(struct msm_gfx_ldo *ldo_vreg)
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_corner_config_init(struct msm_gfx_ldo *ldo_vreg,
regulator/msm_gfx_ldo.c:	rc = msm_gfx_ldo_target_init(ldo_vreg);
regulator/msm_gfx_ldo.c:	rc = msm_gfx_ldo_parse_dt(ldo_vreg);
regulator/msm_gfx_ldo.c:	rc = msm_gfx_ldo_efuse_init(pdev, ldo_vreg);
regulator/msm_gfx_ldo.c:	rc = msm_gfx_ldo_voltage_init(ldo_vreg);
regulator/msm_gfx_ldo.c:	rc = msm_gfx_ldo_mem_acc_init(ldo_vreg);
regulator/msm_gfx_ldo.c:static const struct of_device_id msm_gfx_ldo_match_table[] = {
regulator/msm_gfx_ldo.c:		.compatible = "qcom,msm8953-gfx-ldo",
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_probe(struct platform_device *pdev)
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg;
regulator/msm_gfx_ldo.c:	match = of_match_device(msm_gfx_ldo_match_table, dev);
regulator/msm_gfx_ldo.c:		ldo_vreg->ldo_init_config = msm8953_ldo_config;
regulator/msm_gfx_ldo.c:		rc = msm_gfx_ldo_corner_config_init(ldo_vreg, pdev);
regulator/msm_gfx_ldo.c:	rc = msm_gfx_ldo_init(pdev, ldo_vreg);
regulator/msm_gfx_ldo.c:		rdesc->ops = &msm_gfx_ldo_corner_ops;
regulator/msm_gfx_ldo.c:		rdesc->ops = &msm_gfx_ldo_voltage_ops;
regulator/msm_gfx_ldo.c:	msm_gfx_ldo_debugfs_init(ldo_vreg);
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_remove(struct platform_device *pdev)
regulator/msm_gfx_ldo.c:	struct msm_gfx_ldo *ldo_vreg = platform_get_drvdata(pdev);
regulator/msm_gfx_ldo.c:	msm_gfx_ldo_debugfs_remove(ldo_vreg);
regulator/msm_gfx_ldo.c:static struct platform_driver msm_gfx_ldo_driver = {
regulator/msm_gfx_ldo.c:		.name		= "qcom,msm-gfx-ldo",
regulator/msm_gfx_ldo.c:		.of_match_table = msm_gfx_ldo_match_table,
regulator/msm_gfx_ldo.c:	.probe		= msm_gfx_ldo_probe,
regulator/msm_gfx_ldo.c:	.remove		= msm_gfx_ldo_remove,
regulator/msm_gfx_ldo.c:static int msm_gfx_ldo_platform_init(void)
regulator/msm_gfx_ldo.c:	return platform_driver_register(&msm_gfx_ldo_driver);
regulator/msm_gfx_ldo.c:arch_initcall(msm_gfx_ldo_platform_init);
regulator/msm_gfx_ldo.c:static void msm_gfx_ldo_platform_exit(void)
regulator/msm_gfx_ldo.c:	platform_driver_unregister(&msm_gfx_ldo_driver);
regulator/msm_gfx_ldo.c:module_exit(msm_gfx_ldo_platform_exit);
regulator/rpm-smd-regulator.c:	struct msm_rpm_request	*handle_active;
regulator/rpm-smd-regulator.c:	struct msm_rpm_request	*handle_sleep;
regulator/rpm-smd-regulator.c:	struct msm_rpm_request *handle;
regulator/rpm-smd-regulator.c:		return msm_rpm_add_kvp_data_noirq(handle, params[idx].key,
regulator/rpm-smd-regulator.c:		return msm_rpm_add_kvp_data(handle, params[idx].key,
regulator/rpm-smd-regulator.c:	struct msm_rpm_request *handle
regulator/rpm-smd-regulator.c:		rc = msm_rpm_wait_for_ack_noirq(msm_rpm_send_request_noirq(
regulator/rpm-smd-regulator.c:		rc = msm_rpm_wait_for_ack(msm_rpm_send_request(handle));
regulator/rpm-smd-regulator.c:		temp = msm_rpm_send_request_noack(handle);
regulator/rpm-smd-regulator.c:			"msm rpm send failed: %s %u; set=%s, rc=%d\n",
regulator/rpm-smd-regulator.c:		msm_rpm_free_request(rpm_vreg->handle_active);
regulator/rpm-smd-regulator.c:		msm_rpm_free_request(rpm_vreg->handle_sleep);
regulator/rpm-smd-regulator.c:	rpm_vreg->handle_active = msm_rpm_create_request(RPM_SET_ACTIVE,
regulator/rpm-smd-regulator.c:	rpm_vreg->handle_sleep = msm_rpm_create_request(RPM_SET_SLEEP,
regulator/rpm-smd-regulator.c:	msm_rpm_free_request(rpm_vreg->handle_sleep);
regulator/rpm-smd-regulator.c:	msm_rpm_free_request(rpm_vreg->handle_active);
regulator/spm-regulator.c:		vlevel = msm_spm_get_vdd(vreg->cpu_num);
regulator/spm-regulator.c:			pr_debug("%s: msm_spm_get_vdd failed, rc=%d; falling back on SPMI read\n",
regulator/spm-regulator.c:		rc = msm_spm_set_vdd(vreg->cpu_num, vlevel);
regulator/spm-regulator.c:			pr_debug("%s: msm_spm_set_vdd failed, rc=%d; falling back on SPMI write\n",
regulator/spm-regulator.c:		rc = msm_spm_avs_set_limit(vreg->cpu_num, vlevel_min,
regulator/spm-regulator.c:		rc = msm_spm_avs_enable(vreg->cpu_num);
regulator/spm-regulator.c:		rc = msm_spm_avs_disable(vreg->cpu_num);
regulator/spm-regulator.c:		rc = msm_spm_set_vdd(vreg->cpu_num, vreg->vlevel);
regulator/spm-regulator.c:			pr_err("%s: msm_spm_set_vdd failed, rc=%d\n",
regulator/spm-regulator.c:		rc = msm_spm_probe_done();
remoteproc/qcom_adsp_pil.c:	{ .compatible = "qcom,msm8974-adsp-pil", .data = &adsp_resource_init},
remoteproc/qcom_adsp_pil.c:	{ .compatible = "qcom,msm8996-adsp-pil", .data = &adsp_resource_init},
remoteproc/qcom_adsp_pil.c:	{ .compatible = "qcom,msm8996-slpi-pil", .data = &slpi_resource_init},
remoteproc/qcom_q6v5_pil.c:static const struct rproc_hexagon_res msm8996_mss = {
remoteproc/qcom_q6v5_pil.c:static const struct rproc_hexagon_res msm8916_mss = {
remoteproc/qcom_q6v5_pil.c:static const struct rproc_hexagon_res msm8974_mss = {
remoteproc/qcom_q6v5_pil.c:	{ .compatible = "qcom,q6v5-pil", .data = &msm8916_mss},
remoteproc/qcom_q6v5_pil.c:	{ .compatible = "qcom,msm8916-mss-pil", .data = &msm8916_mss},
remoteproc/qcom_q6v5_pil.c:	{ .compatible = "qcom,msm8974-mss-pil", .data = &msm8974_mss},
remoteproc/qcom_q6v5_pil.c:	{ .compatible = "qcom,msm8996-mss-pil", .data = &msm8996_mss},
rpmsg/rpm-smd.c:static int msm_rpm_debug_mask;
rpmsg/rpm-smd.c:	debug_mask, msm_rpm_debug_mask, int, 0644
rpmsg/rpm-smd.c:struct msm_rpm_driver_data {
rpmsg/rpm-smd.c:static ATOMIC_NOTIFIER_HEAD(msm_rpm_sleep_notifier);
rpmsg/rpm-smd.c:static void msm_rpm_process_ack(uint32_t msg_id, int errno);
rpmsg/rpm-smd.c:int msm_rpm_register_notifier(struct notifier_block *nb)
rpmsg/rpm-smd.c:	return atomic_notifier_chain_register(&msm_rpm_sleep_notifier, nb);
rpmsg/rpm-smd.c:int msm_rpm_unregister_notifier(struct notifier_block *nb)
rpmsg/rpm-smd.c:	return atomic_notifier_chain_unregister(&msm_rpm_sleep_notifier, nb);
rpmsg/rpm-smd.c:static const uint32_t msm_rpm_request_service_v1[MSM_RPM_MSG_TYPE_NR] = {
rpmsg/rpm-smd.c:} msm_rpm_request_service_v2;
rpmsg/rpm-smd.c:	enum msm_rpm_set set;
rpmsg/rpm-smd.c:struct msm_rpm_ack_msg_v0 {
rpmsg/rpm-smd.c:struct msm_rpm_ack_msg_v1 {
rpmsg/rpm-smd.c:struct msm_rpm_kvp_data {
rpmsg/rpm-smd.c:static uint32_t msm_rpm_get_next_msg_id(void);
rpmsg/rpm-smd.c:		return ((struct msm_rpm_ack_msg_v0 *)buf)->id_ack;
rpmsg/rpm-smd.c:	return ((struct msm_rpm_ack_msg_v1 *)buf)->id_ack;
rpmsg/rpm-smd.c:		return ((struct msm_rpm_ack_msg_v0 *)buf)->req_len;
rpmsg/rpm-smd.c:	return get_offset_value(((struct msm_rpm_ack_msg_v1 *)buf)->
rpmsg/rpm-smd.c:		return ((struct msm_rpm_ack_msg_v0 *)buf)->req;
rpmsg/rpm-smd.c:	return get_offset_value(((struct msm_rpm_ack_msg_v1 *)buf)->
rpmsg/rpm-smd.c:			msm_rpm_request_service_v1[val];
rpmsg/rpm-smd.c:static atomic_t msm_rpm_msg_id = ATOMIC_INIT(0);
rpmsg/rpm-smd.c:struct msm_rpm_request {
rpmsg/rpm-smd.c:	struct msm_rpm_kvp_data *kvp;
rpmsg/rpm-smd.c:LIST_HEAD(msm_rpm_wait_list);
rpmsg/rpm-smd.c:struct msm_rpm_wait_data {
rpmsg/rpm-smd.c:DEFINE_SPINLOCK(msm_rpm_list_lock);
rpmsg/rpm-smd.c:LIST_HEAD(msm_rpm_ack_list);
rpmsg/rpm-smd.c:static inline uint32_t msm_rpm_get_msg_id_from_ack(uint8_t *buf)
rpmsg/rpm-smd.c:static inline int msm_rpm_get_error_from_ack(uint8_t *buf)
rpmsg/rpm-smd.c:			sizeof(struct msm_rpm_ack_msg_v1) :
rpmsg/rpm-smd.c:			sizeof(struct msm_rpm_ack_msg_v0);
rpmsg/rpm-smd.c:		err = *(uint32_t *)(buf + sizeof(struct msm_rpm_ack_msg_v1));
rpmsg/rpm-smd.c:int msm_rpm_smd_buffer_request(struct msm_rpm_request *cdata,
rpmsg/rpm-smd.c:static struct msm_rpm_driver_data msm_rpm_data = {
rpmsg/rpm-smd.c:	.smd_open = COMPLETION_INITIALIZER(msm_rpm_data.smd_open),
rpmsg/rpm-smd.c:static int msm_rpm_trysend_smd_buffer(char *buf, uint32_t size)
rpmsg/rpm-smd.c:static int msm_rpm_flush_requests(bool print)
rpmsg/rpm-smd.c:		set_msg_id(s->buf, msm_rpm_get_next_msg_id());
rpmsg/rpm-smd.c:		ret = msm_rpm_trysend_smd_buffer(s->buf, get_buf_len(s->buf));
rpmsg/rpm-smd.c:static void msm_rpm_notify_sleep_chain(char *buf,
rpmsg/rpm-smd.c:		struct msm_rpm_kvp_data *kvp)
rpmsg/rpm-smd.c:	struct msm_rpm_notifier_data notif;
rpmsg/rpm-smd.c:	atomic_notifier_call_chain(&msm_rpm_sleep_notifier, 0, &notif);
rpmsg/rpm-smd.c:static int msm_rpm_add_kvp_data_common(struct msm_rpm_request *handle,
rpmsg/rpm-smd.c:static struct msm_rpm_request *msm_rpm_create_request_common(
rpmsg/rpm-smd.c:		enum msm_rpm_set set, uint32_t rsc_type, uint32_t rsc_id,
rpmsg/rpm-smd.c:	struct msm_rpm_request *cdata;
rpmsg/rpm-smd.c:	cdata = kzalloc(sizeof(struct msm_rpm_request), GFP_NOIO);
rpmsg/rpm-smd.c:	cdata->kvp = kcalloc(num_elements, sizeof(struct msm_rpm_kvp_data),
rpmsg/rpm-smd.c:void msm_rpm_free_request(struct msm_rpm_request *handle)
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_free_request);
rpmsg/rpm-smd.c:struct msm_rpm_request *msm_rpm_create_request(
rpmsg/rpm-smd.c:		enum msm_rpm_set set, uint32_t rsc_type,
rpmsg/rpm-smd.c:	return msm_rpm_create_request_common(set, rsc_type, rsc_id,
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_create_request);
rpmsg/rpm-smd.c:int msm_rpm_add_kvp_data(struct msm_rpm_request *handle,
rpmsg/rpm-smd.c:	return msm_rpm_add_kvp_data_common(handle, key, data, size);
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_add_kvp_data);
rpmsg/rpm-smd.c:int msm_rpm_add_kvp_data_noirq(struct msm_rpm_request *handle,
rpmsg/rpm-smd.c:	return msm_rpm_add_kvp_data_common(handle, key, data, size);
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_add_kvp_data_noirq);
rpmsg/rpm-smd.c:bool msm_rpm_waiting_for_ack(void)
rpmsg/rpm-smd.c:	spin_lock_irqsave(&msm_rpm_list_lock, flags);
rpmsg/rpm-smd.c:	ret = list_empty(&msm_rpm_wait_list);
rpmsg/rpm-smd.c:	spin_unlock_irqrestore(&msm_rpm_list_lock, flags);
rpmsg/rpm-smd.c:static struct msm_rpm_wait_data *msm_rpm_get_entry_from_msg_id(uint32_t msg_id)
rpmsg/rpm-smd.c:	struct msm_rpm_wait_data *elem = NULL;
rpmsg/rpm-smd.c:	spin_lock_irqsave(&msm_rpm_list_lock, flags);
rpmsg/rpm-smd.c:	list_for_each(ptr, &msm_rpm_wait_list) {
rpmsg/rpm-smd.c:		elem = list_entry(ptr, struct msm_rpm_wait_data, list);
rpmsg/rpm-smd.c:	spin_unlock_irqrestore(&msm_rpm_list_lock, flags);
rpmsg/rpm-smd.c:static uint32_t msm_rpm_get_next_msg_id(void)
rpmsg/rpm-smd.c:		id = atomic_inc_return(&msm_rpm_msg_id);
rpmsg/rpm-smd.c:	} while ((id == 0) || (id == 1) || msm_rpm_get_entry_from_msg_id(id));
rpmsg/rpm-smd.c:static int msm_rpm_add_wait_list(uint32_t msg_id, bool delete_on_ack)
rpmsg/rpm-smd.c:	struct msm_rpm_wait_data *data =
rpmsg/rpm-smd.c:		kzalloc(sizeof(struct msm_rpm_wait_data), GFP_ATOMIC);
rpmsg/rpm-smd.c:	spin_lock_irqsave(&msm_rpm_list_lock, flags);
rpmsg/rpm-smd.c:		list_add_tail(&data->list, &msm_rpm_wait_list);
rpmsg/rpm-smd.c:		list_add(&data->list, &msm_rpm_wait_list);
rpmsg/rpm-smd.c:	spin_unlock_irqrestore(&msm_rpm_list_lock, flags);
rpmsg/rpm-smd.c:static void msm_rpm_free_list_entry(struct msm_rpm_wait_data *elem)
rpmsg/rpm-smd.c:	spin_lock_irqsave(&msm_rpm_list_lock, flags);
rpmsg/rpm-smd.c:	spin_unlock_irqrestore(&msm_rpm_list_lock, flags);
rpmsg/rpm-smd.c:static void msm_rpm_process_ack(uint32_t msg_id, int errno)
rpmsg/rpm-smd.c:	struct msm_rpm_wait_data *elem = NULL;
rpmsg/rpm-smd.c:	spin_lock_irqsave(&msm_rpm_list_lock, flags);
rpmsg/rpm-smd.c:	list_for_each_safe(ptr, next, &msm_rpm_wait_list) {
rpmsg/rpm-smd.c:		elem = list_entry(ptr, struct msm_rpm_wait_data, list);
rpmsg/rpm-smd.c:	spin_unlock_irqrestore(&msm_rpm_list_lock, flags);
rpmsg/rpm-smd.c:struct msm_rpm_kvp_packet {
rpmsg/rpm-smd.c:static void msm_rpm_log_request(struct msm_rpm_request *cdata)
rpmsg/rpm-smd.c:	if (msm_rpm_debug_mask & MSM_RPM_LOG_REQUEST_SHOW_MSG_ID)
rpmsg/rpm-smd.c:	if ((msm_rpm_debug_mask & MSM_RPM_LOG_REQUEST_PRETTY)
rpmsg/rpm-smd.c:	    && (msm_rpm_debug_mask & MSM_RPM_LOG_REQUEST_RAW)) {
rpmsg/rpm-smd.c:	} else if (msm_rpm_debug_mask & MSM_RPM_LOG_REQUEST_PRETTY) {
rpmsg/rpm-smd.c:static int msm_rpm_send_data(struct msm_rpm_request *cdata,
rpmsg/rpm-smd.c:			msm_rpm_notify_sleep_chain(cdata->client_buf,
rpmsg/rpm-smd.c:		!msm_rpm_smd_buffer_request(cdata, msg_size, GFP_NOIO)) {
rpmsg/rpm-smd.c:	msg_id = msm_rpm_get_next_msg_id();
rpmsg/rpm-smd.c:	if (msm_rpm_debug_mask
rpmsg/rpm-smd.c:		msm_rpm_log_request(cdata);
rpmsg/rpm-smd.c:	msm_rpm_add_wait_list(msg_id, noack);
rpmsg/rpm-smd.c:		struct msm_rpm_wait_data *rc;
rpmsg/rpm-smd.c:		rc = msm_rpm_get_entry_from_msg_id(msg_id);
rpmsg/rpm-smd.c:			msm_rpm_free_list_entry(rc);
rpmsg/rpm-smd.c:static int _msm_rpm_send_request(struct msm_rpm_request *handle, bool noack)
rpmsg/rpm-smd.c:	ret = msm_rpm_send_data(handle, MSM_RPM_MSG_REQUEST_TYPE, noack);
rpmsg/rpm-smd.c:int msm_rpm_send_request_noirq(struct msm_rpm_request *handle)
rpmsg/rpm-smd.c:	return _msm_rpm_send_request(handle, false);
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_send_request_noirq);
rpmsg/rpm-smd.c:int msm_rpm_send_request(struct msm_rpm_request *handle)
rpmsg/rpm-smd.c:	return _msm_rpm_send_request(handle, false);
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_send_request);
rpmsg/rpm-smd.c:void *msm_rpm_send_request_noack(struct msm_rpm_request *handle)
rpmsg/rpm-smd.c:	ret = _msm_rpm_send_request(handle, true);
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_send_request_noack);
rpmsg/rpm-smd.c:int msm_rpm_wait_for_ack(uint32_t msg_id)
rpmsg/rpm-smd.c:	struct msm_rpm_wait_data *elem;
rpmsg/rpm-smd.c:	elem = msm_rpm_get_entry_from_msg_id(msg_id);
rpmsg/rpm-smd.c:	msm_rpm_free_list_entry(elem);
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_wait_for_ack);
rpmsg/rpm-smd.c:int msm_rpm_wait_for_ack_noirq(uint32_t msg_id)
rpmsg/rpm-smd.c:	return msm_rpm_wait_for_ack(msg_id);
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_wait_for_ack_noirq);
rpmsg/rpm-smd.c:void *msm_rpm_send_message_noack(enum msm_rpm_set set, uint32_t rsc_type,
rpmsg/rpm-smd.c:		uint32_t rsc_id, struct msm_rpm_kvp *kvp, int nelems)
rpmsg/rpm-smd.c:	struct msm_rpm_request *req =
rpmsg/rpm-smd.c:		msm_rpm_create_request_common(set, rsc_type, rsc_id, nelems);
rpmsg/rpm-smd.c:		rc = msm_rpm_add_kvp_data(req, kvp[i].key,
rpmsg/rpm-smd.c:	rc = PTR_ERR(msm_rpm_send_request_noack(req));
rpmsg/rpm-smd.c:	msm_rpm_free_request(req);
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_send_message_noack);
rpmsg/rpm-smd.c:int msm_rpm_send_message(enum msm_rpm_set set, uint32_t rsc_type,
rpmsg/rpm-smd.c:		uint32_t rsc_id, struct msm_rpm_kvp *kvp, int nelems)
rpmsg/rpm-smd.c:	struct msm_rpm_request *req =
rpmsg/rpm-smd.c:		msm_rpm_create_request(set, rsc_type, rsc_id, nelems);
rpmsg/rpm-smd.c:		rc = msm_rpm_add_kvp_data(req, kvp[i].key,
rpmsg/rpm-smd.c:	rc = msm_rpm_wait_for_ack(msm_rpm_send_request(req));
rpmsg/rpm-smd.c:	msm_rpm_free_request(req);
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_send_message);
rpmsg/rpm-smd.c:int msm_rpm_send_message_noirq(enum msm_rpm_set set, uint32_t rsc_type,
rpmsg/rpm-smd.c:			uint32_t rsc_id, struct msm_rpm_kvp *kvp, int nelems)
rpmsg/rpm-smd.c:	return msm_rpm_send_message(set, rsc_type, rsc_id, kvp, nelems);
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_send_message_noirq);
rpmsg/rpm-smd.c:int msm_rpm_enter_sleep(bool print, const struct cpumask *cpumask)
rpmsg/rpm-smd.c:		ret = msm_rpm_flush_requests(print);
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_enter_sleep);
rpmsg/rpm-smd.c:void msm_rpm_exit_sleep(void)
rpmsg/rpm-smd.c:EXPORT_SYMBOL(msm_rpm_exit_sleep);
rpmsg/rpm-smd.c:	struct msm_rpm_wait_data *elem;
rpmsg/rpm-smd.c:	msg_id = msm_rpm_get_msg_id_from_ack(buf);
rpmsg/rpm-smd.c:	errno = msm_rpm_get_error_from_ack(buf);
rpmsg/rpm-smd.c:	elem = msm_rpm_get_entry_from_msg_id(msg_id);
rpmsg/rpm-smd.c:	msm_rpm_process_ack(msg_id, errno);
rpmsg/rpm-smd.c:int __init msm_rpm_driver_init(void)
rpmsg/rpm-smd.c:postcore_initcall_sync(msm_rpm_driver_init);
rtc/Kconfig:	  will be called rtc-msm6242.
rtc/Makefile:obj-$(CONFIG_RTC_DRV_MSM6242)	+= rtc-msm6242.o
rtc/rtc-msm6242.c:struct msm6242_priv {
rtc/rtc-msm6242.c:static inline unsigned int msm6242_read(struct msm6242_priv *priv,
rtc/rtc-msm6242.c:static inline void msm6242_write(struct msm6242_priv *priv, unsigned int val,
rtc/rtc-msm6242.c:static inline void msm6242_set(struct msm6242_priv *priv, unsigned int val,
rtc/rtc-msm6242.c:	msm6242_write(priv, msm6242_read(priv, reg) | val, reg);
rtc/rtc-msm6242.c:static inline void msm6242_clear(struct msm6242_priv *priv, unsigned int val,
rtc/rtc-msm6242.c:	msm6242_write(priv, msm6242_read(priv, reg) & ~val, reg);
rtc/rtc-msm6242.c:static void msm6242_lock(struct msm6242_priv *priv)
rtc/rtc-msm6242.c:	msm6242_set(priv, MSM6242_CD_HOLD, MSM6242_CD);
rtc/rtc-msm6242.c:	while ((msm6242_read(priv, MSM6242_CD) & MSM6242_CD_BUSY) && cnt) {
rtc/rtc-msm6242.c:		msm6242_clear(priv, MSM6242_CD_HOLD, MSM6242_CD);
rtc/rtc-msm6242.c:		msm6242_set(priv, MSM6242_CD_HOLD, MSM6242_CD);
rtc/rtc-msm6242.c:			msm6242_read(priv, MSM6242_CD));
rtc/rtc-msm6242.c:static void msm6242_unlock(struct msm6242_priv *priv)
rtc/rtc-msm6242.c:	msm6242_clear(priv, MSM6242_CD_HOLD, MSM6242_CD);
rtc/rtc-msm6242.c:static int msm6242_read_time(struct device *dev, struct rtc_time *tm)
rtc/rtc-msm6242.c:	struct msm6242_priv *priv = dev_get_drvdata(dev);
rtc/rtc-msm6242.c:	msm6242_lock(priv);
rtc/rtc-msm6242.c:	tm->tm_sec  = msm6242_read(priv, MSM6242_SECOND10) * 10 +
rtc/rtc-msm6242.c:		      msm6242_read(priv, MSM6242_SECOND1);
rtc/rtc-msm6242.c:	tm->tm_min  = msm6242_read(priv, MSM6242_MINUTE10) * 10 +
rtc/rtc-msm6242.c:		      msm6242_read(priv, MSM6242_MINUTE1);
rtc/rtc-msm6242.c:	tm->tm_hour = (msm6242_read(priv, MSM6242_HOUR10) &
rtc/rtc-msm6242.c:		      msm6242_read(priv, MSM6242_HOUR1);
rtc/rtc-msm6242.c:	tm->tm_mday = msm6242_read(priv, MSM6242_DAY10) * 10 +
rtc/rtc-msm6242.c:		      msm6242_read(priv, MSM6242_DAY1);
rtc/rtc-msm6242.c:	tm->tm_wday = msm6242_read(priv, MSM6242_WEEK);
rtc/rtc-msm6242.c:	tm->tm_mon  = msm6242_read(priv, MSM6242_MONTH10) * 10 +
rtc/rtc-msm6242.c:		      msm6242_read(priv, MSM6242_MONTH1) - 1;
rtc/rtc-msm6242.c:	tm->tm_year = msm6242_read(priv, MSM6242_YEAR10) * 10 +
rtc/rtc-msm6242.c:		      msm6242_read(priv, MSM6242_YEAR1);
rtc/rtc-msm6242.c:	if (!(msm6242_read(priv, MSM6242_CF) & MSM6242_CF_24H)) {
rtc/rtc-msm6242.c:		unsigned int pm = msm6242_read(priv, MSM6242_HOUR10) &
rtc/rtc-msm6242.c:	msm6242_unlock(priv);
rtc/rtc-msm6242.c:static int msm6242_set_time(struct device *dev, struct rtc_time *tm)
rtc/rtc-msm6242.c:	struct msm6242_priv *priv = dev_get_drvdata(dev);
rtc/rtc-msm6242.c:	msm6242_lock(priv);
rtc/rtc-msm6242.c:	msm6242_write(priv, tm->tm_sec / 10, MSM6242_SECOND10);
rtc/rtc-msm6242.c:	msm6242_write(priv, tm->tm_sec % 10, MSM6242_SECOND1);
rtc/rtc-msm6242.c:	msm6242_write(priv, tm->tm_min / 10, MSM6242_MINUTE10);
rtc/rtc-msm6242.c:	msm6242_write(priv, tm->tm_min % 10, MSM6242_MINUTE1);
rtc/rtc-msm6242.c:	if (msm6242_read(priv, MSM6242_CF) & MSM6242_CF_24H)
rtc/rtc-msm6242.c:		msm6242_write(priv, tm->tm_hour / 10, MSM6242_HOUR10);
rtc/rtc-msm6242.c:		msm6242_write(priv, MSM6242_HOUR10_PM + (tm->tm_hour - 12) / 10,
rtc/rtc-msm6242.c:		msm6242_write(priv, tm->tm_hour / 10, MSM6242_HOUR10);
rtc/rtc-msm6242.c:	msm6242_write(priv, tm->tm_hour % 10, MSM6242_HOUR1);
rtc/rtc-msm6242.c:	msm6242_write(priv, tm->tm_mday / 10, MSM6242_DAY10);
rtc/rtc-msm6242.c:	msm6242_write(priv, tm->tm_mday % 10, MSM6242_DAY1);
rtc/rtc-msm6242.c:		msm6242_write(priv, tm->tm_wday, MSM6242_WEEK);
rtc/rtc-msm6242.c:	msm6242_write(priv, (tm->tm_mon + 1) / 10, MSM6242_MONTH10);
rtc/rtc-msm6242.c:	msm6242_write(priv, (tm->tm_mon + 1) % 10, MSM6242_MONTH1);
rtc/rtc-msm6242.c:	msm6242_write(priv, tm->tm_year / 10, MSM6242_YEAR10);
rtc/rtc-msm6242.c:	msm6242_write(priv, tm->tm_year % 10, MSM6242_YEAR1);
rtc/rtc-msm6242.c:	msm6242_unlock(priv);
rtc/rtc-msm6242.c:static const struct rtc_class_ops msm6242_rtc_ops = {
rtc/rtc-msm6242.c:	.read_time	= msm6242_read_time,
rtc/rtc-msm6242.c:	.set_time	= msm6242_set_time,
rtc/rtc-msm6242.c:static int __init msm6242_rtc_probe(struct platform_device *pdev)
rtc/rtc-msm6242.c:	struct msm6242_priv *priv;
rtc/rtc-msm6242.c:	rtc = devm_rtc_device_register(&pdev->dev, "rtc-msm6242",
rtc/rtc-msm6242.c:				&msm6242_rtc_ops, THIS_MODULE);
rtc/rtc-msm6242.c:static struct platform_driver msm6242_rtc_driver = {
rtc/rtc-msm6242.c:		.name	= "rtc-msm6242",
rtc/rtc-msm6242.c:module_platform_driver_probe(msm6242_rtc_driver, msm6242_rtc_probe);
rtc/rtc-msm6242.c:MODULE_ALIAS("platform:rtc-msm6242");
scsi/ufs/ufs-qcom.c:#include <linux/msm-bus.h>
scsi/ufs/ufs-qcom.c:		err = msm_bus_scale_client_update_request(
scsi/ufs/ufs-qcom.c:				"%s: msm_bus_scale_client_update_request() failed: bus_client_handle=0x%x, vote=%d, err=%d\n",
scsi/ufs/ufs-qcom.c:	struct msm_bus_scale_pdata *bus_pdata;
scsi/ufs/ufs-qcom.c:	bus_pdata = msm_bus_cl_get_pdata(pdev);
scsi/ufs/ufs-qcom.c:	host->bus_vote.client_handle = msm_bus_scale_register_client(bus_pdata);
scsi/ufs/ufs-qcom.c:		dev_err(dev, "%s: msm_bus_scale_register_client failed\n",
scsi/ufs/ufs-qcom.c:static inline void msm_bus_scale_unregister_client(uint32_t cl)
scsi/ufs/ufs-qcom.c:	msm_bus_scale_unregister_client(host->bus_vote.client_handle);
scsi/ufs/ufs-qcom.c:	msm_bus_scale_unregister_client(host->bus_vote.client_handle);
sensors/sensors_ssc.c:#include <linux/msm_dsps.h>
sensors/sensors_ssc.c:static const struct of_device_id msm_ssc_sensors_dt_match[] = {
sensors/sensors_ssc.c:	{.compatible = "qcom,msm-ssc-sensors"},
sensors/sensors_ssc.c:MODULE_DEVICE_TABLE(of, msm_ssc_sensors_dt_match);
sensors/sensors_ssc.c:		.of_match_table = msm_ssc_sensors_dt_match,
slimbus/Makefile:obj-$(CONFIG_SLIMBUS_MSM_CTRL)		+= slim-msm.o slim-msm-ctrl.o
slimbus/Makefile:obj-$(CONFIG_SLIMBUS_MSM_NGD)		+= slim-msm.o slim-msm-ngd.o
slimbus/slim-msm-ctrl.c:#include <linux/msm-sps.h>
slimbus/slim-msm-ctrl.c:#include "slim-msm.h"
slimbus/slim-msm-ctrl.c:#define MSM_SLIM_NAME	"msm_slim_ctrl"
slimbus/slim-msm-ctrl.c:enum msm_slim_msgq_type {
slimbus/slim-msm-ctrl.c:static struct msm_slim_sat *msm_slim_alloc_sat(struct msm_slim_ctrl *dev);
slimbus/slim-msm-ctrl.c:static int msm_sat_enqueue(struct msm_slim_sat *sat, u32 *buf, u8 len)
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *dev = sat->dev;
slimbus/slim-msm-ctrl.c:static int msm_sat_dequeue(struct msm_slim_sat *sat, u8 *buf)
slimbus/slim-msm-ctrl.c:static void msm_get_eaddr(u8 *e_addr, u32 *buffer)
slimbus/slim-msm-ctrl.c:static bool msm_is_sat_dev(u8 *e_addr)
slimbus/slim-msm-ctrl.c:static struct msm_slim_sat *addr_to_sat(struct msm_slim_ctrl *dev, u8 laddr)
slimbus/slim-msm-ctrl.c:	struct msm_slim_sat *sat = NULL;
slimbus/slim-msm-ctrl.c:static irqreturn_t msm_slim_interrupt(int irq, void *d)
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *dev = d;
slimbus/slim-msm-ctrl.c:		msm_slim_manage_tx_msgq(dev, false, NULL);
slimbus/slim-msm-ctrl.c:			struct msm_slim_sat *sat = addr_to_sat(dev, laddr);
slimbus/slim-msm-ctrl.c:				msm_sat_enqueue(sat, rx_buf, len);
slimbus/slim-msm-ctrl.c:			msm_get_eaddr(e_addr, rx_buf);
slimbus/slim-msm-ctrl.c:			msm_slim_rx_enqueue(dev, rx_buf, len);
slimbus/slim-msm-ctrl.c:			msm_slim_rx_enqueue(dev, rx_buf, len);
slimbus/slim-msm-ctrl.c:		return msm_slim_port_irq_handler(dev, pstat);
slimbus/slim-msm-ctrl.c:static int msm_xfer_msg(struct slim_controller *ctrl, struct slim_msg_txn *txn)
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *dev = slim_get_ctrldata(ctrl);
slimbus/slim-msm-ctrl.c:		msgv = msm_slim_get_ctrl(dev);
slimbus/slim-msm-ctrl.c:			msm_slim_put_ctrl(dev);
slimbus/slim-msm-ctrl.c:			int chv = msm_slim_get_ctrl(dev);
slimbus/slim-msm-ctrl.c:	pbuf = msm_get_msg_buf(dev, txn->rl, &done);
slimbus/slim-msm-ctrl.c:			msm_slim_put_ctrl(dev);
slimbus/slim-msm-ctrl.c:			dev->err = msm_slim_connect_pipe_port(dev, *puc);
slimbus/slim-msm-ctrl.c:				msm_slim_put_ctrl(dev);
slimbus/slim-msm-ctrl.c:				msm_slim_put_ctrl(dev);
slimbus/slim-msm-ctrl.c:	msm_send_msg_buf(dev, pbuf, txn->rl, MGR_TX_MSG);
slimbus/slim-msm-ctrl.c:				msm_slim_put_ctrl(dev);
slimbus/slim-msm-ctrl.c:		msm_slim_put_ctrl(dev);
slimbus/slim-msm-ctrl.c:static void msm_slim_wait_retry(struct msm_slim_ctrl *dev)
slimbus/slim-msm-ctrl.c:static int msm_set_laddr(struct slim_controller *ctrl, const u8 *ea,
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *dev = slim_get_ctrldata(ctrl);
slimbus/slim-msm-ctrl.c:	buf = msm_get_msg_buf(dev, 9, &done);
slimbus/slim-msm-ctrl.c:	ret = msm_send_msg_buf(dev, buf, 9, MGR_TX_MSG);
slimbus/slim-msm-ctrl.c:			msm_slim_wait_retry(dev);
slimbus/slim-msm-ctrl.c:static int msm_clk_pause_wakeup(struct slim_controller *ctrl)
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *dev = slim_get_ctrldata(ctrl);
slimbus/slim-msm-ctrl.c:static int msm_sat_define_ch(struct msm_slim_sat *sat, u8 *buf, u8 len, u8 mc)
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *dev = sat->dev;
slimbus/slim-msm-ctrl.c:static void msm_slim_rxwq(struct msm_slim_ctrl *dev)
slimbus/slim-msm-ctrl.c:	if ((msm_slim_rx_dequeue(dev, (u8 *)buf)) != -ENODATA) {
slimbus/slim-msm-ctrl.c:			if (!ret && msm_is_sat_dev(e_addr)) {
slimbus/slim-msm-ctrl.c:				struct msm_slim_sat *sat = addr_to_sat(dev,
slimbus/slim-msm-ctrl.c:					sat = msm_slim_alloc_sat(dev);
slimbus/slim-msm-ctrl.c:				msm_sat_enqueue(sat, (u32 *)buf, len);
slimbus/slim-msm-ctrl.c:	struct msm_slim_sat *sat = container_of(work, struct msm_slim_sat, wd);
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *dev = sat->dev;
slimbus/slim-msm-ctrl.c:	while ((msm_sat_dequeue(sat, buf)) != -ENODATA) {
slimbus/slim-msm-ctrl.c:				satv = msm_slim_get_ctrl(dev);
slimbus/slim-msm-ctrl.c:			satv = msm_slim_get_ctrl(dev);
slimbus/slim-msm-ctrl.c:					msm_slim_put_ctrl(dev);
slimbus/slim-msm-ctrl.c:					sizeof(struct msm_sat_chan),
slimbus/slim-msm-ctrl.c:			ret = msm_xfer_msg(&dev->ctrl, &txn);
slimbus/slim-msm-ctrl.c:					msm_slim_wait_retry(dev);
slimbus/slim-msm-ctrl.c:			msm_xfer_msg(&dev->ctrl, &txn);
slimbus/slim-msm-ctrl.c:			ret = msm_sat_define_ch(sat, buf, len, mc);
slimbus/slim-msm-ctrl.c:				int chv = msm_slim_get_ctrl(dev);
slimbus/slim-msm-ctrl.c:				struct msm_sat_chan *sch = &sat->satch[i];
slimbus/slim-msm-ctrl.c:				msm_slim_put_ctrl(dev);
slimbus/slim-msm-ctrl.c:			ret = msm_xfer_msg(&dev->ctrl, &txn);
slimbus/slim-msm-ctrl.c:			ret = msm_xfer_msg(&dev->ctrl, &txn);
slimbus/slim-msm-ctrl.c:				msm_slim_put_ctrl(dev);
slimbus/slim-msm-ctrl.c:		msm_xfer_msg(&dev->ctrl, &txn);
slimbus/slim-msm-ctrl.c:			msm_slim_put_ctrl(dev);
slimbus/slim-msm-ctrl.c:static struct msm_slim_sat *msm_slim_alloc_sat(struct msm_slim_ctrl *dev)
slimbus/slim-msm-ctrl.c:	struct msm_slim_sat *sat;
slimbus/slim-msm-ctrl.c:	sat = kzalloc(sizeof(struct msm_slim_sat), GFP_KERNEL);
slimbus/slim-msm-ctrl.c:	snprintf(name, SLIMBUS_NAME_SIZE, "msm_sat%d", dev->nsats);
slimbus/slim-msm-ctrl.c:static int msm_slim_rx_msgq_thread(void *data)
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *dev = (struct msm_slim_ctrl *)data;
slimbus/slim-msm-ctrl.c:	struct msm_slim_sat *sat = NULL;
slimbus/slim-msm-ctrl.c:			msm_slim_rxwq(dev);
slimbus/slim-msm-ctrl.c:		ret = msm_slim_rx_msgq_get(dev, buffer, index);
slimbus/slim-msm-ctrl.c:				msm_sat_enqueue(sat, buffer, msg_len);
slimbus/slim-msm-ctrl.c:				msm_slim_rx_enqueue(dev, buffer, msg_len);
slimbus/slim-msm-ctrl.c:				msm_slim_rxwq(dev);
slimbus/slim-msm-ctrl.c:static void msm_slim_prg_slew(struct platform_device *pdev,
slimbus/slim-msm-ctrl.c:				struct msm_slim_ctrl *dev)
slimbus/slim-msm-ctrl.c:static int msm_slim_probe(struct platform_device *pdev)
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *dev;
slimbus/slim-msm-ctrl.c:	dev = kzalloc(sizeof(struct msm_slim_ctrl), GFP_KERNEL);
slimbus/slim-msm-ctrl.c:	dev->ctrl.set_laddr = msm_set_laddr;
slimbus/slim-msm-ctrl.c:	dev->ctrl.xfer_msg = msm_xfer_msg;
slimbus/slim-msm-ctrl.c:	dev->ctrl.wakeup =  msm_clk_pause_wakeup;
slimbus/slim-msm-ctrl.c:	dev->ctrl.alloc_port = msm_alloc_port;
slimbus/slim-msm-ctrl.c:	dev->ctrl.dealloc_port = msm_dealloc_port;
slimbus/slim-msm-ctrl.c:	dev->ctrl.port_xfer = msm_slim_port_xfer;
slimbus/slim-msm-ctrl.c:	dev->ctrl.port_xfer_status = msm_slim_port_xfer_status;
slimbus/slim-msm-ctrl.c:	ret = msm_slim_sps_init(dev, bam_mem, MGR_STATUS, false);
slimbus/slim-msm-ctrl.c:	dev->rx_msgq_thread = kthread_run(msm_slim_rx_msgq_thread, dev,
slimbus/slim-msm-ctrl.c:	ret = request_threaded_irq(dev->irq, NULL, msm_slim_interrupt,
slimbus/slim-msm-ctrl.c:				"msm_slim_irq", dev);
slimbus/slim-msm-ctrl.c:	msm_slim_prg_slew(pdev, dev);
slimbus/slim-msm-ctrl.c:	msm_slim_sps_exit(dev, true);
slimbus/slim-msm-ctrl.c:	msm_slim_deinit_ep(dev, &dev->rx_msgq,
slimbus/slim-msm-ctrl.c:	msm_slim_deinit_ep(dev, &dev->tx_msgq,
slimbus/slim-msm-ctrl.c:static int msm_slim_remove(struct platform_device *pdev)
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *dev = platform_get_drvdata(pdev);
slimbus/slim-msm-ctrl.c:		struct msm_slim_sat *sat = dev->satd[i];
slimbus/slim-msm-ctrl.c:	msm_slim_sps_exit(dev, true);
slimbus/slim-msm-ctrl.c:	msm_slim_deinit_ep(dev, &dev->rx_msgq,
slimbus/slim-msm-ctrl.c:	msm_slim_deinit_ep(dev, &dev->tx_msgq,
slimbus/slim-msm-ctrl.c:static int msm_slim_runtime_idle(struct device *device)
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *dev = platform_get_drvdata(pdev);
slimbus/slim-msm-ctrl.c:static int msm_slim_runtime_suspend(struct device *device)
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *dev = platform_get_drvdata(pdev);
slimbus/slim-msm-ctrl.c:static int msm_slim_runtime_resume(struct device *device)
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *dev = platform_get_drvdata(pdev);
slimbus/slim-msm-ctrl.c:static int msm_slim_suspend(struct device *dev)
slimbus/slim-msm-ctrl.c:	struct msm_slim_ctrl *cdev = platform_get_drvdata(pdev);
slimbus/slim-msm-ctrl.c:		ret = msm_slim_runtime_suspend(dev);
slimbus/slim-msm-ctrl.c:static int msm_slim_resume(struct device *dev)
slimbus/slim-msm-ctrl.c:		struct msm_slim_ctrl *cdev = platform_get_drvdata(pdev);
slimbus/slim-msm-ctrl.c:		ret = msm_slim_runtime_resume(dev);
slimbus/slim-msm-ctrl.c:static const struct dev_pm_ops msm_slim_dev_pm_ops = {
slimbus/slim-msm-ctrl.c:		msm_slim_suspend,
slimbus/slim-msm-ctrl.c:		msm_slim_resume
slimbus/slim-msm-ctrl.c:		msm_slim_runtime_suspend,
slimbus/slim-msm-ctrl.c:		msm_slim_runtime_resume,
slimbus/slim-msm-ctrl.c:		msm_slim_runtime_idle
slimbus/slim-msm-ctrl.c:static const struct of_device_id msm_slim_dt_match[] = {
slimbus/slim-msm-ctrl.c:		.compatible = "qcom,slim-msm",
slimbus/slim-msm-ctrl.c:static struct platform_driver msm_slim_driver = {
slimbus/slim-msm-ctrl.c:	.probe = msm_slim_probe,
slimbus/slim-msm-ctrl.c:	.remove = msm_slim_remove,
slimbus/slim-msm-ctrl.c:		.pm = &msm_slim_dev_pm_ops,
slimbus/slim-msm-ctrl.c:		.of_match_table = msm_slim_dt_match,
slimbus/slim-msm-ctrl.c:static int msm_slim_init(void)
slimbus/slim-msm-ctrl.c:	return platform_driver_register(&msm_slim_driver);
slimbus/slim-msm-ctrl.c:subsys_initcall(msm_slim_init);
slimbus/slim-msm-ctrl.c:static void msm_slim_exit(void)
slimbus/slim-msm-ctrl.c:	platform_driver_unregister(&msm_slim_driver);
slimbus/slim-msm-ctrl.c:module_exit(msm_slim_exit);
slimbus/slim-msm-ctrl.c:MODULE_ALIAS("platform:msm-slim");
slimbus/slim-msm-ngd.c:#include <linux/msm-sps.h>
slimbus/slim-msm-ngd.c:#include "slim-msm.h"
slimbus/slim-msm-ngd.c:#define NGD_SLIM_NAME	"ngd_msm_ctrl"
slimbus/slim-msm-ngd.c:static void ngd_slim_rx(struct msm_slim_ctrl *dev, u8 *buf);
slimbus/slim-msm-ngd.c:static int ngd_slim_power_up(struct msm_slim_ctrl *dev, bool mdm_restart);
slimbus/slim-msm-ngd.c:static void ngd_dom_down(struct msm_slim_ctrl *dev);
slimbus/slim-msm-ngd.c:static int ngd_slim_qmi_svc_event_init(struct msm_slim_qmi *qmi);
slimbus/slim-msm-ngd.c:static void ngd_slim_qmi_svc_event_deinit(struct msm_slim_qmi *qmi);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = (struct msm_slim_ctrl *)d;
slimbus/slim-msm-ngd.c:		msm_slim_manage_tx_msgq(dev, false, NULL, dev->err);
slimbus/slim-msm-ngd.c:		msm_slim_manage_tx_msgq(dev, false, NULL, 0);
slimbus/slim-msm-ngd.c:		return msm_slim_port_irq_handler(dev, pstat);
slimbus/slim-msm-ngd.c:	struct msm_slim_qmi *qmi =
slimbus/slim-msm-ngd.c:		container_of(hdl, struct msm_slim_qmi, svc_event_hdl);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev =
slimbus/slim-msm-ngd.c:		container_of(qmi, struct msm_slim_ctrl, qmi);
slimbus/slim-msm-ngd.c:	struct msm_slim_qmi *qmi =
slimbus/slim-msm-ngd.c:		container_of(hdl, struct msm_slim_qmi, svc_event_hdl);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev =
slimbus/slim-msm-ngd.c:		container_of(qmi, struct msm_slim_ctrl, qmi);
slimbus/slim-msm-ngd.c:static int ngd_slim_qmi_svc_event_init(struct msm_slim_qmi *qmi)
slimbus/slim-msm-ngd.c:static void ngd_slim_qmi_svc_event_deinit(struct msm_slim_qmi *qmi)
slimbus/slim-msm-ngd.c:static void ngd_reg_ssr(struct msm_slim_ctrl *dev)
slimbus/slim-msm-ngd.c:	struct msm_slim_ss *dsp = container_of(n, struct msm_slim_ss, nb);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = container_of(dsp, struct msm_slim_ctrl,
slimbus/slim-msm-ngd.c:		msm_slim_sps_exit(dev, false);
slimbus/slim-msm-ngd.c:static void ngd_dom_init(struct msm_slim_ctrl *dev)
slimbus/slim-msm-ngd.c:	struct msm_slim_ss *ext_mdm = container_of(n, struct msm_slim_ss, nb);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = container_of(ext_mdm, struct msm_slim_ctrl,
slimbus/slim-msm-ngd.c:		msm_slim_get_ctrl(dev);
slimbus/slim-msm-ngd.c:		msm_slim_qmi_check_framer_request(dev);
slimbus/slim-msm-ngd.c:		msm_slim_put_ctrl(dev);
slimbus/slim-msm-ngd.c:		msm_slim_get_ctrl(dev);
slimbus/slim-msm-ngd.c:		msm_slim_qmi_check_framer_request(dev);
slimbus/slim-msm-ngd.c:		msm_slim_put_ctrl(dev);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = slim_get_ctrldata(ctrl);
slimbus/slim-msm-ngd.c:static void slim_reinit_tx_msgq(struct msm_slim_ctrl *dev)
slimbus/slim-msm-ngd.c:		msm_slim_disconnect_endp(dev, &dev->tx_msgq,
slimbus/slim-msm-ngd.c:		msm_slim_connect_endp(dev, &dev->tx_msgq);
slimbus/slim-msm-ngd.c:static int ngd_check_hw_status(struct msm_slim_ctrl *dev)
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = slim_get_ctrldata(ctrl);
slimbus/slim-msm-ngd.c:		ret = msm_slim_get_ctrl(dev);
slimbus/slim-msm-ngd.c:			msm_slim_put_ctrl(dev);
slimbus/slim-msm-ngd.c:			msm_slim_put_ctrl(dev);
slimbus/slim-msm-ngd.c:		pbuf = msm_get_msg_buf(dev, txn->rl, txn->comp);
slimbus/slim-msm-ngd.c:		pbuf = msm_get_msg_buf(dev, txn->rl, txn->comp);
slimbus/slim-msm-ngd.c:		pbuf = msm_get_msg_buf(dev, txn->rl, &tx_sent);
slimbus/slim-msm-ngd.c:			dev->err = msm_slim_connect_pipe_port(dev, wbuf[1]);
slimbus/slim-msm-ngd.c:	ret = msm_send_msg_buf(dev, pbuf, txn->rl,
slimbus/slim-msm-ngd.c:			struct msm_slim_endp *endpoint = &dev->tx_msgq;
slimbus/slim-msm-ngd.c:		msm_slim_put_ctrl(dev);
slimbus/slim-msm-ngd.c:		msm_slim_put_ctrl(dev);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = slim_get_ctrldata(ctrl);
slimbus/slim-msm-ngd.c:	struct msm_slim_endp *endpoint = &dev->tx_msgq;
slimbus/slim-msm-ngd.c:	ret = msm_slim_get_ctrl(dev);
slimbus/slim-msm-ngd.c:		msm_slim_put_ctrl(dev);
slimbus/slim-msm-ngd.c:		msm_slim_put_ctrl(dev);
slimbus/slim-msm-ngd.c:	msm_slim_put_ctrl(dev);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = slim_get_ctrldata(ctrl);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = slim_get_ctrldata(ctrl);
slimbus/slim-msm-ngd.c:static void ngd_slim_setup(struct msm_slim_ctrl *dev)
slimbus/slim-msm-ngd.c:			msm_slim_deinit_ep(dev, &dev->tx_msgq,
slimbus/slim-msm-ngd.c:			msm_slim_deinit_ep(dev, &dev->rx_msgq,
slimbus/slim-msm-ngd.c:		msm_slim_sps_init(dev, dev->bam_mem,
slimbus/slim-msm-ngd.c:			msm_slim_disconnect_endp(dev, &dev->rx_msgq,
slimbus/slim-msm-ngd.c:		msm_slim_connect_endp(dev, &dev->rx_msgq);
slimbus/slim-msm-ngd.c:			msm_slim_disconnect_endp(dev, &dev->tx_msgq,
slimbus/slim-msm-ngd.c:		msm_slim_connect_endp(dev, &dev->tx_msgq);
slimbus/slim-msm-ngd.c:static void ngd_slim_rx(struct msm_slim_ctrl *dev, u8 *buf)
slimbus/slim-msm-ngd.c:static int ngd_slim_power_up(struct msm_slim_ctrl *dev, bool mdm_restart)
slimbus/slim-msm-ngd.c:	enum msm_ctrl_state cur_state = dev->state;
slimbus/slim-msm-ngd.c:		ret = msm_slim_qmi_power_request(dev, true);
slimbus/slim-msm-ngd.c:				msm_slim_qmi_power_request(dev, false);
slimbus/slim-msm-ngd.c:			msm_slim_disconnect_endp(dev, &dev->rx_msgq,
slimbus/slim-msm-ngd.c:			msm_slim_disconnect_endp(dev, &dev->tx_msgq,
slimbus/slim-msm-ngd.c:		msm_slim_sps_exit(dev, false);
slimbus/slim-msm-ngd.c:static int ngd_slim_enable(struct msm_slim_ctrl *dev, bool enable)
slimbus/slim-msm-ngd.c:		ret = msm_slim_qmi_init(dev, false);
slimbus/slim-msm-ngd.c:		msm_slim_qmi_exit(dev);
slimbus/slim-msm-ngd.c:static int ngd_slim_power_down(struct msm_slim_ctrl *dev)
slimbus/slim-msm-ngd.c:	return msm_slim_qmi_power_request(dev, false);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = (struct msm_slim_ctrl *)data;
slimbus/slim-msm-ngd.c:			enum msm_ctrl_state prev_state = dev->state;
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = (struct msm_slim_ctrl *)data;
slimbus/slim-msm-ngd.c:static void ngd_dom_down(struct msm_slim_ctrl *dev)
slimbus/slim-msm-ngd.c:	struct msm_slim_ss *dsp =
slimbus/slim-msm-ngd.c:		container_of(work, struct msm_slim_ss, dom_up);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev =
slimbus/slim-msm-ngd.c:		container_of(dsp, struct msm_slim_ctrl, dsp);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = platform_get_drvdata(pdev);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = platform_get_drvdata(pdev);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *ctrl_dev;
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev;
slimbus/slim-msm-ngd.c:	dev = kzalloc(sizeof(struct msm_slim_ctrl), GFP_KERNEL);
slimbus/slim-msm-ngd.c:	dev->ctrl.alloc_port = msm_alloc_port;
slimbus/slim-msm-ngd.c:	dev->ctrl.dealloc_port = msm_dealloc_port;
slimbus/slim-msm-ngd.c:	dev->ctrl.port_xfer = msm_slim_port_xfer;
slimbus/slim-msm-ngd.c:	dev->ctrl.port_xfer_status = msm_slim_port_xfer_status;
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = platform_get_drvdata(pdev);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = platform_get_drvdata(pdev);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = platform_get_drvdata(pdev);
slimbus/slim-msm-ngd.c:		ret = msm_slim_qmi_deferred_status_req(dev);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *dev = platform_get_drvdata(pdev);
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *cdev;
slimbus/slim-msm-ngd.c:	struct msm_slim_ctrl *cdev;
slimbus/slim-msm-ngd.c:		ret = msm_slim_qmi_deferred_status_req(cdev);
slimbus/slim-msm-ngd.c:MODULE_ALIAS("platform:msm-slim-ngd");
slimbus/slim-msm.c:#include <linux/msm-sps.h>
slimbus/slim-msm.c:#include "slim-msm.h"
slimbus/slim-msm.c:int msm_slim_rx_enqueue(struct msm_slim_ctrl *dev, u32 *buf, u8 len)
slimbus/slim-msm.c:int msm_slim_rx_dequeue(struct msm_slim_ctrl *dev, u8 *buf)
slimbus/slim-msm.c:int msm_slim_get_ctrl(struct msm_slim_ctrl *dev)
slimbus/slim-msm.c:void msm_slim_put_ctrl(struct msm_slim_ctrl *dev)
slimbus/slim-msm.c:irqreturn_t msm_slim_port_irq_handler(struct msm_slim_ctrl *dev, u32 pstat)
slimbus/slim-msm.c:		struct msm_slim_endp *endpoint = &dev->pipes[i];
slimbus/slim-msm.c:int msm_slim_init_endpoint(struct msm_slim_ctrl *dev, struct msm_slim_endp *ep)
slimbus/slim-msm.c:void msm_slim_free_endpoint(struct msm_slim_endp *ep)
slimbus/slim-msm.c:int msm_slim_sps_mem_alloc(
slimbus/slim-msm.c:		struct msm_slim_ctrl *dev, struct sps_mem_buffer *mem, u32 len)
slimbus/slim-msm.c:msm_slim_sps_mem_free(struct msm_slim_ctrl *dev, struct sps_mem_buffer *mem)
slimbus/slim-msm.c:void msm_hw_set_port(struct msm_slim_ctrl *dev, u8 pipenum, u8 portnum)
slimbus/slim-msm.c:	struct msm_slim_pshpull_parm *parm;
slimbus/slim-msm.c:static void msm_slim_disconn_pipe_port(struct msm_slim_ctrl *dev, u8 pn)
slimbus/slim-msm.c:	struct msm_slim_endp *endpoint = &dev->pipes[pn];
slimbus/slim-msm.c:static void msm_slim_calc_pshpull_parm(struct msm_slim_ctrl *dev,
slimbus/slim-msm.c:	struct msm_slim_endp *endpoint = &dev->pipes[pn];
slimbus/slim-msm.c:	struct msm_slim_pshpull_parm *parm = &endpoint->psh_pull;
slimbus/slim-msm.c:int msm_slim_connect_pipe_port(struct msm_slim_ctrl *dev, u8 pn)
slimbus/slim-msm.c:	struct msm_slim_endp *endpoint;
slimbus/slim-msm.c:		msm_slim_calc_pshpull_parm(dev, pn, prop);
slimbus/slim-msm.c:			msm_hw_set_port(dev, endpoint->port_b, pn);
slimbus/slim-msm.c:		msm_slim_disconn_pipe_port(dev, pn);
slimbus/slim-msm.c:	ret = msm_slim_sps_mem_alloc(dev, &cfg->desc,
slimbus/slim-msm.c:		msm_hw_set_port(dev, endpoint->port_b, pn);
slimbus/slim-msm.c:int msm_alloc_port(struct slim_controller *ctrl, u8 pn)
slimbus/slim-msm.c:	struct msm_slim_ctrl *dev = slim_get_ctrldata(ctrl);
slimbus/slim-msm.c:	struct msm_slim_endp *endpoint;
slimbus/slim-msm.c:	ret = msm_slim_init_endpoint(dev, endpoint);
slimbus/slim-msm.c:void msm_dealloc_port(struct slim_controller *ctrl, u8 pn)
slimbus/slim-msm.c:	struct msm_slim_ctrl *dev = slim_get_ctrldata(ctrl);
slimbus/slim-msm.c:	struct msm_slim_endp *endpoint;
slimbus/slim-msm.c:		msm_slim_disconn_pipe_port(dev, pn);
slimbus/slim-msm.c:		msm_slim_sps_mem_free(dev, &config->desc);
slimbus/slim-msm.c:		msm_slim_free_endpoint(endpoint);
slimbus/slim-msm.c:enum slim_port_err msm_slim_port_xfer_status(struct slim_controller *ctr,
slimbus/slim-msm.c:	struct msm_slim_ctrl *dev = slim_get_ctrldata(ctr);
slimbus/slim-msm.c:static dma_addr_t msm_slim_iommu_map(struct msm_slim_ctrl *dev, void *buf_addr,
slimbus/slim-msm.c:static void msm_slim_iommu_unmap(struct msm_slim_ctrl *dev, dma_addr_t buf_addr,
slimbus/slim-msm.c:static void msm_slim_port_cb(struct sps_event_notify *ev)
slimbus/slim-msm.c:	struct msm_slim_ctrl *dev = ev->user;
slimbus/slim-msm.c:		msm_slim_iommu_unmap(dev, iovec->addr, iovec->size);
slimbus/slim-msm.c:int msm_slim_port_xfer(struct slim_controller *ctrl, u8 pn, void *buf,
slimbus/slim-msm.c:	struct msm_slim_ctrl *dev = slim_get_ctrldata(ctrl);
slimbus/slim-msm.c:	dma_buf =  msm_slim_iommu_map(dev, buf, len);
slimbus/slim-msm.c:	sreg.callback = msm_slim_port_cb;
slimbus/slim-msm.c:		msm_slim_iommu_unmap(dev, dma_buf, len);
slimbus/slim-msm.c:		msm_slim_iommu_unmap(dev, dma_buf, len);
slimbus/slim-msm.c:static int msm_slim_post_tx_msgq(struct msm_slim_ctrl *dev, u8 *buf, int len)
slimbus/slim-msm.c:	struct msm_slim_endp *endpoint = &dev->tx_msgq;
slimbus/slim-msm.c:void msm_slim_tx_msg_return(struct msm_slim_ctrl *dev, int err)
slimbus/slim-msm.c:	struct msm_slim_endp *endpoint = &dev->tx_msgq;
slimbus/slim-msm.c:static u32 *msm_slim_modify_tx_buf(struct msm_slim_ctrl *dev,
slimbus/slim-msm.c:	struct msm_slim_endp *endpoint = &dev->tx_msgq;
slimbus/slim-msm.c:u32 *msm_slim_manage_tx_msgq(struct msm_slim_ctrl *dev, bool getbuf,
slimbus/slim-msm.c:		msm_slim_tx_msg_return(dev, err);
slimbus/slim-msm.c:	retbuf = msm_slim_modify_tx_buf(dev, comp);
slimbus/slim-msm.c:		msm_slim_tx_msg_return(dev, err);
slimbus/slim-msm.c:		retbuf = msm_slim_modify_tx_buf(dev, comp);
slimbus/slim-msm.c:int msm_send_msg_buf(struct msm_slim_ctrl *dev, u32 *buf, u8 len, u32 tx_reg)
slimbus/slim-msm.c:	return msm_slim_post_tx_msgq(dev, (u8 *)buf, len);
slimbus/slim-msm.c:u32 *msm_get_msg_buf(struct msm_slim_ctrl *dev, int len,
slimbus/slim-msm.c:	return msm_slim_manage_tx_msgq(dev, true, comp, 0);
slimbus/slim-msm.c:msm_slim_rx_msgq_event(struct msm_slim_ctrl *dev, struct sps_event_notify *ev)
slimbus/slim-msm.c:msm_slim_handle_rx(struct msm_slim_ctrl *dev, struct sps_event_notify *ev)
slimbus/slim-msm.c:		ret = msm_slim_rx_msgq_get(dev, dev->current_rx_buf,
slimbus/slim-msm.c:static void msm_slim_rx_msgq_cb(struct sps_event_notify *notify)
slimbus/slim-msm.c:	struct msm_slim_ctrl *dev = (struct msm_slim_ctrl *)notify->user;
slimbus/slim-msm.c:		msm_slim_rx_msgq_event(dev, notify);
slimbus/slim-msm.c:		msm_slim_handle_rx(dev, notify);
slimbus/slim-msm.c:static int msm_slim_post_rx_msgq(struct msm_slim_ctrl *dev, int ix)
slimbus/slim-msm.c:	struct msm_slim_endp *endpoint = &dev->rx_msgq;
slimbus/slim-msm.c:int msm_slim_rx_msgq_get(struct msm_slim_ctrl *dev, u32 *data, int offset)
slimbus/slim-msm.c:	struct msm_slim_endp *endpoint = &dev->rx_msgq;
slimbus/slim-msm.c:	(void)msm_slim_post_rx_msgq(dev, index);
slimbus/slim-msm.c:int msm_slim_connect_endp(struct msm_slim_ctrl *dev,
slimbus/slim-msm.c:				struct msm_slim_endp *endpoint)
slimbus/slim-msm.c:		sps_descr_event.callback = msm_slim_rx_msgq_cb;
slimbus/slim-msm.c:	sps_error_event.callback = msm_slim_rx_msgq_cb;
slimbus/slim-msm.c:			ret = msm_slim_post_rx_msgq(dev, i);
slimbus/slim-msm.c:static int msm_slim_init_rx_msgq(struct msm_slim_ctrl *dev, u32 pipe_reg)
slimbus/slim-msm.c:	struct msm_slim_endp *endpoint = &dev->rx_msgq;
slimbus/slim-msm.c:	ret = msm_slim_init_endpoint(dev, endpoint);
slimbus/slim-msm.c:	ret = msm_slim_sps_mem_alloc(dev, descr,
slimbus/slim-msm.c:	ret = msm_slim_sps_mem_alloc(dev, mem, MSM_SLIM_DESC_NUM * 4);
slimbus/slim-msm.c:	ret = msm_slim_connect_endp(dev, endpoint);
slimbus/slim-msm.c:	msm_slim_sps_mem_free(dev, mem);
slimbus/slim-msm.c:	msm_slim_sps_mem_free(dev, descr);
slimbus/slim-msm.c:	msm_slim_free_endpoint(endpoint);
slimbus/slim-msm.c:static int msm_slim_init_tx_msgq(struct msm_slim_ctrl *dev, u32 pipe_reg)
slimbus/slim-msm.c:	struct msm_slim_endp *endpoint = &dev->tx_msgq;
slimbus/slim-msm.c:	ret = msm_slim_init_endpoint(dev, endpoint);
slimbus/slim-msm.c:	ret = msm_slim_sps_mem_alloc(dev, descr,
slimbus/slim-msm.c:	ret = msm_slim_sps_mem_alloc(dev, mem, ((MSM_TX_BUFS + 1) *
slimbus/slim-msm.c:	ret = msm_slim_connect_endp(dev, endpoint);
slimbus/slim-msm.c:	msm_slim_sps_mem_free(dev, mem);
slimbus/slim-msm.c:	msm_slim_sps_mem_free(dev, descr);
slimbus/slim-msm.c:	msm_slim_free_endpoint(endpoint);
slimbus/slim-msm.c:static int msm_slim_data_port_assign(struct msm_slim_ctrl *dev)
slimbus/slim-msm.c:int msm_slim_sps_init(struct msm_slim_ctrl *dev, struct resource *bam_mem,
slimbus/slim-msm.c:	dev->port_nums = msm_slim_data_port_assign(dev);
slimbus/slim-msm.c:				     sizeof(struct msm_slim_endp), GFP_KERNEL);
slimbus/slim-msm.c:		msm_slim_data_port_assign(dev);
slimbus/slim-msm.c:	ret = msm_slim_init_rx_msgq(dev, pipe_reg);
slimbus/slim-msm.c:		dev_err(dev->dev, "msm_slim_init_rx_msgq failed 0x%x\n", ret);
slimbus/slim-msm.c:	ret = msm_slim_init_tx_msgq(dev, pipe_reg);
slimbus/slim-msm.c:		dev_err(dev->dev, "msm_slim_init_tx_msgq failed 0x%x\n", ret);
slimbus/slim-msm.c:void msm_slim_disconnect_endp(struct msm_slim_ctrl *dev,
slimbus/slim-msm.c:					struct msm_slim_endp *endpoint,
slimbus/slim-msm.c:					enum msm_slim_msgq *msgq_flag)
slimbus/slim-msm.c:static int msm_slim_discard_rx_data(struct msm_slim_ctrl *dev,
slimbus/slim-msm.c:					struct msm_slim_endp *endpoint)
slimbus/slim-msm.c:static void msm_slim_remove_ep(struct msm_slim_ctrl *dev,
slimbus/slim-msm.c:					struct msm_slim_endp *endpoint,
slimbus/slim-msm.c:					enum msm_slim_msgq *msgq_flag)
slimbus/slim-msm.c:	msm_slim_sps_mem_free(dev, mem);
slimbus/slim-msm.c:	msm_slim_sps_mem_free(dev, descr);
slimbus/slim-msm.c:	msm_slim_free_endpoint(endpoint);
slimbus/slim-msm.c:void msm_slim_deinit_ep(struct msm_slim_ctrl *dev,
slimbus/slim-msm.c:				struct msm_slim_endp *endpoint,
slimbus/slim-msm.c:				enum msm_slim_msgq *msgq_flag)
slimbus/slim-msm.c:			ret = msm_slim_discard_rx_data(dev, endpoint);
slimbus/slim-msm.c:		msm_slim_disconnect_endp(dev, endpoint, msgq_flag);
slimbus/slim-msm.c:		msm_slim_remove_ep(dev, endpoint, msgq_flag);
slimbus/slim-msm.c:static void msm_slim_sps_unreg_event(struct sps_pipe *sps)
slimbus/slim-msm.c:void msm_slim_sps_exit(struct msm_slim_ctrl *dev, bool dereg)
slimbus/slim-msm.c:		msm_slim_sps_unreg_event(dev->rx_msgq.sps);
slimbus/slim-msm.c:		msm_slim_sps_unreg_event(dev->tx_msgq.sps);
slimbus/slim-msm.c:			msm_slim_disconn_pipe_port(dev, i);
slimbus/slim-msm.c:				msm_dealloc_port(&dev->ctrl, i);
slimbus/slim-msm.c:static void msm_slim_qmi_power_resp_cb(struct qmi_handle *handle,
slimbus/slim-msm.c:static struct qmi_msg_handler msm_slim_qmi_msg_handlers[] = {
slimbus/slim-msm.c:		.fn = msm_slim_qmi_power_resp_cb,
slimbus/slim-msm.c:static int msm_slim_qmi_send_select_inst_req(struct msm_slim_ctrl *dev,
slimbus/slim-msm.c:static void msm_slim_qmi_power_resp_cb(struct qmi_handle *handle,
slimbus/slim-msm.c:static int msm_slim_qmi_send_power_request(struct msm_slim_ctrl *dev,
slimbus/slim-msm.c:int msm_slim_qmi_init(struct msm_slim_ctrl *dev, bool apps_is_master)
slimbus/slim-msm.c:				NULL, msm_slim_qmi_msg_handlers);
slimbus/slim-msm.c:	rc = msm_slim_qmi_send_select_inst_req(dev, &req);
slimbus/slim-msm.c:void msm_slim_qmi_exit(struct msm_slim_ctrl *dev)
slimbus/slim-msm.c:int msm_slim_qmi_power_request(struct msm_slim_ctrl *dev, bool active)
slimbus/slim-msm.c:	return msm_slim_qmi_send_power_request(dev, &req);
slimbus/slim-msm.c:int msm_slim_qmi_check_framer_request(struct msm_slim_ctrl *dev)
slimbus/slim-msm.c:int msm_slim_qmi_deferred_status_req(struct msm_slim_ctrl *dev)
slimbus/slim-msm.h:enum msm_slim_port_status {
slimbus/slim-msm.h:enum msm_ctrl_state {
slimbus/slim-msm.h:enum msm_slim_msgq {
slimbus/slim-msm.h:struct msm_slim_sps_bam {
slimbus/slim-msm.h:struct msm_slim_pshpull_parm {
slimbus/slim-msm.h:struct msm_slim_endp {
slimbus/slim-msm.h:	struct msm_slim_pshpull_parm	psh_pull;
slimbus/slim-msm.h:struct msm_slim_qmi {
slimbus/slim-msm.h:enum msm_slim_dom {
slimbus/slim-msm.h:struct msm_slim_ss {
slimbus/slim-msm.h:	enum msm_ctrl_state state;
slimbus/slim-msm.h:	enum msm_slim_dom dom_t;
slimbus/slim-msm.h:struct msm_slim_pdata {
slimbus/slim-msm.h:struct msm_slim_bulk_wr {
slimbus/slim-msm.h:struct msm_slim_iommu {
slimbus/slim-msm.h:struct msm_slim_ctrl {
slimbus/slim-msm.h:	struct msm_slim_iommu	iommu_desc;
slimbus/slim-msm.h:	struct msm_slim_sps_bam	lpass;
slimbus/slim-msm.h:	struct msm_slim_sat	*satd[MSM_MAX_NSATS];
slimbus/slim-msm.h:	struct msm_slim_endp	*pipes;
slimbus/slim-msm.h:	struct msm_slim_sps_bam	bam;
slimbus/slim-msm.h:	struct msm_slim_endp	tx_msgq;
slimbus/slim-msm.h:	struct msm_slim_endp	rx_msgq;
slimbus/slim-msm.h:	enum msm_slim_msgq	use_rx_msgqs;
slimbus/slim-msm.h:	enum msm_slim_msgq	use_tx_msgqs;
slimbus/slim-msm.h:	enum msm_ctrl_state	state;
slimbus/slim-msm.h:	struct msm_slim_qmi	qmi;
slimbus/slim-msm.h:	struct msm_slim_pdata	pdata;
slimbus/slim-msm.h:	struct msm_slim_ss	ext_mdm;
slimbus/slim-msm.h:	struct msm_slim_ss	dsp;
slimbus/slim-msm.h:	struct msm_slim_bulk_wr	bulk;
slimbus/slim-msm.h:	void (*rx_slim)(struct msm_slim_ctrl *dev, u8 *buf);
slimbus/slim-msm.h:struct msm_sat_chan {
slimbus/slim-msm.h:struct msm_slim_sat {
slimbus/slim-msm.h:	struct msm_slim_ctrl	*dev;
slimbus/slim-msm.h:	struct msm_sat_chan	*satch;
slimbus/slim-msm.h:int msm_slim_rx_enqueue(struct msm_slim_ctrl *dev, u32 *buf, u8 len);
slimbus/slim-msm.h:int msm_slim_rx_dequeue(struct msm_slim_ctrl *dev, u8 *buf);
slimbus/slim-msm.h:int msm_slim_get_ctrl(struct msm_slim_ctrl *dev);
slimbus/slim-msm.h:void msm_slim_put_ctrl(struct msm_slim_ctrl *dev);
slimbus/slim-msm.h:irqreturn_t msm_slim_port_irq_handler(struct msm_slim_ctrl *dev, u32 pstat);
slimbus/slim-msm.h:int msm_slim_init_endpoint(struct msm_slim_ctrl *dev, struct msm_slim_endp *ep);
slimbus/slim-msm.h:void msm_slim_free_endpoint(struct msm_slim_endp *ep);
slimbus/slim-msm.h:void msm_hw_set_port(struct msm_slim_ctrl *dev, u8 pipenum, u8 portnum);
slimbus/slim-msm.h:int msm_alloc_port(struct slim_controller *ctrl, u8 pn);
slimbus/slim-msm.h:void msm_dealloc_port(struct slim_controller *ctrl, u8 pn);
slimbus/slim-msm.h:int msm_slim_connect_pipe_port(struct msm_slim_ctrl *dev, u8 pn);
slimbus/slim-msm.h:enum slim_port_err msm_slim_port_xfer_status(struct slim_controller *ctr,
slimbus/slim-msm.h:int msm_slim_port_xfer(struct slim_controller *ctrl, u8 pn, void *buf,
slimbus/slim-msm.h:int msm_send_msg_buf(struct msm_slim_ctrl *dev, u32 *buf, u8 len, u32 tx_reg);
slimbus/slim-msm.h:u32 *msm_get_msg_buf(struct msm_slim_ctrl *dev, int len,
slimbus/slim-msm.h:u32 *msm_slim_manage_tx_msgq(struct msm_slim_ctrl *dev, bool getbuf,
slimbus/slim-msm.h:int msm_slim_rx_msgq_get(struct msm_slim_ctrl *dev, u32 *data, int offset);
slimbus/slim-msm.h:int msm_slim_sps_init(struct msm_slim_ctrl *dev, struct resource *bam_mem,
slimbus/slim-msm.h:void msm_slim_sps_exit(struct msm_slim_ctrl *dev, bool dereg);
slimbus/slim-msm.h:int msm_slim_connect_endp(struct msm_slim_ctrl *dev,
slimbus/slim-msm.h:				struct msm_slim_endp *endpoint);
slimbus/slim-msm.h:void msm_slim_disconnect_endp(struct msm_slim_ctrl *dev,
slimbus/slim-msm.h:					struct msm_slim_endp *endpoint,
slimbus/slim-msm.h:					enum msm_slim_msgq *msgq_flag);
slimbus/slim-msm.h:void msm_slim_deinit_ep(struct msm_slim_ctrl *dev,
slimbus/slim-msm.h:				struct msm_slim_endp *endpoint,
slimbus/slim-msm.h:				enum msm_slim_msgq *msgq_flag);
slimbus/slim-msm.h:void msm_slim_qmi_exit(struct msm_slim_ctrl *dev);
slimbus/slim-msm.h:int msm_slim_qmi_init(struct msm_slim_ctrl *dev, bool apps_is_master);
slimbus/slim-msm.h:int msm_slim_qmi_power_request(struct msm_slim_ctrl *dev, bool active);
slimbus/slim-msm.h:int msm_slim_qmi_check_framer_request(struct msm_slim_ctrl *dev);
slimbus/slim-msm.h:int msm_slim_qmi_deferred_status_req(struct msm_slim_ctrl *dev);
soc/bcm/brcmstb/pm/pm-arm.c:static void brcmstb_do_pmsm_power_down(unsigned long base_cmd, bool onewrite)
soc/bcm/brcmstb/pm/pm-arm.c:		brcmstb_do_pmsm_power_down(M1_PM_COLD_CONFIG, true);
soc/bcm/brcmstb/pm/pm-arm.c:	brcmstb_do_pmsm_power_down(PM_COLD_CONFIG, false);
soc/bcm/brcmstb/pm/pm-arm.c:		brcmstb_do_pmsm_power_down(PM_WARM_CONFIG, false);
soc/bcm/brcmstb/pm/pm-arm.c:		brcmstb_do_pmsm_power_down(M1_PM_WARM_CONFIG, true);
soc/qcom/Kconfig:	  Use this to report msm boot stats such as bootloader throughput,
soc/qcom/Kconfig:	  and export them in proc/msm_pm_stats. User can read
soc/qcom/Kconfig:	tristate "msm performance driver to support userspace fmin/fmax request"
soc/qcom/Makefile:obj-$(CONFIG_MSM_SPM) += msm-spm.o spm_devices.o
soc/qcom/Makefile:obj-$(CONFIG_QCOM_SMSM)	+= smsm.o
soc/qcom/Makefile:obj-$(CONFIG_MSM_TZ_SMMU) += msm_tz_smmu.o
soc/qcom/Makefile:obj-$(CONFIG_QCOM_MINIDUMP) += msm_minidump.o minidump_log.o
soc/qcom/Makefile:obj-$(CONFIG_QCOM_BUS_SCALING) += msm_bus/
soc/qcom/Makefile:obj-$(CONFIG_MSM_PERFORMANCE) += msm_performance.o
soc/qcom/Makefile:obj-$(CONFIG_ICNSS) += msm_icnss.o
soc/qcom/Makefile:msm_icnss-y := icnss.o
soc/qcom/Makefile:msm_icnss-$(CONFIG_ICNSS_QMI) += icnss_qmi.o wlan_firmware_service_v01.o
soc/qcom/bam_dmux.c:#include <linux/msm-sps.h>
soc/qcom/bam_dmux.c:static int msm_bam_dmux_debug_enable;
soc/qcom/bam_dmux.c:module_param_named(debug_enable, msm_bam_dmux_debug_enable,
soc/qcom/bam_dmux.c:	/* smsm */
soc/qcom/bam_dmux.c:	.smsm_change_state_ptr = &qcom_smem_state_update_bits,
soc/qcom/bam_dmux.c:	.smsm_get_state_ptr = &qcom_smem_state_get,
soc/qcom/bam_dmux.c:	.smsm_put_state_ptr = &qcom_smem_state_put,
soc/qcom/bam_dmux.c:static DEFINE_MUTEX(smsm_cb_lock);
soc/qcom/bam_dmux.c:int msm_bam_dmux_write(uint32_t id, struct sk_buff *skb)
soc/qcom/bam_dmux.c:int msm_bam_dmux_open(uint32_t id, void *priv,
soc/qcom/bam_dmux.c:int msm_bam_dmux_close(uint32_t id)
soc/qcom/bam_dmux.c:int msm_bam_dmux_is_ch_full(uint32_t id)
soc/qcom/bam_dmux.c:int msm_bam_dmux_is_ch_low(uint32_t id)
soc/qcom/bam_dmux.c:int msm_bam_dmux_kickoff_ul_wakeup(void)
soc/qcom/bam_dmux.c:		bam_ops->smsm_change_state_ptr(bam_ops->pwr_state,
soc/qcom/bam_dmux.c:		bam_ops->smsm_change_state_ptr(bam_ops->pwr_state,
soc/qcom/bam_dmux.c:int msm_bam_dmux_ul_power_vote(void)
soc/qcom/bam_dmux.c:int msm_bam_dmux_ul_power_unvote(void)
soc/qcom/bam_dmux.c:int msm_bam_dmux_reg_notify(void *priv,
soc/qcom/bam_dmux.c:		msm_bam_dmux_kickoff_ul_wakeup();
soc/qcom/bam_dmux.c:	bam_ops->smsm_change_state_ptr(bam_ops->pwr_ack_state,
soc/qcom/bam_dmux.c:static int bam_dmux_smsm_cb(void *state, u32 old_state, u32 new_state)
soc/qcom/bam_dmux.c:	mutex_lock(&smsm_cb_lock);
soc/qcom/bam_dmux.c:		mutex_unlock(&smsm_cb_lock);
soc/qcom/bam_dmux.c:	mutex_unlock(&smsm_cb_lock);
soc/qcom/bam_dmux.c:static irqreturn_t bam_dmux_smsm_ack_cb(int irq, void *data)
soc/qcom/bam_dmux.c:		bam_dmux_smsm_cb(NULL, 0, SMSM_A2_POWER_CONTROL);
soc/qcom/bam_dmux.c:		bam_dmux_smsm_cb(NULL, SMSM_A2_POWER_CONTROL, 0);
soc/qcom/bam_dmux.c: * msm_bam_dmux_set_bam_ops() - sets the bam_ops
soc/qcom/bam_dmux.c:void msm_bam_dmux_set_bam_ops(struct bam_ops_if *ops)
soc/qcom/bam_dmux.c:EXPORT_SYMBOL(msm_bam_dmux_set_bam_ops);
soc/qcom/bam_dmux.c: * msm_bam_dmux_deinit() - puts bam dmux into a deinited state
soc/qcom/bam_dmux.c:void msm_bam_dmux_deinit(void)
soc/qcom/bam_dmux.c:EXPORT_SYMBOL(msm_bam_dmux_deinit);
soc/qcom/bam_dmux.c: * msm_bam_dmux_reinit() - reinitializes bam dmux
soc/qcom/bam_dmux.c:void msm_bam_dmux_reinit(void)
soc/qcom/bam_dmux.c:EXPORT_SYMBOL(msm_bam_dmux_reinit);
soc/qcom/bam_dmux.c:	bam_ops->pwr_state = bam_ops->smsm_get_state_ptr(&pdev->dev,
soc/qcom/bam_dmux.c:		pr_err("%s: smsm power control state get failed, rc: %d\n",
soc/qcom/bam_dmux.c:	bam_ops->pwr_ack_state = bam_ops->smsm_get_state_ptr(&pdev->dev,
soc/qcom/bam_dmux.c:		pr_err("%s: smsm power control ack state get failed, rc: %d\n",
soc/qcom/bam_dmux.c:			dev_err(dma_dev, "smsm power control irq %d attach failed\n",
soc/qcom/bam_dmux.c:				bam_dmux_smsm_ack_cb,
soc/qcom/bam_dmux.c:			dev_err(dma_dev, "smsm power control ack irq %d attach failed\n",
soc/qcom/bam_dmux.c:	bam_ops->smsm_put_state_ptr(bam_ops->pwr_ack_state);
soc/qcom/bam_dmux.c:	bam_ops->smsm_put_state_ptr(bam_ops->pwr_state);
soc/qcom/bam_dmux.c:static const struct of_device_id msm_match_table[] = {
soc/qcom/bam_dmux.c:		.of_match_table = msm_match_table,
soc/qcom/bam_dmux_private.h:#include <linux/msm-sps.h>
soc/qcom/bam_dmux_private.h: * @smsm_change_state_ptr: pointer to smsm_change_state function
soc/qcom/bam_dmux_private.h: * @smsm_get_state_ptr: pointer to smsm_get_state function
soc/qcom/bam_dmux_private.h: * @smsm_state_cb_register_ptr: pointer to smsm_state_cb_register function
soc/qcom/bam_dmux_private.h: * @smsm_state_cb_deregister_ptr: pointer to smsm_state_cb_deregister function
soc/qcom/bam_dmux_private.h: * This struct contains the interface from bam_dmux to smsm and sps. The
soc/qcom/bam_dmux_private.h:	/* smsm */
soc/qcom/bam_dmux_private.h:	int (*smsm_change_state_ptr)(struct qcom_smem_state *state, u32 mask,
soc/qcom/bam_dmux_private.h:	struct qcom_smem_state *(*smsm_get_state_ptr)(struct device *dev,
soc/qcom/bam_dmux_private.h:	void (*smsm_put_state_ptr)(struct qcom_smem_state *state);
soc/qcom/bam_dmux_private.h:void msm_bam_dmux_set_bam_ops(struct bam_ops_if *ops);
soc/qcom/bam_dmux_private.h:void msm_bam_dmux_deinit(void);
soc/qcom/bam_dmux_private.h:void msm_bam_dmux_reinit(void);
soc/qcom/boot_stats.c:				"qcom,msm-imem-boot_stats");
soc/qcom/boot_stats.c:		pr_err("can't find qcom,msm-imem node\n");
soc/qcom/cdsprm.c:	{ .compatible = "qcom,msm-cdsprm-rpmsg" },
soc/qcom/cdsprm.c:		.name = "qcom,msm_cdsprm_rpmsg",
soc/qcom/cdsprm.c:	{ .compatible = "qcom,msm-cdsp-rm" },
soc/qcom/cdsprm.c:		.name = "msm_cdsp_rm",
soc/qcom/cdsprm.c:	{ .compatible = "qcom,msm-hvx-rm" },
soc/qcom/cdsprm.c:		.name = "msm_hvx_rm",
soc/qcom/core_hang_detect.c:#define MODULE_NAME	"msm_hang_detect"
soc/qcom/core_hang_detect.c:static const struct of_device_id msm_hang_detect_table[] = {
soc/qcom/core_hang_detect.c:static int msm_hang_detect_probe(struct platform_device *pdev)
soc/qcom/core_hang_detect.c:static int msm_hang_detect_remove(struct platform_device *pdev)
soc/qcom/core_hang_detect.c:static struct platform_driver msm_hang_detect_driver = {
soc/qcom/core_hang_detect.c:	.probe = msm_hang_detect_probe,
soc/qcom/core_hang_detect.c:	.remove = msm_hang_detect_remove,
soc/qcom/core_hang_detect.c:		.of_match_table = msm_hang_detect_table,
soc/qcom/core_hang_detect.c:module_platform_driver(msm_hang_detect_driver);
soc/qcom/cpuss_dump.c:	struct msm_dump_data *dump_data;
soc/qcom/cpuss_dump.c:	struct msm_dump_entry dump_entry;
soc/qcom/cpuss_dump.c:				sizeof(struct msm_dump_data), GFP_KERNEL);
soc/qcom/cpuss_dump.c:		ret = msm_dump_data_register(MSM_DUMP_TABLE_APPS, &dump_entry);
soc/qcom/cpuss_dump.c:		.name = "msm_cpuss_dump",
soc/qcom/dcc.c:	struct msm_dump_data	reg_data;
soc/qcom/dcc.c:	struct msm_dump_data	sram_data;
soc/qcom/dcc.c:	struct msm_rpm_kvp	rpm_kvp;
soc/qcom/dcc.c:	struct msm_rpm_kvp *rpm_kvp = &drvdata->rpm_kvp;
soc/qcom/dcc.c:	ret = msm_rpm_send_message(MSM_RPM_CTX_ACTIVE_SET,
soc/qcom/dcc.c:	struct msm_dump_entry reg_dump_entry, sram_dump_entry;
soc/qcom/dcc.c:		ret = msm_dump_data_register(MSM_DUMP_TABLE_APPS,
soc/qcom/dcc.c:		ret = msm_dump_data_register(MSM_DUMP_TABLE_APPS,
soc/qcom/dcc.c:static const struct of_device_id msm_dcc_match[] = {
soc/qcom/dcc.c:		.name   = "msm-dcc",
soc/qcom/dcc.c:		.of_match_table	= msm_dcc_match,
soc/qcom/dcc_v2.c:	if (msm_minidump_add_region(&md_entry))
soc/qcom/dcc_v2.c:static const struct of_device_id msm_dcc_match[] = {
soc/qcom/dcc_v2.c:		.name   = "msm-dcc",
soc/qcom/dcc_v2.c:		.of_match_table	= msm_dcc_match,
soc/qcom/ddr_stats.c:MODULE_ALIAS("platform:msm_ddr_stats_log");
soc/qcom/eud.c:	.driver_name	= "msm-eud",
soc/qcom/eud.c:static int msm_eud_suspend(struct device *dev)
soc/qcom/eud.c:static int msm_eud_resume(struct device *dev)
soc/qcom/eud.c:static int msm_eud_probe(struct platform_device *pdev)
soc/qcom/eud.c:static int msm_eud_remove(struct platform_device *pdev)
soc/qcom/eud.c:static const struct of_device_id msm_eud_dt_match[] = {
soc/qcom/eud.c:	{.compatible = "qcom,msm-eud"},
soc/qcom/eud.c:MODULE_DEVICE_TABLE(of, msm_eud_dt_match);
soc/qcom/eud.c:static const struct dev_pm_ops msm_eud_dev_pm_ops = {
soc/qcom/eud.c:	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(msm_eud_suspend, msm_eud_resume)
soc/qcom/eud.c:static struct platform_driver msm_eud_driver = {
soc/qcom/eud.c:	.probe		= msm_eud_probe,
soc/qcom/eud.c:	.remove		= msm_eud_remove,
soc/qcom/eud.c:		.name		= "msm-eud",
soc/qcom/eud.c:		.pm = &msm_eud_dev_pm_ops,
soc/qcom/eud.c:		.of_match_table = msm_eud_dt_match,
soc/qcom/eud.c:static int __init msm_eud_init(void)
soc/qcom/eud.c:	ret = platform_driver_register(&msm_eud_driver);
soc/qcom/eud.c:module_init(msm_eud_init);
soc/qcom/eud.c:static void __exit msm_eud_exit(void)
soc/qcom/eud.c:	platform_driver_unregister(&msm_eud_driver);
soc/qcom/eud.c:module_exit(msm_eud_exit);
soc/qcom/gladiator_erp.c:struct msm_gladiator_data {
soc/qcom/gladiator_erp.c:				struct msm_gladiator_data *msm_gld_data)
soc/qcom/gladiator_erp.c:		decode_gld_errlog0(err_reg, msm_gld_data->reg_masks_shifts);
soc/qcom/gladiator_erp.c:		decode_gld_errlog1(err_reg, msm_gld_data->reg_masks_shifts);
soc/qcom/gladiator_erp.c:		decode_gld_errlog2(err_reg, msm_gld_data->reg_masks_shifts);
soc/qcom/gladiator_erp.c:		struct msm_gladiator_data *msm_gld_data)
soc/qcom/gladiator_erp.c:		decode_obs_errlog0(err_reg, msm_gld_data->reg_masks_shifts);
soc/qcom/gladiator_erp.c:		decode_obs_errlog0_len(err_reg, msm_gld_data->reg_masks_shifts);
soc/qcom/gladiator_erp.c:		struct msm_gladiator_data *msm_gld_data)
soc/qcom/gladiator_erp.c:		decode_obs_errlog0(err_reg, msm_gld_data->reg_masks_shifts);
soc/qcom/gladiator_erp.c:		decode_obs_errlog0_len(err_reg, msm_gld_data->reg_masks_shifts);
soc/qcom/gladiator_erp.c:static void decode_gld_errlog5(struct msm_gladiator_data *msm_gld_data)
soc/qcom/gladiator_erp.c:	struct reg_masks_shift *mask_shifts = msm_gld_data->reg_masks_shifts;
soc/qcom/gladiator_erp.c:	err_reg0 = readl_relaxed(msm_gld_data->gladiator_virt_base +
soc/qcom/gladiator_erp.c:			get_gld_offset(ERR_LOG0, msm_gld_data->reg_offs));
soc/qcom/gladiator_erp.c:	err_reg5 = readl_relaxed(msm_gld_data->gladiator_virt_base +
soc/qcom/gladiator_erp.c:			get_gld_offset(ERR_LOG5, msm_gld_data->reg_offs));
soc/qcom/gladiator_erp.c:static void dump_gld_err_regs(struct msm_gladiator_data *msm_gld_data,
soc/qcom/gladiator_erp.c:	if (msm_gld_data->glad_v2 || msm_gld_data->glad_v3) {
soc/qcom/gladiator_erp.c:				msm_gld_data->gladiator_virt_base +
soc/qcom/gladiator_erp.c:					msm_gld_data->reg_offs));
soc/qcom/gladiator_erp.c:static void dump_obsrv_err_regs(struct msm_gladiator_data *msm_gld_data,
soc/qcom/gladiator_erp.c:	if (msm_gld_data->glad_v2) {
soc/qcom/gladiator_erp.c:	} else if (msm_gld_data->glad_v3) {
soc/qcom/gladiator_erp.c:				msm_gld_data->gladiator_virt_base +
soc/qcom/gladiator_erp.c:					msm_gld_data->reg_offs)
soc/qcom/gladiator_erp.c:static void parse_gld_err_regs(struct msm_gladiator_data *msm_gld_data,
soc/qcom/gladiator_erp.c:			decode_gld_errlog5(msm_gld_data);
soc/qcom/gladiator_erp.c:				msm_gld_data);
soc/qcom/gladiator_erp.c:static void parse_obsrv_err_regs(struct msm_gladiator_data *msm_gld_data,
soc/qcom/gladiator_erp.c:	if (msm_gld_data->glad_v2) {
soc/qcom/gladiator_erp.c:					msm_gld_data);
soc/qcom/gladiator_erp.c:	} else if (msm_gld_data->glad_v3) {
soc/qcom/gladiator_erp.c:					msm_gld_data);
soc/qcom/gladiator_erp.c:					msm_gld_data);
soc/qcom/gladiator_erp.c:static irqreturn_t msm_gladiator_isr(int irq, void *dev_id)
soc/qcom/gladiator_erp.c:	struct msm_gladiator_data *msm_gld_data = dev_id;
soc/qcom/gladiator_erp.c:	bool gld_err_valid = readl_relaxed(msm_gld_data->gladiator_virt_base +
soc/qcom/gladiator_erp.c:			msm_gld_data->reg_offs->gladiator_errvld);
soc/qcom/gladiator_erp.c:			msm_gld_data->gladiator_virt_base +
soc/qcom/gladiator_erp.c:			msm_gld_data->reg_offs->observer_0_errvld);
soc/qcom/gladiator_erp.c:		clear_gladiator_error(msm_gld_data->gladiator_virt_base,
soc/qcom/gladiator_erp.c:					msm_gld_data->reg_offs);
soc/qcom/gladiator_erp.c:		dump_gld_err_regs(msm_gld_data, gld_err_buf);
soc/qcom/gladiator_erp.c:		dump_obsrv_err_regs(msm_gld_data, obs_err_buf);
soc/qcom/gladiator_erp.c:		parse_gld_err_regs(msm_gld_data, gld_err_buf);
soc/qcom/gladiator_erp.c:		parse_obsrv_err_regs(msm_gld_data, obs_err_buf);
soc/qcom/gladiator_erp.c:	clear_gladiator_error(msm_gld_data->gladiator_virt_base,
soc/qcom/gladiator_erp.c:				msm_gld_data->reg_offs);
soc/qcom/gladiator_erp.c:	{ .compatible = "qcom,msm-gladiator-v2" },
soc/qcom/gladiator_erp.c:	{ .compatible = "qcom,msm-gladiator-v3" },
soc/qcom/gladiator_erp.c:		struct msm_gladiator_data *msm_gld_data)
soc/qcom/gladiator_erp.c:				"msm-gladiator-erp")) {
soc/qcom/gladiator_erp.c:	msm_gld_data->gladiator_virt_base  = devm_ioremap(&pdev->dev,
soc/qcom/gladiator_erp.c:	if (!msm_gld_data->gladiator_virt_base) {
soc/qcom/gladiator_erp.c:	msm_gld_data->erp_irq = platform_get_irq(pdev, 0);
soc/qcom/gladiator_erp.c:	if (!msm_gld_data->erp_irq)
soc/qcom/gladiator_erp.c:	clear_gladiator_error(msm_gld_data->gladiator_virt_base,
soc/qcom/gladiator_erp.c:			msm_gld_data->reg_offs);
soc/qcom/gladiator_erp.c:	ret = devm_request_irq(&pdev->dev, msm_gld_data->erp_irq,
soc/qcom/gladiator_erp.c:			msm_gladiator_isr, IRQF_TRIGGER_HIGH,
soc/qcom/gladiator_erp.c:			"gladiator-error", msm_gld_data);
soc/qcom/gladiator_erp.c:	struct msm_gladiator_data *msm_gld_data = container_of(nb,
soc/qcom/gladiator_erp.c:			struct msm_gladiator_data, pm_notifier_block);
soc/qcom/gladiator_erp.c:		gladiator_irq_init(msm_gld_data->gladiator_virt_base,
soc/qcom/gladiator_erp.c:				msm_gld_data->reg_offs);
soc/qcom/gladiator_erp.c:static void init_offsets_and_masks_v2(struct msm_gladiator_data *msm_gld_data)
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_id_coreid		= 0x0;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_id_revisionid		= 0x4;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_faulten		= 0x1010;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errvld		= 0x1014;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errclr		= 0x1018;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog0		= 0x101C;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog1		= 0x1020;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog2		= 0x1024;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog3		= 0x1028;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog4		= 0x102C;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog5		= 0x1030;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog6		= 0x1034;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog7		= 0x1038;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog8		= 0x103C;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_id_coreid		= 0x8000;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_id_revisionid	= 0x8004;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_faulten		= 0x8008;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errvld		= 0x800C;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errclr		= 0x8010;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog0		= 0x8014;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog1		= 0x8018;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog2		= 0x801C;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog3		= 0x8020;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog4		= 0x8024;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog5		= 0x8028;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog6		= 0x802C;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog7		= 0x8030;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog8		= 0x8034;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_stallen		= 0x8038;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_trans_opcode_mask = 0xE;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_trans_opcode_shift = 1;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_error_type_mask = 0x700;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_error_type_shift = 8;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_len1_mask = 0xFFF;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_len1_shift = 16;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_trans_sourceid_mask = 0x7;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_trans_sourceid_shift = 0;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_trans_targetid_mask = 0x7;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_trans_targetid_shift = 0;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_errlog_error = 0x7;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_errlog5_error_type_mask =
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_errlog5_error_type_shift = 24;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_ace_port_parity_mask = 0xc000;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_ace_port_parity_shift = 14;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_ace_port_disconnect_mask = 0xf0000;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_ace_port_disconnect_shift = 16;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_ace_port_directory_mask = 0xf00000;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_ace_port_directory_shift = 20;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_index_parity_mask = 0x1FFF;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_index_parity_shift = 0;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->obs_trans_opcode_mask = 0x1E;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->obs_trans_opcode_shift = 1;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->obs_error_type_mask = 0x700;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->obs_error_type_shift = 8;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->obs_len1_mask = 0x7F0;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->obs_len1_shift = 16;
soc/qcom/gladiator_erp.c:static void init_offsets_and_masks_v3(struct msm_gladiator_data *msm_gld_data)
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_id_coreid	= 0x0;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_id_revisionid = 0x4;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_faulten	= 0x1010;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errvld	= 0x1014;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errclr	= 0x1018;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog0	= 0x101C;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog1	= 0x1020;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog2	= 0x1024;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog3	= 0x1028;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog4	= 0x102C;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog5	= 0x1030;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog6	= 0x1034;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog7	= 0x1038;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->gladiator_errlog8	= 0x103C;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_id_coreid	= INVALID_NUM;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_id_revisionid = INVALID_NUM;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_faulten	= 0x2008;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errvld	= 0x2010;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errclr	= 0x2018;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog0	= 0x2020;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog1	= 0x2024;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog2	= 0x2028;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog3	= 0x202C;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog4	= 0x2030;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog5	= 0x2034;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog6	= 0x2038;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog7	= 0x203C;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_errlog8	= INVALID_NUM;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs->observer_0_stallen	= INVALID_NUM;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_trans_opcode_mask = 0xE;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_trans_opcode_shift = 1;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_error_type_mask = 0x700;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_error_type_shift = 8;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_len1_mask = 0xFFF0000;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_len1_shift = 16;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_trans_sourceid_mask = 0x7;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_trans_sourceid_shift = 0;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_trans_targetid_mask = 0x7;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_trans_targetid_shift = 0;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_errlog_error = 0x7;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_errlog5_error_type_mask =
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_errlog5_error_type_shift = 24;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_ace_port_parity_mask = 0xc000;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_ace_port_parity_shift = 14;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_ace_port_disconnect_mask = 0xf0000;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_ace_port_disconnect_shift = 16;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_ace_port_directory_mask = 0xf00000;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_ace_port_directory_shift = 20;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_index_parity_mask = 0x1FFF;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->gld_index_parity_shift = 0;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->obs_trans_opcode_mask = 0x70;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->obs_trans_opcode_shift = 4;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->obs_error_type_mask = 0x700;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->obs_error_type_shift = 8;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->obs_len1_mask = 0x1FF;
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts->obs_len1_shift = 0;
soc/qcom/gladiator_erp.c:	struct msm_gladiator_data *msm_gld_data;
soc/qcom/gladiator_erp.c:	msm_gld_data = devm_kzalloc(&pdev->dev,
soc/qcom/gladiator_erp.c:			sizeof(struct msm_gladiator_data), GFP_KERNEL);
soc/qcom/gladiator_erp.c:	if (!msm_gld_data) {
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_offs = devm_kzalloc(&pdev->dev,
soc/qcom/gladiator_erp.c:	msm_gld_data->reg_masks_shifts = devm_kzalloc(&pdev->dev,
soc/qcom/gladiator_erp.c:	if (!msm_gld_data->reg_offs || !msm_gld_data->reg_masks_shifts) {
soc/qcom/gladiator_erp.c:	msm_gld_data->glad_v2 = of_device_is_compatible(pdev->dev.of_node,
soc/qcom/gladiator_erp.c:					"qcom,msm-gladiator-v2");
soc/qcom/gladiator_erp.c:	msm_gld_data->glad_v3 = of_device_is_compatible(pdev->dev.of_node,
soc/qcom/gladiator_erp.c:					"qcom,msm-gladiator-v3");
soc/qcom/gladiator_erp.c:	if (msm_gld_data->glad_v2)
soc/qcom/gladiator_erp.c:		init_offsets_and_masks_v2(msm_gld_data);
soc/qcom/gladiator_erp.c:	else if (msm_gld_data->glad_v3)
soc/qcom/gladiator_erp.c:		init_offsets_and_masks_v3(msm_gld_data);
soc/qcom/gladiator_erp.c:	if (msm_gld_data->glad_v2) {
soc/qcom/gladiator_erp.c:			msm_gld_data->qdss_clk = devm_clk_get(&pdev->dev,
soc/qcom/gladiator_erp.c:			if (IS_ERR(msm_gld_data->qdss_clk)) {
soc/qcom/gladiator_erp.c:		ret = clk_prepare_enable(msm_gld_data->qdss_clk);
soc/qcom/gladiator_erp.c:	ret = parse_dt_node(pdev, msm_gld_data);
soc/qcom/gladiator_erp.c:	msm_gld_data->pm_notifier_block.notifier_call =
soc/qcom/gladiator_erp.c:	gladiator_irq_init(msm_gld_data->gladiator_virt_base,
soc/qcom/gladiator_erp.c:			msm_gld_data->reg_offs);
soc/qcom/gladiator_erp.c:	platform_set_drvdata(pdev, msm_gld_data);
soc/qcom/gladiator_erp.c:	cpu_pm_register_notifier(&msm_gld_data->pm_notifier_block);
soc/qcom/gladiator_erp.c:	clk_disable_unprepare(msm_gld_data->qdss_clk);
soc/qcom/gladiator_erp.c:	struct msm_gladiator_data *msm_gld_data = platform_get_drvdata(pdev);
soc/qcom/gladiator_erp.c:	cpu_pm_unregister_notifier(&msm_gld_data->pm_notifier_block);
soc/qcom/gladiator_erp.c:	clk_disable_unprepare(msm_gld_data->qdss_clk);
soc/qcom/gladiator_hang_detect.c:static const struct of_device_id msm_gladiator_hang_detect_table[] = {
soc/qcom/gladiator_hang_detect.c:static int msm_gladiator_hang_detect_probe(struct platform_device *pdev)
soc/qcom/gladiator_hang_detect.c:static int msm_gladiator_hang_detect_remove(struct platform_device *pdev)
soc/qcom/gladiator_hang_detect.c:static struct platform_driver msm_gladiator_hang_detect_driver = {
soc/qcom/gladiator_hang_detect.c:	.probe = msm_gladiator_hang_detect_probe,
soc/qcom/gladiator_hang_detect.c:	.remove = msm_gladiator_hang_detect_remove,
soc/qcom/gladiator_hang_detect.c:		.of_match_table = msm_gladiator_hang_detect_table,
soc/qcom/gladiator_hang_detect.c:	return platform_driver_register(&msm_gladiator_hang_detect_driver);
soc/qcom/gladiator_hang_detect.c:	platform_driver_unregister(&msm_gladiator_hang_detect_driver);
soc/qcom/glink_probe.c:		.name = "msm_glink",
soc/qcom/jtagv8-etm.c:int msm_jtag_save_register(struct notifier_block *nb)
soc/qcom/jtagv8-etm.c:EXPORT_SYMBOL(msm_jtag_save_register);
soc/qcom/jtagv8-etm.c:int msm_jtag_save_unregister(struct notifier_block *nb)
soc/qcom/jtagv8-etm.c:EXPORT_SYMBOL(msm_jtag_save_unregister);
soc/qcom/jtagv8-etm.c:int msm_jtag_restore_register(struct notifier_block *nb)
soc/qcom/jtagv8-etm.c:EXPORT_SYMBOL(msm_jtag_restore_register);
soc/qcom/jtagv8-etm.c:int msm_jtag_restore_unregister(struct notifier_block *nb)
soc/qcom/jtagv8-etm.c:EXPORT_SYMBOL(msm_jtag_restore_unregister);
soc/qcom/jtagv8-etm.c:void msm_jtag_etm_save_state(void)
soc/qcom/jtagv8-etm.c:EXPORT_SYMBOL(msm_jtag_etm_save_state);
soc/qcom/jtagv8-etm.c:void msm_jtag_etm_restore_state(void)
soc/qcom/jtagv8-etm.c:EXPORT_SYMBOL(msm_jtag_etm_restore_state);
soc/qcom/jtagv8-etm.c:static const struct of_device_id msm_qdss_mm_match[] = {
soc/qcom/jtagv8-etm.c:		.name   = "msm-jtagv8-mm",
soc/qcom/jtagv8-etm.c:		.of_match_table	= msm_qdss_mm_match,
soc/qcom/jtagv8.c:static uint32_t msm_jtag_save_cntr[NR_CPUS];
soc/qcom/jtagv8.c:static uint32_t msm_jtag_restore_cntr[NR_CPUS];
soc/qcom/jtagv8.c: * msm_jtag_save_state - save debug registers
soc/qcom/jtagv8.c:void msm_jtag_save_state(void)
soc/qcom/jtagv8.c:	msm_jtag_save_cntr[cpu]++;
soc/qcom/jtagv8.c:	msm_jtag_etm_save_state();
soc/qcom/jtagv8.c:EXPORT_SYMBOL(msm_jtag_save_state);
soc/qcom/jtagv8.c:void msm_jtag_restore_state(void)
soc/qcom/jtagv8.c:	 * and hence msm_jtag_save_state will not occur. Subsequently,
soc/qcom/jtagv8.c:	 * during hotplug on of non-boot core when msm_jtag_restore_state
soc/qcom/jtagv8.c:	 * is called via msm_platform_secondary_init, this check will help
soc/qcom/jtagv8.c:	if (msm_jtag_save_cntr[cpu] == msm_jtag_restore_cntr[cpu])
soc/qcom/jtagv8.c:	else if (msm_jtag_save_cntr[cpu] != msm_jtag_restore_cntr[cpu] + 1)
soc/qcom/jtagv8.c:				   (unsigned long)msm_jtag_save_cntr[cpu],
soc/qcom/jtagv8.c:				   (unsigned long)msm_jtag_restore_cntr[cpu]);
soc/qcom/jtagv8.c:	msm_jtag_restore_cntr[cpu]++;
soc/qcom/jtagv8.c:	msm_jtag_etm_restore_state();
soc/qcom/jtagv8.c:EXPORT_SYMBOL(msm_jtag_restore_state);
soc/qcom/jtagv8.c:	msm_jtag_save_state();
soc/qcom/jtagv8.c:	msm_jtag_restore_state();
soc/qcom/jtagv8.c:		msm_jtag_save_state();
soc/qcom/jtagv8.c:		msm_jtag_restore_state();
soc/qcom/jtagv8.c:static int __init msm_jtag_dbg_init(void)
soc/qcom/jtagv8.c:arch_initcall(msm_jtag_dbg_init);
soc/qcom/mem-offline.c:	struct msm_rpm_kvp rpm_kvp;
soc/qcom/mem-offline.c:	return msm_rpm_send_message(MSM_RPM_CTX_ACTIVE_SET, RPM_DDR_REQ, 0,
soc/qcom/memory_dump_v2.c:struct msm_dump_table {
soc/qcom/memory_dump_v2.c:	struct msm_dump_entry entries[MAX_NUM_ENTRIES];
soc/qcom/memory_dump_v2.c:struct msm_memory_dump {
soc/qcom/memory_dump_v2.c:	struct msm_dump_table *table;
soc/qcom/memory_dump_v2.c:static struct msm_memory_dump memdump;
soc/qcom/memory_dump_v2.c:static struct msm_mem_dump_vaddr_tbl vaddr_tbl;
soc/qcom/memory_dump_v2.c:uint32_t msm_dump_table_version(void)
soc/qcom/memory_dump_v2.c:EXPORT_SYMBOL(msm_dump_table_version);
soc/qcom/memory_dump_v2.c:static int msm_dump_table_register(struct msm_dump_entry *entry)
soc/qcom/memory_dump_v2.c:	struct msm_dump_entry *e;
soc/qcom/memory_dump_v2.c:	struct msm_dump_table *table = memdump.table;
soc/qcom/memory_dump_v2.c:	dmac_flush_range(table, (void *)table + sizeof(struct msm_dump_table));
soc/qcom/memory_dump_v2.c:static struct msm_dump_table *msm_dump_get_table(enum msm_dump_table_ids id)
soc/qcom/memory_dump_v2.c:	struct msm_dump_table *table = memdump.table;
soc/qcom/memory_dump_v2.c:static int msm_dump_data_add_minidump(struct msm_dump_entry *entry)
soc/qcom/memory_dump_v2.c:	struct msm_dump_data *data;
soc/qcom/memory_dump_v2.c:	data = (struct msm_dump_data *)(phys_to_virt(entry->addr));
soc/qcom/memory_dump_v2.c:	return msm_minidump_add_region(&md_entry);
soc/qcom/memory_dump_v2.c:static int register_dump_table_entry(enum msm_dump_table_ids id,
soc/qcom/memory_dump_v2.c:					struct msm_dump_entry *entry)
soc/qcom/memory_dump_v2.c:	struct msm_dump_entry *e;
soc/qcom/memory_dump_v2.c:	struct msm_dump_table *table;
soc/qcom/memory_dump_v2.c:	table = msm_dump_get_table(id);
soc/qcom/memory_dump_v2.c:	dmac_flush_range(table, (void *)table + sizeof(struct msm_dump_table));
soc/qcom/memory_dump_v2.c: * msm_dump_data_register - register to dump data and minidump framework
soc/qcom/memory_dump_v2.c:int msm_dump_data_register(enum msm_dump_table_ids id,
soc/qcom/memory_dump_v2.c:			   struct msm_dump_entry *entry)
soc/qcom/memory_dump_v2.c:		if (msm_dump_data_add_minidump(entry) < 0)
soc/qcom/memory_dump_v2.c:EXPORT_SYMBOL(msm_dump_data_register);
soc/qcom/memory_dump_v2.c: * msm_dump_data_register_nominidump - register to dump data framework
soc/qcom/memory_dump_v2.c:int msm_dump_data_register_nominidump(enum msm_dump_table_ids id,
soc/qcom/memory_dump_v2.c:			   struct msm_dump_entry *entry)
soc/qcom/memory_dump_v2.c:EXPORT_SYMBOL(msm_dump_data_register_nominidump);
soc/qcom/memory_dump_v2.c:struct dump_vaddr_entry *get_msm_dump_ptr(enum msm_dump_data_ids id)
soc/qcom/memory_dump_v2.c:EXPORT_SYMBOL(get_msm_dump_ptr);
soc/qcom/memory_dump_v2.c:	struct msm_dump_table *table;
soc/qcom/memory_dump_v2.c:	struct msm_dump_entry entry;
soc/qcom/memory_dump_v2.c:				     "qcom,msm-imem-mem_dump_table");
soc/qcom/memory_dump_v2.c:	ret = msm_dump_table_register(&entry);
soc/qcom/memory_dump_v2.c:#define MSM_DUMP_DATA_SIZE sizeof(struct msm_dump_data)
soc/qcom/memory_dump_v2.c:	struct msm_dump_data *dump_data;
soc/qcom/memory_dump_v2.c:	struct msm_dump_entry dump_entry;
soc/qcom/memory_dump_v2.c:	total_size = sizeof(struct msm_dump_table) * 2;
soc/qcom/memory_dump_v2.c:	dump_vaddr += (sizeof(struct msm_dump_table) * 2);
soc/qcom/memory_dump_v2.c:	phys_addr += (sizeof(struct msm_dump_table) * 2);
soc/qcom/memory_dump_v2.c:		ret = msm_dump_data_register_nominidump(MSM_DUMP_TABLE_APPS,
soc/qcom/memory_dump_v2.c:		if (msm_minidump_add_region(&md_entry) < 0)
soc/qcom/memory_dump_v2.c:		.name = "msm_mem_dump",
soc/qcom/memshare/Makefile:obj-$(CONFIG_MEM_SHARE_QMI_SERVICE) := heap_mem_ext_v01.o msm_memshare.o
soc/qcom/memshare/msm_memshare.c:#include "msm_memshare.h"
soc/qcom/minidump_log.c:	if (msm_minidump_add_region(&md_entry) < 0)
soc/qcom/minidump_log.c:	entry = msm_minidump_add_region(ksp_entry);
soc/qcom/minidump_log.c:	if (msm_minidump_add_region(&ksec_entry) < 0)
soc/qcom/minidump_log.c:		if (msm_minidump_add_region(&ksec_entry) < 0)
soc/qcom/minidump_log.c:	if (msm_minidump_add_region(&ktsk_entry) < 0)
soc/qcom/minidump_log.c:	if (msm_minidump_update_region(mdno, ksp_entry) < 0) {
soc/qcom/minidump_log.c:static int __init msm_minidump_log_init(void)
soc/qcom/minidump_log.c:subsys_initcall(msm_minidump_log_init);
soc/qcom/msm-spm.c:static uint32_t msm_spm_reg_offsets_saw2_v2_1[MSM_SPM_REG_NR] = {
soc/qcom/msm-spm.c:static uint32_t msm_spm_reg_offsets_saw2_v3_0[MSM_SPM_REG_NR] = {
soc/qcom/msm-spm.c:static uint32_t msm_spm_reg_offsets_saw2_v4_1[MSM_SPM_REG_NR] = {
soc/qcom/msm-spm.c:		msm_spm_reg_offsets_saw2_v2_1,
soc/qcom/msm-spm.c:		msm_spm_reg_offsets_saw2_v3_0,
soc/qcom/msm-spm.c:		msm_spm_reg_offsets_saw2_v3_0,
soc/qcom/msm-spm.c:		msm_spm_reg_offsets_saw2_v4_1,
soc/qcom/msm-spm.c:static void msm_spm_drv_flush_shadow(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:static void msm_spm_drv_load_shadow(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:static inline uint32_t msm_spm_drv_get_num_spm_entry(
soc/qcom/msm-spm.c:		struct msm_spm_driver_data *dev)
soc/qcom/msm-spm.c:	msm_spm_drv_load_shadow(dev, MSM_SPM_REG_SAW_ID);
soc/qcom/msm-spm.c:static inline void msm_spm_drv_set_start_addr(
soc/qcom/msm-spm.c:		struct msm_spm_driver_data *dev, uint32_t ctl)
soc/qcom/msm-spm.c:static inline bool msm_spm_pmic_arb_present(struct msm_spm_driver_data *dev)
soc/qcom/msm-spm.c:	msm_spm_drv_load_shadow(dev, MSM_SPM_REG_SAW_ID);
soc/qcom/msm-spm.c:static inline void msm_spm_drv_set_vctl2(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:	msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_VCTL);
soc/qcom/msm-spm.c:	msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_PMIC_DATA_3);
soc/qcom/msm-spm.c:static inline uint32_t msm_spm_drv_get_num_pmic_data(
soc/qcom/msm-spm.c:		struct msm_spm_driver_data *dev)
soc/qcom/msm-spm.c:	msm_spm_drv_load_shadow(dev, MSM_SPM_REG_SAW_ID);
soc/qcom/msm-spm.c:static inline uint32_t msm_spm_drv_get_sts_pmic_state(
soc/qcom/msm-spm.c:		struct msm_spm_driver_data *dev)
soc/qcom/msm-spm.c:	msm_spm_drv_load_shadow(dev, MSM_SPM_REG_SAW_PMIC_STS);
soc/qcom/msm-spm.c:uint32_t msm_spm_drv_get_sts_curr_pmic_data(
soc/qcom/msm-spm.c:		struct msm_spm_driver_data *dev)
soc/qcom/msm-spm.c:	msm_spm_drv_load_shadow(dev, MSM_SPM_REG_SAW_PMIC_STS);
soc/qcom/msm-spm.c:static inline void msm_spm_drv_get_saw2_ver(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:inline int msm_spm_drv_set_spm_enable(
soc/qcom/msm-spm.c:		struct msm_spm_driver_data *dev, bool enable)
soc/qcom/msm-spm.c:		msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_SPM_CTL);
soc/qcom/msm-spm.c:int msm_spm_drv_get_avs_enable(struct msm_spm_driver_data *dev)
soc/qcom/msm-spm.c:int msm_spm_drv_set_avs_enable(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:		msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_AVS_CTL);
soc/qcom/msm-spm.c:int msm_spm_drv_set_avs_limit(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:	msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_AVS_LIMIT);
soc/qcom/msm-spm.c:static int msm_spm_drv_avs_irq_mask(enum msm_spm_avs_irq irq)
soc/qcom/msm-spm.c:int msm_spm_drv_set_avs_irq_enable(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:		enum msm_spm_avs_irq irq, bool enable)
soc/qcom/msm-spm.c:	int mask = msm_spm_drv_avs_irq_mask(irq);
soc/qcom/msm-spm.c:		msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_AVS_CTL);
soc/qcom/msm-spm.c:int msm_spm_drv_avs_clear_irq(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:		enum msm_spm_avs_irq irq)
soc/qcom/msm-spm.c:	int mask = msm_spm_drv_avs_irq_mask(irq);
soc/qcom/msm-spm.c:		msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_AVS_CTL);
soc/qcom/msm-spm.c:		msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_AVS_CTL);
soc/qcom/msm-spm.c:void msm_spm_drv_flush_seq_entry(struct msm_spm_driver_data *dev)
soc/qcom/msm-spm.c:	int num_spm_entry = msm_spm_drv_get_num_spm_entry(dev);
soc/qcom/msm-spm.c:void dump_regs(struct msm_spm_driver_data *dev, int cpu)
soc/qcom/msm-spm.c:	msm_spm_drv_load_shadow(dev, MSM_SPM_REG_SAW_SPM_STS);
soc/qcom/msm-spm.c:	msm_spm_drv_load_shadow(dev, MSM_SPM_REG_SAW_SPM_CTL);
soc/qcom/msm-spm.c:int msm_spm_drv_write_seq_data(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:int msm_spm_drv_set_low_power_mode(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:	msm_spm_drv_set_start_addr(dev, ctl);
soc/qcom/msm-spm.c:	msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_SPM_CTL);
soc/qcom/msm-spm.c:	msm_spm_drv_load_shadow(dev, MSM_SPM_REG_SAW_SPM_STS);
soc/qcom/msm-spm.c:uint32_t msm_spm_drv_get_vdd(struct msm_spm_driver_data *dev)
soc/qcom/msm-spm.c:	msm_spm_drv_load_shadow(dev, MSM_SPM_REG_SAW_PMIC_STS);
soc/qcom/msm-spm.c:static bool msm_spm_drv_is_avs_enabled(struct msm_spm_driver_data *dev)
soc/qcom/msm-spm.c:	msm_spm_drv_load_shadow(dev, MSM_SPM_REG_SAW_AVS_CTL);
soc/qcom/msm-spm.c:static void msm_spm_drv_disable_avs(struct msm_spm_driver_data *dev)
soc/qcom/msm-spm.c:	msm_spm_drv_load_shadow(dev, MSM_SPM_REG_SAW_AVS_CTL);
soc/qcom/msm-spm.c:	msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_AVS_CTL);
soc/qcom/msm-spm.c:static void msm_spm_drv_enable_avs(struct msm_spm_driver_data *dev)
soc/qcom/msm-spm.c:	msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_AVS_CTL);
soc/qcom/msm-spm.c:static void msm_spm_drv_set_avs_vlevel(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:	msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_AVS_CTL);
soc/qcom/msm-spm.c:static bool msm_spm_drv_is_avs_enabled(struct msm_spm_driver_data *dev)
soc/qcom/msm-spm.c:static void msm_spm_drv_disable_avs(struct msm_spm_driver_data *dev) { }
soc/qcom/msm-spm.c:static void msm_spm_drv_enable_avs(struct msm_spm_driver_data *dev) { }
soc/qcom/msm-spm.c:static void msm_spm_drv_set_avs_vlevel(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:static inline int msm_spm_drv_validate_data(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:		new_level = msm_spm_drv_get_sts_curr_pmic_data(dev);
soc/qcom/msm-spm.c:int msm_spm_drv_set_vdd(struct msm_spm_driver_data *dev, unsigned int vlevel)
soc/qcom/msm-spm.c:	avs_enabled  = msm_spm_drv_is_avs_enabled(dev);
soc/qcom/msm-spm.c:	if (!msm_spm_pmic_arb_present(dev))
soc/qcom/msm-spm.c:		msm_spm_drv_disable_avs(dev);
soc/qcom/msm-spm.c:	msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_RST);
soc/qcom/msm-spm.c:	msm_spm_drv_set_vctl2(dev, vlevel, dev->vctl_port);
soc/qcom/msm-spm.c:	ret = msm_spm_drv_validate_data(dev, vlevel, dev->vctl_port);
soc/qcom/msm-spm.c:		msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_RST);
soc/qcom/msm-spm.c:		msm_spm_drv_set_vctl2(dev, vlevel, dev->vctl_port_ub);
soc/qcom/msm-spm.c:		ret = msm_spm_drv_validate_data(dev, vlevel, dev->vctl_port_ub);
soc/qcom/msm-spm.c:		msm_spm_drv_set_avs_vlevel(dev, vlevel_set);
soc/qcom/msm-spm.c:		msm_spm_drv_enable_avs(dev);
soc/qcom/msm-spm.c:		msm_spm_drv_enable_avs(dev);
soc/qcom/msm-spm.c:static int msm_spm_drv_get_pmic_port(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:		enum msm_spm_pmic_port port)
soc/qcom/msm-spm.c:int msm_spm_drv_set_pmic_data(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:		enum msm_spm_pmic_port port, unsigned int data)
soc/qcom/msm-spm.c:	if (!msm_spm_pmic_arb_present(dev))
soc/qcom/msm-spm.c:	index = msm_spm_drv_get_pmic_port(dev, port);
soc/qcom/msm-spm.c:	msm_spm_drv_flush_shadow(dev, MSM_SPM_REG_SAW_VCTL);
soc/qcom/msm-spm.c:		if (msm_spm_drv_get_sts_pmic_state(dev) ==
soc/qcom/msm-spm.c:void msm_spm_drv_reinit(struct msm_spm_driver_data *dev, bool seq_write)
soc/qcom/msm-spm.c:		msm_spm_drv_flush_seq_entry(dev);
soc/qcom/msm-spm.c:		msm_spm_drv_load_shadow(dev, i);
soc/qcom/msm-spm.c:		msm_spm_drv_load_shadow(dev, i);
soc/qcom/msm-spm.c:int msm_spm_drv_reg_init(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:		struct msm_spm_platform_data *data)
soc/qcom/msm-spm.c:	msm_spm_drv_get_saw2_ver(dev, &dev->major, &dev->minor);
soc/qcom/msm-spm.c:void msm_spm_drv_upd_reg_shadow(struct msm_spm_driver_data *dev, int id,
soc/qcom/msm-spm.c:	msm_spm_drv_flush_shadow(dev, id);
soc/qcom/msm-spm.c:int msm_spm_drv_init(struct msm_spm_driver_data *dev,
soc/qcom/msm-spm.c:		struct msm_spm_platform_data *data)
soc/qcom/msm-spm.c:		num_pmic_data = msm_spm_drv_get_num_pmic_data(dev);
soc/qcom/msm-spm.c:	num_spm_entry = msm_spm_drv_get_num_spm_entry(dev);
soc/qcom/msm_bus/Makefile:# Makefile for msm-bus driver specific files
soc/qcom/msm_bus/Makefile:obj-y +=  msm_bus_core.o msm_bus_client_api.o
soc/qcom/msm_bus/Makefile:obj-$(CONFIG_OF) += msm_bus_of.o
soc/qcom/msm_bus/Makefile:obj-$(CONFIG_MSM_RPM_SMD) += msm_bus_rpm_smd.o
soc/qcom/msm_bus/Makefile:	obj-y += msm_bus_fabric_rpmh.o msm_bus_arb_rpmh.o msm_bus_rules.o \
soc/qcom/msm_bus/Makefile:		msm_bus_bimc_rpmh.o msm_bus_noc_rpmh.o msm_bus_proxy_client.o
soc/qcom/msm_bus/Makefile:	obj-$(CONFIG_OF) += msm_bus_of_rpmh.o
soc/qcom/msm_bus/Makefile:	obj-$(CONFIG_DEBUG_FS) += msm_bus_dbg_rpmh.o
soc/qcom/msm_bus/Makefile:	obj-y += msm_bus_fabric_adhoc.o msm_bus_arb_adhoc.o msm_bus_rules.o \
soc/qcom/msm_bus/Makefile:		msm_bus_bimc_adhoc.o msm_bus_noc_adhoc.o msm_bus_qnoc_adhoc.o
soc/qcom/msm_bus/Makefile:	obj-$(CONFIG_OF) += msm_bus_of_adhoc.o
soc/qcom/msm_bus/Makefile:	obj-$(CONFIG_DEBUG_FS) += msm_bus_dbg.o
soc/qcom/msm_bus/msm_bus_adhoc.h:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_adhoc.h:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_adhoc.h:#include <linux/msm_bus_rules.h>
soc/qcom/msm_bus/msm_bus_adhoc.h:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_adhoc.h:struct msm_bus_node_device_type;
soc/qcom/msm_bus/msm_bus_adhoc.h:struct msm_bus_noc_ops {
soc/qcom/msm_bus/msm_bus_adhoc.h:	int (*qos_init)(struct msm_bus_node_device_type *dev,
soc/qcom/msm_bus/msm_bus_adhoc.h:	int (*set_bw)(struct msm_bus_node_device_type *dev,
soc/qcom/msm_bus/msm_bus_adhoc.h:	int (*limit_mport)(struct msm_bus_node_device_type *dev,
soc/qcom/msm_bus/msm_bus_adhoc.h:struct msm_bus_fab_device_type {
soc/qcom/msm_bus/msm_bus_adhoc.h:	struct msm_bus_noc_ops noc_ops;
soc/qcom/msm_bus/msm_bus_adhoc.h:	enum msm_bus_hw_sel bus_type;
soc/qcom/msm_bus/msm_bus_adhoc.h:struct msm_bus_noc_limiter {
soc/qcom/msm_bus/msm_bus_adhoc.h:struct msm_bus_noc_regulator {
soc/qcom/msm_bus/msm_bus_adhoc.h:struct msm_bus_noc_regulator_mode {
soc/qcom/msm_bus/msm_bus_adhoc.h:	struct msm_bus_noc_limiter limiter;
soc/qcom/msm_bus/msm_bus_adhoc.h:	struct msm_bus_noc_regulator reg;
soc/qcom/msm_bus/msm_bus_adhoc.h:	struct msm_bus_noc_regulator_mode reg_mode;
soc/qcom/msm_bus/msm_bus_adhoc.h:struct msm_bus_node_info_type {
soc/qcom/msm_bus/msm_bus_adhoc.h:struct msm_bus_node_device_type {
soc/qcom/msm_bus/msm_bus_adhoc.h:	struct msm_bus_node_info_type *node_info;
soc/qcom/msm_bus/msm_bus_adhoc.h:	struct msm_bus_fab_device_type *fabdev;
soc/qcom/msm_bus/msm_bus_adhoc.h:static inline struct msm_bus_node_device_type *to_msm_bus_node(struct device *d)
soc/qcom/msm_bus/msm_bus_adhoc.h:	return container_of(d, struct msm_bus_node_device_type, dev);
soc/qcom/msm_bus/msm_bus_adhoc.h:int msm_bus_enable_limiter(struct msm_bus_node_device_type *nodedev,
soc/qcom/msm_bus/msm_bus_adhoc.h:int msm_bus_commit_data(struct list_head *clist);
soc/qcom/msm_bus/msm_bus_adhoc.h:void *msm_bus_realloc_devmem(struct device *dev, void *p, size_t old_size,
soc/qcom/msm_bus/msm_bus_adhoc.h:extern struct msm_bus_device_node_registration
soc/qcom/msm_bus/msm_bus_adhoc.h:	*msm_bus_of_to_pdata(struct platform_device *pdev);
soc/qcom/msm_bus/msm_bus_adhoc.h:extern void msm_bus_arb_setops_adhoc(struct msm_bus_arb_ops *arb_ops);
soc/qcom/msm_bus/msm_bus_adhoc.h:extern int msm_bus_bimc_set_ops(struct msm_bus_node_device_type *bus_dev);
soc/qcom/msm_bus/msm_bus_adhoc.h:extern int msm_bus_noc_set_ops(struct msm_bus_node_device_type *bus_dev);
soc/qcom/msm_bus/msm_bus_adhoc.h:extern int msm_bus_qnoc_set_ops(struct msm_bus_node_device_type *bus_dev);
soc/qcom/msm_bus/msm_bus_adhoc.h:extern int msm_bus_of_get_static_rules(struct platform_device *pdev,
soc/qcom/msm_bus/msm_bus_adhoc.h:extern int msm_rules_update_path(struct list_head *input_list,
soc/qcom/msm_bus/msm_bus_adhoc.h:int msm_bus_floor_init(struct device *dev);
soc/qcom/msm_bus/msm_bus_adhoc.h:static inline int msm_bus_floor_init(struct device *dev)
soc/qcom/msm_bus/msm_bus_bimc.h:struct msm_bus_bimc_params {
soc/qcom/msm_bus/msm_bus_bimc.h:struct msm_bus_bimc_commit {
soc/qcom/msm_bus/msm_bus_bimc.h:	struct msm_bus_node_hw_info *mas;
soc/qcom/msm_bus/msm_bus_bimc.h:	struct msm_bus_node_hw_info *slv;
soc/qcom/msm_bus/msm_bus_bimc.h:struct msm_bus_bimc_info {
soc/qcom/msm_bus/msm_bus_bimc.h:	struct msm_bus_bimc_params params;
soc/qcom/msm_bus/msm_bus_bimc.h:	struct msm_bus_bimc_commit cdata[NUM_CTX];
soc/qcom/msm_bus/msm_bus_bimc.h:struct msm_bus_bimc_node {
soc/qcom/msm_bus/msm_bus_bimc.h:enum msm_bus_bimc_arb_mode {
soc/qcom/msm_bus/msm_bus_bimc.h:enum msm_bus_bimc_interleave {
soc/qcom/msm_bus/msm_bus_bimc.h:struct msm_bus_bimc_slave_seg {
soc/qcom/msm_bus/msm_bus_bimc.h:enum msm_bus_bimc_qos_mode_type {
soc/qcom/msm_bus/msm_bus_bimc.h:struct msm_bus_bimc_qos_health {
soc/qcom/msm_bus/msm_bus_bimc.h:struct msm_bus_bimc_mode_fixed {
soc/qcom/msm_bus/msm_bus_bimc.h:struct msm_bus_bimc_mode_rl {
soc/qcom/msm_bus/msm_bus_bimc.h:	struct msm_bus_bimc_qos_health qhealth[4];
soc/qcom/msm_bus/msm_bus_bimc.h:struct msm_bus_bimc_qos_mode {
soc/qcom/msm_bus/msm_bus_bimc.h:	struct msm_bus_bimc_mode_fixed fixed;
soc/qcom/msm_bus/msm_bus_bimc.h:	struct msm_bus_bimc_mode_rl rl;
soc/qcom/msm_bus/msm_bus_bimc.h:struct msm_bus_bimc_qos_bw {
soc/qcom/msm_bus/msm_bus_bimc.h:struct msm_bus_bimc_clk_gate {
soc/qcom/msm_bus/msm_bus_bimc.h:void msm_bus_bimc_set_slave_seg(struct msm_bus_bimc_info *binfo,
soc/qcom/msm_bus/msm_bus_bimc.h:	struct msm_bus_bimc_slave_seg *bsseg);
soc/qcom/msm_bus/msm_bus_bimc.h:void msm_bus_bimc_set_slave_clk_gate(struct msm_bus_bimc_info *binfo,
soc/qcom/msm_bus/msm_bus_bimc.h:	uint32_t slv_index, struct msm_bus_bimc_clk_gate *bgate);
soc/qcom/msm_bus/msm_bus_bimc.h:void msm_bus_bimc_set_mas_clk_gate(struct msm_bus_bimc_info *binfo,
soc/qcom/msm_bus/msm_bus_bimc.h:	uint32_t mas_index, struct msm_bus_bimc_clk_gate *bgate);
soc/qcom/msm_bus/msm_bus_bimc.h:void msm_bus_bimc_arb_en(struct msm_bus_bimc_info *binfo,
soc/qcom/msm_bus/msm_bus_bimc.h:void msm_bus_bimc_get_params(struct msm_bus_bimc_info *binfo,
soc/qcom/msm_bus/msm_bus_bimc.h:	struct msm_bus_bimc_params *params);
soc/qcom/msm_bus/msm_bus_bimc.h:void msm_bus_bimc_get_mas_params(struct msm_bus_bimc_info *binfo,
soc/qcom/msm_bus/msm_bus_bimc.h:	uint32_t mas_index, struct msm_bus_bimc_node *mparams);
soc/qcom/msm_bus/msm_bus_bimc.h:void msm_bus_bimc_get_slv_params(struct msm_bus_bimc_info *binfo,
soc/qcom/msm_bus/msm_bus_bimc.h:	uint32_t slv_index, struct msm_bus_bimc_node *sparams);
soc/qcom/msm_bus/msm_bus_bimc.h:bool msm_bus_bimc_get_arb_en(struct msm_bus_bimc_info *binfo,
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:#include "msm_bus_bimc.h"
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:#include "msm_bus_adhoc.h"
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:#include <trace/events/trace_msm_bus.h>
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:	uint8_t index, struct msm_bus_bimc_qos_mode *qmode)
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:static void msm_bus_bimc_set_qos_prio(void __iomem *base,
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:	struct msm_bus_bimc_qos_mode *qmode)
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:	int mport, struct msm_bus_bimc_qos_bw *qbw)
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:static int msm_bus_bimc_limit_mport(struct msm_bus_node_device_type *info,
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:	struct msm_bus_bimc_qos_mode qmode = {0};
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:			struct msm_bus_bimc_qos_bw qbw;
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:		msm_bus_bimc_set_qos_prio(qos_base, info->node_info->qport[i],
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:static bool msm_bus_bimc_update_bw_reg(int mode)
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:static int msm_bus_bimc_qos_init(struct msm_bus_node_device_type *info,
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:	struct msm_bus_bimc_qos_mode qmode = {0};
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:		msm_bus_bimc_set_qos_prio(qos_base, info->node_info->qport[i],
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:static int msm_bus_bimc_set_bw(struct msm_bus_node_device_type *dev,
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:	struct msm_bus_bimc_qos_bw qbw;
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:	struct msm_bus_bimc_qos_mode qmode = {0};
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:	struct msm_bus_node_info_type *info = dev->node_info;
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:		bw = msm_bus_div64(dev->node_bw[ACTIVE_CTX].sum_ab,
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:			msm_bus_bimc_set_qos_prio(qos_base,
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:int msm_bus_bimc_set_ops(struct msm_bus_node_device_type *bus_dev)
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:	bus_dev->fabdev->noc_ops.qos_init = msm_bus_bimc_qos_init;
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:	bus_dev->fabdev->noc_ops.set_bw = msm_bus_bimc_set_bw;
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:	bus_dev->fabdev->noc_ops.limit_mport = msm_bus_bimc_limit_mport;
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:					msm_bus_bimc_update_bw_reg;
soc/qcom/msm_bus/msm_bus_bimc_adhoc.c:EXPORT_SYMBOL(msm_bus_bimc_set_ops);
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:#include "msm_bus_bimc.h"
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:#include "msm_bus_adhoc.h"
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:	uint8_t index, struct msm_bus_bimc_qos_mode *qmode)
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:static void msm_bus_bimc_set_qos_prio(void __iomem *base,
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:	struct msm_bus_bimc_qos_mode *qmode)
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:	int mport, struct msm_bus_bimc_qos_bw *qbw)
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:static int msm_bus_bimc_limit_mport(struct msm_bus_node_device_type *info,
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:	struct msm_bus_bimc_qos_mode qmode = {0};
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:			struct msm_bus_bimc_qos_bw qbw;
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:		msm_bus_bimc_set_qos_prio(qos_base, info->node_info->qport[i],
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:static bool msm_bus_bimc_update_bw_reg(int mode)
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:static int msm_bus_bimc_qos_init(struct msm_bus_node_device_type *info,
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:	struct msm_bus_bimc_qos_mode qmode = {0};
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:		msm_bus_bimc_set_qos_prio(qos_base, info->node_info->qport[i],
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:static int msm_bus_bimc_set_bw(struct msm_bus_node_device_type *dev,
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:	struct msm_bus_bimc_qos_bw qbw;
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:	struct msm_bus_bimc_qos_mode qmode = {0};
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:	struct msm_bus_node_info_type *info = dev->node_info;
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:		bw = msm_bus_div64(info->num_qports,
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:			msm_bus_bimc_set_qos_prio(qos_base,
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:int msm_bus_bimc_set_ops(struct msm_bus_node_device_type *bus_dev)
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:	bus_dev->fabdev->noc_ops.qos_init = msm_bus_bimc_qos_init;
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:	bus_dev->fabdev->noc_ops.set_bw = msm_bus_bimc_set_bw;
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:	bus_dev->fabdev->noc_ops.limit_mport = msm_bus_bimc_limit_mport;
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:					msm_bus_bimc_update_bw_reg;
soc/qcom/msm_bus/msm_bus_bimc_rpmh.c:EXPORT_SYMBOL(msm_bus_bimc_set_ops);
soc/qcom/msm_bus/msm_bus_client_api.c:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_client_api.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_client_api.c:struct msm_bus_arb_ops arb_ops;
soc/qcom/msm_bus/msm_bus_client_api.c: * msm_bus_scale_register_client() - Register the clients with the msm bus
soc/qcom/msm_bus/msm_bus_client_api.c:uint32_t msm_bus_scale_register_client(struct msm_bus_scale_pdata *pdata)
soc/qcom/msm_bus/msm_bus_client_api.c:EXPORT_SYMBOL(msm_bus_scale_register_client);
soc/qcom/msm_bus/msm_bus_client_api.c: * msm_bus_scale_client_update_request() - Update the request for bandwidth
soc/qcom/msm_bus/msm_bus_client_api.c:int msm_bus_scale_client_update_request(uint32_t cl, unsigned int index)
soc/qcom/msm_bus/msm_bus_client_api.c:EXPORT_SYMBOL(msm_bus_scale_client_update_request);
soc/qcom/msm_bus/msm_bus_client_api.c: * msm_bus_scale_client_update_context() - Update the context for a client
soc/qcom/msm_bus/msm_bus_client_api.c:int msm_bus_scale_client_update_context(uint32_t cl, bool active_only,
soc/qcom/msm_bus/msm_bus_client_api.c:EXPORT_SYMBOL(msm_bus_scale_client_update_context);
soc/qcom/msm_bus/msm_bus_client_api.c: * msm_bus_scale_unregister_client() - Unregister the client from the bus driver
soc/qcom/msm_bus/msm_bus_client_api.c:void msm_bus_scale_unregister_client(uint32_t cl)
soc/qcom/msm_bus/msm_bus_client_api.c:EXPORT_SYMBOL(msm_bus_scale_unregister_client);
soc/qcom/msm_bus/msm_bus_client_api.c: * msm_bus_scale_register() - Register the clients with the msm bus
soc/qcom/msm_bus/msm_bus_client_api.c:struct msm_bus_client_handle*
soc/qcom/msm_bus/msm_bus_client_api.c:msm_bus_scale_register(uint32_t mas, uint32_t slv, char *name, bool active_only)
soc/qcom/msm_bus/msm_bus_client_api.c:EXPORT_SYMBOL(msm_bus_scale_register);
soc/qcom/msm_bus/msm_bus_client_api.c: * msm_bus_scale_client_update_bw() - Update the request for bandwidth
soc/qcom/msm_bus/msm_bus_client_api.c:int msm_bus_scale_update_bw(struct msm_bus_client_handle *cl, u64 ab, u64 ib)
soc/qcom/msm_bus/msm_bus_client_api.c:EXPORT_SYMBOL(msm_bus_scale_update_bw);
soc/qcom/msm_bus/msm_bus_client_api.c: * msm_bus_scale_change_context() - Update the context for a particular client
soc/qcom/msm_bus/msm_bus_client_api.c:msm_bus_scale_update_bw_context(struct msm_bus_client_handle *cl, u64 act_ab,
soc/qcom/msm_bus/msm_bus_client_api.c:EXPORT_SYMBOL(msm_bus_scale_update_bw_context);
soc/qcom/msm_bus/msm_bus_client_api.c: * msm_bus_scale_unregister() - Update the request for bandwidth
soc/qcom/msm_bus/msm_bus_client_api.c:void msm_bus_scale_unregister(struct msm_bus_client_handle *cl)
soc/qcom/msm_bus/msm_bus_client_api.c:EXPORT_SYMBOL(msm_bus_scale_unregister);
soc/qcom/msm_bus/msm_bus_client_api.c: * msm_bus_scale_query_tcs_cmd() - Query for a list of TCS commands for
soc/qcom/msm_bus/msm_bus_client_api.c:int msm_bus_scale_query_tcs_cmd(struct msm_bus_tcs_usecase *tcs_usecase,
soc/qcom/msm_bus/msm_bus_client_api.c:EXPORT_SYMBOL(msm_bus_scale_query_tcs_cmd);
soc/qcom/msm_bus/msm_bus_client_api.c: * msm_bus_scale_query_tcs_cmd_all() - Query for a list of TCS commands for
soc/qcom/msm_bus/msm_bus_client_api.c:int msm_bus_scale_query_tcs_cmd_all(struct msm_bus_tcs_handle *tcs_handle,
soc/qcom/msm_bus/msm_bus_client_api.c:EXPORT_SYMBOL(msm_bus_scale_query_tcs_cmd_all);
soc/qcom/msm_bus/msm_bus_core.c:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_core.c:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_core.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_core.c:int msm_bus_get_num_fab(void)
soc/qcom/msm_bus/msm_bus_core.c:int msm_bus_device_match(struct device *dev, void *id)
soc/qcom/msm_bus/msm_bus_core.c:	struct msm_bus_fabric_device *fabdev = to_msm_bus_fabric_device(dev);
soc/qcom/msm_bus/msm_bus_core.c:static void msm_bus_release(struct device *device)
soc/qcom/msm_bus/msm_bus_core.c:struct bus_type msm_bus_type = {
soc/qcom/msm_bus/msm_bus_core.c:	.name      = "msm-bus-type",
soc/qcom/msm_bus/msm_bus_core.c:EXPORT_SYMBOL(msm_bus_type);
soc/qcom/msm_bus/msm_bus_core.c: * msm_bus_get_fabric_device() - This function is used to search for
soc/qcom/msm_bus/msm_bus_core.c:struct msm_bus_fabric_device *msm_bus_get_fabric_device(int fabid)
soc/qcom/msm_bus/msm_bus_core.c:	struct msm_bus_fabric_device *fabric;
soc/qcom/msm_bus/msm_bus_core.c:	dev = bus_find_device(&msm_bus_type, NULL, (void *)&fabid,
soc/qcom/msm_bus/msm_bus_core.c:		msm_bus_device_match);
soc/qcom/msm_bus/msm_bus_core.c:	fabric = to_msm_bus_fabric_device(dev);
soc/qcom/msm_bus/msm_bus_core.c: * msm_bus_fabric_device_register() - Registers a fabric on msm bus
soc/qcom/msm_bus/msm_bus_core.c:int msm_bus_fabric_device_register(struct msm_bus_fabric_device *fabdev)
soc/qcom/msm_bus/msm_bus_core.c:	fabdev->dev.bus = &msm_bus_type;
soc/qcom/msm_bus/msm_bus_core.c:	fabdev->dev.release = msm_bus_release;
soc/qcom/msm_bus/msm_bus_core.c: * msm_bus_fabric_device_unregister() - Unregisters the fabric
soc/qcom/msm_bus/msm_bus_core.c: * devices from the msm bus
soc/qcom/msm_bus/msm_bus_core.c:void msm_bus_fabric_device_unregister(struct msm_bus_fabric_device *fabdev)
soc/qcom/msm_bus/msm_bus_core.c:static void __exit msm_bus_exit(void)
soc/qcom/msm_bus/msm_bus_core.c:	bus_unregister(&msm_bus_type);
soc/qcom/msm_bus/msm_bus_core.c:static int __init msm_bus_init(void)
soc/qcom/msm_bus/msm_bus_core.c:	retval = bus_register(&msm_bus_type);
soc/qcom/msm_bus/msm_bus_core.c:postcore_initcall(msm_bus_init);
soc/qcom/msm_bus/msm_bus_core.c:module_exit(msm_bus_exit);
soc/qcom/msm_bus/msm_bus_core.c:MODULE_ALIAS("platform:msm_bus");
soc/qcom/msm_bus/msm_bus_core.h:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_core.h:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_core.h:	? -msm_bus_div64((ports), (-bw)) : msm_bus_div64((ports), (bw))) : (bw))
soc/qcom/msm_bus/msm_bus_core.h:enum msm_bus_dbg_op_type {
soc/qcom/msm_bus/msm_bus_core.h:enum msm_bus_hw_sel {
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_arb_ops {
soc/qcom/msm_bus/msm_bus_core.h:	uint32_t (*register_client)(struct msm_bus_scale_pdata *pdata);
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_client_handle*
soc/qcom/msm_bus/msm_bus_core.h:	int (*update_bw)(struct msm_bus_client_handle *cl, u64 ab, u64 ib);
soc/qcom/msm_bus/msm_bus_core.h:	void (*unregister)(struct msm_bus_client_handle *cl);
soc/qcom/msm_bus/msm_bus_core.h:	int (*update_bw_context)(struct msm_bus_client_handle *cl, u64 act_ab,
soc/qcom/msm_bus/msm_bus_core.h:	int (*query_usecase)(struct msm_bus_tcs_usecase *tcs_usecase,
soc/qcom/msm_bus/msm_bus_core.h:	int (*query_usecase_all)(struct msm_bus_tcs_handle *tcs_handle,
soc/qcom/msm_bus/msm_bus_core.h:extern struct bus_type msm_bus_type;
soc/qcom/msm_bus/msm_bus_core.h:extern struct msm_bus_arb_ops arb_ops;
soc/qcom/msm_bus/msm_bus_core.h:extern void msm_bus_arb_setops_legacy(struct msm_bus_arb_ops *arb_ops);
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_node_info {
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_link_info {
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_inode_info {
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_node_info *node_info;
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_link_info link_info;
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_node_hw_info {
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_hw_algorithm {
soc/qcom/msm_bus/msm_bus_core.h:	int (*allocate_commit_data)(struct msm_bus_fabric_registration
soc/qcom/msm_bus/msm_bus_core.h:		struct msm_bus_fabric_registration *fab_pdata);
soc/qcom/msm_bus/msm_bus_core.h:	void (*node_init)(void *hw_data, struct msm_bus_inode_info *info);
soc/qcom/msm_bus/msm_bus_core.h:	void (*update_bw)(struct msm_bus_inode_info *hop,
soc/qcom/msm_bus/msm_bus_core.h:		struct msm_bus_inode_info *info,
soc/qcom/msm_bus/msm_bus_core.h:		struct msm_bus_fabric_registration *fab_pdata,
soc/qcom/msm_bus/msm_bus_core.h:	int (*commit)(struct msm_bus_fabric_registration
soc/qcom/msm_bus/msm_bus_core.h:	void (*config_master)(struct msm_bus_fabric_registration *fab_pdata,
soc/qcom/msm_bus/msm_bus_core.h:		struct msm_bus_inode_info *info,
soc/qcom/msm_bus/msm_bus_core.h:	void (*config_limiter)(struct msm_bus_fabric_registration *fab_pdata,
soc/qcom/msm_bus/msm_bus_core.h:		struct msm_bus_inode_info *info);
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_fabric_device {
soc/qcom/msm_bus/msm_bus_core.h:	const struct msm_bus_fab_algorithm *algo;
soc/qcom/msm_bus/msm_bus_core.h:	const struct msm_bus_board_algorithm *board_algo;
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_hw_algorithm hw_algo;
soc/qcom/msm_bus/msm_bus_core.h:#define to_msm_bus_fabric_device(d) container_of(d, \
soc/qcom/msm_bus/msm_bus_core.h:		struct msm_bus_fabric_device, d)
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_fabric {
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_fabric_device fabdev;
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_inode_info info;
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_fabric_registration *pdata;
soc/qcom/msm_bus/msm_bus_core.h:#define to_msm_bus_fabric(d) container_of(d, \
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_fabric, d)
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_fab_algorithm {
soc/qcom/msm_bus/msm_bus_core.h:	int (*update_clks)(struct msm_bus_fabric_device *fabdev,
soc/qcom/msm_bus/msm_bus_core.h:		struct msm_bus_inode_info *pme, int index,
soc/qcom/msm_bus/msm_bus_core.h:	int (*port_halt)(struct msm_bus_fabric_device *fabdev, int portid);
soc/qcom/msm_bus/msm_bus_core.h:	int (*port_unhalt)(struct msm_bus_fabric_device *fabdev, int portid);
soc/qcom/msm_bus/msm_bus_core.h:	int (*commit)(struct msm_bus_fabric_device *fabdev);
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_inode_info *(*find_node)(struct msm_bus_fabric_device
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_inode_info *(*find_gw_node)(struct msm_bus_fabric_device
soc/qcom/msm_bus/msm_bus_core.h:	struct list_head *(*get_gw_list)(struct msm_bus_fabric_device *fabdev);
soc/qcom/msm_bus/msm_bus_core.h:	void (*update_bw)(struct msm_bus_fabric_device *fabdev, struct
soc/qcom/msm_bus/msm_bus_core.h:		msm_bus_inode_info * hop, struct msm_bus_inode_info *info,
soc/qcom/msm_bus/msm_bus_core.h:	void (*config_master)(struct msm_bus_fabric_device *fabdev,
soc/qcom/msm_bus/msm_bus_core.h:		struct msm_bus_inode_info *info, uint64_t req_clk,
soc/qcom/msm_bus/msm_bus_core.h:	void (*config_limiter)(struct msm_bus_fabric_device *fabdev,
soc/qcom/msm_bus/msm_bus_core.h:		struct msm_bus_inode_info *info);
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_board_algorithm {
soc/qcom/msm_bus/msm_bus_core.h:	void (*assign_iids)(struct msm_bus_fabric_registration *fabreg,
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_fabnodeinfo {
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_inode_info *info;
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_client {
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_core.h:uint64_t msm_bus_div64(uint64_t num, unsigned int base);
soc/qcom/msm_bus/msm_bus_core.h:int msm_bus_fabric_device_register(struct msm_bus_fabric_device *fabric);
soc/qcom/msm_bus/msm_bus_core.h:void msm_bus_fabric_device_unregister(struct msm_bus_fabric_device *fabric);
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_fabric_device *msm_bus_get_fabric_device(int fabid);
soc/qcom/msm_bus/msm_bus_core.h:int msm_bus_get_num_fab(void);
soc/qcom/msm_bus/msm_bus_core.h:int msm_bus_hw_fab_init(struct msm_bus_fabric_registration *pdata,
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_hw_algorithm *hw_algo);
soc/qcom/msm_bus/msm_bus_core.h:void msm_bus_board_init(struct msm_bus_fabric_registration *pdata);
soc/qcom/msm_bus/msm_bus_core.h:int msm_bus_rpm_hw_init(struct msm_bus_fabric_registration *pdata,
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_hw_algorithm *hw_algo);
soc/qcom/msm_bus/msm_bus_core.h:int msm_bus_remote_hw_commit(struct msm_bus_fabric_registration
soc/qcom/msm_bus/msm_bus_core.h:void msm_bus_rpm_fill_cdata_buffer(int *curr, char *buf, const int max_size,
soc/qcom/msm_bus/msm_bus_core.h:static inline int msm_bus_rpm_hw_init(struct msm_bus_fabric_registration *pdata,
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_hw_algorithm *hw_algo)
soc/qcom/msm_bus/msm_bus_core.h:static inline int msm_bus_remote_hw_commit(struct msm_bus_fabric_registration
soc/qcom/msm_bus/msm_bus_core.h:static inline void msm_bus_rpm_fill_cdata_buffer(int *curr, char *buf,
soc/qcom/msm_bus/msm_bus_core.h:int msm_bus_noc_hw_init(struct msm_bus_fabric_registration *pdata,
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_hw_algorithm *hw_algo);
soc/qcom/msm_bus/msm_bus_core.h:int msm_bus_bimc_hw_init(struct msm_bus_fabric_registration *pdata,
soc/qcom/msm_bus/msm_bus_core.h:	struct msm_bus_hw_algorithm *hw_algo);
soc/qcom/msm_bus/msm_bus_core.h:void msm_bus_dbg_client_data(struct msm_bus_scale_pdata *pdata, int index,
soc/qcom/msm_bus/msm_bus_core.h:void msm_bus_dbg_commit_data(const char *fabname, void *cdata,
soc/qcom/msm_bus/msm_bus_core.h:int msm_bus_dbg_add_client(const struct msm_bus_client_handle *pdata);
soc/qcom/msm_bus/msm_bus_core.h:int msm_bus_dbg_rec_transaction(const struct msm_bus_client_handle *pdata,
soc/qcom/msm_bus/msm_bus_core.h:void msm_bus_dbg_remove_client(const struct msm_bus_client_handle *pdata);
soc/qcom/msm_bus/msm_bus_core.h:int msm_bus_dbg_add_bcm(struct msm_bus_node_device_type *cur_bcm);
soc/qcom/msm_bus/msm_bus_core.h:void msm_bus_dbg_remove_bcm(struct msm_bus_node_device_type *cur_bcm);
soc/qcom/msm_bus/msm_bus_core.h:static inline void msm_bus_dbg_client_data(struct msm_bus_scale_pdata *pdata,
soc/qcom/msm_bus/msm_bus_core.h:static inline void msm_bus_dbg_commit_data(const char *fabname,
soc/qcom/msm_bus/msm_bus_core.h:static inline void msm_bus_dbg_remove_client
soc/qcom/msm_bus/msm_bus_core.h:		(const struct msm_bus_client_handle *pdata)
soc/qcom/msm_bus/msm_bus_core.h:msm_bus_dbg_rec_transaction(const struct msm_bus_client_handle *pdata,
soc/qcom/msm_bus/msm_bus_core.h:msm_bus_dbg_add_client(const struct msm_bus_client_handle *pdata)
soc/qcom/msm_bus/msm_bus_core.h:msm_bus_dbg_add_bcm(struct msm_bus_node_device_type *cur_bcm)
soc/qcom/msm_bus/msm_bus_core.h:msm_bus_dbg_remove_bcm(struct msm_bus_node_device_type *cur_bcm)
soc/qcom/msm_bus/msm_bus_core.h:int msmbus_coresight_init(struct platform_device *pdev);
soc/qcom/msm_bus/msm_bus_core.h:void msmbus_coresight_remove(struct platform_device *pdev);
soc/qcom/msm_bus/msm_bus_core.h:int msmbus_coresight_init_adhoc(struct platform_device *pdev,
soc/qcom/msm_bus/msm_bus_core.h:void msmbus_coresight_remove_adhoc(struct platform_device *pdev);
soc/qcom/msm_bus/msm_bus_core.h:static inline int msmbus_coresight_init(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_core.h:static inline void msmbus_coresight_remove(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_core.h:static inline int msmbus_coresight_init_adhoc(struct platform_device *pdev,
soc/qcom/msm_bus/msm_bus_core.h:static inline void msmbus_coresight_remove_adhoc(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_core.h:void msm_bus_of_get_nfab(struct platform_device *pdev,
soc/qcom/msm_bus/msm_bus_core.h:		struct msm_bus_fabric_registration *pdata);
soc/qcom/msm_bus/msm_bus_core.h:struct msm_bus_fabric_registration
soc/qcom/msm_bus/msm_bus_core.h:	*msm_bus_of_get_fab_data(struct platform_device *pdev);
soc/qcom/msm_bus/msm_bus_core.h:static inline void msm_bus_board_set_nfab(struct msm_bus_fabric_registration
soc/qcom/msm_bus/msm_bus_core.h:void msm_bus_board_set_nfab(struct msm_bus_fabric_registration *pdata,
soc/qcom/msm_bus/msm_bus_core.h:static inline void msm_bus_of_get_nfab(struct platform_device *pdev,
soc/qcom/msm_bus/msm_bus_core.h:		struct msm_bus_fabric_registration *pdata)
soc/qcom/msm_bus/msm_bus_core.h:static inline struct msm_bus_fabric_registration
soc/qcom/msm_bus/msm_bus_core.h:	*msm_bus_of_get_fab_data(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_dbg.c:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_dbg.c:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_dbg.c:#include <linux/msm_bus_rules.h>
soc/qcom/msm_bus/msm_bus_dbg.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_dbg.c:#include "msm_bus_adhoc.h"
soc/qcom/msm_bus/msm_bus_dbg.c:#include <trace/events/trace_msm_bus.h>
soc/qcom/msm_bus/msm_bus_dbg.c:static DEFINE_MUTEX(msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:static DEFINE_RT_MUTEX(msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:struct msm_bus_dbg_state {
soc/qcom/msm_bus/msm_bus_dbg.c:struct msm_bus_cldata {
soc/qcom/msm_bus/msm_bus_dbg.c:	const struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_dbg.c:	const struct msm_bus_client_handle *handle;
soc/qcom/msm_bus/msm_bus_dbg.c:struct msm_bus_fab_list {
soc/qcom/msm_bus/msm_bus_dbg.c:static struct msm_bus_vectors init_vectors[1];
soc/qcom/msm_bus/msm_bus_dbg.c:static struct msm_bus_vectors current_vectors[1];
soc/qcom/msm_bus/msm_bus_dbg.c:static struct msm_bus_vectors requested_vectors[1];
soc/qcom/msm_bus/msm_bus_dbg.c:static struct msm_bus_paths shell_client_usecases[] = {
soc/qcom/msm_bus/msm_bus_dbg.c:static struct msm_bus_scale_pdata shell_client = {
soc/qcom/msm_bus/msm_bus_dbg.c:static void msm_bus_dbg_init_vectors(void)
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_update_cl_request(uint32_t cl)
soc/qcom/msm_bus/msm_bus_dbg.c:		ret = msm_bus_scale_client_update_request(clstate.cl,
soc/qcom/msm_bus/msm_bus_dbg.c:static void msm_bus_dbg_unregister_client(uint32_t cl)
soc/qcom/msm_bus/msm_bus_dbg.c:	msm_bus_scale_unregister_client(clstate.cl);
soc/qcom/msm_bus/msm_bus_dbg.c:static uint32_t msm_bus_dbg_register_client(void)
soc/qcom/msm_bus/msm_bus_dbg.c:		msm_bus_dbg_unregister_client(clstate.cl);
soc/qcom/msm_bus/msm_bus_dbg.c:		msm_bus_dbg_unregister_client(clstate.cl);
soc/qcom/msm_bus/msm_bus_dbg.c:	ret = msm_bus_scale_register_client(&shell_client);
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_mas_get(void  *data, u64 *val)
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_mas_set(void  *data, u64 val)
soc/qcom/msm_bus/msm_bus_dbg.c:	clstate.cl = msm_bus_dbg_register_client();
soc/qcom/msm_bus/msm_bus_dbg.c:DEFINE_DEBUGFS_ATTRIBUTE(shell_client_mas_fops, msm_bus_dbg_mas_get,
soc/qcom/msm_bus/msm_bus_dbg.c:	msm_bus_dbg_mas_set, "%llu\n");
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_slv_get(void  *data, u64 *val)
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_slv_set(void  *data, u64 val)
soc/qcom/msm_bus/msm_bus_dbg.c:	clstate.cl = msm_bus_dbg_register_client();
soc/qcom/msm_bus/msm_bus_dbg.c:DEFINE_DEBUGFS_ATTRIBUTE(shell_client_slv_fops, msm_bus_dbg_slv_get,
soc/qcom/msm_bus/msm_bus_dbg.c:	msm_bus_dbg_slv_set, "%llu\n");
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_ab_get(void  *data, u64 *val)
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_ab_set(void  *data, u64 val)
soc/qcom/msm_bus/msm_bus_dbg.c:DEFINE_DEBUGFS_ATTRIBUTE(shell_client_ab_fops, msm_bus_dbg_ab_get,
soc/qcom/msm_bus/msm_bus_dbg.c:	msm_bus_dbg_ab_set, "%llu\n");
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_ib_get(void  *data, u64 *val)
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_ib_set(void  *data, u64 val)
soc/qcom/msm_bus/msm_bus_dbg.c:DEFINE_DEBUGFS_ATTRIBUTE(shell_client_ib_fops, msm_bus_dbg_ib_get,
soc/qcom/msm_bus/msm_bus_dbg.c:	msm_bus_dbg_ib_set, "%llu\n");
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_en_get(void  *data, u64 *val)
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_en_set(void  *data, u64 val)
soc/qcom/msm_bus/msm_bus_dbg.c:			clstate.cl = msm_bus_dbg_register_client();
soc/qcom/msm_bus/msm_bus_dbg.c:				ret = msm_bus_dbg_update_cl_request(clstate.cl);
soc/qcom/msm_bus/msm_bus_dbg.c:			ret = msm_bus_dbg_update_cl_request(clstate.cl);
soc/qcom/msm_bus/msm_bus_dbg.c:DEFINE_DEBUGFS_ATTRIBUTE(shell_client_en_fops, msm_bus_dbg_en_get,
soc/qcom/msm_bus/msm_bus_dbg.c:	msm_bus_dbg_en_set, "%llu\n");
soc/qcom/msm_bus/msm_bus_dbg.c:	struct msm_bus_cldata *cldata = NULL;
soc/qcom/msm_bus/msm_bus_dbg.c:	const struct msm_bus_client_handle *handle = file->private_data;
soc/qcom/msm_bus/msm_bus_dbg.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:		rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:struct dentry *msm_bus_dbg_create(const char *name, mode_t mode,
soc/qcom/msm_bus/msm_bus_dbg.c:int msm_bus_dbg_add_client(const struct msm_bus_client_handle *pdata)
soc/qcom/msm_bus/msm_bus_dbg.c:int msm_bus_dbg_rec_transaction(const struct msm_bus_client_handle *pdata,
soc/qcom/msm_bus/msm_bus_dbg.c:void msm_bus_dbg_remove_client(const struct msm_bus_client_handle *pdata)
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_record_client(const struct msm_bus_scale_pdata *pdata,
soc/qcom/msm_bus/msm_bus_dbg.c:static void msm_bus_dbg_free_client(uint32_t clid)
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_fill_cl_buffer(const struct msm_bus_scale_pdata *pdata,
soc/qcom/msm_bus/msm_bus_dbg.c:	struct msm_bus_cldata *cldata = NULL;
soc/qcom/msm_bus/msm_bus_dbg.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:		rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:			rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:		cldata->file = msm_bus_dbg_create(pdata->name, 0444,
soc/qcom/msm_bus/msm_bus_dbg.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:static ssize_t  msm_bus_dbg_update_request_write(struct file *file,
soc/qcom/msm_bus/msm_bus_dbg.c:	struct msm_bus_cldata *cldata;
soc/qcom/msm_bus/msm_bus_dbg.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:						&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:				rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:		msm_bus_scale_client_update_request(clid, index);
soc/qcom/msm_bus/msm_bus_dbg.c:	struct msm_bus_fab_list *fablist = NULL;
soc/qcom/msm_bus/msm_bus_dbg.c:	mutex_lock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:		mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:	mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_record_fabric(const char *fabname, struct dentry *file)
soc/qcom/msm_bus/msm_bus_dbg.c:	struct msm_bus_fab_list *fablist;
soc/qcom/msm_bus/msm_bus_dbg.c:	mutex_lock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:	fablist = kmalloc(sizeof(struct msm_bus_fab_list), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_dbg.c:	mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:static void msm_bus_dbg_free_fabric(const char *fabname)
soc/qcom/msm_bus/msm_bus_dbg.c:	struct msm_bus_fab_list *fablist = NULL;
soc/qcom/msm_bus/msm_bus_dbg.c:	mutex_lock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:	mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:static int msm_bus_dbg_fill_fab_buffer(const char *fabname,
soc/qcom/msm_bus/msm_bus_dbg.c:	struct msm_bus_fab_list *fablist = NULL;
soc/qcom/msm_bus/msm_bus_dbg.c:	mutex_lock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:		mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:		mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:	mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:	msm_bus_rpm_fill_cdata_buffer(&i, buf, MAX_BUFF_SIZE, cdata,
soc/qcom/msm_bus/msm_bus_dbg.c:	mutex_lock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:	mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:static const struct file_operations msm_bus_dbg_update_request_fops = {
soc/qcom/msm_bus/msm_bus_dbg.c:	.write = msm_bus_dbg_update_request_write,
soc/qcom/msm_bus/msm_bus_dbg.c:static ssize_t msm_bus_dbg_dump_clients_read(struct file *file,
soc/qcom/msm_bus/msm_bus_dbg.c:	struct msm_bus_cldata *cldata = NULL;
soc/qcom/msm_bus/msm_bus_dbg.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:static const struct file_operations msm_bus_dbg_dump_clients_fops = {
soc/qcom/msm_bus/msm_bus_dbg.c:	.read		= msm_bus_dbg_dump_clients_read,
soc/qcom/msm_bus/msm_bus_dbg.c: * msm_bus_dbg_client_data() - Add debug data for clients
soc/qcom/msm_bus/msm_bus_dbg.c:void msm_bus_dbg_client_data(struct msm_bus_scale_pdata *pdata, int index,
soc/qcom/msm_bus/msm_bus_dbg.c:		msm_bus_dbg_record_client(pdata, index, clid, file);
soc/qcom/msm_bus/msm_bus_dbg.c:		msm_bus_dbg_free_client(clid);
soc/qcom/msm_bus/msm_bus_dbg.c:		msm_bus_dbg_fill_cl_buffer(pdata, index, clid);
soc/qcom/msm_bus/msm_bus_dbg.c:EXPORT_SYMBOL(msm_bus_dbg_client_data);
soc/qcom/msm_bus/msm_bus_dbg.c: * msm_bus_dbg_commit_data() - Add commit data from fabrics
soc/qcom/msm_bus/msm_bus_dbg.c:void msm_bus_dbg_commit_data(const char *fabname, void *cdata,
soc/qcom/msm_bus/msm_bus_dbg.c:		msm_bus_dbg_record_fabric(fabname, file);
soc/qcom/msm_bus/msm_bus_dbg.c:		msm_bus_dbg_free_fabric(fabname);
soc/qcom/msm_bus/msm_bus_dbg.c:		msm_bus_dbg_fill_fab_buffer(fabname, cdata, nmasters,
soc/qcom/msm_bus/msm_bus_dbg.c:EXPORT_SYMBOL(msm_bus_dbg_commit_data);
soc/qcom/msm_bus/msm_bus_dbg.c:static int __init msm_bus_debugfs_init(void)
soc/qcom/msm_bus/msm_bus_dbg.c:late_initcall(msm_bus_debugfs_init);
soc/qcom/msm_bus/msm_bus_dbg.c:static void __exit msm_bus_dbg_teardown(void)
soc/qcom/msm_bus/msm_bus_dbg.c:	struct msm_bus_fab_list *fablist = NULL, *fablist_temp;
soc/qcom/msm_bus/msm_bus_dbg.c:	struct msm_bus_cldata *cldata = NULL, *cldata_temp;
soc/qcom/msm_bus/msm_bus_dbg.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:	mutex_lock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:	mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg.c:module_exit(msm_bus_dbg_teardown);
soc/qcom/msm_bus/msm_bus_dbg.c:MODULE_DESCRIPTION("Debugfs for msm bus scaling client");
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:#include <linux/msm_bus_rules.h>
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:#include "msm_bus_rpmh.h"
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:#include <trace/events/trace_msm_bus.h>
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static DEFINE_MUTEX(msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static DEFINE_RT_MUTEX(msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static struct msm_bus_dbg_state {
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:struct msm_bus_cldata {
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	const struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	const struct msm_bus_client_handle *handle;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:struct msm_bus_fab_list {
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static struct msm_bus_cldata *dbg_cldata1;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static struct msm_bus_cldata *dbg_cldata2;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static struct msm_bus_fab_list *dbg_fablist;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static struct msm_bus_vectors init_vectors[1];
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static struct msm_bus_vectors current_vectors[1];
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static struct msm_bus_vectors requested_vectors[1];
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static struct msm_bus_paths shell_client_usecases[] = {
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static struct msm_bus_scale_pdata shell_client = {
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static void msm_bus_dbg_init_vectors(void)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_update_cl_request(uint32_t cl)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		ret = msm_bus_scale_client_update_request(clstate.cl,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static void msm_bus_dbg_unregister_client(uint32_t cl)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	msm_bus_scale_unregister_client(clstate.cl);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static uint32_t msm_bus_dbg_register_client(void)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		msm_bus_dbg_unregister_client(clstate.cl);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		msm_bus_dbg_unregister_client(clstate.cl);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	ret = msm_bus_scale_register_client(&shell_client);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_mas_get(void  *data, u64 *val)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_mas_set(void  *data, u64 val)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	clstate.cl = msm_bus_dbg_register_client();
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:DEFINE_DEBUGFS_ATTRIBUTE(shell_client_mas_fops, msm_bus_dbg_mas_get,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	msm_bus_dbg_mas_set, "%llu\n");
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_slv_get(void  *data, u64 *val)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_slv_set(void  *data, u64 val)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	clstate.cl = msm_bus_dbg_register_client();
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:DEFINE_DEBUGFS_ATTRIBUTE(shell_client_slv_fops, msm_bus_dbg_slv_get,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	msm_bus_dbg_slv_set, "%llu\n");
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_ab_get(void  *data, u64 *val)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_ab_set(void  *data, u64 val)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:DEFINE_DEBUGFS_ATTRIBUTE(shell_client_ab_fops, msm_bus_dbg_ab_get,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	msm_bus_dbg_ab_set, "%llu\n");
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_ib_get(void  *data, u64 *val)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_ib_set(void  *data, u64 val)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:DEFINE_DEBUGFS_ATTRIBUTE(shell_client_ib_fops, msm_bus_dbg_ib_get,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	msm_bus_dbg_ib_set, "%llu\n");
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_en_get(void  *data, u64 *val)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_en_set(void  *data, u64 val)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:			clstate.cl = msm_bus_dbg_register_client();
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:				ret = msm_bus_dbg_update_cl_request(clstate.cl);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:			ret = msm_bus_dbg_update_cl_request(clstate.cl);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:DEFINE_DEBUGFS_ATTRIBUTE(shell_client_en_fops, msm_bus_dbg_en_get,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	msm_bus_dbg_en_set, "%llu\n");
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_cldata *cldata = NULL;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	const struct msm_bus_client_handle *handle = file->private_data;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static struct dentry *msm_bus_dbg_create(const char *name, mode_t mode,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:int msm_bus_dbg_add_client(const struct msm_bus_client_handle *pdata)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	dbg_cldata1 = kzalloc(sizeof(struct msm_bus_cldata), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:int msm_bus_dbg_add_bcm(struct msm_bus_node_device_type *cur_bcm)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:int msm_bus_dbg_rec_transaction(const struct msm_bus_client_handle *pdata,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_cldata *cldata;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:			rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:void msm_bus_dbg_remove_client(const struct msm_bus_client_handle *pdata)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_cldata *cldata = NULL;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:void msm_bus_dbg_remove_bcm(struct msm_bus_node_device_type *cur_bcm)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_record_client(const struct msm_bus_scale_pdata *pdata,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	dbg_cldata2 = kmalloc(sizeof(struct msm_bus_cldata), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static void msm_bus_dbg_free_client(uint32_t clid)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_cldata *cldata = NULL;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_fill_cl_buffer(const struct msm_bus_scale_pdata *pdata,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_cldata *cldata = NULL;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:			rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		cldata->file = msm_bus_dbg_create(pdata->name, 0444,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static ssize_t  msm_bus_dbg_update_request_write(struct file *file,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_cldata *cldata;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:						&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:				rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		msm_bus_scale_client_update_request(clid, index);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_fab_list *fablist = NULL;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	mutex_lock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_record_fabric(const char *fabname, struct dentry *file)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	mutex_lock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	dbg_fablist = kmalloc(sizeof(struct msm_bus_fab_list), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static void msm_bus_dbg_free_fabric(const char *fabname)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_fab_list *fablist = NULL;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	mutex_lock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int msm_bus_dbg_fill_fab_buffer(const char *fabname,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_fab_list *fablist = NULL;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	mutex_lock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	msm_bus_rpm_fill_cdata_buffer(&i, buf, MAX_BUFF_SIZE, cdata,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	mutex_lock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static const struct file_operations msm_bus_dbg_update_request_fops = {
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	.write = msm_bus_dbg_update_request_write,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_node_device_type *cur_node = NULL;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_node_device_type *cur_bcm = NULL;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:			dev = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:			cur_node = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static const struct file_operations msm_bus_dbg_dump_bcm_clients_fops = {
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static ssize_t msm_bus_dbg_dump_clients_read(struct file *file,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_cldata *cldata = NULL;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static const struct file_operations msm_bus_dbg_dump_clients_fops = {
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	.read		= msm_bus_dbg_dump_clients_read,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c: * msm_bus_dbg_client_data() - Add debug data for clients
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:void msm_bus_dbg_client_data(struct msm_bus_scale_pdata *pdata, int index,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		msm_bus_dbg_record_client(pdata, index, clid, file);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		msm_bus_dbg_free_client(clid);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		msm_bus_dbg_fill_cl_buffer(pdata, index, clid);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:EXPORT_SYMBOL(msm_bus_dbg_client_data);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c: * msm_bus_dbg_commit_data() - Add commit data from fabrics
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:void msm_bus_dbg_commit_data(const char *fabname, void *cdata,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		msm_bus_dbg_record_fabric(fabname, file);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		msm_bus_dbg_free_fabric(fabname);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:		msm_bus_dbg_fill_fab_buffer(fabname, cdata, nmasters,
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:EXPORT_SYMBOL(msm_bus_dbg_commit_data);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static int __init msm_bus_debugfs_init(void)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:late_initcall(msm_bus_debugfs_init);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:static void __exit msm_bus_dbg_teardown(void)
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_fab_list *fablist = NULL, *fablist_temp;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	struct msm_bus_cldata *cldata = NULL, *cldata_temp;
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_lock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	rt_mutex_unlock(&msm_bus_dbg_cllist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	mutex_lock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:	mutex_unlock(&msm_bus_dbg_fablist_lock);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:module_exit(msm_bus_dbg_teardown);
soc/qcom/msm_bus/msm_bus_dbg_rpmh.c:MODULE_DESCRIPTION("Debugfs for msm bus scaling client");
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:#include <trace/events/trace_msm_bus.h>
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:#include "msm_bus_adhoc.h"
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:#include "msm_bus_noc.h"
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:#include "msm_bus_bimc.h"
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int msm_bus_dev_init_qos(struct device *dev, void *data);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_info_type *node_info = NULL;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	bus_node = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *node_dev;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	node_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int send_rpm_msg(struct msm_bus_node_device_type *ndev, int ctx)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_rpm_kvp rpm_kvp;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		ret = msm_rpm_send_message(rpm_ctx, rsc_type,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		ret = msm_rpm_send_message(rpm_ctx, rsc_type,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int flush_bw_data(struct msm_bus_node_device_type *node_info, int ctx)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			struct msm_bus_node_device_type *bus_device =
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			to_msm_bus_node(node_info->node_info->bus_device);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			struct msm_bus_fab_device_type *fabdev =
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int flush_clk_data(struct msm_bus_node_device_type *node, int ctx)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int msm_bus_agg_fab_clks(struct msm_bus_node_device_type *bus_dev)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *node;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:int msm_bus_commit_data(struct list_head *clist)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *node;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *node_tmp;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			msm_bus_agg_fab_clks(node);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			msm_bus_dev_init_qos(&node->dev, NULL);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:void *msm_bus_realloc_devmem(struct device *dev, void *p, size_t old_size,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static void msm_bus_fab_init_noc_ops(struct msm_bus_node_device_type *bus_dev)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		msm_bus_noc_set_ops(bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		msm_bus_bimc_set_ops(bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		msm_bus_qnoc_set_ops(bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int msm_bus_disable_node_qos_clk(struct msm_bus_node_device_type *node)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	if (!node || (!to_msm_bus_node(node->node_info->bus_device))) {
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	bus_node = to_msm_bus_node(node->node_info->bus_device);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int msm_bus_enable_node_qos_clk(struct msm_bus_node_device_type *node)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	if (!node || (!to_msm_bus_node(node->node_info->bus_device))) {
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	bus_node = to_msm_bus_node(node->node_info->bus_device);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			msm_bus_disable_node_qos_clk(node);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			msm_bus_disable_node_qos_clk(node);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:int msm_bus_enable_limiter(struct msm_bus_node_device_type *node_dev,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *bus_node_dev;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	bus_node_dev = to_msm_bus_node(node_dev->node_info->bus_device);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int msm_bus_dev_init_qos(struct device *dev, void *data)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *node_dev = NULL;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	node_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		struct msm_bus_node_device_type *bus_node_info;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			to_msm_bus_node(node_dev->node_info->bus_device);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:				ret = msm_bus_enable_node_qos_clk(node_dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:				ret = msm_bus_disable_node_qos_clk(node_dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int msm_bus_fabric_init(struct device *dev,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			struct msm_bus_node_device_type *pdata)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_fab_device_type *fabdev;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *node_dev = NULL;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	node_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	fabdev = devm_kzalloc(dev, sizeof(struct msm_bus_fab_device_type),
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	msm_bus_fab_init_noc_ops(node_dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int msm_bus_init_clk(struct device *bus_dev,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:				struct msm_bus_node_device_type *pdata)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *node_dev = to_msm_bus_node(bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int msm_bus_copy_node_info(struct msm_bus_node_device_type *pdata,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_info_type *node_info = NULL;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_info_type *pdata_node_info = NULL;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	bus_node = to_msm_bus_node(bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static struct device *msm_bus_device_init(
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			struct msm_bus_node_device_type *pdata)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_info_type *node_info = NULL;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	bus_node = kzalloc(sizeof(struct msm_bus_node_device_type), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			sizeof(struct msm_bus_node_info_type), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	ret = msm_bus_copy_node_info(pdata, bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	bus_dev->bus = &msm_bus_type;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int msm_bus_setup_dev_conn(struct device *bus_dev, void *data)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *fab;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	bus_node = to_msm_bus_node(bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		fab = to_msm_bus_node(bus_parent_device);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int msm_bus_node_debug(struct device *bus_dev, void *data)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int msm_bus_free_dev(struct device *dev, void *data)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	bus_node = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:int msm_bus_device_remove(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	bus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_free_dev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int msm_bus_device_probe(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	struct msm_bus_device_node_registration *pdata;
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		pdata = msm_bus_of_to_pdata(pdev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		(struct msm_bus_device_node_registration *)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		node_dev = msm_bus_device_init(&pdata->info[i]);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		ret = msm_bus_init_clk(node_dev, &pdata->info[i]);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			msm_bus_device_remove(pdev);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:			ret = msm_bus_fabric_init(node_dev, &pdata->info[i]);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	ret = bus_for_each_dev(&msm_bus_type, NULL, NULL,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:						msm_bus_setup_dev_conn);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	ret = bus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_dev_init_qos);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	msm_bus_arb_setops_adhoc(&arb_ops);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	bus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_node_debug);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static int msm_bus_device_rules_probe(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	num_rules = msm_bus_of_get_static_rules(pdev, &rule_data);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	msm_rule_register(num_rules, rule_data, NULL);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:int msm_bus_device_rules_remove(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		msm_rule_unregister(static_rules->num_rules,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	{.compatible = "qcom,msm-bus-static-bw-rules"},
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static struct platform_driver msm_bus_rules_driver = {
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	.probe = msm_bus_device_rules_probe,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	.remove = msm_bus_device_rules_remove,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		.name = "msm_bus_rules_device",
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	{.compatible = "qcom,msm-bus-device"},
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:static struct platform_driver msm_bus_device_driver = {
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	.probe = msm_bus_device_probe,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	.remove = msm_bus_device_remove,
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:		.name = "msm_bus_device",
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:int __init msm_bus_device_init_driver(void)
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	MSM_BUS_ERR("msm_bus_fabric_init_driver\n");
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	rc =  platform_driver_register(&msm_bus_device_driver);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:	return platform_driver_register(&msm_bus_rules_driver);
soc/qcom/msm_bus/msm_bus_fabric_adhoc.c:fs_initcall(msm_bus_device_init_driver);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:#include <trace/events/trace_msm_bus.h>
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:#include <dt-bindings/msm/msm-bus-ids.h>
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:#include "msm_bus_rpmh.h"
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:#include "msm_bus_noc.h"
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:#include "msm_bus_bimc.h"
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_dev_init_qos(struct device *dev, void *data);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_dev_sbm_config(struct device *dev, bool enable);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static struct msm_bus_node_device_type *cur_rsc;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:struct msm_bus_rsc_client {
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:struct msm_bus_rsc_client rsc_clients[MSM_BUS_RSC_COUNT];
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_info_type *node_info = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	bus_node = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *node_dev;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	node_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int tcs_cmd_gen(struct msm_bus_node_device_type *cur_bcm,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *cur_bcm = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *cur_bcm = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int bcm_clist_add(struct msm_bus_node_device_type *cur_dev)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *cur_bcm = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		cur_bcm = to_msm_bus_node(cur_dev->node_info->bcm_devs[i]);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			cur_rsc = to_msm_bus_node(
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			msm_bus_dbg_add_bcm(cur_bcm);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int bcm_query_list_add(struct msm_bus_node_device_type *cur_dev)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *cur_bcm = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		cur_bcm = to_msm_bus_node(cur_dev->node_info->bcm_devs[i]);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int bcm_clist_clean(struct msm_bus_node_device_type *cur_dev)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *cur_bcm = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		cur_bcm = to_msm_bus_node(cur_dev->node_info->bcm_devs[i]);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			msm_bus_dbg_remove_bcm(cur_bcm);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int bcm_query_list_clean(struct msm_bus_node_device_type *cur_dev)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *cur_bcm = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		cur_bcm = to_msm_bus_node(cur_dev->node_info->bcm_devs[i]);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:int msm_bus_commit_data(struct list_head *clist)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *node_tmp = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *cur_bcm = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			msm_bus_dev_sbm_config(&node->dev, false);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		goto exit_msm_bus_commit_data;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			msm_bus_dev_init_qos(&node->dev, NULL);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		msm_bus_dev_sbm_config(&node->dev, true);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:exit_msm_bus_commit_data:
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:int msm_bus_query_gen(struct list_head *query_list,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:				struct msm_bus_tcs_usecase *tcs_usecase)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *node_tmp = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *cur_bcm = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static void bcm_commit_single_req(struct msm_bus_node_device_type *cur_bcm,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *cur_rsc = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	cur_rsc = to_msm_bus_node(cur_bcm->node_info->rsc_devs[0]);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:void *msm_bus_realloc_devmem(struct device *dev, void *p, size_t old_size,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static void msm_bus_fab_init_noc_ops(struct msm_bus_node_device_type *bus_dev)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		msm_bus_noc_set_ops(bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		msm_bus_bimc_set_ops(bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_disable_node_qos_clk(struct msm_bus_node_device_type *node)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_enable_node_qos_clk(struct msm_bus_node_device_type *node)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			msm_bus_disable_node_qos_clk(node);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_vote_qos_bcms(struct msm_bus_node_device_type *node)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *cur_dev = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *cur_bcm = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	if (!node || (!to_msm_bus_node(node->node_info->bus_device)))
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		dev = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:					msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		cur_bcm = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_rm_vote_qos_bcms(struct msm_bus_node_device_type *node)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *cur_dev = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *cur_bcm = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	if (!node || (!to_msm_bus_node(node->node_info->bus_device)))
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		dev = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:					msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		cur_bcm = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:int msm_bus_enable_limiter(struct msm_bus_node_device_type *node_dev,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *bus_node_dev;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	bus_node_dev = to_msm_bus_node(node_dev->node_info->bus_device);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_dev_init_qos(struct device *dev, void *data)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *node_dev = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	node_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		struct msm_bus_node_device_type *bus_node_info;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			to_msm_bus_node(node_dev->node_info->bus_device);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:				ret = msm_bus_vote_qos_bcms(node_dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:				ret = msm_bus_enable_node_qos_clk(node_dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:				ret = msm_bus_disable_node_qos_clk(node_dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:				ret = msm_bus_rm_vote_qos_bcms(node_dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_dev_sbm_config(struct device *dev, bool enable)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *node_dev = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *fab_dev = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	node_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		fab_dev = to_msm_bus_node(node_dev->node_info->bus_device);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_fabric_init(struct device *dev,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			struct msm_bus_node_device_type *pdata)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_fab_device_type *fabdev;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *node_dev = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	node_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	fabdev = devm_kzalloc(dev, sizeof(struct msm_bus_fab_device_type),
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	msm_bus_fab_init_noc_ops(node_dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_bcm_init(struct device *dev,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			struct msm_bus_node_device_type *pdata)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_bcm_device_type *bcmdev;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *node_dev = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	node_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	bcmdev = devm_kzalloc(dev, sizeof(struct msm_bus_bcm_device_type),
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_rsc_init(struct platform_device *pdev,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			struct msm_bus_node_device_type *pdata)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_rsc_device_type *rscdev;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *node_dev = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	node_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	rscdev = devm_kzalloc(dev, sizeof(struct msm_bus_rsc_device_type),
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_postcon_setup(struct device *bus_dev, void *data)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_rsc_device_type *rscdev;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	bus_node = to_msm_bus_node(bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_init_clk(struct device *bus_dev,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:				struct msm_bus_node_device_type *pdata)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *node_dev = to_msm_bus_node(bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_copy_node_info(struct msm_bus_node_device_type *pdata,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_info_type *node_info = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_info_type *pdata_node_info = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	bus_node = to_msm_bus_node(bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static struct device *msm_bus_device_init(
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			struct msm_bus_node_device_type *pdata)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_info_type *node_info = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	bus_node = kzalloc(sizeof(struct msm_bus_node_device_type), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			sizeof(struct msm_bus_node_info_type), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	ret = msm_bus_copy_node_info(pdata, bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	bus_dev->bus = &msm_bus_type;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_setup_dev_conn(struct device *bus_dev, void *data)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *bcm_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *rsc_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *fab;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	bus_node = to_msm_bus_node(bus_dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		fab = to_msm_bus_node(bus_parent_device);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		bcm_node = to_msm_bus_node(bus_node->node_info->bcm_devs[j]);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		rsc_node = to_msm_bus_node(bus_node->node_info->rsc_devs[j]);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_node_debug(struct device *bus_dev, void *data)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_free_dev(struct device *dev, void *data)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	bus_node = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:int msm_bus_device_remove(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	bus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_free_dev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_device_probe(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	struct msm_bus_device_node_registration *pdata;
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	MSM_BUS_ERR("msm_bus: Probe started");
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		pdata = msm_bus_of_to_pdata(pdev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		pdata = (struct msm_bus_device_node_registration *)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	MSM_BUS_ERR("msm_bus: DT Parsing complete");
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		node_dev = msm_bus_device_init(&pdata->info[i]);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		ret = msm_bus_init_clk(node_dev, &pdata->info[i]);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			msm_bus_device_remove(pdev);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			ret = msm_bus_fabric_init(node_dev, &pdata->info[i]);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			ret = msm_bus_bcm_init(node_dev, &pdata->info[i]);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:			ret = msm_bus_rsc_init(pdev, node_dev, &pdata->info[i]);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	ret = bus_for_each_dev(&msm_bus_type, NULL, NULL,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:						msm_bus_setup_dev_conn);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	ret = bus_for_each_dev(&msm_bus_type, NULL, NULL,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:						msm_bus_postcon_setup);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	ret = bus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_dev_init_qos);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	msm_bus_arb_setops_adhoc(&arb_ops);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	bus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_node_debug);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_device_rules_probe(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	num_rules = msm_bus_of_get_static_rules(pdev, &rule_data);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	msm_rule_register(num_rules, rule_data, NULL);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:int msm_bus_device_rules_remove(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		msm_rule_unregister(static_rules->num_rules,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static int msm_bus_rsc_probe(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	ret = of_property_read_u32(pdev->dev.of_node, "qcom,msm-bus-id",
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		MSM_BUS_ERR("unable to find msm bus id\n");
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:int msm_bus_rsc_remove(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	{.compatible = "qcom,msm-bus-static-bw-rules"},
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static struct platform_driver msm_bus_rules_driver = {
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	.probe = msm_bus_device_rules_probe,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	.remove = msm_bus_device_rules_remove,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		.name = "msm_bus_rules_device",
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	{.compatible = "qcom,msm-bus-device"},
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static struct platform_driver msm_bus_device_driver = {
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	.probe = msm_bus_device_probe,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	.remove = msm_bus_device_remove,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		.name = "msm_bus_device",
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	{.compatible = "qcom,msm-bus-rsc"},
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:static struct platform_driver msm_bus_rsc_driver = {
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	.probe = msm_bus_rsc_probe,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	.remove = msm_bus_rsc_remove,
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		.name = "msm_bus_rsc",
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:int __init msm_bus_rsc_init_driver(void)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	rc =  platform_driver_register(&msm_bus_rsc_driver);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:		MSM_BUS_ERR("Failed to register msm bus rsc device driver");
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:int __init msm_bus_device_init_driver(void)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	MSM_BUS_ERR("msm_bus_fabric_rpmh_init_driver\n");
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	rc =  platform_driver_register(&msm_bus_device_driver);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	return platform_driver_register(&msm_bus_rules_driver);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:int __init msm_bus_device_late_init(void)
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:	MSM_BUS_ERR("msm_bus_late_init: Remove handoff bw requests\n");
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:core_initcall(msm_bus_rsc_init_driver);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:subsys_initcall(msm_bus_device_init_driver);
soc/qcom/msm_bus/msm_bus_fabric_rpmh.c:late_initcall_sync(msm_bus_device_late_init);
soc/qcom/msm_bus/msm_bus_noc.h:enum msm_bus_noc_qos_mode_type {
soc/qcom/msm_bus/msm_bus_noc.h:enum msm_bus_noc_qos_mode_perm {
soc/qcom/msm_bus/msm_bus_noc.h:struct msm_bus_noc_commit {
soc/qcom/msm_bus/msm_bus_noc.h:	struct msm_bus_node_hw_info *mas;
soc/qcom/msm_bus/msm_bus_noc.h:	struct msm_bus_node_hw_info *slv;
soc/qcom/msm_bus/msm_bus_noc.h:struct msm_bus_noc_info {
soc/qcom/msm_bus/msm_bus_noc.h:	struct msm_bus_noc_commit cdata[NUM_CTX];
soc/qcom/msm_bus/msm_bus_noc.h:struct msm_bus_noc_qos_priority {
soc/qcom/msm_bus/msm_bus_noc.h:struct msm_bus_noc_qos_bw {
soc/qcom/msm_bus/msm_bus_noc.h:void msm_bus_noc_init(struct msm_bus_noc_info *ninfo);
soc/qcom/msm_bus/msm_bus_noc.h:uint8_t msm_bus_noc_get_qos_mode(void __iomem *base, uint32_t qos_off,
soc/qcom/msm_bus/msm_bus_noc.h:void msm_bus_noc_get_qos_priority(void __iomem *base, uint32_t qos_off,
soc/qcom/msm_bus/msm_bus_noc.h:	struct msm_bus_noc_qos_priority *qprio);
soc/qcom/msm_bus/msm_bus_noc.h:void msm_bus_noc_get_qos_bw(void __iomem *base, uint32_t qos_off,
soc/qcom/msm_bus/msm_bus_noc.h:	uint8_t perm_mode, struct msm_bus_noc_qos_bw *qbw);
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:#include "msm_bus_noc.h"
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:#include "msm_bus_adhoc.h"
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:		struct msm_bus_noc_qos_priority *priority)
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:static void msm_bus_noc_set_qos_bw(void __iomem *base, uint32_t qos_off,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:		uint8_t perm_mode, struct msm_bus_noc_qos_bw *qbw)
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:uint8_t msm_bus_noc_get_qos_mode(void __iomem *base, uint32_t qos_off,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:void msm_bus_noc_get_qos_priority(void __iomem *base, uint32_t qos_off,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:	struct msm_bus_noc_qos_priority *priority)
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:void msm_bus_noc_get_qos_bw(void __iomem *base, uint32_t qos_off,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:	struct msm_bus_noc_qos_bw *qbw)
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:static bool msm_bus_noc_update_bw_reg(int mode)
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:static int msm_bus_noc_qos_init(struct msm_bus_node_device_type *info,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:	struct msm_bus_noc_qos_priority prio;
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:				struct msm_bus_noc_qos_bw qbw;
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:				msm_bus_noc_set_qos_bw(qos_base, qos_off,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:static int msm_bus_noc_set_bw(struct msm_bus_node_device_type *dev,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:	struct msm_bus_node_info_type *info = dev->node_info;
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:		struct msm_bus_noc_qos_bw qos_bw;
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:		bw = msm_bus_div64(dev->node_bw[ACTIVE_CTX].sum_ab,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:			msm_bus_noc_set_qos_bw(qos_base, qos_off, qos_freq,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:static int msm_bus_noc_set_lim_mode(struct msm_bus_node_device_type *info,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:		struct msm_bus_noc_qos_bw qos_bw;
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:					msm_bus_noc_set_qos_bw(qos_base,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:static int msm_bus_noc_set_reg_mode(struct msm_bus_node_device_type *info,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:		struct msm_bus_noc_qos_priority prio;
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:		struct msm_bus_noc_qos_bw qos_bw;
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:				msm_bus_noc_set_qos_bw(qos_base, qos_off,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:static int msm_bus_noc_set_def_mode(struct msm_bus_node_device_type *info,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:			struct msm_bus_noc_qos_priority prio;
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:static int msm_bus_noc_limit_mport(struct msm_bus_node_device_type *info,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:			msm_bus_noc_set_reg_mode(info, qos_base, qos_off,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:			msm_bus_noc_set_lim_mode(info, qos_base, qos_off,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:			msm_bus_noc_set_def_mode(info, qos_base, qos_off,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:		msm_bus_noc_set_def_mode(info, qos_base, qos_off,
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:int msm_bus_noc_set_ops(struct msm_bus_node_device_type *bus_dev)
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:	bus_dev->fabdev->noc_ops.qos_init = msm_bus_noc_qos_init;
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:	bus_dev->fabdev->noc_ops.set_bw = msm_bus_noc_set_bw;
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:	bus_dev->fabdev->noc_ops.limit_mport = msm_bus_noc_limit_mport;
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:	bus_dev->fabdev->noc_ops.update_bw_reg = msm_bus_noc_update_bw_reg;
soc/qcom/msm_bus/msm_bus_noc_adhoc.c:EXPORT_SYMBOL(msm_bus_noc_set_ops);
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:#include "msm_bus_noc.h"
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:#include "msm_bus_rpmh.h"
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:		struct msm_bus_noc_limiter *lim, uint32_t lim_en)
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:		struct msm_bus_noc_regulator *reg,
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:		struct msm_bus_noc_regulator_mode *reg_mode)
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:void msm_bus_noc_get_qos_bw(void __iomem *base, uint32_t qos_off,
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:	struct msm_bus_noc_qos_bw *qbw)
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:static int msm_bus_noc_qos_init(struct msm_bus_node_device_type *info,
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:	struct msm_bus_noc_qos_params *qos_params;
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:static int msm_bus_noc_sbm_config(struct msm_bus_node_device_type *node_dev,
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:int msm_bus_noc_set_ops(struct msm_bus_node_device_type *bus_dev)
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:	bus_dev->fabdev->noc_ops.qos_init = msm_bus_noc_qos_init;
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:	bus_dev->fabdev->noc_ops.sbm_config = msm_bus_noc_sbm_config;
soc/qcom/msm_bus/msm_bus_noc_rpmh.c:EXPORT_SYMBOL(msm_bus_noc_set_ops);
soc/qcom/msm_bus/msm_bus_of.c:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_of.c:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_of.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_of.c:static struct msm_bus_scale_pdata *get_pdata(struct device *dev,
soc/qcom/msm_bus/msm_bus_of.c:	struct msm_bus_scale_pdata *pdata = NULL;
soc/qcom/msm_bus/msm_bus_of.c:	struct msm_bus_paths *usecase = NULL;
soc/qcom/msm_bus/msm_bus_of.c:	struct msm_bus_lat_vectors *usecase_lat = NULL;
soc/qcom/msm_bus/msm_bus_of.c:	pdata = devm_kzalloc(dev, sizeof(struct msm_bus_scale_pdata),
soc/qcom/msm_bus/msm_bus_of.c:	ret = of_property_read_string(of_node, "qcom,msm-bus,name",
soc/qcom/msm_bus/msm_bus_of.c:	ret = of_property_read_u32(of_node, "qcom,msm-bus,num-cases",
soc/qcom/msm_bus/msm_bus_of.c:	if (of_property_read_bool(of_node, "qcom,msm-bus,active-only"))
soc/qcom/msm_bus/msm_bus_of.c:	pdata->alc = of_property_read_bool(of_node, "qcom,msm-bus,alc-voter");
soc/qcom/msm_bus/msm_bus_of.c:				(sizeof(struct msm_bus_lat_vectors) *
soc/qcom/msm_bus/msm_bus_of.c:					"qcom,msm-bus,vectors-alc", &len);
soc/qcom/msm_bus/msm_bus_of.c:	usecase = devm_kzalloc(dev, (sizeof(struct msm_bus_paths) *
soc/qcom/msm_bus/msm_bus_of.c:	ret = of_property_read_u32(of_node, "qcom,msm-bus,num-paths",
soc/qcom/msm_bus/msm_bus_of.c:	vec_arr = of_get_property(of_node, "qcom,msm-bus,vectors-KBps", &len);
soc/qcom/msm_bus/msm_bus_of.c:			sizeof(struct msm_bus_vectors), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_of.c: * msm_bus_cl_get_pdata() - Generate bus client data from device tree
soc/qcom/msm_bus/msm_bus_of.c:struct msm_bus_scale_pdata *msm_bus_cl_get_pdata(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_of.c:	struct msm_bus_scale_pdata *pdata = NULL;
soc/qcom/msm_bus/msm_bus_of.c:EXPORT_SYMBOL(msm_bus_cl_get_pdata);
soc/qcom/msm_bus/msm_bus_of.c: * msm_bus_cl_get_pdata_from_dev() - Generate bus client data from device tree
soc/qcom/msm_bus/msm_bus_of.c:struct msm_bus_scale_pdata *msm_bus_cl_get_pdata_from_dev(struct device *dev)
soc/qcom/msm_bus/msm_bus_of.c:	struct msm_bus_scale_pdata *pdata = NULL;
soc/qcom/msm_bus/msm_bus_of.c:EXPORT_SYMBOL(msm_bus_cl_get_pdata_from_dev);
soc/qcom/msm_bus/msm_bus_of.c: * msm_bus_cl_pdata_from_node() - Generate bus client data from device tree
soc/qcom/msm_bus/msm_bus_of.c:struct msm_bus_scale_pdata *msm_bus_pdata_from_node(
soc/qcom/msm_bus/msm_bus_of.c:	struct msm_bus_scale_pdata *pdata = NULL;
soc/qcom/msm_bus/msm_bus_of.c:EXPORT_SYMBOL(msm_bus_pdata_from_node);
soc/qcom/msm_bus/msm_bus_of.c:static struct msm_bus_node_info *get_nodes(struct device_node *of_node,
soc/qcom/msm_bus/msm_bus_of.c:	struct msm_bus_fabric_registration *pdata)
soc/qcom/msm_bus/msm_bus_of.c:	struct msm_bus_node_info *info;
soc/qcom/msm_bus/msm_bus_of.c:	info = devm_kzalloc(&pdev->dev, sizeof(struct msm_bus_node_info) *
soc/qcom/msm_bus/msm_bus_of.c:void msm_bus_of_get_nfab(struct platform_device *pdev,
soc/qcom/msm_bus/msm_bus_of.c:		struct msm_bus_fabric_registration *pdata)
soc/qcom/msm_bus/msm_bus_of.c:	msm_bus_board_set_nfab(pdata, nfab);
soc/qcom/msm_bus/msm_bus_of.c:struct msm_bus_fabric_registration
soc/qcom/msm_bus/msm_bus_of.c:	*msm_bus_of_get_fab_data(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_of.c:	struct msm_bus_fabric_registration *pdata;
soc/qcom/msm_bus/msm_bus_of.c:			sizeof(struct msm_bus_fabric_registration), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_of.c:EXPORT_SYMBOL(msm_bus_of_get_fab_data);
soc/qcom/msm_bus/msm_bus_of_adhoc.c:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_of_adhoc.c:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_of_adhoc.c:#include <linux/msm_bus_rules.h>
soc/qcom/msm_bus/msm_bus_of_adhoc.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_of_adhoc.c:#include "msm_bus_adhoc.h"
soc/qcom/msm_bus/msm_bus_of_adhoc.c:static struct msm_bus_fab_device_type *get_fab_device_info(
soc/qcom/msm_bus/msm_bus_of_adhoc.c:	struct msm_bus_fab_device_type *fab_dev;
soc/qcom/msm_bus/msm_bus_of_adhoc.c:			sizeof(struct msm_bus_fab_device_type),
soc/qcom/msm_bus/msm_bus_of_adhoc.c:		struct msm_bus_node_info_type *node_info)
soc/qcom/msm_bus/msm_bus_of_adhoc.c:static int msm_bus_of_parse_clk_array(struct device_node *dev_node,
soc/qcom/msm_bus/msm_bus_of_adhoc.c:		struct msm_bus_node_info_type *node_info)
soc/qcom/msm_bus/msm_bus_of_adhoc.c:static struct msm_bus_node_info_type *get_node_info_data(
soc/qcom/msm_bus/msm_bus_of_adhoc.c:	struct msm_bus_node_info_type *node_info;
soc/qcom/msm_bus/msm_bus_of_adhoc.c:			sizeof(struct msm_bus_node_info_type),
soc/qcom/msm_bus/msm_bus_of_adhoc.c:		struct msm_bus_node_device_type * const node_device)
soc/qcom/msm_bus/msm_bus_of_adhoc.c:			if (msm_bus_of_parse_clk_array(qos_clk_node, dev_node,
soc/qcom/msm_bus/msm_bus_of_adhoc.c:			if (msm_bus_of_parse_clk_array(qos_clk_node, dev_node,
soc/qcom/msm_bus/msm_bus_of_adhoc.c:struct msm_bus_device_node_registration
soc/qcom/msm_bus/msm_bus_of_adhoc.c:	*msm_bus_of_to_pdata(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_of_adhoc.c:	struct msm_bus_device_node_registration *pdata;
soc/qcom/msm_bus/msm_bus_of_adhoc.c:			sizeof(struct msm_bus_device_node_registration),
soc/qcom/msm_bus/msm_bus_of_adhoc.c:			sizeof(struct msm_bus_node_device_type) *
soc/qcom/msm_bus/msm_bus_of_adhoc.c:static int msm_bus_of_get_ids(struct platform_device *pdev,
soc/qcom/msm_bus/msm_bus_of_adhoc.c:int msm_bus_of_get_static_rules(struct platform_device *pdev,
soc/qcom/msm_bus/msm_bus_of_adhoc.c:		ret = msm_bus_of_get_ids(pdev, child_node,
soc/qcom/msm_bus/msm_bus_of_adhoc.c:		ret = msm_bus_of_get_ids(pdev, child_node,
soc/qcom/msm_bus/msm_bus_of_rpmh.c:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_of_rpmh.c:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_of_rpmh.c:#include <linux/msm_bus_rules.h>
soc/qcom/msm_bus/msm_bus_of_rpmh.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_of_rpmh.c:#include "msm_bus_rpmh.h"
soc/qcom/msm_bus/msm_bus_of_rpmh.c:static struct msm_bus_rsc_device_type *get_rsc_device_info(
soc/qcom/msm_bus/msm_bus_of_rpmh.c:	struct msm_bus_rsc_device_type *rsc_dev;
soc/qcom/msm_bus/msm_bus_of_rpmh.c:static struct msm_bus_bcm_device_type *get_bcm_device_info(
soc/qcom/msm_bus/msm_bus_of_rpmh.c:	struct msm_bus_bcm_device_type *bcm_dev;
soc/qcom/msm_bus/msm_bus_of_rpmh.c:static struct msm_bus_fab_device_type *get_fab_device_info(
soc/qcom/msm_bus/msm_bus_of_rpmh.c:	struct msm_bus_fab_device_type *fab_dev;
soc/qcom/msm_bus/msm_bus_of_rpmh.c:		struct msm_bus_node_info_type *node_info)
soc/qcom/msm_bus/msm_bus_of_rpmh.c:static int msm_bus_of_parse_clk_array(struct device_node *dev_node,
soc/qcom/msm_bus/msm_bus_of_rpmh.c:		struct msm_bus_node_info_type *node_info)
soc/qcom/msm_bus/msm_bus_of_rpmh.c:static struct msm_bus_node_info_type *get_node_info_data(
soc/qcom/msm_bus/msm_bus_of_rpmh.c:	struct msm_bus_node_info_type *node_info;
soc/qcom/msm_bus/msm_bus_of_rpmh.c:		struct msm_bus_node_device_type * const node_device)
soc/qcom/msm_bus/msm_bus_of_rpmh.c:			if (msm_bus_of_parse_clk_array(qos_clk_node, dev_node,
soc/qcom/msm_bus/msm_bus_of_rpmh.c:struct msm_bus_device_node_registration
soc/qcom/msm_bus/msm_bus_of_rpmh.c:	*msm_bus_of_to_pdata(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_of_rpmh.c:	struct msm_bus_device_node_registration *pdata;
soc/qcom/msm_bus/msm_bus_of_rpmh.c:static int msm_bus_of_get_ids(struct platform_device *pdev,
soc/qcom/msm_bus/msm_bus_of_rpmh.c:int msm_bus_of_get_static_rules(struct platform_device *pdev,
soc/qcom/msm_bus/msm_bus_of_rpmh.c:		ret = msm_bus_of_get_ids(pdev, child_node,
soc/qcom/msm_bus/msm_bus_of_rpmh.c:		ret = msm_bus_of_get_ids(pdev, child_node,
soc/qcom/msm_bus/msm_bus_proxy_client.c:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_proxy_client.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_proxy_client.c:static int msm_bus_device_proxy_client_probe(struct platform_device *pdev)
soc/qcom/msm_bus/msm_bus_proxy_client.c:	proxy_client_info.pdata = msm_bus_cl_get_pdata(pdev);
soc/qcom/msm_bus/msm_bus_proxy_client.c:		msm_bus_scale_register_client(proxy_client_info.pdata);
soc/qcom/msm_bus/msm_bus_proxy_client.c:	ret = msm_bus_scale_client_update_request(
soc/qcom/msm_bus/msm_bus_proxy_client.c:static struct platform_driver msm_bus_proxy_client_driver = {
soc/qcom/msm_bus/msm_bus_proxy_client.c:	.probe = msm_bus_device_proxy_client_probe,
soc/qcom/msm_bus/msm_bus_proxy_client.c:		.name = "msm_bus_proxy_client_device",
soc/qcom/msm_bus/msm_bus_proxy_client.c:static int __init msm_bus_proxy_client_init_driver(void)
soc/qcom/msm_bus/msm_bus_proxy_client.c:	rc =  platform_driver_register(&msm_bus_proxy_client_driver);
soc/qcom/msm_bus/msm_bus_proxy_client.c:static int __init msm_bus_proxy_client_unvote(void)
soc/qcom/msm_bus/msm_bus_proxy_client.c:	ret = msm_bus_scale_client_update_request(
soc/qcom/msm_bus/msm_bus_proxy_client.c:	msm_bus_scale_unregister_client(proxy_client_info.client_handle);
soc/qcom/msm_bus/msm_bus_proxy_client.c:subsys_initcall_sync(msm_bus_proxy_client_init_driver);
soc/qcom/msm_bus/msm_bus_proxy_client.c:late_initcall_sync(msm_bus_proxy_client_unvote);
soc/qcom/msm_bus/msm_bus_qnoc_adhoc.c:#include "msm_bus_adhoc.h"
soc/qcom/msm_bus/msm_bus_qnoc_adhoc.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_qnoc_adhoc.c:#include "msm_bus_noc.h"
soc/qcom/msm_bus/msm_bus_qnoc_adhoc.c:		struct msm_bus_noc_limiter *lim, uint32_t lim_en)
soc/qcom/msm_bus/msm_bus_qnoc_adhoc.c:		struct msm_bus_noc_regulator *reg,
soc/qcom/msm_bus/msm_bus_qnoc_adhoc.c:		struct msm_bus_noc_regulator_mode *reg_mode)
soc/qcom/msm_bus/msm_bus_qnoc_adhoc.c:static int msm_bus_noc_qos_init(struct msm_bus_node_device_type *info,
soc/qcom/msm_bus/msm_bus_qnoc_adhoc.c:int msm_bus_qnoc_set_ops(struct msm_bus_node_device_type *bus_dev)
soc/qcom/msm_bus/msm_bus_qnoc_adhoc.c:	bus_dev->fabdev->noc_ops.qos_init = msm_bus_noc_qos_init;
soc/qcom/msm_bus/msm_bus_rpm_smd.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_rpm_smd.c:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_rpm_smd.c:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_rpm_smd.c:void msm_bus_rpm_set_mt_mask(void)
soc/qcom/msm_bus/msm_bus_rpm_smd.c:bool msm_bus_rpm_is_mem_interleaved(void)
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	struct msm_bus_node_hw_info *mas_arb;
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	struct msm_bus_node_hw_info *slv_arb;
soc/qcom/msm_bus/msm_bus_rpm_smd.c:void msm_bus_rpm_fill_cdata_buffer(int *curr, char *buf, const int max_size,
soc/qcom/msm_bus/msm_bus_rpm_smd.c:static int msm_bus_rpm_compare_cdata(
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	struct msm_bus_fabric_registration *fab_pdata,
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	n = sizeof(struct msm_bus_node_hw_info) * fab_pdata->nmasters * 2;
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	n = sizeof(struct msm_bus_node_hw_info) * fab_pdata->nslaves * 2;
soc/qcom/msm_bus/msm_bus_rpm_smd.c:static int msm_bus_rpm_req(int ctx, uint32_t rsc_type, uint32_t key,
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	struct msm_bus_node_hw_info *hw_info, bool valid)
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	struct msm_rpm_request *rpm_req;
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	rpm_req = msm_rpm_create_request(ctx, rsc_type, hw_info->hw_id, 1);
soc/qcom/msm_bus/msm_bus_rpm_smd.c:		ret = msm_rpm_add_kvp_data(rpm_req, key, (const uint8_t *)
soc/qcom/msm_bus/msm_bus_rpm_smd.c:		ret = msm_rpm_add_kvp_data(rpm_req, 0, NULL, 0);
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	msg_id = msm_rpm_send_request(rpm_req);
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	ret = msm_rpm_wait_for_ack(msg_id);
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	msm_rpm_free_request(rpm_req);
soc/qcom/msm_bus/msm_bus_rpm_smd.c:static int msm_bus_rpm_commit_arb(struct msm_bus_fabric_registration
soc/qcom/msm_bus/msm_bus_rpm_smd.c:		status = msm_bus_rpm_req(ctx, rsc_type, key,
soc/qcom/msm_bus/msm_bus_rpm_smd.c:		status = msm_bus_rpm_req(ctx, rsc_type, key,
soc/qcom/msm_bus/msm_bus_rpm_smd.c: * msm_bus_remote_hw_commit() - Commit the arbitration data to RPM
soc/qcom/msm_bus/msm_bus_rpm_smd.c:int msm_bus_remote_hw_commit(struct msm_bus_fabric_registration
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	ret = msm_bus_rpm_compare_cdata(fab_pdata, act_cd, dual_cd);
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	ret = msm_bus_rpm_commit_arb(fab_pdata, DUAL_CTX, rpm_data,
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	ret = msm_bus_rpm_commit_arb(fab_pdata, ACTIVE_CTX, rpm_data, act_cd,
soc/qcom/msm_bus/msm_bus_rpm_smd.c:int msm_bus_rpm_hw_init(struct msm_bus_fabric_registration *pdata,
soc/qcom/msm_bus/msm_bus_rpm_smd.c:	struct msm_bus_hw_algorithm *hw_algo)
soc/qcom/msm_bus/msm_bus_rpmh.h:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_rpmh.h:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_rpmh.h:#include <linux/msm_bus_rules.h>
soc/qcom/msm_bus/msm_bus_rpmh.h:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_rpmh.h:#include "msm_bus_noc.h"
soc/qcom/msm_bus/msm_bus_rpmh.h:struct msm_bus_node_device_type;
soc/qcom/msm_bus/msm_bus_rpmh.h:struct msm_bus_noc_ops {
soc/qcom/msm_bus/msm_bus_rpmh.h:	int (*qos_init)(struct msm_bus_node_device_type *dev,
soc/qcom/msm_bus/msm_bus_rpmh.h:	int (*set_bw)(struct msm_bus_node_device_type *dev,
soc/qcom/msm_bus/msm_bus_rpmh.h:	int (*limit_mport)(struct msm_bus_node_device_type *dev,
soc/qcom/msm_bus/msm_bus_rpmh.h:	int (*sbm_config)(struct msm_bus_node_device_type *node_dev,
soc/qcom/msm_bus/msm_bus_rpmh.h:struct msm_bus_rsc_device_type {
soc/qcom/msm_bus/msm_bus_rpmh.h:struct msm_bus_bcm_device_type {
soc/qcom/msm_bus/msm_bus_rpmh.h:struct msm_bus_fab_device_type {
soc/qcom/msm_bus/msm_bus_rpmh.h:	struct msm_bus_noc_ops noc_ops;
soc/qcom/msm_bus/msm_bus_rpmh.h:	enum msm_bus_hw_sel bus_type;
soc/qcom/msm_bus/msm_bus_rpmh.h:struct msm_bus_noc_limiter {
soc/qcom/msm_bus/msm_bus_rpmh.h:struct msm_bus_noc_regulator {
soc/qcom/msm_bus/msm_bus_rpmh.h:struct msm_bus_noc_regulator_mode {
soc/qcom/msm_bus/msm_bus_rpmh.h:struct msm_bus_noc_qos_params {
soc/qcom/msm_bus/msm_bus_rpmh.h:	struct msm_bus_noc_limiter limiter;
soc/qcom/msm_bus/msm_bus_rpmh.h:	struct msm_bus_noc_regulator reg;
soc/qcom/msm_bus/msm_bus_rpmh.h:	struct msm_bus_noc_regulator_mode reg_mode;
soc/qcom/msm_bus/msm_bus_rpmh.h:struct msm_bus_node_info_type {
soc/qcom/msm_bus/msm_bus_rpmh.h:	struct msm_bus_noc_qos_params qos_params;
soc/qcom/msm_bus/msm_bus_rpmh.h:struct msm_bus_node_device_type {
soc/qcom/msm_bus/msm_bus_rpmh.h:	struct msm_bus_node_info_type *node_info;
soc/qcom/msm_bus/msm_bus_rpmh.h:	struct msm_bus_fab_device_type *fabdev;
soc/qcom/msm_bus/msm_bus_rpmh.h:	struct msm_bus_bcm_device_type *bcmdev;
soc/qcom/msm_bus/msm_bus_rpmh.h:	struct msm_bus_rsc_device_type *rscdev;
soc/qcom/msm_bus/msm_bus_rpmh.h:static inline struct msm_bus_node_device_type *to_msm_bus_node(struct device *d)
soc/qcom/msm_bus/msm_bus_rpmh.h:	return container_of(d, struct msm_bus_node_device_type, dev);
soc/qcom/msm_bus/msm_bus_rpmh.h:int msm_bus_enable_limiter(struct msm_bus_node_device_type *nodedev,
soc/qcom/msm_bus/msm_bus_rpmh.h:int msm_bus_commit_data(struct list_head *clist);
soc/qcom/msm_bus/msm_bus_rpmh.h:int msm_bus_query_gen(struct list_head *qlist,
soc/qcom/msm_bus/msm_bus_rpmh.h:				struct msm_bus_tcs_usecase *tcs_usecase);
soc/qcom/msm_bus/msm_bus_rpmh.h:void *msm_bus_realloc_devmem(struct device *dev, void *p, size_t old_size,
soc/qcom/msm_bus/msm_bus_rpmh.h:extern struct msm_bus_device_node_registration
soc/qcom/msm_bus/msm_bus_rpmh.h:	*msm_bus_of_to_pdata(struct platform_device *pdev);
soc/qcom/msm_bus/msm_bus_rpmh.h:extern void msm_bus_arb_setops_adhoc(struct msm_bus_arb_ops *arb_ops);
soc/qcom/msm_bus/msm_bus_rpmh.h:extern int msm_bus_bimc_set_ops(struct msm_bus_node_device_type *bus_dev);
soc/qcom/msm_bus/msm_bus_rpmh.h:extern int msm_bus_noc_set_ops(struct msm_bus_node_device_type *bus_dev);
soc/qcom/msm_bus/msm_bus_rpmh.h:extern int msm_bus_of_get_static_rules(struct platform_device *pdev,
soc/qcom/msm_bus/msm_bus_rpmh.h:extern int msm_rules_update_path(struct list_head *input_list,
soc/qcom/msm_bus/msm_bus_rpmh.h:int msm_bus_floor_init(struct device *dev);
soc/qcom/msm_bus/msm_bus_rpmh.h:static inline int msm_bus_floor_init(struct device *dev)
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:struct msmbus_coresight_adhoc_clock_drvdata {
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:struct msmbus_coresight_adhoc_drvdata {
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:static int msmbus_coresight_enable_adhoc(struct coresight_device *csdev)
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	struct msmbus_coresight_adhoc_clock_drvdata *clk;
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	struct msmbus_coresight_adhoc_drvdata *drvdata =
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:static void msmbus_coresight_disable_adhoc(struct coresight_device *csdev)
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	struct msmbus_coresight_adhoc_clock_drvdata *clk;
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	struct msmbus_coresight_adhoc_drvdata *drvdata =
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:static const struct coresight_ops_source msmbus_coresight_adhoc_source_ops = {
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	.enable		= msmbus_coresight_enable_adhoc,
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	.disable	= msmbus_coresight_disable_adhoc,
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:static const struct coresight_ops msmbus_coresight_cs_ops = {
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	.source_ops	= &msmbus_coresight_adhoc_source_ops,
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:void msmbus_coresight_remove_adhoc(struct platform_device *pdev)
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	struct msmbus_coresight_adhoc_clock_drvdata *clk, *next_clk;
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	struct msmbus_coresight_adhoc_drvdata *drvdata =
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	msmbus_coresight_disable_adhoc(drvdata->csdev);
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:EXPORT_SYMBOL(msmbus_coresight_remove_adhoc);
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	struct msmbus_coresight_adhoc_drvdata *drvdata, const char *name)
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	struct msmbus_coresight_adhoc_clock_drvdata *clk;
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:int msmbus_coresight_init_adhoc(struct platform_device *pdev,
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	struct msmbus_coresight_adhoc_drvdata *drvdata;
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:	desc->ops = &msmbus_coresight_cs_ops;
soc/qcom/msm_bus/msm_buspm_coresight_adhoc.c:EXPORT_SYMBOL(msmbus_coresight_init_adhoc);
soc/qcom/msm_bus/msm_bus_rules.c:#include <linux/msm-bus-board.h>
soc/qcom/msm_bus/msm_bus_rules.c:#include <linux/msm_bus_rules.h>
soc/qcom/msm_bus/msm_bus_rules.c:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_rules.c:DEFINE_MUTEX(msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:int msm_rules_update_path(struct list_head *input_list,
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_lock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_unlock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_lock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_unlock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_lock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_unlock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:void msm_rule_register(int num_rules, struct bus_rule_type *rule,
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_lock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_unlock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:void msm_rule_unregister(int num_rules, struct bus_rule_type *rule,
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_lock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_unlock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:bool msm_rule_update(struct bus_rule_type *old_rule,
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_lock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_unlock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:void msm_rule_evaluate_rules(int node)
soc/qcom/msm_bus/msm_bus_rules.c:	struct msm_bus_client_handle *handle;
soc/qcom/msm_bus/msm_bus_rules.c:	handle = msm_bus_scale_register(node, node, "tmp-rm", false);
soc/qcom/msm_bus/msm_bus_rules.c:	msm_bus_scale_update_bw(handle, 0, 0);
soc/qcom/msm_bus/msm_bus_rules.c:	msm_bus_scale_unregister(handle);
soc/qcom/msm_bus/msm_bus_rules.c:bool msm_rule_are_rules_registered(void)
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_lock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_rules.c:	mutex_unlock(&msm_bus_rules_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:#include "msm_bus_adhoc.h"
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:#include <trace/events/trace_msm_bus.h>
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_client **cl_list;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:DEFINE_RT_MUTEX(msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c: * Duplicate instantiaion from msm_bus_arb.c. Todo there needs to be a
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:uint64_t msm_bus_div64(uint64_t num, unsigned int base)
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:int msm_bus_device_match_adhoc(struct device *dev, void *id)
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_node_device_type *bnode = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_node_device_type *cur_dev = NULL;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	cur_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:			realloc_list = msm_bus_realloc_devmem(
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		lnode->next_dev = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:					msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static int remove_lnode(struct msm_bus_node_device_type *cur_dev,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_node_device_type *bus_node;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct device *dest_dev = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:					msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:						&msm_bus_type,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:						msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static void setup_bl_list(struct msm_bus_node_device_type *node,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		struct msm_bus_node_device_type *bdev;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		bdev = to_msm_bus_node(node->node_info->black_connections[i]);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_node_device_type *src_node;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	src_node = to_msm_bus_node(src_dev);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:					struct msm_bus_node_device_type
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:					node_conn = to_msm_bus_node(
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static uint64_t scheme1_agg_scheme(struct msm_bus_node_device_type *bus_dev,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:			struct msm_bus_node_device_type *fab_dev, int ctx)
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		sum_ab = msm_bus_div64(sum_ab, 100);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		max_ib = msm_bus_div64(max_ib, vrail_comp);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		sum_ab = msm_bus_div64(sum_ab,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	bw_max_hz = msm_bus_div64(bw_max_hz,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static uint64_t legacy_agg_scheme(struct msm_bus_node_device_type *bus_dev,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:			struct msm_bus_node_device_type *fab_dev, int ctx)
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		sum_ab = msm_bus_div64(sum_ab, 100);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		max_ib = msm_bus_div64(max_ib, vrail_comp);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		sum_ab = msm_bus_div64(sum_ab,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	bw_max_hz = msm_bus_div64(bw_max_hz,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static uint64_t aggregate_bus_req(struct msm_bus_node_device_type *bus_dev,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_node_device_type *fab_dev = NULL;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	if (!bus_dev || !to_msm_bus_node(bus_dev->node_info->bus_device)) {
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	fab_dev = to_msm_bus_node(bus_dev->node_info->bus_device);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static int msm_bus_apply_rules(struct list_head *list, bool after_clk_commit)
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_node_device_type *dev_info = NULL;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		dev = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		dev_info = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		ret = msm_bus_enable_limiter(dev_info, rule->throttle,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	bool rules_registered = msm_rule_are_rules_registered();
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		msm_rules_update_path(&input_list, &apply_list);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		msm_bus_apply_rules(&apply_list, false);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	msm_bus_commit_data(&commit_list);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		msm_bus_apply_rules(&apply_list, true);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static void add_node_to_clist(struct msm_bus_node_device_type *node)
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_node_device_type *node_parent =
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:			to_msm_bus_node(node->node_info->bus_device);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_node_device_type *dev_info = NULL;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	bool rules_registered = msm_rule_are_rules_registered();
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		dev_info = to_msm_bus_node(next_dev);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_node_device_type *dev_info = NULL;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		dev_info = to_msm_bus_node(next_dev);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_node_device_type *devinfo;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	dev_node = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	devinfo = to_msm_bus_node(dev_node);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		struct msm_bus_node_device_type *busdev =
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:			to_msm_bus_node(devinfo->node_info->bus_device);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:			devinfo = to_msm_bus_node(dev_it);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_client *client;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	msm_bus_dbg_client_data(client->pdata, MSM_BUS_DBG_UNREGISTER, cl);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_client **t_cl_list;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		t_cl_list = kzalloc(sizeof(struct msm_bus_client *)
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:				sizeof(struct msm_bus_client *) *
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:			NUM_CL_HANDLES * sizeof(struct msm_bus_client *));
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static uint32_t gen_handle(struct msm_bus_client *client)
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static uint32_t register_client_adhoc(struct msm_bus_scale_pdata *pdata)
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_client *client = NULL;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	client = kzalloc(sizeof(struct msm_bus_client), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		dev = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	msm_bus_dbg_client_data(client->pdata, MSM_BUS_DBG_REGISTER,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static int update_client_paths(struct msm_bus_client *client, bool log_trns,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_client *client;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	msm_bus_dbg_client_data(client->pdata, ctx_idx, cl);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_client *client;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	msm_bus_dbg_client_data(client->pdata, index, cl);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static void free_cl_mem(struct msm_bus_client_handle *cl)
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static int update_bw_adhoc(struct msm_bus_client_handle *cl, u64 ab, u64 ib)
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		msm_bus_dbg_rec_transaction(cl, ab, ib);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static int update_bw_context(struct msm_bus_client_handle *cl, u64 act_ab,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:		msm_bus_dbg_rec_transaction(cl, cl->cur_act_ab,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static void unregister_adhoc(struct msm_bus_client_handle *cl)
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	msm_bus_dbg_remove_client(cl);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:static struct msm_bus_client_handle*
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	struct msm_bus_client_handle *client = NULL;
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	client = kzalloc(sizeof(struct msm_bus_client_handle), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	client->mas_dev = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:					msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	msm_bus_dbg_add_client(client);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:	rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_adhoc.c: *  msm_bus_arb_setops_adhoc() : Setup the bus arbitration ops
soc/qcom/msm_bus/msm_bus_arb_adhoc.c:void msm_bus_arb_setops_adhoc(struct msm_bus_arb_ops *arb_ops)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:#include <linux/msm-bus.h>
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:#include "msm_bus_core.h"
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:#include "msm_bus_rpmh.h"
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_client **cl_list;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:DEFINE_RT_MUTEX(msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c: * Duplicate instantiaion from msm_bus_arb.c. Todo there needs to be a
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:uint64_t msm_bus_div64(uint64_t num, unsigned int base)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:int msm_bus_device_match_adhoc(struct device *dev, void *id)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *bnode = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *cur_dev = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *bcm_dev = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	cur_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		bcm_dev = to_msm_bus_node(cur_dev->node_info->bcm_devs[i]);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:				realloc_list = msm_bus_realloc_devmem(
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *cur_dev = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	cur_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:			realloc_list = msm_bus_realloc_devmem(
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		lnode->next_dev = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:					msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static int remove_lnode(struct msm_bus_node_device_type *cur_dev,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *bus_node;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct device *dest_dev = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:					msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:						&msm_bus_type,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:						msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static void setup_bl_list(struct msm_bus_node_device_type *node,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		struct msm_bus_node_device_type *bdev;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		bdev = to_msm_bus_node(node->node_info->black_connections[i]);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *src_node;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	src_node = to_msm_bus_node(src_dev);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		struct msm_bus_node_device_type *bus_node = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:				struct msm_bus_node_device_type
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:				to_msm_bus_node(
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static void bcm_update_acv_req(struct msm_bus_node_device_type *cur_rsc,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *cur_dev = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *bcm_dev = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *cur_rsc = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	cur_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		bcm_dev = to_msm_bus_node(cur_dev->node_info->bcm_devs[i]);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:			msm_bus_div64(cur_dev->node_bw[ctx].max_ib *
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:			msm_bus_div64(cur_dev->node_bw[ctx].sum_ab *
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		max_ab = msm_bus_div64(max_ab, bcm_dev->bcmdev->unit_size);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		max_ib = msm_bus_div64(max_ib, bcm_dev->bcmdev->unit_size);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:			to_msm_bus_node(bcm_dev->node_info->rsc_devs[0]);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *cur_dev = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *bcm_dev = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *cur_rsc = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	cur_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		bcm_dev = to_msm_bus_node(cur_dev->node_info->bcm_devs[i]);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:			msm_bus_div64(cur_dev->node_bw[ctx].max_query_ib *
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:			msm_bus_div64(cur_dev->node_bw[ctx].sum_query_ab *
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		max_query_ab = msm_bus_div64(max_query_ab,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		max_query_ib = msm_bus_div64(max_query_ib,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:			to_msm_bus_node(bcm_dev->node_info->rsc_devs[0]);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static void bcm_update_alc_req(struct msm_bus_node_device_type *dev, int ctx)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *bcm_dev = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	if (!dev || !to_msm_bus_node(dev->node_info->bus_device)) {
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	bcm_dev = to_msm_bus_node(dev->node_info->bcm_devs[0]);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *bus_dev = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *cur_bcm = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *cur_rsc = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	bus_dev = to_msm_bus_node(dev);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		cur_bcm = to_msm_bus_node(bus_dev->node_info->bcm_devs[0]);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:			to_msm_bus_node(cur_bcm->node_info->rsc_devs[0]);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static void aggregate_bus_req(struct msm_bus_node_device_type *bus_dev,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	if (!bus_dev || !to_msm_bus_node(bus_dev->node_info->bus_device)) {
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static void aggregate_bus_query_req(struct msm_bus_node_device_type *bus_dev,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	if (!bus_dev || !to_msm_bus_node(bus_dev->node_info->bus_device)) {
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	msm_bus_commit_data(&commit_list);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		mbus_rpmh_rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	rc = bus_for_each_dev(&msm_bus_type, NULL, NULL,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	msm_bus_commit_data(&late_init_clist);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static void add_node_to_clist(struct msm_bus_node_device_type *node)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *node_parent =
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:			to_msm_bus_node(node->node_info->bus_device);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static void add_node_to_query_list(struct msm_bus_node_device_type *node)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *dev_info = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		dev_info = to_msm_bus_node(next_dev);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *dev_info = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	dev_info = to_msm_bus_node(alc_dev);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *dev_info = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		dev_info = to_msm_bus_node(next_dev);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *dev_info = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		dev_info = to_msm_bus_node(next_dev);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *devinfo;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	dev_node = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	devinfo = to_msm_bus_node(dev_node);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		struct msm_bus_node_device_type *busdev =
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:			to_msm_bus_node(devinfo->node_info->bus_device);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:			devinfo = to_msm_bus_node(dev_it);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_client *client;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	msm_bus_dbg_client_data(client->pdata, MSM_BUS_DBG_UNREGISTER, cl);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_client **t_cl_list;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		t_cl_list = kzalloc(sizeof(struct msm_bus_client *)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:				sizeof(struct msm_bus_client *) *
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:			NUM_CL_HANDLES * sizeof(struct msm_bus_client *));
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static uint32_t gen_handle(struct msm_bus_client *client)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static uint32_t register_client_adhoc(struct msm_bus_scale_pdata *pdata)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_client *client = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	client = kzalloc(sizeof(struct msm_bus_client), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		dev = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		dev = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:				msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	msm_bus_dbg_client_data(client->pdata, MSM_BUS_DBG_REGISTER,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static int update_client_paths(struct msm_bus_client *client, unsigned int idx)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static int update_client_alc(struct msm_bus_client *client, unsigned int idx)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static int query_usecase(struct msm_bus_client *client, bool log_trns,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:					struct msm_bus_tcs_usecase *tcs_usecase)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *node = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_node_device_type *node_tmp = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	msm_bus_query_gen(&query_list, tcs_usecase);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_client *client;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	msm_bus_dbg_client_data(client->pdata, ctx_idx, cl);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_client *client;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static int query_client_usecase(struct msm_bus_tcs_usecase *tcs_usecase,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_client *client;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static int query_client_usecase_all(struct msm_bus_tcs_handle *tcs_handle,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_client *client;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static void free_cl_mem(struct msm_bus_client_handle *cl)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static int update_bw_adhoc(struct msm_bus_client_handle *cl, u64 ab, u64 ib)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		msm_bus_dbg_rec_transaction(cl, ab, ib);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static int update_bw_context(struct msm_bus_client_handle *cl, u64 act_ab,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:		msm_bus_dbg_rec_transaction(cl, cl->cur_act_ab,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static void unregister_adhoc(struct msm_bus_client_handle *cl)
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	msm_bus_dbg_remove_client(cl);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:static struct msm_bus_client_handle*
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	struct msm_bus_client_handle *client = NULL;
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_lock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	client = kzalloc(sizeof(struct msm_bus_client_handle), GFP_KERNEL);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	client->mas_dev = bus_find_device(&msm_bus_type, NULL,
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:					msm_bus_device_match_adhoc);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	msm_bus_dbg_add_client(client);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:	mbus_rpmh_rt_mutex_unlock(&msm_bus_adhoc_lock);
soc/qcom/msm_bus/msm_bus_arb_rpmh.c: *  msm_bus_arb_setops_adhoc() : Setup the bus arbitration ops
soc/qcom/msm_bus/msm_bus_arb_rpmh.c:void msm_bus_arb_setops_adhoc(struct msm_bus_arb_ops *arb_ops)
soc/qcom/msm_minidump.c:bool msm_minidump_enabled(void)
soc/qcom/msm_minidump.c:EXPORT_SYMBOL(msm_minidump_enabled);
soc/qcom/msm_minidump.c:int msm_minidump_update_region(int regno, const struct md_region *entry)
soc/qcom/msm_minidump.c:EXPORT_SYMBOL(msm_minidump_update_region);
soc/qcom/msm_minidump.c:int msm_minidump_add_region(const struct md_region *entry)
soc/qcom/msm_minidump.c:EXPORT_SYMBOL(msm_minidump_add_region);
soc/qcom/msm_minidump.c:int msm_minidump_clear_headers(const struct md_region *entry)
soc/qcom/msm_minidump.c:int msm_minidump_remove_region(const struct md_region *entry)
soc/qcom/msm_minidump.c:	ret = msm_minidump_clear_headers(entry);
soc/qcom/msm_minidump.c:EXPORT_SYMBOL(msm_minidump_remove_region);
soc/qcom/msm_minidump.c:static int msm_minidump_add_header(void)
soc/qcom/msm_minidump.c:static int __init msm_minidump_init(void)
soc/qcom/msm_minidump.c:	msm_minidump_add_header();
soc/qcom/msm_minidump.c:subsys_initcall(msm_minidump_init)
soc/qcom/msm_performance.c:static DEFINE_PER_CPU(struct cpu_status, msm_perf_cpu_stats);
soc/qcom/msm_performance.c:		i_cpu_stats = &per_cpu(msm_perf_cpu_stats, cpu);
soc/qcom/msm_performance.c:		i_cpu_stats = &per_cpu(msm_perf_cpu_stats, i);
soc/qcom/msm_performance.c:				per_cpu(msm_perf_cpu_stats, cpu).min);
soc/qcom/msm_performance.c:		i_cpu_stats = &per_cpu(msm_perf_cpu_stats, cpu);
soc/qcom/msm_performance.c:		i_cpu_stats = &per_cpu(msm_perf_cpu_stats, i);
soc/qcom/msm_performance.c:				per_cpu(msm_perf_cpu_stats, cpu).max);
soc/qcom/msm_performance.c:	struct cpu_status *cpu_st = &per_cpu(msm_perf_cpu_stats, cpu);
soc/qcom/msm_performance.c:	pr_debug("msm_perf: CPU%u policy before: %u:%u kHz\n", cpu,
soc/qcom/msm_performance.c:	pr_debug("msm_perf: CPU%u seting min:max %u:%u kHz\n", cpu, min, max);
soc/qcom/msm_performance.c:	pr_debug("msm_perf: CPU%u policy after: %u:%u kHz\n", cpu,
soc/qcom/msm_performance.c:		pr_err("msm_perf: Couldn't find module kobject\n");
soc/qcom/msm_performance.c:		pr_err("msm_perf: Failed to add notify_kobj\n");
soc/qcom/msm_performance.c:		pr_err("msm_perf: Failed to create sysfs\n");
soc/qcom/msm_performance.c:		pr_err("msm_perf: Couldn't find module kobject\n");
soc/qcom/msm_performance.c:		pr_err("msm_perf: Failed to add events_kobj\n");
soc/qcom/msm_performance.c:		pr_err("msm_perf: Failed to create sysfs\n");
soc/qcom/msm_performance.c:					NULL, "msm_perf:events_notify");
soc/qcom/msm_performance.c:static int msm_perf_core_ctl_notify(struct notifier_block *nb,
soc/qcom/msm_performance.c:static struct notifier_block msm_perf_nb = {
soc/qcom/msm_performance.c:	.notifier_call = msm_perf_core_ctl_notify
soc/qcom/msm_performance.c:		core_ctl_notifier_register(&msm_perf_nb);
soc/qcom/msm_performance.c:		core_ctl_notifier_unregister(&msm_perf_nb);
soc/qcom/msm_performance.c:static int __init msm_performance_init(void)
soc/qcom/msm_performance.c:		per_cpu(msm_perf_cpu_stats, cpu).max = UINT_MAX;
soc/qcom/msm_performance.c:		"msm_performance_cpu_hotplug",
soc/qcom/msm_performance.c:late_initcall(msm_performance_init);
soc/qcom/msm_tz_smmu.c:#include <soc/qcom/msm_tz_smmu.h>
soc/qcom/msm_tz_smmu.c:enum tz_smmu_device_id msm_dev_to_device_id(struct device *dev)
soc/qcom/msm_tz_smmu.c:static int __msm_tz_smmu_atos(struct device *dev, int cb_num, int operation)
soc/qcom/msm_tz_smmu.c:	enum tz_smmu_device_id devid = msm_dev_to_device_id(dev);
soc/qcom/msm_tz_smmu.c:int msm_tz_smmu_atos_start(struct device *dev, int cb_num)
soc/qcom/msm_tz_smmu.c:	return __msm_tz_smmu_atos(dev, cb_num, TZ_SMMU_ATOS_START);
soc/qcom/msm_tz_smmu.c:int msm_tz_smmu_atos_end(struct device *dev, int cb_num)
soc/qcom/msm_tz_smmu.c:	return __msm_tz_smmu_atos(dev, cb_num, TZ_SMMU_ATOS_END);
soc/qcom/msm_tz_smmu.c:int msm_tz_set_cb_format(enum tz_smmu_device_id sec_id, int cbndx)
soc/qcom/peripheral-loader.c:#include <trace/events/trace_msm_pil_event.h>
soc/qcom/peripheral-loader.c:static int __init msm_pil_init(void)
soc/qcom/peripheral-loader.c:	np = of_find_compatible_node(NULL, NULL, "qcom,msm-imem-pil");
soc/qcom/peripheral-loader.c:		pr_warn("pil: failed to find qcom,msm-imem-pil node\n");
soc/qcom/peripheral-loader.c:subsys_initcall(msm_pil_init);
soc/qcom/peripheral-loader.c:static void __exit msm_pil_exit(void)
soc/qcom/peripheral-loader.c:module_exit(msm_pil_exit);
soc/qcom/pil-msa.c:#include <trace/events/trace_msm_pil_event.h>
soc/qcom/pil-q6v5.c:#include <trace/events/trace_msm_pil_event.h>
soc/qcom/qcom_gsbi.c:static const unsigned int crci_msm8960[][MAX_GSBI] = {
soc/qcom/qcom_gsbi.c:static const struct crci_config config_msm8960 = {
soc/qcom/qcom_gsbi.c:	.num_rows = ARRAY_SIZE(crci_msm8960),
soc/qcom/qcom_gsbi.c:	.array = crci_msm8960,
soc/qcom/qcom_gsbi.c:static const unsigned int crci_msm8660[][MAX_GSBI] = {
soc/qcom/qcom_gsbi.c:static const struct crci_config config_msm8660 = {
soc/qcom/qcom_gsbi.c:	.num_rows = ARRAY_SIZE(crci_msm8660),
soc/qcom/qcom_gsbi.c:	.array = crci_msm8660,
soc/qcom/qcom_gsbi.c:	{ .compatible = "qcom,tcsr-msm8960", .data = &config_msm8960},
soc/qcom/qcom_gsbi.c:	{ .compatible = "qcom,tcsr-msm8660", .data = &config_msm8660},
soc/qcom/qcom_ipcc.c:static int msm_ipcc_suspend(void)
soc/qcom/qcom_ipcc.c:static void msm_ipcc_resume(void)
soc/qcom/qcom_ipcc.c:#define msm_ipcc_suspend NULL
soc/qcom/qcom_ipcc.c:#define msm_ipcc_resume NULL
soc/qcom/qcom_ipcc.c:static struct syscore_ops msm_ipcc_pm_ops = {
soc/qcom/qcom_ipcc.c:	.suspend = msm_ipcc_suspend,
soc/qcom/qcom_ipcc.c:	.resume = msm_ipcc_resume,
soc/qcom/qcom_ipcc.c:	register_syscore_ops(&msm_ipcc_pm_ops);
soc/qcom/qcom_ipcc.c:	unregister_syscore_ops(&msm_ipcc_pm_ops);
soc/qcom/rpm-smd-debug.c:	struct msm_rpm_request *req;
soc/qcom/rpm-smd-debug.c:	req = msm_rpm_create_request(set, rsc_type, rsc_id, nelems);
soc/qcom/rpm-smd-debug.c:		if (msm_rpm_add_kvp_data(req, key,
soc/qcom/rpm-smd-debug.c:	if (msm_rpm_wait_for_ack(msm_rpm_send_request(req)))
soc/qcom/rpm-smd-debug.c:	msm_rpm_free_request(req);
soc/qcom/rpm_master_stat.c:struct msm_rpm_master_stats_platform_data {
soc/qcom/rpm_master_stat.c:static DEFINE_MUTEX(msm_rpm_master_stats_mutex);
soc/qcom/rpm_master_stat.c:struct msm_rpm_master_stats {
soc/qcom/rpm_master_stat.c:struct msm_rpm_master_stats_private_data {
soc/qcom/rpm_master_stat.c:	struct msm_rpm_master_stats_platform_data *platform_data;
soc/qcom/rpm_master_stat.c:static int msm_rpm_master_stats_file_close(struct inode *inode,
soc/qcom/rpm_master_stat.c:	struct msm_rpm_master_stats_private_data *private = file->private_data;
soc/qcom/rpm_master_stat.c:	mutex_lock(&msm_rpm_master_stats_mutex);
soc/qcom/rpm_master_stat.c:	mutex_unlock(&msm_rpm_master_stats_mutex);
soc/qcom/rpm_master_stat.c:static int msm_rpm_master_copy_stats(
soc/qcom/rpm_master_stat.c:		struct msm_rpm_master_stats_private_data *prvdata)
soc/qcom/rpm_master_stat.c:	struct msm_rpm_master_stats record;
soc/qcom/rpm_master_stat.c:	struct msm_rpm_master_stats_platform_data *pdata;
soc/qcom/rpm_master_stat.c:			offsetof(struct msm_rpm_master_stats, shutdown_req)));
soc/qcom/rpm_master_stat.c:			offsetof(struct msm_rpm_master_stats, wakeup_ind)));
soc/qcom/rpm_master_stat.c:			offsetof(struct msm_rpm_master_stats, bringup_req)));
soc/qcom/rpm_master_stat.c:			offsetof(struct msm_rpm_master_stats, bringup_ack)));
soc/qcom/rpm_master_stat.c:			offsetof(struct msm_rpm_master_stats,
soc/qcom/rpm_master_stat.c:			offsetof(struct msm_rpm_master_stats,
soc/qcom/rpm_master_stat.c:				offsetof(struct msm_rpm_master_stats,
soc/qcom/rpm_master_stat.c:				offsetof(struct msm_rpm_master_stats,
soc/qcom/rpm_master_stat.c:				offsetof(struct msm_rpm_master_stats,
soc/qcom/rpm_master_stat.c:				offsetof(struct msm_rpm_master_stats,
soc/qcom/rpm_master_stat.c:					offsetof(struct msm_rpm_master_stats,
soc/qcom/rpm_master_stat.c:			 offsetof(struct msm_rpm_master_stats, numshutdowns)));
soc/qcom/rpm_master_stat.c:			offsetof(struct msm_rpm_master_stats, active_cores));
soc/qcom/rpm_master_stat.c:static ssize_t msm_rpm_master_stats_file_read(struct file *file,
soc/qcom/rpm_master_stat.c:	struct msm_rpm_master_stats_private_data *prvdata;
soc/qcom/rpm_master_stat.c:	struct msm_rpm_master_stats_platform_data *pdata;
soc/qcom/rpm_master_stat.c:	mutex_lock(&msm_rpm_master_stats_mutex);
soc/qcom/rpm_master_stat.c:		prvdata->len = msm_rpm_master_copy_stats(prvdata);
soc/qcom/rpm_master_stat.c:	mutex_unlock(&msm_rpm_master_stats_mutex);
soc/qcom/rpm_master_stat.c:static int msm_rpm_master_stats_file_open(struct inode *inode,
soc/qcom/rpm_master_stat.c:	struct msm_rpm_master_stats_private_data *prvdata;
soc/qcom/rpm_master_stat.c:	struct msm_rpm_master_stats_platform_data *pdata;
soc/qcom/rpm_master_stat.c:	mutex_lock(&msm_rpm_master_stats_mutex);
soc/qcom/rpm_master_stat.c:		kzalloc(sizeof(struct msm_rpm_master_stats_private_data),
soc/qcom/rpm_master_stat.c:	mutex_unlock(&msm_rpm_master_stats_mutex);
soc/qcom/rpm_master_stat.c:static const struct file_operations msm_rpm_master_stats_fops = {
soc/qcom/rpm_master_stat.c:	.open	  = msm_rpm_master_stats_file_open,
soc/qcom/rpm_master_stat.c:	.read	  = msm_rpm_master_stats_file_read,
soc/qcom/rpm_master_stat.c:	.release  = msm_rpm_master_stats_file_close,
soc/qcom/rpm_master_stat.c:static struct msm_rpm_master_stats_platform_data
soc/qcom/rpm_master_stat.c:			*msm_rpm_master_populate_pdata(struct device *dev)
soc/qcom/rpm_master_stat.c:	struct msm_rpm_master_stats_platform_data *pdata;
soc/qcom/rpm_master_stat.c:static  int msm_rpm_master_stats_probe(struct platform_device *pdev)
soc/qcom/rpm_master_stat.c:	struct msm_rpm_master_stats_platform_data *pdata;
soc/qcom/rpm_master_stat.c:		pdata = msm_rpm_master_populate_pdata(&pdev->dev);
soc/qcom/rpm_master_stat.c:					pdata, &msm_rpm_master_stats_fops);
soc/qcom/rpm_master_stat.c:static int msm_rpm_master_stats_remove(struct platform_device *pdev)
soc/qcom/rpm_master_stat.c:static struct platform_driver msm_rpm_master_stats_driver = {
soc/qcom/rpm_master_stat.c:	.probe	= msm_rpm_master_stats_probe,
soc/qcom/rpm_master_stat.c:	.remove = msm_rpm_master_stats_remove,
soc/qcom/rpm_master_stat.c:		.name = "msm_rpm_master_stats",
soc/qcom/rpm_master_stat.c:static int __init msm_rpm_master_stats_init(void)
soc/qcom/rpm_master_stat.c:	return platform_driver_register(&msm_rpm_master_stats_driver);
soc/qcom/rpm_master_stat.c:static void __exit msm_rpm_master_stats_exit(void)
soc/qcom/rpm_master_stat.c:	platform_driver_unregister(&msm_rpm_master_stats_driver);
soc/qcom/rpm_master_stat.c:module_init(msm_rpm_master_stats_init);
soc/qcom/rpm_master_stat.c:module_exit(msm_rpm_master_stats_exit);
soc/qcom/rpm_master_stat.c:MODULE_ALIAS("platform:msm_master_stat_log");
soc/qcom/rpm_stats.c:	(container_of(attr, struct msm_rpmstats_kobj_attr, ka)->pd)
soc/qcom/rpm_stats.c:struct msm_rpmstats_record {
soc/qcom/rpm_stats.c:struct msm_rpmstats_platform_data {
soc/qcom/rpm_stats.c:struct msm_rpmstats_private_data {
soc/qcom/rpm_stats.c:	struct msm_rpmstats_platform_data *platform_data;
soc/qcom/rpm_stats.c:struct msm_rpm_stats_data {
soc/qcom/rpm_stats.c:struct msm_rpmstats_kobj_attr {
soc/qcom/rpm_stats.c:	struct msm_rpmstats_platform_data *pd;
soc/qcom/rpm_stats.c:static inline int msm_rpmstats_append_data_to_buf(char *buf,
soc/qcom/rpm_stats.c:		struct msm_rpm_stats_data *data, int buflength)
soc/qcom/rpm_stats.c:static inline u32 msm_rpmstats_read_long_register(void __iomem *regbase,
soc/qcom/rpm_stats.c:			index * sizeof(struct msm_rpm_stats_data));
soc/qcom/rpm_stats.c:static inline u64 msm_rpmstats_read_quad_register(void __iomem *regbase,
soc/qcom/rpm_stats.c:		regbase + offset + index * sizeof(struct msm_rpm_stats_data),
soc/qcom/rpm_stats.c:static inline int msm_rpmstats_copy_stats(
soc/qcom/rpm_stats.c:			struct msm_rpmstats_private_data *prvdata)
soc/qcom/rpm_stats.c:	struct msm_rpm_stats_data data;
soc/qcom/rpm_stats.c:		data.stat_type = msm_rpmstats_read_long_register(reg, i,
soc/qcom/rpm_stats.c:				offsetof(struct msm_rpm_stats_data,
soc/qcom/rpm_stats.c:		data.count = msm_rpmstats_read_long_register(reg, i,
soc/qcom/rpm_stats.c:				offsetof(struct msm_rpm_stats_data, count));
soc/qcom/rpm_stats.c:		data.last_entered_at = msm_rpmstats_read_quad_register(reg,
soc/qcom/rpm_stats.c:				i, offsetof(struct msm_rpm_stats_data,
soc/qcom/rpm_stats.c:		data.last_exited_at = msm_rpmstats_read_quad_register(reg,
soc/qcom/rpm_stats.c:				i, offsetof(struct msm_rpm_stats_data,
soc/qcom/rpm_stats.c:		data.accumulated = msm_rpmstats_read_quad_register(reg,
soc/qcom/rpm_stats.c:				i, offsetof(struct msm_rpm_stats_data,
soc/qcom/rpm_stats.c:		data.client_votes = msm_rpmstats_read_long_register(reg,
soc/qcom/rpm_stats.c:				i, offsetof(struct msm_rpm_stats_data,
soc/qcom/rpm_stats.c:		length += msm_rpmstats_append_data_to_buf(prvdata->buf + length,
soc/qcom/rpm_stats.c:	struct msm_rpmstats_private_data prvdata;
soc/qcom/rpm_stats.c:	struct msm_rpmstats_platform_data *pdata = NULL;
soc/qcom/rpm_stats.c:		prvdata.len = msm_rpmstats_copy_stats(&prvdata);
soc/qcom/rpm_stats.c:static int msm_rpmstats_create_sysfs(struct platform_device *pdev,
soc/qcom/rpm_stats.c:				struct msm_rpmstats_platform_data *pd)
soc/qcom/rpm_stats.c:	struct msm_rpmstats_kobj_attr *rpms_ka = NULL;
soc/qcom/rpm_stats.c:static int msm_rpmstats_probe(struct platform_device *pdev)
soc/qcom/rpm_stats.c:	struct msm_rpmstats_platform_data *pdata;
soc/qcom/rpm_stats.c:	msm_rpmstats_create_sysfs(pdev, pdata);
soc/qcom/rpm_stats.c:static int msm_rpmstats_remove(struct platform_device *pdev)
soc/qcom/rpm_stats.c:	struct msm_rpmstats_kobj_attr *rpms_ka;
soc/qcom/rpm_stats.c:	rpms_ka = (struct msm_rpmstats_kobj_attr *)
soc/qcom/rpm_stats.c:static struct platform_driver msm_rpmstats_driver = {
soc/qcom/rpm_stats.c:	.probe = msm_rpmstats_probe,
soc/qcom/rpm_stats.c:	.remove = msm_rpmstats_remove,
soc/qcom/rpm_stats.c:		.name = "msm_rpm_stat",
soc/qcom/rpm_stats.c:builtin_platform_driver(msm_rpmstats_driver);
soc/qcom/rpmh_master_stat.c:struct msm_rpmh_master_data {
soc/qcom/rpmh_master_stat.c:static const struct msm_rpmh_master_data rpmh_masters[] = {
soc/qcom/rpmh_master_stat.c:struct msm_rpmh_master_stats {
soc/qcom/rpmh_master_stat.c:struct msm_rpmh_profile_unit {
soc/qcom/rpmh_master_stat.c:static struct msm_rpmh_master_stats apss_master_stats;
soc/qcom/rpmh_master_stat.c:static ssize_t msm_rpmh_master_stats_print_data(char *prvbuf, ssize_t length,
soc/qcom/rpmh_master_stat.c:				struct msm_rpmh_master_stats *record,
soc/qcom/rpmh_master_stat.c:static ssize_t msm_rpmh_master_stats_show(struct kobject *kobj,
soc/qcom/rpmh_master_stat.c:	struct msm_rpmh_master_stats *record = NULL;
soc/qcom/rpmh_master_stat.c:	length = msm_rpmh_master_stats_print_data(buf, PAGE_SIZE,
soc/qcom/rpmh_master_stat.c:		record = (struct msm_rpmh_master_stats *) qcom_smem_get(
soc/qcom/rpmh_master_stat.c:			length += msm_rpmh_master_stats_print_data(
soc/qcom/rpmh_master_stat.c:static inline void msm_rpmh_apss_master_stats_update(
soc/qcom/rpmh_master_stat.c:				struct msm_rpmh_profile_unit *profile_unit)
soc/qcom/rpmh_master_stat.c:void msm_rpmh_master_stats_update(void)
soc/qcom/rpmh_master_stat.c:	struct msm_rpmh_profile_unit profile_unit[NUM_UNIT];
soc/qcom/rpmh_master_stat.c:	msm_rpmh_apss_master_stats_update(profile_unit);
soc/qcom/rpmh_master_stat.c:EXPORT_SYMBOL(msm_rpmh_master_stats_update);
soc/qcom/rpmh_master_stat.c:static int msm_rpmh_master_stats_probe(struct platform_device *pdev)
soc/qcom/rpmh_master_stat.c:	prvdata->ka.show = msm_rpmh_master_stats_show;
soc/qcom/rpmh_master_stat.c:static int msm_rpmh_master_stats_remove(struct platform_device *pdev)
soc/qcom/rpmh_master_stat.c:static struct platform_driver msm_rpmh_master_stats_driver = {
soc/qcom/rpmh_master_stat.c:	.probe	= msm_rpmh_master_stats_probe,
soc/qcom/rpmh_master_stat.c:	.remove = msm_rpmh_master_stats_remove,
soc/qcom/rpmh_master_stat.c:		.name = "msm_rpmh_master_stats",
soc/qcom/rpmh_master_stat.c:module_platform_driver(msm_rpmh_master_stats_driver);
soc/qcom/rpmh_master_stat.c:MODULE_ALIAS("platform:msm_rpmh_master_stat_log");
soc/qcom/rpmh_master_stat.h:void msm_rpmh_master_stats_update(void);
soc/qcom/rpmh_master_stat.h:static inline void msm_rpmh_master_stats_update(void) {}
soc/qcom/rq_stats.c:static int __init msm_rq_stats_init(void)
soc/qcom/rq_stats.c:late_initcall(msm_rq_stats_init);
soc/qcom/secure_buffer.c:int msm_secure_table(struct sg_table *table)
soc/qcom/secure_buffer.c:int msm_unsecure_table(struct sg_table *table)
soc/qcom/secure_buffer.c:const char *msm_secure_vmid_to_string(int secure_vmid)
soc/qcom/secure_buffer.c:bool msm_secure_v2_is_supported(void)
soc/qcom/secure_buffer.c:u32 msm_secure_get_vmid_perms(u32 vmid)
soc/qcom/secure_buffer.c:EXPORT_SYMBOL(msm_secure_get_vmid_perms);
soc/qcom/smd-rpm.c:	{ .compatible = "qcom,rpm-msm8916" },
soc/qcom/smd-rpm.c:	{ .compatible = "qcom,rpm-msm8974" },
soc/qcom/smd-rpm.c:	{ .compatible = "qcom,rpm-msm8996" },
soc/qcom/smd-rpm.c:	{ .compatible = "qcom,rpm-msm8998" },
soc/qcom/smsm.c:struct smsm_entry;
soc/qcom/smsm.c:struct smsm_host;
soc/qcom/smsm.c: * struct qcom_smsm - smsm driver context
soc/qcom/smsm.c: * @dev:	smsm device pointer
soc/qcom/smsm.c:struct qcom_smsm {
soc/qcom/smsm.c:	struct smsm_entry *entries;
soc/qcom/smsm.c:	struct smsm_host *hosts;
soc/qcom/smsm.c: * struct smsm_entry - per remote processor entry context
soc/qcom/smsm.c: * @smsm:	back-reference to driver context
soc/qcom/smsm.c:struct smsm_entry {
soc/qcom/smsm.c:	struct qcom_smsm *smsm;
soc/qcom/smsm.c: * struct smsm_host - representation of a remote host
soc/qcom/smsm.c:struct smsm_host {
soc/qcom/smsm.c: * smsm_update_bits() - change bit in outgoing entry and inform subscribers
soc/qcom/smsm.c: * @data:	smsm context pointer
soc/qcom/smsm.c:static int smsm_update_bits(void *data, u32 mask, u32 value)
soc/qcom/smsm.c:	struct qcom_smsm *smsm = data;
soc/qcom/smsm.c:	struct smsm_host *hostp;
soc/qcom/smsm.c:	spin_lock_irqsave(&smsm->lock, flags);
soc/qcom/smsm.c:	val = orig = readl(smsm->local_state);
soc/qcom/smsm.c:		spin_unlock_irqrestore(&smsm->lock, flags);
soc/qcom/smsm.c:	writel(val, smsm->local_state);
soc/qcom/smsm.c:	spin_unlock_irqrestore(&smsm->lock, flags);
soc/qcom/smsm.c:	for (host = 0; host < smsm->num_hosts; host++) {
soc/qcom/smsm.c:		hostp = &smsm->hosts[host];
soc/qcom/smsm.c:		val = readl(smsm->subscription + host);
soc/qcom/smsm.c:static const struct qcom_smem_state_ops smsm_state_ops = {
soc/qcom/smsm.c:	.update_bits = smsm_update_bits,
soc/qcom/smsm.c: * smsm_intr() - cascading IRQ handler for SMSM
soc/qcom/smsm.c:static irqreturn_t smsm_intr(int irq, void *data)
soc/qcom/smsm.c:	struct smsm_entry *entry = data;
soc/qcom/smsm.c: * smsm_mask_irq() - un-subscribe from cascades of IRQs of a certain staus bit
soc/qcom/smsm.c:static void smsm_mask_irq(struct irq_data *irqd)
soc/qcom/smsm.c:	struct smsm_entry *entry = irq_data_get_irq_chip_data(irqd);
soc/qcom/smsm.c:	struct qcom_smsm *smsm = entry->smsm;
soc/qcom/smsm.c:		val = readl(entry->subscription + smsm->local_host);
soc/qcom/smsm.c:		writel(val, entry->subscription + smsm->local_host);
soc/qcom/smsm.c: * smsm_unmask_irq() - subscribe to cascades of IRQs of a certain status bit
soc/qcom/smsm.c:static void smsm_unmask_irq(struct irq_data *irqd)
soc/qcom/smsm.c:	struct smsm_entry *entry = irq_data_get_irq_chip_data(irqd);
soc/qcom/smsm.c:	struct qcom_smsm *smsm = entry->smsm;
soc/qcom/smsm.c:		val = readl(entry->subscription + smsm->local_host);
soc/qcom/smsm.c:		writel(val, entry->subscription + smsm->local_host);
soc/qcom/smsm.c: * smsm_set_irq_type() - updates the requested IRQ type for the cascading
soc/qcom/smsm.c:static int smsm_set_irq_type(struct irq_data *irqd, unsigned int type)
soc/qcom/smsm.c:	struct smsm_entry *entry = irq_data_get_irq_chip_data(irqd);
soc/qcom/smsm.c:static struct irq_chip smsm_irq_chip = {
soc/qcom/smsm.c:	.name           = "smsm",
soc/qcom/smsm.c:	.irq_mask       = smsm_mask_irq,
soc/qcom/smsm.c:	.irq_unmask     = smsm_unmask_irq,
soc/qcom/smsm.c:	.irq_set_type	= smsm_set_irq_type,
soc/qcom/smsm.c: * smsm_irq_map() - sets up a mapping for a cascaded IRQ
soc/qcom/smsm.c:static int smsm_irq_map(struct irq_domain *d,
soc/qcom/smsm.c:	struct smsm_entry *entry = d->host_data;
soc/qcom/smsm.c:	irq_set_chip_and_handler(irq, &smsm_irq_chip, handle_level_irq);
soc/qcom/smsm.c:	irq_set_parent(irq, entry->smsm->irq);
soc/qcom/smsm.c:static const struct irq_domain_ops smsm_irq_ops = {
soc/qcom/smsm.c:	.map = smsm_irq_map,
soc/qcom/smsm.c: * smsm_parse_ipc() - parses a qcom,ipc-%d device tree property
soc/qcom/smsm.c: * @smsm:	smsm driver context
soc/qcom/smsm.c:static int smsm_parse_ipc(struct qcom_smsm *smsm, unsigned host_id)
soc/qcom/smsm.c:	struct device_node *node = smsm->dev->of_node;
soc/qcom/smsm.c:	struct smsm_host *host = &smsm->hosts[host_id];
soc/qcom/smsm.c:		dev_err(smsm->dev, "no offset in %s\n", key);
soc/qcom/smsm.c:		dev_err(smsm->dev, "no bit in %s\n", key);
soc/qcom/smsm.c: * smsm_inbound_entry() - parse DT and set up an entry representing a remote system
soc/qcom/smsm.c: * @smsm:	smsm driver context
soc/qcom/smsm.c:static int smsm_inbound_entry(struct qcom_smsm *smsm,
soc/qcom/smsm.c:			      struct smsm_entry *entry,
soc/qcom/smsm.c:	smsm->irq = irq_of_parse_and_map(node, 0);
soc/qcom/smsm.c:	if (!smsm->irq) {
soc/qcom/smsm.c:		dev_err(smsm->dev, "failed to parse smsm interrupt\n");
soc/qcom/smsm.c:	ret = devm_request_threaded_irq(smsm->dev, smsm->irq,
soc/qcom/smsm.c:					NULL, smsm_intr,
soc/qcom/smsm.c:					"smsm", (void *)entry);
soc/qcom/smsm.c:		dev_err(smsm->dev, "failed to request interrupt\n");
soc/qcom/smsm.c:	entry->domain = irq_domain_add_linear(node, 32, &smsm_irq_ops, entry);
soc/qcom/smsm.c:		dev_err(smsm->dev, "failed to add irq_domain\n");
soc/qcom/smsm.c: * smsm_get_size_info() - parse the optional memory segment for sizes
soc/qcom/smsm.c: * @smsm:	smsm driver context
soc/qcom/smsm.c:static int smsm_get_size_info(struct qcom_smsm *smsm)
soc/qcom/smsm.c:			dev_err(smsm->dev, "unable to retrieve smsm size info\n");
soc/qcom/smsm.c:		dev_warn(smsm->dev, "no smsm size info, using defaults\n");
soc/qcom/smsm.c:		smsm->num_entries = SMSM_DEFAULT_NUM_ENTRIES;
soc/qcom/smsm.c:		smsm->num_hosts = SMSM_DEFAULT_NUM_HOSTS;
soc/qcom/smsm.c:	smsm->num_entries = info->num_entries;
soc/qcom/smsm.c:	smsm->num_hosts = info->num_hosts;
soc/qcom/smsm.c:	dev_dbg(smsm->dev,
soc/qcom/smsm.c:		"found custom size of smsm: %d entries %d hosts\n",
soc/qcom/smsm.c:		smsm->num_entries, smsm->num_hosts);
soc/qcom/smsm.c:static int qcom_smsm_probe(struct platform_device *pdev)
soc/qcom/smsm.c:	struct smsm_entry *entry;
soc/qcom/smsm.c:	struct qcom_smsm *smsm;
soc/qcom/smsm.c:	smsm = devm_kzalloc(&pdev->dev, sizeof(*smsm), GFP_KERNEL);
soc/qcom/smsm.c:	if (!smsm)
soc/qcom/smsm.c:	smsm->dev = &pdev->dev;
soc/qcom/smsm.c:	spin_lock_init(&smsm->lock);
soc/qcom/smsm.c:	ret = smsm_get_size_info(smsm);
soc/qcom/smsm.c:	smsm->entries = devm_kcalloc(&pdev->dev,
soc/qcom/smsm.c:				     smsm->num_entries,
soc/qcom/smsm.c:				     sizeof(struct smsm_entry),
soc/qcom/smsm.c:	if (!smsm->entries)
soc/qcom/smsm.c:	smsm->hosts = devm_kcalloc(&pdev->dev,
soc/qcom/smsm.c:				   smsm->num_hosts,
soc/qcom/smsm.c:				   sizeof(struct smsm_host),
soc/qcom/smsm.c:	if (!smsm->hosts)
soc/qcom/smsm.c:			     &smsm->local_host);
soc/qcom/smsm.c:	for (id = 0; id < smsm->num_hosts; id++) {
soc/qcom/smsm.c:		ret = smsm_parse_ipc(smsm, id);
soc/qcom/smsm.c:			      smsm->num_entries * sizeof(u32));
soc/qcom/smsm.c:	size = smsm->num_entries * smsm->num_hosts * sizeof(u32);
soc/qcom/smsm.c:		dev_err(&pdev->dev, "unable to allocate smsm interrupt mask\n");
soc/qcom/smsm.c:	smsm->local_state = states + smsm->local_host;
soc/qcom/smsm.c:	smsm->subscription = intr_mask + smsm->local_host * smsm->num_hosts;
soc/qcom/smsm.c:	smsm->state = qcom_smem_state_register(local_node, &smsm_state_ops, smsm);
soc/qcom/smsm.c:	if (IS_ERR(smsm->state)) {
soc/qcom/smsm.c:		dev_err(smsm->dev, "failed to register qcom_smem_state\n");
soc/qcom/smsm.c:		ret = PTR_ERR(smsm->state);
soc/qcom/smsm.c:		if (ret || id >= smsm->num_entries) {
soc/qcom/smsm.c:		entry = &smsm->entries[id];
soc/qcom/smsm.c:		entry->smsm = smsm;
soc/qcom/smsm.c:		entry->subscription = intr_mask + id * smsm->num_hosts;
soc/qcom/smsm.c:		writel(0, entry->subscription + smsm->local_host);
soc/qcom/smsm.c:		ret = smsm_inbound_entry(smsm, entry, node);
soc/qcom/smsm.c:	platform_set_drvdata(pdev, smsm);
soc/qcom/smsm.c:	for (id = 0; id < smsm->num_entries; id++)
soc/qcom/smsm.c:		if (smsm->entries[id].domain)
soc/qcom/smsm.c:			irq_domain_remove(smsm->entries[id].domain);
soc/qcom/smsm.c:	qcom_smem_state_unregister(smsm->state);
soc/qcom/smsm.c:static int qcom_smsm_remove(struct platform_device *pdev)
soc/qcom/smsm.c:	struct qcom_smsm *smsm = platform_get_drvdata(pdev);
soc/qcom/smsm.c:	for (id = 0; id < smsm->num_entries; id++)
soc/qcom/smsm.c:		if (smsm->entries[id].domain)
soc/qcom/smsm.c:			irq_domain_remove(smsm->entries[id].domain);
soc/qcom/smsm.c:	qcom_smem_state_unregister(smsm->state);
soc/qcom/smsm.c:static const struct of_device_id qcom_smsm_of_match[] = {
soc/qcom/smsm.c:	{ .compatible = "qcom,smsm" },
soc/qcom/smsm.c:MODULE_DEVICE_TABLE(of, qcom_smsm_of_match);
soc/qcom/smsm.c:static struct platform_driver qcom_smsm_driver = {
soc/qcom/smsm.c:	.probe = qcom_smsm_probe,
soc/qcom/smsm.c:	.remove = qcom_smsm_remove,
soc/qcom/smsm.c:		.name  = "qcom-smsm",
soc/qcom/smsm.c:		.of_match_table = qcom_smsm_of_match,
soc/qcom/smsm.c:module_platform_driver(qcom_smsm_driver);
soc/qcom/socinfo.c:static struct msm_soc_info cpu_of_id[] = {
soc/qcom/socinfo.c:static enum msm_cpu cur_cpu;
soc/qcom/socinfo.c:static char *msm_read_hardware_id(void)
soc/qcom/socinfo.c:	static char msm_soc_str[256] = "Qualcomm Technologies, Inc ";
soc/qcom/socinfo.c:		return msm_soc_str;
soc/qcom/socinfo.c:	ret = strlcat(msm_soc_str, cpu_of_id[socinfo->v0_1.id].soc_id_string,
soc/qcom/socinfo.c:			sizeof(msm_soc_str));
soc/qcom/socinfo.c:	if (ret > sizeof(msm_soc_str))
soc/qcom/socinfo.c:	return msm_soc_str;
soc/qcom/socinfo.c:	static char msm_machine_name[256] = "Qualcomm Technologies, Inc. ";
soc/qcom/socinfo.c:		return msm_machine_name;
soc/qcom/socinfo.c:	len = strlen(msm_machine_name);
soc/qcom/socinfo.c:				"qcom,msm-name", NULL);
soc/qcom/socinfo.c:		len += snprintf(msm_machine_name + len,
soc/qcom/socinfo.c:					sizeof(msm_machine_name) - len,
soc/qcom/socinfo.c:		len += snprintf(msm_machine_name + len,
soc/qcom/socinfo.c:					sizeof(msm_machine_name) - len,
soc/qcom/socinfo.c:		len += snprintf(msm_machine_name + len,
soc/qcom/socinfo.c:					sizeof(msm_machine_name) - len,
soc/qcom/socinfo.c:		len += snprintf(msm_machine_name + len,
soc/qcom/socinfo.c:					sizeof(msm_machine_name) - len,
soc/qcom/socinfo.c:		len += snprintf(msm_machine_name + len,
soc/qcom/socinfo.c:					sizeof(msm_machine_name) - len,
soc/qcom/socinfo.c:	return msm_machine_name;
soc/qcom/socinfo.c:enum msm_cpu socinfo_get_msm_cpu(void)
soc/qcom/socinfo.c:EXPORT_SYMBOL(socinfo_get_msm_cpu);
soc/qcom/socinfo.c:msm_get_vendor(struct device *dev,
soc/qcom/socinfo.c:msm_get_raw_id(struct device *dev,
soc/qcom/socinfo.c:msm_get_raw_version(struct device *dev,
soc/qcom/socinfo.c:msm_get_build_id(struct device *dev,
soc/qcom/socinfo.c:msm_get_hw_platform(struct device *dev,
soc/qcom/socinfo.c:msm_get_platform_version(struct device *dev,
soc/qcom/socinfo.c:msm_get_accessory_chip(struct device *dev,
soc/qcom/socinfo.c:msm_get_platform_subtype(struct device *dev,
soc/qcom/socinfo.c:msm_get_platform_subtype_id(struct device *dev,
soc/qcom/socinfo.c:msm_get_foundry_id(struct device *dev,
soc/qcom/socinfo.c:msm_get_serial_number(struct device *dev,
soc/qcom/socinfo.c:msm_get_chip_family(struct device *dev,
soc/qcom/socinfo.c:msm_get_raw_device_family(struct device *dev,
soc/qcom/socinfo.c:msm_get_raw_device_number(struct device *dev,
soc/qcom/socinfo.c:msm_get_chip_name(struct device *dev,
soc/qcom/socinfo.c:msm_get_nproduct_id(struct device *dev,
soc/qcom/socinfo.c:msm_get_num_clusters(struct device *dev,
soc/qcom/socinfo.c:msm_get_ncluster_array_offset(struct device *dev,
soc/qcom/socinfo.c:msm_get_num_defective_parts(struct device *dev,
soc/qcom/socinfo.c:msm_get_ndefective_parts_array_offset(struct device *dev,
soc/qcom/socinfo.c:msm_get_nmodem_supported(struct device *dev,
soc/qcom/socinfo.c:msm_get_pmic_model(struct device *dev,
soc/qcom/socinfo.c:msm_get_pmic_die_revision(struct device *dev,
soc/qcom/socinfo.c:msm_get_image_version(struct device *dev,
soc/qcom/socinfo.c:msm_set_image_version(struct device *dev,
soc/qcom/socinfo.c:msm_get_image_variant(struct device *dev,
soc/qcom/socinfo.c:msm_set_image_variant(struct device *dev,
soc/qcom/socinfo.c:msm_get_image_crm_version(struct device *dev,
soc/qcom/socinfo.c:msm_set_image_crm_version(struct device *dev,
soc/qcom/socinfo.c:msm_get_image_number(struct device *dev,
soc/qcom/socinfo.c:msm_select_image(struct device *dev, struct device_attribute *attr,
soc/qcom/socinfo.c:msm_get_images(struct device *dev,
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_raw_version =
soc/qcom/socinfo.c:	__ATTR(raw_version, 0444, msm_get_raw_version,  NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_raw_id =
soc/qcom/socinfo.c:	__ATTR(raw_id, 0444, msm_get_raw_id,  NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_vendor =
soc/qcom/socinfo.c:	__ATTR(vendor, 0444, msm_get_vendor,  NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_build_id =
soc/qcom/socinfo.c:	__ATTR(build_id, 0444, msm_get_build_id, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_hw_platform =
soc/qcom/socinfo.c:	__ATTR(hw_platform, 0444, msm_get_hw_platform, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_platform_version =
soc/qcom/socinfo.c:			msm_get_platform_version, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_accessory_chip =
soc/qcom/socinfo.c:			msm_get_accessory_chip, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_platform_subtype =
soc/qcom/socinfo.c:			msm_get_platform_subtype, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_platform_subtype_id =
soc/qcom/socinfo.c:			msm_get_platform_subtype_id, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_foundry_id =
soc/qcom/socinfo.c:			msm_get_foundry_id, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_serial_number =
soc/qcom/socinfo.c:			msm_get_serial_number, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_chip_family =
soc/qcom/socinfo.c:			msm_get_chip_family, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_raw_device_family =
soc/qcom/socinfo.c:			msm_get_raw_device_family, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_raw_device_number =
soc/qcom/socinfo.c:			msm_get_raw_device_number, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_chip_name =
soc/qcom/socinfo.c:			msm_get_chip_name, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_nproduct_id =
soc/qcom/socinfo.c:			msm_get_nproduct_id, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_num_clusters =
soc/qcom/socinfo.c:			msm_get_num_clusters, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_ncluster_array_offset =
soc/qcom/socinfo.c:			msm_get_ncluster_array_offset, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_num_defective_parts =
soc/qcom/socinfo.c:			msm_get_num_defective_parts, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_ndefective_parts_array_offset =
soc/qcom/socinfo.c:			msm_get_ndefective_parts_array_offset, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_nmodem_supported =
soc/qcom/socinfo.c:			msm_get_nmodem_supported, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_pmic_model =
soc/qcom/socinfo.c:			msm_get_pmic_model, NULL);
soc/qcom/socinfo.c:static struct device_attribute msm_soc_attr_pmic_die_revision =
soc/qcom/socinfo.c:			msm_get_pmic_die_revision, NULL);
soc/qcom/socinfo.c:			msm_get_image_version, msm_set_image_version);
soc/qcom/socinfo.c:			msm_get_image_variant, msm_set_image_variant);
soc/qcom/socinfo.c:			msm_get_image_crm_version, msm_set_image_crm_version);
soc/qcom/socinfo.c:			msm_get_image_number, msm_select_image);
soc/qcom/socinfo.c:	__ATTR(images, 0444, msm_get_images, NULL);
soc/qcom/socinfo.c:	} else if (early_machine_is_msm8916()) {
soc/qcom/socinfo.c:		strlcpy(dummy_socinfo.build_id, "msm8916 - ",
soc/qcom/socinfo.c:	} else if (early_machine_is_msm8996()) {
soc/qcom/socinfo.c:		strlcpy(dummy_socinfo.build_id, "msm8996 - ",
soc/qcom/socinfo.c:	} else if (early_machine_is_msm8996_auto()) {
soc/qcom/socinfo.c:		strlcpy(dummy_socinfo.build_id, "msm8996-auto - ",
soc/qcom/socinfo.c:	} else if (early_machine_is_msm8937()) {
soc/qcom/socinfo.c:		strlcpy(dummy_socinfo.build_id, "msm8937 - ",
soc/qcom/socinfo.c:	} else if (early_machine_is_msm8917()) {
soc/qcom/socinfo.c:		strlcpy(dummy_socinfo.build_id, "msm8917 - ",
soc/qcom/socinfo.c:	} else if (early_machine_is_msm8953()) {
soc/qcom/socinfo.c:		strlcpy(dummy_socinfo.build_id, "msm8953 - ",
soc/qcom/socinfo.c:static void __init populate_soc_sysfs_files(struct device *msm_soc_device)
soc/qcom/socinfo.c:	device_create_file(msm_soc_device, &msm_soc_attr_vendor);
soc/qcom/socinfo.c:	device_create_file(msm_soc_device, &image_version);
soc/qcom/socinfo.c:	device_create_file(msm_soc_device, &image_variant);
soc/qcom/socinfo.c:	device_create_file(msm_soc_device, &image_crm_version);
soc/qcom/socinfo.c:	device_create_file(msm_soc_device, &select_image);
soc/qcom/socinfo.c:	device_create_file(msm_soc_device, &images);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_nmodem_supported);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_num_clusters);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_ncluster_array_offset);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_num_defective_parts);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:				&msm_soc_attr_ndefective_parts_array_offset);
soc/qcom/socinfo.c:		 device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_nproduct_id);
soc/qcom/socinfo.c:		 device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_chip_name);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_chip_family);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_raw_device_family);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_raw_device_number);
soc/qcom/socinfo.c:		 device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_serial_number);
soc/qcom/socinfo.c:		 device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_foundry_id);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_pmic_model);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_pmic_die_revision);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_platform_subtype);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_platform_subtype_id);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_accessory_chip);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_platform_version);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_hw_platform);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_raw_id);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_raw_version);
soc/qcom/socinfo.c:		device_create_file(msm_soc_device,
soc/qcom/socinfo.c:					&msm_soc_attr_build_id);
soc/qcom/socinfo.c:	struct device *msm_soc_device;
soc/qcom/socinfo.c:	msm_soc_device = soc_device_to_device(soc_dev);
soc/qcom/socinfo.c:	populate_soc_sysfs_files(msm_soc_device);
soc/qcom/socinfo.c:	arch_read_hardware_id = msm_read_hardware_id;
soc/qcom/spm.c:	{ .compatible = "qcom,msm8974-saw2-v2.1-cpu",
soc/qcom/spm_devices.c:struct msm_spm_power_modes {
soc/qcom/spm_devices.c:struct msm_spm_device {
soc/qcom/spm_devices.c:	struct msm_spm_driver_data reg_data;
soc/qcom/spm_devices.c:	struct msm_spm_power_modes *modes;
soc/qcom/spm_devices.c:struct msm_spm_vdd_info {
soc/qcom/spm_devices.c:	struct msm_spm_device *vctl_dev;
soc/qcom/spm_devices.c:static DEFINE_PER_CPU_SHARED_ALIGNED(struct msm_spm_device, msm_cpu_spm_device);
soc/qcom/spm_devices.c:static DEFINE_PER_CPU(struct msm_spm_device *, cpu_vctl_device);
soc/qcom/spm_devices.c:static void msm_spm_smp_set_vdd(void *data)
soc/qcom/spm_devices.c:	struct msm_spm_vdd_info *info = (struct msm_spm_vdd_info *)data;
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = info->vctl_dev;
soc/qcom/spm_devices.c:	info->err = msm_spm_drv_set_vdd(&dev->reg_data, info->vlevel);
soc/qcom/spm_devices.c: * msm_spm_probe_done(): Verify and return the status of the cpu(s) and l2
soc/qcom/spm_devices.c:int msm_spm_probe_done(void)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev;
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_probe_done);
soc/qcom/spm_devices.c:void msm_spm_dump_regs(unsigned int cpu)
soc/qcom/spm_devices.c:	dump_regs(&per_cpu(msm_cpu_spm_device, cpu).reg_data, cpu);
soc/qcom/spm_devices.c: * msm_spm_set_vdd(): Set core voltage
soc/qcom/spm_devices.c:int msm_spm_set_vdd(unsigned int cpu, unsigned int vlevel)
soc/qcom/spm_devices.c:	struct msm_spm_vdd_info info;
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = per_cpu(cpu_vctl_device, cpu);
soc/qcom/spm_devices.c:	ret = smp_call_function_any(&dev->mask, msm_spm_smp_set_vdd, &info,
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_set_vdd);
soc/qcom/spm_devices.c: * msm_spm_get_vdd(): Get core voltage
soc/qcom/spm_devices.c:int msm_spm_get_vdd(unsigned int cpu)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = per_cpu(cpu_vctl_device, cpu);
soc/qcom/spm_devices.c:	return msm_spm_drv_get_vdd(&dev->reg_data) ? : -EINVAL;
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_get_vdd);
soc/qcom/spm_devices.c:static void msm_spm_config_q2s(struct msm_spm_device *dev, unsigned int mode)
soc/qcom/spm_devices.c:static void msm_spm_config_hw_flush(struct msm_spm_device *dev,
soc/qcom/spm_devices.c:static void msm_spm_config_slpreq(struct msm_spm_device *dev,
soc/qcom/spm_devices.c:static int msm_spm_dev_set_low_power_mode(struct msm_spm_device *dev,
soc/qcom/spm_devices.c:		ret = msm_spm_drv_set_spm_enable(&dev->reg_data, false);
soc/qcom/spm_devices.c:			ret = msm_spm_drv_set_spm_enable(&dev->reg_data, true);
soc/qcom/spm_devices.c:		ret = msm_spm_drv_set_low_power_mode(&dev->reg_data, ctl);
soc/qcom/spm_devices.c:	msm_spm_config_q2s(dev, mode);
soc/qcom/spm_devices.c:	msm_spm_config_hw_flush(dev, mode);
soc/qcom/spm_devices.c:	msm_spm_config_slpreq(dev, mode);
soc/qcom/spm_devices.c:static int msm_spm_dev_init(struct msm_spm_device *dev,
soc/qcom/spm_devices.c:		struct msm_spm_platform_data *data)
soc/qcom/spm_devices.c:			dev->num_modes, sizeof(struct msm_spm_power_modes),
soc/qcom/spm_devices.c:	ret = msm_spm_drv_init(&dev->reg_data, data);
soc/qcom/spm_devices.c:		ret = msm_spm_drv_write_seq_data(&dev->reg_data,
soc/qcom/spm_devices.c:	msm_spm_drv_reinit(&dev->reg_data, dev->num_modes ? true : false);
soc/qcom/spm_devices.c: * msm_spm_turn_on_cpu_rail(): Power on cpu rail before turning on core
soc/qcom/spm_devices.c:int msm_spm_turn_on_cpu_rail(struct device_node *vctl_node,
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = per_cpu(cpu_vctl_device, cpu);
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_turn_on_cpu_rail);
soc/qcom/spm_devices.c:void msm_spm_reinit(void)
soc/qcom/spm_devices.c:		msm_spm_drv_reinit(
soc/qcom/spm_devices.c:			&per_cpu(msm_cpu_spm_device.reg_data, cpu), true);
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_reinit);
soc/qcom/spm_devices.c: * msm_spm_is_mode_avail() - Specifies if a mode is available for the cpu
soc/qcom/spm_devices.c:bool msm_spm_is_mode_avail(unsigned int mode)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = this_cpu_ptr(&msm_cpu_spm_device);
soc/qcom/spm_devices.c: * msm_spm_is_avs_enabled() - Functions returns 1 if AVS is enabled and
soc/qcom/spm_devices.c:int msm_spm_is_avs_enabled(unsigned int cpu)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = per_cpu(cpu_vctl_device, cpu);
soc/qcom/spm_devices.c:	return msm_spm_drv_get_avs_enable(&dev->reg_data);
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_is_avs_enabled);
soc/qcom/spm_devices.c: * msm_spm_avs_enable() - Enables AVS on the SAW that controls this cpu's
soc/qcom/spm_devices.c:int msm_spm_avs_enable(unsigned int cpu)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = per_cpu(cpu_vctl_device, cpu);
soc/qcom/spm_devices.c:	return msm_spm_drv_set_avs_enable(&dev->reg_data, true);
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_avs_enable);
soc/qcom/spm_devices.c: * msm_spm_avs_disable() - Disables AVS on the SAW that controls this cpu's
soc/qcom/spm_devices.c:int msm_spm_avs_disable(unsigned int cpu)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = per_cpu(cpu_vctl_device, cpu);
soc/qcom/spm_devices.c:	return msm_spm_drv_set_avs_enable(&dev->reg_data, false);
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_avs_disable);
soc/qcom/spm_devices.c: * msm_spm_avs_set_limit() - Set maximum and minimum AVS limits on the
soc/qcom/spm_devices.c:int msm_spm_avs_set_limit(unsigned int cpu,
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = per_cpu(cpu_vctl_device, cpu);
soc/qcom/spm_devices.c:	return msm_spm_drv_set_avs_limit(&dev->reg_data, min_lvl, max_lvl);
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_avs_set_limit);
soc/qcom/spm_devices.c: * msm_spm_avs_enable_irq() - Enable an AVS interrupt
soc/qcom/spm_devices.c:int msm_spm_avs_enable_irq(unsigned int cpu, enum msm_spm_avs_irq irq)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = per_cpu(cpu_vctl_device, cpu);
soc/qcom/spm_devices.c:	return msm_spm_drv_set_avs_irq_enable(&dev->reg_data, irq, true);
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_avs_enable_irq);
soc/qcom/spm_devices.c: * msm_spm_avs_disable_irq() - Disable an AVS interrupt
soc/qcom/spm_devices.c:int msm_spm_avs_disable_irq(unsigned int cpu, enum msm_spm_avs_irq irq)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = per_cpu(cpu_vctl_device, cpu);
soc/qcom/spm_devices.c:	return msm_spm_drv_set_avs_irq_enable(&dev->reg_data, irq, false);
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_avs_disable_irq);
soc/qcom/spm_devices.c: * msm_spm_avs_clear_irq() - Clear a latched AVS interrupt
soc/qcom/spm_devices.c:int msm_spm_avs_clear_irq(unsigned int cpu, enum msm_spm_avs_irq irq)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = per_cpu(cpu_vctl_device, cpu);
soc/qcom/spm_devices.c:	return msm_spm_drv_avs_clear_irq(&dev->reg_data, irq);
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_avs_clear_irq);
soc/qcom/spm_devices.c: * msm_spm_set_low_power_mode() - Configure SPM start address for low power mode
soc/qcom/spm_devices.c:int msm_spm_set_low_power_mode(unsigned int mode, bool notify_rpm)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = this_cpu_ptr(&msm_cpu_spm_device);
soc/qcom/spm_devices.c:	return msm_spm_dev_set_low_power_mode(dev, mode, notify_rpm, true);
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_set_low_power_mode);
soc/qcom/spm_devices.c:void msm_spm_set_rpm_hs(bool allow_rpm_hs)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = this_cpu_ptr(&msm_cpu_spm_device);
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_set_rpm_hs);
soc/qcom/spm_devices.c:int msm_spm_config_low_power_mode_addr(struct msm_spm_device *dev,
soc/qcom/spm_devices.c:	return msm_spm_dev_set_low_power_mode(dev, mode, notify_rpm, false);
soc/qcom/spm_devices.c: * msm_spm_init(): Board initalization function
soc/qcom/spm_devices.c:int __init msm_spm_init(struct msm_spm_platform_data *data, int nr_devs)
soc/qcom/spm_devices.c:		struct msm_spm_device *dev = &per_cpu(msm_cpu_spm_device, cpu);
soc/qcom/spm_devices.c:		ret = msm_spm_dev_init(dev, &data[cpu]);
soc/qcom/spm_devices.c:struct msm_spm_device *msm_spm_get_device_by_name(const char *name)
soc/qcom/spm_devices.c:		struct msm_spm_device *dev
soc/qcom/spm_devices.c:int msm_spm_config_low_power_mode(struct msm_spm_device *dev,
soc/qcom/spm_devices.c:	return msm_spm_dev_set_low_power_mode(dev, mode, notify_rpm, true);
soc/qcom/spm_devices.c: * msm_spm_apcs_set_phase(): Set number of SMPS phases.
soc/qcom/spm_devices.c:int msm_spm_apcs_set_phase(int cpu, unsigned int phase_cnt)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = per_cpu(cpu_vctl_device, cpu);
soc/qcom/spm_devices.c:	return msm_spm_drv_set_pmic_data(&dev->reg_data,
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_apcs_set_phase);
soc/qcom/spm_devices.c:/** msm_spm_enable_fts_lpm() : Enable FTS to switch to low power
soc/qcom/spm_devices.c:int msm_spm_enable_fts_lpm(int cpu, uint32_t mode)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = per_cpu(cpu_vctl_device, cpu);
soc/qcom/spm_devices.c:	return msm_spm_drv_set_pmic_data(&dev->reg_data,
soc/qcom/spm_devices.c:EXPORT_SYMBOL(msm_spm_enable_fts_lpm);
soc/qcom/spm_devices.c:static struct msm_spm_device *msm_spm_get_device(struct platform_device *pdev)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = NULL;
soc/qcom/spm_devices.c:		dev = &per_cpu(msm_cpu_spm_device, cpu);
soc/qcom/spm_devices.c:		dev = devm_kzalloc(&pdev->dev, sizeof(struct msm_spm_device),
soc/qcom/spm_devices.c:static int msm_spm_dev_probe(struct platform_device *pdev)
soc/qcom/spm_devices.c:	struct msm_spm_platform_data spm_data;
soc/qcom/spm_devices.c:	struct msm_spm_seq_entry modes[MSM_SPM_MODE_NR];
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = NULL;
soc/qcom/spm_devices.c:	dev = msm_spm_get_device(pdev);
soc/qcom/spm_devices.c:	memset(&spm_data, 0, sizeof(struct msm_spm_platform_data));
soc/qcom/spm_devices.c:		(MSM_SPM_MODE_NR - 2) * sizeof(struct msm_spm_seq_entry));
soc/qcom/spm_devices.c:	msm_spm_config_q2s(dev, MSM_SPM_MODE_POWER_COLLAPSE);
soc/qcom/spm_devices.c:	msm_spm_drv_reg_init(&dev->reg_data, &spm_data);
soc/qcom/spm_devices.c:		msm_spm_drv_upd_reg_shadow(&dev->reg_data, spm_of_data[i].id,
soc/qcom/spm_devices.c:	ret = msm_spm_dev_init(dev, &spm_data);
soc/qcom/spm_devices.c:		msm_spm_config_low_power_mode(dev, MSM_SPM_MODE_CLOCK_GATING,
soc/qcom/spm_devices.c:static int msm_spm_dev_remove(struct platform_device *pdev)
soc/qcom/spm_devices.c:	struct msm_spm_device *dev = platform_get_drvdata(pdev);
soc/qcom/spm_devices.c:static const struct of_device_id msm_spm_match_table[] = {
soc/qcom/spm_devices.c:static struct platform_driver msm_spm_device_driver = {
soc/qcom/spm_devices.c:	.probe = msm_spm_dev_probe,
soc/qcom/spm_devices.c:	.remove = msm_spm_dev_remove,
soc/qcom/spm_devices.c:		.of_match_table = msm_spm_match_table,
soc/qcom/spm_devices.c: * msm_spm_device_init(): Device tree initialization function
soc/qcom/spm_devices.c:int __init msm_spm_device_init(void)
soc/qcom/spm_devices.c:	return platform_driver_register(&msm_spm_device_driver);
soc/qcom/spm_devices.c:arch_initcall(msm_spm_device_init);
soc/qcom/spm_driver.h:struct msm_spm_seq_entry {
soc/qcom/spm_driver.h:struct msm_spm_platform_data {
soc/qcom/spm_driver.h:	struct msm_spm_seq_entry *modes;
soc/qcom/spm_driver.h:enum msm_spm_pmic_port {
soc/qcom/spm_driver.h:struct msm_spm_driver_data {
soc/qcom/spm_driver.h:int msm_spm_drv_init(struct msm_spm_driver_data *dev,
soc/qcom/spm_driver.h:		struct msm_spm_platform_data *data);
soc/qcom/spm_driver.h:int msm_spm_drv_reg_init(struct msm_spm_driver_data *dev,
soc/qcom/spm_driver.h:		struct msm_spm_platform_data *data);
soc/qcom/spm_driver.h:void msm_spm_drv_reinit(struct msm_spm_driver_data *dev, bool seq);
soc/qcom/spm_driver.h:int msm_spm_drv_set_low_power_mode(struct msm_spm_driver_data *dev,
soc/qcom/spm_driver.h:int msm_spm_drv_set_vdd(struct msm_spm_driver_data *dev,
soc/qcom/spm_driver.h:void dump_regs(struct msm_spm_driver_data *dev, int cpu);
soc/qcom/spm_driver.h:uint32_t msm_spm_drv_get_sts_curr_pmic_data(
soc/qcom/spm_driver.h:		struct msm_spm_driver_data *dev);
soc/qcom/spm_driver.h:int msm_spm_drv_write_seq_data(struct msm_spm_driver_data *dev,
soc/qcom/spm_driver.h:void msm_spm_drv_flush_seq_entry(struct msm_spm_driver_data *dev);
soc/qcom/spm_driver.h:int msm_spm_drv_set_spm_enable(struct msm_spm_driver_data *dev,
soc/qcom/spm_driver.h:int msm_spm_drv_set_pmic_data(struct msm_spm_driver_data *dev,
soc/qcom/spm_driver.h:		enum msm_spm_pmic_port port, unsigned int data);
soc/qcom/spm_driver.h:int msm_spm_drv_set_avs_limit(struct msm_spm_driver_data *dev,
soc/qcom/spm_driver.h:int msm_spm_drv_set_avs_enable(struct msm_spm_driver_data *dev,
soc/qcom/spm_driver.h:int msm_spm_drv_get_avs_enable(struct msm_spm_driver_data *dev);
soc/qcom/spm_driver.h:int msm_spm_drv_set_avs_irq_enable(struct msm_spm_driver_data *dev,
soc/qcom/spm_driver.h:		enum msm_spm_avs_irq irq, bool enable);
soc/qcom/spm_driver.h:int msm_spm_drv_avs_clear_irq(struct msm_spm_driver_data *dev,
soc/qcom/spm_driver.h:		enum msm_spm_avs_irq irq);
soc/qcom/spm_driver.h:void msm_spm_reinit(void);
soc/qcom/spm_driver.h:int msm_spm_init(struct msm_spm_platform_data *data, int nr_devs);
soc/qcom/spm_driver.h:void msm_spm_drv_upd_reg_shadow(struct msm_spm_driver_data *dev, int id,
soc/qcom/spm_driver.h:uint32_t msm_spm_drv_get_vdd(struct msm_spm_driver_data *dev);
soc/qcom/subsys-pil-tz.c:#include <linux/msm-bus-board.h>
soc/qcom/subsys-pil-tz.c:#include <linux/msm-bus.h>
soc/qcom/subsys-pil-tz.c:static struct msm_bus_paths scm_pas_bw_tbl[] = {
soc/qcom/subsys-pil-tz.c:		.vectors = (struct msm_bus_vectors[]){
soc/qcom/subsys-pil-tz.c:		.vectors = (struct msm_bus_vectors[]){
soc/qcom/subsys-pil-tz.c:static struct msm_bus_scale_pdata scm_pas_bus_pdata = {
soc/qcom/subsys-pil-tz.c:		ret = msm_bus_scale_client_update_request(scm_perf_client, 1);
soc/qcom/subsys-pil-tz.c:	msm_bus_scale_client_update_request(scm_perf_client, 0);
soc/qcom/subsys-pil-tz.c:		msm_bus_scale_client_update_request(scm_perf_client, 0);
soc/qcom/subsys-pil-tz.c:	scm_perf_client = msm_bus_scale_register_client(&scm_pas_bus_pdata);
soc/qcom/subsys-pil-tz.c:	struct msm_bus_scale_pdata *pdata;
soc/qcom/subsys-pil-tz.c:	pdata = msm_bus_cl_get_pdata(pdev);
soc/qcom/subsys-pil-tz.c:	d->bus_client = msm_bus_scale_register_client(pdata);
soc/qcom/subsys-pil-tz.c:		rc = msm_bus_scale_client_update_request(d->bus_client, enable);
soc/qcom/subsys-pil-tz.c:	if (of_find_property(dev->of_node, "qcom,msm-bus,name", &len)) {
soc/qcom/subsys-pil-tz.c:		msm_bus_scale_unregister_client(d->bus_client);
soc/qcom/system_pm.c:		msm_rpmh_master_stats_update();
soc/qcom/watchdog_v2.c:#define MODULE_NAME "msm_watchdog"
soc/qcom/watchdog_v2.c:static struct msm_watchdog_data *wdog_data;
soc/qcom/watchdog_v2.c:struct msm_watchdog_data {
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data __percpu **wdog_cpu_dd;
soc/qcom/watchdog_v2.c:static void dump_cpu_alive_mask(struct msm_watchdog_data *wdog_dd)
soc/qcom/watchdog_v2.c:static int msm_watchdog_suspend(struct device *dev)
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd =
soc/qcom/watchdog_v2.c:			(struct msm_watchdog_data *)dev_get_drvdata(dev);
soc/qcom/watchdog_v2.c:static int msm_watchdog_resume(struct device *dev)
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd =
soc/qcom/watchdog_v2.c:			(struct msm_watchdog_data *)dev_get_drvdata(dev);
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd = container_of(this,
soc/qcom/watchdog_v2.c:				struct msm_watchdog_data, panic_blk);
soc/qcom/watchdog_v2.c:static void wdog_disable(struct msm_watchdog_data *wdog_dd)
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd = dev_get_drvdata(dev);
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd = dev_get_drvdata(dev);
soc/qcom/watchdog_v2.c:static void __wdog_user_pet(struct msm_watchdog_data *wdog_dd)
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd = dev_get_drvdata(dev);
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd = dev_get_drvdata(dev);
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd = dev_get_drvdata(dev);
soc/qcom/watchdog_v2.c:static void pet_watchdog(struct msm_watchdog_data *wdog_dd)
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd = (struct msm_watchdog_data *)info;
soc/qcom/watchdog_v2.c:static void ping_other_cpus(struct msm_watchdog_data *wdog_dd)
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd =
soc/qcom/watchdog_v2.c:static void print_irq_stat(struct msm_watchdog_data *wdog_dd)
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd = container_of(work,
soc/qcom/watchdog_v2.c:					    struct msm_watchdog_data,
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd =
soc/qcom/watchdog_v2.c:		(struct msm_watchdog_data *)arg;
soc/qcom/watchdog_v2.c:static int msm_watchdog_remove(struct platform_device *pdev)
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd =
soc/qcom/watchdog_v2.c:			(struct msm_watchdog_data *)platform_get_drvdata(pdev);
soc/qcom/watchdog_v2.c:void msm_trigger_wdog_bite(void)
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd = (struct msm_watchdog_data *)dev_id;
soc/qcom/watchdog_v2.c:	msm_trigger_wdog_bite();
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd =
soc/qcom/watchdog_v2.c:			*(struct msm_watchdog_data **)(dev_id);
soc/qcom/watchdog_v2.c:static int init_watchdog_sysfs(struct msm_watchdog_data *wdog_dd)
soc/qcom/watchdog_v2.c:	if (msm_minidump_add_region(&md_entry) < 0)
soc/qcom/watchdog_v2.c:static void init_watchdog_data(struct msm_watchdog_data *wdog_dd)
soc/qcom/watchdog_v2.c:		wdog_dd->wdog_cpu_dd = alloc_percpu(struct msm_watchdog_data *);
soc/qcom/watchdog_v2.c:static const struct of_device_id msm_wdog_match_table[] = {
soc/qcom/watchdog_v2.c:	{ .compatible = "qcom,msm-watchdog" },
soc/qcom/watchdog_v2.c:static void dump_pdata(struct msm_watchdog_data *pdata)
soc/qcom/watchdog_v2.c:static int msm_wdog_dt_to_pdata(struct platform_device *pdev,
soc/qcom/watchdog_v2.c:					struct msm_watchdog_data *pdata)
soc/qcom/watchdog_v2.c:					       pdata->size, "msm-watchdog")))) {
soc/qcom/watchdog_v2.c:static int msm_watchdog_probe(struct platform_device *pdev)
soc/qcom/watchdog_v2.c:	struct msm_watchdog_data *wdog_dd;
soc/qcom/watchdog_v2.c:	wdog_dd = kzalloc(sizeof(struct msm_watchdog_data), GFP_KERNEL);
soc/qcom/watchdog_v2.c:	ret = msm_wdog_dt_to_pdata(pdev, wdog_dd);
soc/qcom/watchdog_v2.c:			"msm_watchdog");
soc/qcom/watchdog_v2.c:	if (msm_minidump_add_region(&md_entry) < 0)
soc/qcom/watchdog_v2.c:static const struct dev_pm_ops msm_watchdog_dev_pm_ops = {
soc/qcom/watchdog_v2.c:	.suspend_noirq = msm_watchdog_suspend,
soc/qcom/watchdog_v2.c:	.resume_noirq = msm_watchdog_resume,
soc/qcom/watchdog_v2.c:static struct platform_driver msm_watchdog_driver = {
soc/qcom/watchdog_v2.c:	.probe = msm_watchdog_probe,
soc/qcom/watchdog_v2.c:	.remove = msm_watchdog_remove,
soc/qcom/watchdog_v2.c:		.pm = &msm_watchdog_dev_pm_ops,
soc/qcom/watchdog_v2.c:		.of_match_table = msm_wdog_match_table,
soc/qcom/watchdog_v2.c:	return platform_driver_register(&msm_watchdog_driver);
soc/qcom/wcnss/wcnss_vreg.c:static void __iomem *msm_wcnss_base;
soc/qcom/wcnss/wcnss_vreg.c:		msm_wcnss_base = cfg->msm_wcnss_base;
soc/qcom/wcnss/wcnss_vreg.c:		if (!msm_wcnss_base) {
soc/qcom/wcnss/wcnss_vreg.c:		spare_reg = msm_wcnss_base + spare_offset;
soc/qcom/wcnss/wcnss_vreg.c:		pmu_conf_reg = msm_wcnss_base + pmu_offset;
soc/qcom/wcnss/wcnss_vreg.c:			iris_read_reg = msm_wcnss_base +
soc/qcom/wcnss/wcnss_wlan.c:	void __iomem *msm_wcnss_base;
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base + PRONTO_PMU_SPARE_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base + PRONTO_PMU_COM_CPU_CBCR_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base + PRONTO_PMU_COM_AHB_CBCR_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base + PRONTO_PMU_CFG_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base + PRONTO_PMU_COM_CSR_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base + PRONTO_PMU_SOFT_RESET_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base + PRONTO_PMU_WDOG_CTL;
soc/qcom/wcnss/wcnss_wlan.c:		reg_addr = penv->msm_wcnss_base +
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base  + PRONTO_PMU_CCPU_BOOT_REMAP_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base + PRONTO_PMU_CPU_AHB_CMD_RCGR_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base + PRONTO_PMU_COM_GDSCR_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base + PRONTO_PMU_CBCR_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base + PRONTO_PMU_WLAN_BCR_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base + PRONTO_PMU_WLAN_GDSCR_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	reg_addr = penv->msm_wcnss_base + PRONTO_PMU_WLAN_AHB_CBCR_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	pmu_conf_reg = penv->msm_wcnss_base + PRONTO_PMU_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	pmu_spare_reg = penv->msm_wcnss_base + RIVA_SPARE_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:	pmu_spare_reg = penv->msm_wcnss_base + RIVA_SPARE_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:		penv->msm_wcnss_base =
soc/qcom/wcnss/wcnss_wlan.c:		penv->msm_wcnss_base =
soc/qcom/wcnss/wcnss_wlan.c:	if (!penv->msm_wcnss_base) {
soc/qcom/wcnss/wcnss_wlan.c:	penv->wlan_config.msm_wcnss_base = penv->msm_wcnss_base;
soc/qcom/wcnss/wcnss_wlan.c:			penv->msm_wcnss_base + PRONTO_PLL_MODE_OFFSET;
soc/qcom/wcnss/wcnss_wlan.c:static const struct of_device_id msm_wcnss_pronto_match[] = {
soc/qcom/wcnss/wcnss_wlan.c:		.of_match_table = msm_wcnss_pronto_match,
soc/qcom/subsystem_restart.c:#include <trace/events/trace_msm_pil_event.h>
soc/qcom/subsystem_restart.c:	.name		= "msm_subsys",
spi/spi-geni-qcom.c:#include <linux/msm_gpi.h>
spi/spi-geni-qcom.c:	struct msm_gpi_tre config0_tre;
spi/spi-geni-qcom.c:	struct msm_gpi_tre go_tre;
spi/spi-geni-qcom.c:	struct msm_gpi_tre tx_dma_tre;
spi/spi-geni-qcom.c:	struct msm_gpi_tre rx_dma_tre;
spi/spi-geni-qcom.c:	struct msm_gpi_dma_async_tx_cb_param tx_cb_param;
spi/spi-geni-qcom.c:	struct msm_gpi_dma_async_tx_cb_param rx_cb_param;
spi/spi-geni-qcom.c:	struct msm_gpi_ctrl tx_event;
spi/spi-geni-qcom.c:	struct msm_gpi_ctrl rx_event;
spi/spi-geni-qcom.c:static struct msm_gpi_tre *setup_config0_tre(struct spi_transfer *xfer,
spi/spi-geni-qcom.c:	struct msm_gpi_tre *c0_tre = &mas->gsi[mas->num_xfers].config0_tre;
spi/spi-geni-qcom.c:static struct msm_gpi_tre *setup_go_tre(int cmd, int cs, int rx_len, int flags,
spi/spi-geni-qcom.c:	struct msm_gpi_tre *go_tre = &mas->gsi[mas->num_xfers].go_tre;
spi/spi-geni-qcom.c:static struct msm_gpi_tre *setup_dma_tre(struct msm_gpi_tre *tre,
spi/spi-geni-qcom.c:static void spi_gsi_ch_cb(struct dma_chan *ch, struct msm_gpi_cb const *cb,
spi/spi-geni-qcom.c:	struct msm_gpi_dma_async_tx_cb_param *cb_param =
spi/spi-geni-qcom.c:			(struct msm_gpi_dma_async_tx_cb_param *)cb;
spi/spi-geni-qcom.c:	struct msm_gpi_dma_async_tx_cb_param *cb_param = cb;
spi/spi-geni-qcom.c:	struct msm_gpi_tre *c0_tre = NULL;
spi/spi-geni-qcom.c:	struct msm_gpi_tre *go_tre = NULL;
spi/spi-geni-qcom.c:	struct msm_gpi_tre *tx_tre = NULL;
spi/spi-geni-qcom.c:	struct msm_gpi_tre *rx_tre = NULL;
spi/spi_qsd.c:#include <linux/msm-sps.h>
spi/spi_qsd.c:#include <linux/msm-bus.h>
spi/spi_qsd.c:#include <linux/msm-bus-board.h>
spi/spi_qsd.c:static int msm_spi_pm_resume_runtime(struct device *device);
spi/spi_qsd.c:static int msm_spi_pm_suspend_runtime(struct device *device);
spi/spi_qsd.c:static inline void msm_spi_dma_unmap_buffers(struct msm_spi *dd);
spi/spi_qsd.c:static int get_local_resources(struct msm_spi *dd);
spi/spi_qsd.c:static void put_local_resources(struct msm_spi *dd);
spi/spi_qsd.c:static inline int msm_spi_configure_gsbi(struct msm_spi *dd,
spi/spi_qsd.c:static inline void msm_spi_register_init(struct msm_spi *dd)
spi/spi_qsd.c:	msm_spi_set_state(dd, SPI_OP_STATE_RESET);
spi/spi_qsd.c:static int msm_spi_pinctrl_init(struct msm_spi *dd)
spi/spi_qsd.c:static inline int msm_spi_request_gpios(struct msm_spi *dd)
spi/spi_qsd.c:static inline void msm_spi_free_gpios(struct msm_spi *dd)
spi/spi_qsd.c:static inline int msm_spi_request_cs_gpio(struct msm_spi *dd)
spi/spi_qsd.c:static inline void msm_spi_free_cs_gpio(struct msm_spi *dd)
spi/spi_qsd.c: * msm_spi_clk_max_rate: finds the nearest lower rate for a clk
spi/spi_qsd.c:static long msm_spi_clk_max_rate(struct clk *clk, unsigned long rate)
spi/spi_qsd.c:static void msm_spi_clock_set(struct msm_spi *dd, int speed)
spi/spi_qsd.c:	rate = msm_spi_clk_max_rate(dd->clk, speed);
spi/spi_qsd.c:static void msm_spi_clk_path_vote(struct msm_spi *dd, u32 rate)
spi/spi_qsd.c:		msm_bus_scale_update_bw(dd->bus_cl_hdl, 0, ib);
spi/spi_qsd.c:static void msm_spi_clk_path_teardown(struct msm_spi *dd)
spi/spi_qsd.c:	msm_spi_clk_path_vote(dd, 0);
spi/spi_qsd.c:		msm_bus_scale_unregister(dd->bus_cl_hdl);
spi/spi_qsd.c: * msm_spi_clk_path_postponed_register: reg with bus-scaling after it is probed
spi/spi_qsd.c: * msm_bus_scale_register_client() will fail if the bus scaling driver is not
spi/spi_qsd.c:static int msm_spi_clk_path_postponed_register(struct msm_spi *dd)
spi/spi_qsd.c:	dd->bus_cl_hdl = msm_bus_scale_register(dd->pdata->master_id,
spi/spi_qsd.c:static void msm_spi_clk_path_init(struct msm_spi *dd)
spi/spi_qsd.c:	if (msm_spi_clk_path_postponed_register(dd))
spi/spi_qsd.c:static int msm_spi_calculate_size(int *fifo_size,
spi/spi_qsd.c:static void msm_spi_calculate_fifo_size(struct msm_spi *dd)
spi/spi_qsd.c:	if (msm_spi_calculate_size(&dd->input_fifo_size, &dd->input_block_size,
spi/spi_qsd.c:	if (msm_spi_calculate_size(&dd->output_fifo_size,
spi/spi_qsd.c:static void msm_spi_read_word_from_fifo(struct msm_spi *dd)
spi/spi_qsd.c:static inline bool msm_spi_is_valid_state(struct msm_spi *dd)
spi/spi_qsd.c:static inline void msm_spi_udelay(unsigned int delay_usecs)
spi/spi_qsd.c:static inline int msm_spi_wait_valid(struct msm_spi *dd)
spi/spi_qsd.c:	while (!msm_spi_is_valid_state(dd)) {
spi/spi_qsd.c:			if (!msm_spi_is_valid_state(dd)) {
spi/spi_qsd.c:		msm_spi_udelay(delay);
spi/spi_qsd.c:static inline int msm_spi_set_state(struct msm_spi *dd,
spi/spi_qsd.c:				    enum msm_spi_state state)
spi/spi_qsd.c:	enum msm_spi_state cur_state;
spi/spi_qsd.c:	if (msm_spi_wait_valid(dd))
spi/spi_qsd.c:	if (msm_spi_wait_valid(dd))
spi/spi_qsd.c: * msm_spi_set_bpw_and_no_io_flags: configure N, and no-input/no-output flags
spi/spi_qsd.c:msm_spi_set_bpw_and_no_io_flags(struct msm_spi *dd, u32 *config, int n)
spi/spi_qsd.c: * msm_spi_calc_spi_config_loopback_and_input_first: Calculate the values that
spi/spi_qsd.c:msm_spi_calc_spi_config_loopback_and_input_first(u32 spi_config, u8 mode)
spi/spi_qsd.c: * msm_spi_set_spi_config: prepares register SPI_CONFIG to process the
spi/spi_qsd.c:static void msm_spi_set_spi_config(struct msm_spi *dd, int bpw)
spi/spi_qsd.c:	spi_config = msm_spi_calc_spi_config_loopback_and_input_first(
spi/spi_qsd.c:		msm_spi_set_bpw_and_no_io_flags(dd, &spi_config, bpw-1);
spi/spi_qsd.c: * msm_spi_set_mx_counts: set SPI_MX_INPUT_COUNT and SPI_MX_INPUT_COUNT
spi/spi_qsd.c:static void msm_spi_set_mx_counts(struct msm_spi *dd, u32 n_words)
spi/spi_qsd.c:				msm_spi_set_write_count(dd, n_words);
spi/spi_qsd.c:				msm_spi_set_write_count(dd, 0);
spi/spi_qsd.c:		msm_spi_set_write_count(dd, 0);
spi/spi_qsd.c:static int msm_spi_bam_pipe_disconnect(struct msm_spi *dd,
spi/spi_qsd.c:						struct msm_spi_bam_pipe  *pipe)
spi/spi_qsd.c:static int msm_spi_bam_pipe_connect(struct msm_spi *dd,
spi/spi_qsd.c:		struct msm_spi_bam_pipe  *pipe, struct sps_connect *config)
spi/spi_qsd.c:		msm_spi_bam_pipe_disconnect(dd, pipe);
spi/spi_qsd.c:static void msm_spi_bam_pipe_flush(struct msm_spi *dd,
spi/spi_qsd.c:					enum msm_spi_pipe_direction pipe_dir)
spi/spi_qsd.c:	struct msm_spi_bam_pipe *pipe = (pipe_dir == SPI_BAM_CONSUMER_PIPE) ?
spi/spi_qsd.c:	ret = msm_spi_bam_pipe_disconnect(dd, pipe);
spi/spi_qsd.c:	ret = msm_spi_bam_pipe_connect(dd, pipe, &config);
spi/spi_qsd.c:static void msm_spi_bam_flush(struct msm_spi *dd)
spi/spi_qsd.c:	msm_spi_bam_pipe_flush(dd, SPI_BAM_CONSUMER_PIPE);
spi/spi_qsd.c:	msm_spi_bam_pipe_flush(dd, SPI_BAM_PRODUCER_PIPE);
spi/spi_qsd.c:msm_spi_bam_process_rx(struct msm_spi *dd, u32 *bytes_to_send, u32 desc_cnt)
spi/spi_qsd.c:msm_spi_bam_process_tx(struct msm_spi *dd, u32 *bytes_to_send, u32 desc_cnt)
spi/spi_qsd.c: * msm_spi_bam_begin_transfer: transfer dd->tx_bytes_remaining bytes
spi/spi_qsd.c:msm_spi_bam_begin_transfer(struct msm_spi *dd)
spi/spi_qsd.c:	msm_spi_set_mx_counts(dd, n_words_xfr);
spi/spi_qsd.c:	ret = msm_spi_set_state(dd, SPI_OP_STATE_RUN);
spi/spi_qsd.c:			ret = msm_spi_bam_process_rx(dd, &rx_bytes_to_recv,
spi/spi_qsd.c:			ret = msm_spi_bam_process_tx(dd, &tx_bytes_to_send,
spi/spi_qsd.c:msm_spi_bam_next_transfer(struct msm_spi *dd)
spi/spi_qsd.c:		if (msm_spi_set_state(dd, SPI_OP_STATE_RESET))
spi/spi_qsd.c:		if ((msm_spi_bam_begin_transfer(dd)) < 0) {
spi/spi_qsd.c:static int msm_spi_dma_send_next(struct msm_spi *dd)
spi/spi_qsd.c:		ret = msm_spi_bam_next_transfer(dd);
spi/spi_qsd.c:static inline void msm_spi_ack_transfer(struct msm_spi *dd)
spi/spi_qsd.c:static inline irqreturn_t msm_spi_qup_irq(int irq, void *dev_id)
spi/spi_qsd.c:	struct msm_spi *dd = dev_id;
spi/spi_qsd.c:		ret |= msm_spi_error_irq(irq, master);
spi/spi_qsd.c:		ret |= msm_spi_input_irq(irq, dev_id);
spi/spi_qsd.c:		ret |= msm_spi_output_irq(irq, dev_id);
spi/spi_qsd.c:		msm_spi_set_state(dd, SPI_OP_STATE_RESET);
spi/spi_qsd.c:static irqreturn_t msm_spi_input_irq(int irq, void *dev_id)
spi/spi_qsd.c:	struct msm_spi	       *dd = dev_id;
spi/spi_qsd.c:			msm_spi_read_word_from_fifo(dd);
spi/spi_qsd.c:			msm_spi_read_word_from_fifo(dd);
spi/spi_qsd.c:static void msm_spi_write_word_to_fifo(struct msm_spi *dd)
spi/spi_qsd.c:static inline void msm_spi_write_rmn_to_fifo(struct msm_spi *dd)
spi/spi_qsd.c:			msm_spi_write_word_to_fifo(dd);
spi/spi_qsd.c:			msm_spi_write_word_to_fifo(dd);
spi/spi_qsd.c:static irqreturn_t msm_spi_output_irq(int irq, void *dev_id)
spi/spi_qsd.c:	struct msm_spi	       *dd = dev_id;
spi/spi_qsd.c:		msm_spi_write_rmn_to_fifo(dd);
spi/spi_qsd.c:static irqreturn_t msm_spi_error_irq(int irq, void *dev_id)
spi/spi_qsd.c:	struct msm_spi          *dd = spi_master_get_devdata(master);
spi/spi_qsd.c:	msm_spi_get_clk_err(dd, &spi_err);
spi/spi_qsd.c:	msm_spi_clear_error_flags(dd);
spi/spi_qsd.c:	msm_spi_ack_clk_err(dd);
spi/spi_qsd.c:static int msm_spi_bam_map_buffers(struct msm_spi *dd)
spi/spi_qsd.c:	msm_spi_dma_unmap_buffers(dd);
spi/spi_qsd.c:static int msm_spi_dma_map_buffers(struct msm_spi *dd)
spi/spi_qsd.c:		ret = msm_spi_bam_map_buffers(dd);
spi/spi_qsd.c:static void msm_spi_bam_unmap_buffers(struct msm_spi *dd)
spi/spi_qsd.c:static inline void msm_spi_dma_unmap_buffers(struct msm_spi *dd)
spi/spi_qsd.c:		msm_spi_bam_unmap_buffers(dd);
spi/spi_qsd.c: * msm_spi_use_dma - decides whether to use Data-Mover or BAM for
spi/spi_qsd.c:msm_spi_use_dma(struct msm_spi *dd, struct spi_transfer *tr, u8 bpw)
spi/spi_qsd.c: * msm_spi_set_transfer_mode: Chooses optimal transfer mode. Sets dd->mode and
spi/spi_qsd.c:msm_spi_set_transfer_mode(struct msm_spi *dd, u8 bpw, u32 read_count)
spi/spi_qsd.c:	if (msm_spi_use_dma(dd, dd->cur_transfer, bpw)) {
spi/spi_qsd.c: * msm_spi_set_qup_io_modes: prepares register QUP_IO_MODES to process a
spi/spi_qsd.c:static void msm_spi_set_qup_io_modes(struct msm_spi *dd)
spi/spi_qsd.c:static u32 msm_spi_calc_spi_ioc_clk_polarity(u32 spi_ioc, u8 mode)
spi/spi_qsd.c: * msm_spi_set_spi_io_control: prepares register SPI_IO_CONTROL to process the
spi/spi_qsd.c:static u32 msm_spi_set_spi_io_control(struct msm_spi *dd)
spi/spi_qsd.c:	spi_ioc = msm_spi_calc_spi_ioc_clk_polarity(spi_ioc
spi/spi_qsd.c: * msm_spi_set_qup_op_mask: prepares register QUP_OPERATIONAL_MASK to process
spi/spi_qsd.c:static void msm_spi_set_qup_op_mask(struct msm_spi *dd)
spi/spi_qsd.c:static void get_transfer_length(struct msm_spi *dd)
spi/spi_qsd.c:static int msm_spi_process_transfer(struct msm_spi *dd)
spi/spi_qsd.c:		msm_spi_clock_set(dd, max_speed);
spi/spi_qsd.c:	ret = msm_spi_set_state(dd, SPI_OP_STATE_RESET);
spi/spi_qsd.c:	msm_spi_set_transfer_mode(dd, bpw, read_count);
spi/spi_qsd.c:	msm_spi_set_mx_counts(dd, read_count);
spi/spi_qsd.c:		ret = msm_spi_dma_map_buffers(dd);
spi/spi_qsd.c:	msm_spi_set_qup_io_modes(dd);
spi/spi_qsd.c:	msm_spi_set_spi_config(dd, bpw);
spi/spi_qsd.c:	msm_spi_set_qup_config(dd, bpw);
spi/spi_qsd.c:	spi_ioc = msm_spi_set_spi_io_control(dd);
spi/spi_qsd.c:	msm_spi_set_qup_op_mask(dd);
spi/spi_qsd.c:		if (msm_spi_prepare_for_write(dd))
spi/spi_qsd.c:		msm_spi_start_write(dd, read_count);
spi/spi_qsd.c:		if ((msm_spi_bam_begin_transfer(dd)) < 0) {
spi/spi_qsd.c:		if (msm_spi_set_state(dd, SPI_OP_STATE_RUN)) {
spi/spi_qsd.c:	} while (msm_spi_dma_send_next(dd));
spi/spi_qsd.c:	msm_spi_udelay(dd->xfrs_delay_usec);
spi/spi_qsd.c:		msm_spi_bam_flush(dd);
spi/spi_qsd.c:	msm_spi_dma_unmap_buffers(dd);
spi/spi_qsd.c:	msm_spi_set_state(dd, SPI_OP_STATE_RESET);
spi/spi_qsd.c:static inline void msm_spi_set_cs(struct spi_device *spi, bool set_flag)
spi/spi_qsd.c:	struct msm_spi *dd = spi_master_get_devdata(spi->master);
spi/spi_qsd.c:	msm_spi_clk_path_vote(dd, spi->max_speed_hz);
spi/spi_qsd.c:static void reset_core(struct msm_spi *dd)
spi/spi_qsd.c:	msm_spi_register_init(dd);
spi/spi_qsd.c:	msm_spi_enable_error_flags(dd);
spi/spi_qsd.c:	msm_spi_set_state(dd, SPI_OP_STATE_RESET);
spi/spi_qsd.c:static void put_local_resources(struct msm_spi *dd)
spi/spi_qsd.c:	msm_spi_disable_irqs(dd);
spi/spi_qsd.c:	msm_spi_free_gpios(dd);
spi/spi_qsd.c:static int get_local_resources(struct msm_spi *dd)
spi/spi_qsd.c:	ret = msm_spi_request_gpios(dd);
spi/spi_qsd.c:	msm_spi_enable_irqs(dd);
spi/spi_qsd.c:	msm_spi_free_gpios(dd);
spi/spi_qsd.c: * msm_spi_transfer_one: To process one spi transfer at a time
spi/spi_qsd.c:static int msm_spi_transfer_one(struct spi_master *master,
spi/spi_qsd.c:	struct msm_spi	*dd;
spi/spi_qsd.c:			msm_spi_bam_pipe_connect(dd, &dd->bam.prod,
spi/spi_qsd.c:			msm_spi_bam_pipe_connect(dd, &dd->bam.cons,
spi/spi_qsd.c:	if (dd->suspended || !msm_spi_is_valid_state(dd)) {
spi/spi_qsd.c:			msm_spi_process_transfer(dd);
spi/spi_qsd.c:			msm_spi_bam_pipe_disconnect(dd, &dd->bam.prod);
spi/spi_qsd.c:			msm_spi_bam_pipe_disconnect(dd, &dd->bam.cons);
spi/spi_qsd.c:static int msm_spi_pm_get_sync(struct device *dev)
spi/spi_qsd.c:		ret = msm_spi_pm_resume_runtime(dev);
spi/spi_qsd.c:static int msm_spi_pm_put_sync(struct device *dev)
spi/spi_qsd.c:		ret = msm_spi_pm_suspend_runtime(dev);
spi/spi_qsd.c:static int msm_spi_prepare_message(struct spi_master *master,
spi/spi_qsd.c:	struct msm_spi *dd = spi_master_get_devdata(master);
spi/spi_qsd.c:	resume_state = msm_spi_pm_get_sync(dd->dev);
spi/spi_qsd.c:static int msm_spi_unprepare_message(struct spi_master *master,
spi/spi_qsd.c:	struct msm_spi *dd = spi_master_get_devdata(master);
spi/spi_qsd.c:	ret = msm_spi_pm_put_sync(dd->dev);
spi/spi_qsd.c:static int msm_spi_prepare_transfer_hardware(struct spi_master *master)
spi/spi_qsd.c:	struct msm_spi *dd = spi_master_get_devdata(master);
spi/spi_qsd.c:		resume_state = msm_spi_pm_get_sync(dd->dev);
spi/spi_qsd.c:static int msm_spi_unprepare_transfer_hardware(struct spi_master *master)
spi/spi_qsd.c:	struct msm_spi	*dd = spi_master_get_devdata(master);
spi/spi_qsd.c:		ret = msm_spi_pm_put_sync(dd->dev);
spi/spi_qsd.c:static int msm_spi_setup(struct spi_device *spi)
spi/spi_qsd.c:	struct msm_spi	*dd;
spi/spi_qsd.c:		rc = msm_spi_pm_resume_runtime(dd->dev);
spi/spi_qsd.c:	spi_ioc = msm_spi_calc_spi_ioc_clk_polarity(spi_ioc, spi->mode);
spi/spi_qsd.c:	spi_config = msm_spi_calc_spi_config_loopback_and_input_first(
spi/spi_qsd.c:		msm_spi_pm_suspend_runtime(dd->dev);
spi/spi_qsd.c:	struct msm_spi_debugfs_data *reg = (struct msm_spi_debugfs_data *)data;
spi/spi_qsd.c:	struct msm_spi *dd = reg->dd;
spi/spi_qsd.c:	struct msm_spi_debugfs_data *reg = (struct msm_spi_debugfs_data *)data;
spi/spi_qsd.c:	struct msm_spi *dd = reg->dd;
spi/spi_qsd.c:static void spi_debugfs_init(struct msm_spi *dd)
spi/spi_qsd.c:static void spi_debugfs_exit(struct msm_spi *dd)
spi/spi_qsd.c:static void spi_debugfs_init(struct msm_spi *dd) {}
spi/spi_qsd.c:static void spi_debugfs_exit(struct msm_spi *dd) {}
spi/spi_qsd.c:	struct msm_spi *dd =  spi_master_get_devdata(master);
spi/spi_qsd.c:	struct msm_spi *dd = dev_get_drvdata(dev);
spi/spi_qsd.c:static void msm_spi_bam_pipe_teardown(struct msm_spi *dd,
spi/spi_qsd.c:					enum msm_spi_pipe_direction pipe_dir)
spi/spi_qsd.c:	struct msm_spi_bam_pipe *pipe = (pipe_dir == SPI_BAM_CONSUMER_PIPE) ?
spi/spi_qsd.c:	msm_spi_bam_pipe_disconnect(dd, pipe);
spi/spi_qsd.c:static int msm_spi_bam_pipe_init(struct msm_spi *dd,
spi/spi_qsd.c:					enum msm_spi_pipe_direction pipe_dir)
spi/spi_qsd.c:	struct msm_spi_bam_pipe *pipe = (pipe_dir == SPI_BAM_CONSUMER_PIPE) ?
spi/spi_qsd.c:static void msm_spi_bam_teardown(struct msm_spi *dd)
spi/spi_qsd.c:	msm_spi_bam_pipe_teardown(dd, SPI_BAM_PRODUCER_PIPE);
spi/spi_qsd.c:	msm_spi_bam_pipe_teardown(dd, SPI_BAM_CONSUMER_PIPE);
spi/spi_qsd.c:static int msm_spi_bam_init(struct msm_spi *dd)
spi/spi_qsd.c:	rc = msm_spi_bam_pipe_init(dd, SPI_BAM_PRODUCER_PIPE);
spi/spi_qsd.c:	rc = msm_spi_bam_pipe_init(dd, SPI_BAM_CONSUMER_PIPE);
spi/spi_qsd.c:	msm_spi_bam_teardown(dd);
spi/spi_qsd.c:enum msm_spi_dt_entry_status {
spi/spi_qsd.c:enum msm_spi_dt_entry_type {
spi/spi_qsd.c:struct msm_spi_dt_to_pdata_map {
spi/spi_qsd.c:	enum msm_spi_dt_entry_status status;
spi/spi_qsd.c:	enum msm_spi_dt_entry_type   type;
spi/spi_qsd.c:static int msm_spi_dt_to_pdata_populate(struct platform_device *pdev,
spi/spi_qsd.c:					struct msm_spi_platform_data *pdata,
spi/spi_qsd.c:					struct msm_spi_dt_to_pdata_map  *itr)
spi/spi_qsd.c: * msm_spi_dt_to_pdata: create pdata and read gpio config from device tree
spi/spi_qsd.c:static struct msm_spi_platform_data *msm_spi_dt_to_pdata(
spi/spi_qsd.c:			struct platform_device *pdev, struct msm_spi *dd)
spi/spi_qsd.c:	struct msm_spi_platform_data *pdata;
spi/spi_qsd.c:		struct msm_spi_dt_to_pdata_map map[] = {
spi/spi_qsd.c:		if (msm_spi_dt_to_pdata_populate(pdev, pdata, map))
spi/spi_qsd.c:static int msm_spi_get_qup_hw_ver(struct device *dev, struct msm_spi *dd)
spi/spi_qsd.c:static int msm_spi_bam_get_resources(struct msm_spi *dd,
spi/spi_qsd.c:	dd->dma_init = msm_spi_bam_init;
spi/spi_qsd.c:	dd->dma_teardown = msm_spi_bam_teardown;
spi/spi_qsd.c:	struct msm_spi	  *dd;
spi/spi_qsd.c:		rc = msm_spi_pinctrl_init(dd);
spi/spi_qsd.c:		msm_spi_clock_set(dd, dd->pdata->max_clock_speed);
spi/spi_qsd.c:		enum msm_spi_qup_version ver =
spi/spi_qsd.c:					msm_spi_get_qup_hw_ver(&pdev->dev, dd);
spi/spi_qsd.c:		rc = msm_spi_configure_gsbi(dd, pdev);
spi/spi_qsd.c:	msm_spi_calculate_fifo_size(dd);
spi/spi_qsd.c:	msm_spi_register_init(dd);
spi/spi_qsd.c:	msm_spi_enable_error_flags(dd);
spi/spi_qsd.c:	rc = msm_spi_set_state(dd, SPI_OP_STATE_RESET);
spi/spi_qsd.c:	rc = msm_spi_request_irq(dd, pdev, master);
spi/spi_qsd.c:	msm_spi_disable_irqs(dd);
spi/spi_qsd.c:static int msm_spi_probe(struct platform_device *pdev)
spi/spi_qsd.c:	struct msm_spi	       *dd;
spi/spi_qsd.c:	struct msm_spi_platform_data *pdata;
spi/spi_qsd.c:	master = spi_alloc_master(&pdev->dev, sizeof(struct msm_spi));
spi/spi_qsd.c:	master->set_cs	       = msm_spi_set_cs;
spi/spi_qsd.c:	master->setup          = msm_spi_setup;
spi/spi_qsd.c:	master->prepare_transfer_hardware = msm_spi_prepare_transfer_hardware;
spi/spi_qsd.c:	master->transfer_one = msm_spi_transfer_one;
spi/spi_qsd.c:			= msm_spi_unprepare_transfer_hardware;
spi/spi_qsd.c:		pdata = msm_spi_dt_to_pdata(pdev, dd);
spi/spi_qsd.c:		rc = msm_spi_bam_get_resources(dd, pdev, master);
spi/spi_qsd.c:		master->prepare_message = msm_spi_prepare_message;
spi/spi_qsd.c:		master->unprepare_message = msm_spi_unprepare_message;
spi/spi_qsd.c:static int msm_spi_pm_suspend_runtime(struct device *device)
spi/spi_qsd.c:	struct msm_spi	  *dd;
spi/spi_qsd.c:		msm_spi_bam_pipe_disconnect(dd, &dd->bam.prod);
spi/spi_qsd.c:		msm_spi_bam_pipe_disconnect(dd, &dd->bam.cons);
spi/spi_qsd.c:		msm_spi_clk_path_vote(dd, 0);
spi/spi_qsd.c:static int msm_spi_pm_resume_runtime(struct device *device)
spi/spi_qsd.c:	struct msm_spi	  *dd;
spi/spi_qsd.c:	msm_spi_clk_path_init(dd);
spi/spi_qsd.c:	msm_spi_clk_path_vote(dd, dd->pdata->max_clock_speed);
spi/spi_qsd.c:		msm_spi_bam_pipe_connect(dd, &dd->bam.prod,
spi/spi_qsd.c:		msm_spi_bam_pipe_connect(dd, &dd->bam.cons,
spi/spi_qsd.c:static int msm_spi_suspend(struct device *device)
spi/spi_qsd.c:	struct msm_spi   *dd;
spi/spi_qsd.c:		msm_spi_pm_suspend_runtime(device);
spi/spi_qsd.c:static int msm_spi_resume(struct device *device)
spi/spi_qsd.c:	struct msm_spi   *dd;
spi/spi_qsd.c:#define msm_spi_suspend NULL
spi/spi_qsd.c:#define msm_spi_resume NULL
spi/spi_qsd.c:static int msm_spi_remove(struct platform_device *pdev)
spi/spi_qsd.c:	struct msm_spi    *dd = spi_master_get_devdata(master);
spi/spi_qsd.c:	msm_spi_clk_path_teardown(dd);
spi/spi_qsd.c:static const struct of_device_id msm_spi_dt_match[] = {
spi/spi_qsd.c:static const struct dev_pm_ops msm_spi_dev_pm_ops = {
spi/spi_qsd.c:	SET_SYSTEM_SLEEP_PM_OPS(msm_spi_suspend, msm_spi_resume)
spi/spi_qsd.c:	SET_RUNTIME_PM_OPS(msm_spi_pm_suspend_runtime,
spi/spi_qsd.c:			msm_spi_pm_resume_runtime, NULL)
spi/spi_qsd.c:static struct platform_driver msm_spi_driver = {
spi/spi_qsd.c:		.pm		= &msm_spi_dev_pm_ops,
spi/spi_qsd.c:		.of_match_table = msm_spi_dt_match,
spi/spi_qsd.c:	.probe		= msm_spi_probe,
spi/spi_qsd.c:	.remove		= msm_spi_remove,
spi/spi_qsd.c:module_platform_driver(msm_spi_driver);
spi/spi_qsd.h:enum msm_spi_state {
spi/spi_qsd.h:enum msm_spi_qup_version {
spi/spi_qsd.h:enum msm_spi_pipe_direction {
spi/spi_qsd.h:enum msm_spi_clk_path_vec_idx {
spi/spi_qsd.h:enum msm_spi_mode {
spi/spi_qsd.h:struct msm_spi_debugfs_data {
spi/spi_qsd.h:	struct msm_spi *dd;
spi/spi_qsd.h:static struct msm_spi_regs{
spi/spi_qsd.h:struct msm_spi_bam_pipe {
spi/spi_qsd.h:struct msm_spi_bam {
spi/spi_qsd.h:	struct msm_spi_bam_pipe  prod;
spi/spi_qsd.h:	struct msm_spi_bam_pipe  cons;
spi/spi_qsd.h:struct msm_spi {
spi/spi_qsd.h:	struct msm_bus_client_handle *bus_cl_hdl;
spi/spi_qsd.h:	enum msm_spi_mode        tx_mode;
spi/spi_qsd.h:	enum msm_spi_mode        rx_mode;
spi/spi_qsd.h:	int                      (*dma_init)(struct msm_spi *dd);
spi/spi_qsd.h:	void                     (*dma_teardown)(struct msm_spi *dd);
spi/spi_qsd.h:	struct msm_spi_bam       bam;
spi/spi_qsd.h:	struct msm_spi_debugfs_data reg_data[ARRAY_SIZE(debugfs_spi_regs)];
spi/spi_qsd.h:	struct msm_spi_platform_data *pdata; /* Platform data */
spi/spi_qsd.h:	enum msm_spi_qup_version qup_ver;
spi/spi_qsd.h:static irqreturn_t msm_spi_input_irq(int irq, void *dev_id);
spi/spi_qsd.h:static irqreturn_t msm_spi_output_irq(int irq, void *dev_id);
spi/spi_qsd.h:static irqreturn_t msm_spi_error_irq(int irq, void *dev_id);
spi/spi_qsd.h:static inline int msm_spi_set_state(struct msm_spi *dd,
spi/spi_qsd.h:				    enum msm_spi_state state);
spi/spi_qsd.h:static void msm_spi_write_word_to_fifo(struct msm_spi *dd);
spi/spi_qsd.h:static inline void msm_spi_write_rmn_to_fifo(struct msm_spi *dd);
spi/spi_qsd.h:static irqreturn_t msm_spi_qup_irq(int irq, void *dev_id);
spi/spi_qsd.h:static inline void msm_spi_disable_irqs(struct msm_spi *dd)
spi/spi_qsd.h:static inline void msm_spi_enable_irqs(struct msm_spi *dd)
spi/spi_qsd.h:static inline int msm_spi_request_irq(struct msm_spi *dd,
spi/spi_qsd.h:	rc = devm_request_irq(dd->dev, dd->irq_in, msm_spi_input_irq,
spi/spi_qsd.h:	rc = devm_request_irq(dd->dev, dd->irq_out, msm_spi_output_irq,
spi/spi_qsd.h:	rc = devm_request_irq(dd->dev, dd->irq_err, msm_spi_error_irq,
spi/spi_qsd.h:static inline void msm_spi_get_clk_err(struct msm_spi *dd, u32 *spi_err) {}
spi/spi_qsd.h:static inline void msm_spi_ack_clk_err(struct msm_spi *dd) {}
spi/spi_qsd.h:static inline void msm_spi_set_qup_config(struct msm_spi *dd, int bpw) {}
spi/spi_qsd.h:static inline int  msm_spi_prepare_for_write(struct msm_spi *dd) { return 0; }
spi/spi_qsd.h:static inline void msm_spi_start_write(struct msm_spi *dd, u32 read_count)
spi/spi_qsd.h:	msm_spi_write_word_to_fifo(dd);
spi/spi_qsd.h:static inline void msm_spi_set_write_count(struct msm_spi *dd, int val) {}
spi/spi_qsd.h:static inline void msm_spi_complete(struct msm_spi *dd)
spi/spi_qsd.h:static inline void msm_spi_enable_error_flags(struct msm_spi *dd)
spi/spi_qsd.h:static inline void msm_spi_clear_error_flags(struct msm_spi *dd)
spi/spi_qsd.h:static inline int msm_spi_request_irq(struct msm_spi *dd,
spi/spi_qsd.h:	return devm_request_irq(dd->dev, dd->irq_in, msm_spi_qup_irq,
spi/spi_qsd.h:static inline void msm_spi_disable_irqs(struct msm_spi *dd)
spi/spi_qsd.h:static inline void msm_spi_enable_irqs(struct msm_spi *dd)
spi/spi_qsd.h:static inline void msm_spi_get_clk_err(struct msm_spi *dd, u32 *spi_err)
spi/spi_qsd.h:static inline void msm_spi_ack_clk_err(struct msm_spi *dd)
spi/spi_qsd.h:msm_spi_set_bpw_and_no_io_flags(struct msm_spi *dd, u32 *config, int n);
spi/spi_qsd.h: * msm_spi_set_qup_config: set QUP_CONFIG to no_input, no_output, and N bits
spi/spi_qsd.h:static inline void msm_spi_set_qup_config(struct msm_spi *dd, int bpw)
spi/spi_qsd.h:	msm_spi_set_bpw_and_no_io_flags(dd, &qup_config, bpw-1);
spi/spi_qsd.h:static inline int msm_spi_prepare_for_write(struct msm_spi *dd)
spi/spi_qsd.h:	if (msm_spi_set_state(dd, SPI_OP_STATE_RUN))
spi/spi_qsd.h:	if (msm_spi_set_state(dd, SPI_OP_STATE_PAUSE))
spi/spi_qsd.h:static inline void msm_spi_start_write(struct msm_spi *dd, u32 read_count)
spi/spi_qsd.h:	msm_spi_write_rmn_to_fifo(dd);
spi/spi_qsd.h:static inline void msm_spi_set_write_count(struct msm_spi *dd, int val)
spi/spi_qsd.h:static inline void msm_spi_complete(struct msm_spi *dd)
spi/spi_qsd.h:static inline void msm_spi_enable_error_flags(struct msm_spi *dd)
spi/spi_qsd.h:static inline void msm_spi_clear_error_flags(struct msm_spi *dd)
staging/android/ion/Makefile:			ion_secure_util.o ion_cma_secure_heap.o msm/
staging/android/ion/ion.c:#include <linux/msm_dma_iommu_mapping.h>
staging/android/ion/ion.c:	msm_dma_buf_freed(&buffer->iommu_data);
staging/android/ion/ion.c:		count = msm_dma_map_sg_attrs(attachment->dev, table->sgl,
staging/android/ion/ion.c:		msm_dma_unmap_sg_attrs(attachment->dev, table->sgl,
staging/android/ion/ion.h:#include <linux/msm_dma_iommu_mapping.h>
staging/android/ion/ion.h:#include "../uapi/msm_ion.h"
staging/android/ion/ion.h:	struct msm_iommu_data iommu_data;
staging/android/ion/ion_carveout_heap.c:#include <linux/msm_ion.h>
staging/android/ion/ion_cma_secure_heap.c:#include <linux/msm_ion.h>
staging/android/ion/ion_cma_secure_heap.c:		if (!msm_secure_v2_is_supported()) {
staging/android/ion/ion_cma_secure_heap.c:			ret = msm_secure_table(buf->table);
staging/android/ion/ion_cma_secure_heap.c:	if (msm_secure_v2_is_supported())
staging/android/ion/ion_cma_secure_heap.c:		ret = msm_unsecure_table(info->table);
staging/android/ion/ion_kernel.h:#include "../uapi/msm_ion.h"
staging/android/ion/ion_secure_util.c:		dest_perms[i] = msm_secure_get_vmid_perms(dest_vm_list[i]);
staging/android/ion/ion_secure_util.c:		modes[i] = msm_secure_get_vmid_perms(vmids[i]);
staging/android/ion/msm/Makefile:obj-y += msm_ion_of.o
staging/android/ion/msm/msm_ion_of.c:#define ION_COMPAT_STR	"qcom,msm-ion"
staging/android/ion/msm/msm_ion_of.c:static int msm_ion_get_heap_type_from_dt_node(struct device_node *node,
staging/android/ion/msm/msm_ion_of.c:static int msm_ion_populate_heap(struct device_node *node,
staging/android/ion/msm/msm_ion_of.c:			ret = msm_ion_get_heap_type_from_dt_node(node,
staging/android/ion/msm/msm_ion_of.c:static int msm_ion_get_heap_dt_data(struct device_node *node,
staging/android/ion/msm/msm_ion_of.c:static struct ion_platform_data *msm_ion_parse_dt(struct platform_device *pdev)
staging/android/ion/msm/msm_ion_of.c:		ret = msm_ion_populate_heap(node, &pdata->heaps[idx]);
staging/android/ion/msm/msm_ion_of.c:		ret = msm_ion_get_heap_dt_data(node, &pdata->heaps[idx]);
staging/android/ion/msm/msm_ion_of.c:static struct ion_platform_data *msm_ion_parse_dt(struct platform_device *pdev)
staging/android/ion/msm/msm_ion_of.c:static int msm_ion_probe(struct platform_device *pdev)
staging/android/ion/msm/msm_ion_of.c:		pdata = msm_ion_parse_dt(pdev);
staging/android/ion/msm/msm_ion_of.c:static const struct of_device_id msm_ion_match_table[] = {
staging/android/ion/msm/msm_ion_of.c:static struct platform_driver msm_ion_driver = {
staging/android/ion/msm/msm_ion_of.c:	.probe = msm_ion_probe,
staging/android/ion/msm/msm_ion_of.c:		.name = "ion-msm",
staging/android/ion/msm/msm_ion_of.c:		.of_match_table = msm_ion_match_table,
staging/android/ion/msm/msm_ion_of.c:static int __init msm_ion_init(void)
staging/android/ion/msm/msm_ion_of.c:	return platform_driver_register(&msm_ion_driver);
staging/android/ion/msm/msm_ion_of.c:subsys_initcall(msm_ion_init);
staging/android/uapi/msm_ion.h:enum msm_ion_heap_types {
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/kiwi/v1/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/kiwi/v1/msmhwioreg.h:#include "msmhwiobase.h"
staging/fw-api/hw/kiwi/v1/wcss_seq_hwioreg_umac.h:#include "msmhwio.h"
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS 
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/kiwi/v2/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/kiwi/v2/msmhwioreg.h:#include "msmhwiobase.h"
staging/fw-api/hw/kiwi/v2/wcss_seq_hwioreg_umac.h:#include "msmhwio.h"
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qca5018/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS 
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qca5018/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qca5018/mac_tcl_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca5018/mac_tcl_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca5018/reo_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca5018/reo_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca5018/rfa_from_wsi_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca5018/seq_hwio.h: * - This is an extension of standard msmhwio.h to support relative addressing
staging/fw-api/hw/qca5018/seq_hwio.h: * - As such, macros defined in this file must be used with 'seq_msmhwiobase.h',
staging/fw-api/hw/qca5018/seq_hwio.h: *   'seq_msmhwioreg.h', and the C codes generated from SCALe Autoseq.
staging/fw-api/hw/qca5018/seq_hwio.h: *   standard 'msmhwio.h', and the two sets of macros are compatible.
staging/fw-api/hw/qca5018/wbm_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca5018/wbm_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca5018/wcss_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca5018/wcss_seq_hwiobase_ext.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS 
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qca6290/11ax/v1/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6290/11ax/v1/mac_tcl_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v1/mac_tcl_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v1/msmhwio.h:  @file msmhwio.h 
staging/fw-api/hw/qca6290/11ax/v1/msmhwio.h:  The msmhwio.h file is the legacy public API interface to the HW I/O (HWIO)
staging/fw-api/hw/qca6290/11ax/v1/msmhwio.h:  $Header: //components/rel/core.mpss/3.9.2/api/systemdrivers/msmhwio.h#1 $ $DateTime: 2016/01/19 23:36:58 $ $Author: pwbldsvc $
staging/fw-api/hw/qca6290/11ax/v1/reo_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v1/reo_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v1/wbm_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v1/wbm_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v1/wcss_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v1/wfss_ce_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v1/wfss_ce_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS 
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qca6290/11ax/v2/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6290/11ax/v2/mac_tcl_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v2/mac_tcl_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v2/msmhwio.h:  @file msmhwio.h 
staging/fw-api/hw/qca6290/11ax/v2/msmhwio.h:  The msmhwio.h file is the legacy public API interface to the HW I/O (HWIO)
staging/fw-api/hw/qca6290/11ax/v2/msmhwio.h:  $Header: //components/rel/core.mpss/3.9.2/api/systemdrivers/msmhwio.h#1 $ $DateTime: 2016/01/19 23:36:58 $ $Author: pwbldsvc $
staging/fw-api/hw/qca6290/11ax/v2/reo_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v2/reo_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v2/wbm_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v2/wbm_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v2/wcss_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v2/wfss_ce_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/11ax/v2/wfss_ce_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS 
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qca6290/v1/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6290/v1/mac_tcl_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v1/mac_tcl_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v1/msmhwio.h:  @file msmhwio.h 
staging/fw-api/hw/qca6290/v1/msmhwio.h:  The msmhwio.h file is the legacy public API interface to the HW I/O (HWIO)
staging/fw-api/hw/qca6290/v1/msmhwio.h:  $Header: //components/rel/core.mpss/3.9.2/api/systemdrivers/msmhwio.h#1 $ $DateTime: 2016/01/19 23:36:58 $ $Author: pwbldsvc $
staging/fw-api/hw/qca6290/v1/reo_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v1/reo_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v1/seq_hwio.h: * - This is an extension of standard msmhwio.h to support relative addressing
staging/fw-api/hw/qca6290/v1/seq_hwio.h: * - As such, macros defined in this file must be used with 'seq_msmhwiobase.h',
staging/fw-api/hw/qca6290/v1/seq_hwio.h: *   'seq_msmhwioreg.h', and the C codes generated from SCALe Autoseq.
staging/fw-api/hw/qca6290/v1/seq_hwio.h: *   standard 'msmhwio.h', and the two sets of macros are compatible.
staging/fw-api/hw/qca6290/v1/wbm_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v1/wbm_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v1/wcss_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v1/wfss_ce_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v1/wfss_ce_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS 
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qca6290/v2/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6290/v2/mac_tcl_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v2/mac_tcl_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v2/msmhwio.h:  @file msmhwio.h 
staging/fw-api/hw/qca6290/v2/msmhwio.h:  The msmhwio.h file is the legacy public API interface to the HW I/O (HWIO)
staging/fw-api/hw/qca6290/v2/msmhwio.h:  $Header: //components/rel/core.mpss/3.9.2/api/systemdrivers/msmhwio.h#1 $ $DateTime: 2016/01/19 23:36:58 $ $Author: pwbldsvc $
staging/fw-api/hw/qca6290/v2/reo_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v2/reo_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v2/seq_hwio.h: * - This is an extension of standard msmhwio.h to support relative addressing
staging/fw-api/hw/qca6290/v2/seq_hwio.h: * - As such, macros defined in this file must be used with 'seq_msmhwiobase.h',
staging/fw-api/hw/qca6290/v2/seq_hwio.h: *   'seq_msmhwioreg.h', and the C codes generated from SCALe Autoseq.
staging/fw-api/hw/qca6290/v2/seq_hwio.h: *   standard 'msmhwio.h', and the two sets of macros are compatible.
staging/fw-api/hw/qca6290/v2/wbm_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v2/wbm_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v2/wcss_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v2/wfss_ce_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6290/v2/wfss_ce_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS 
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qca6390/v1/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6390/v1/mac_tcl_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6390/v1/mac_tcl_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6390/v1/reo_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6390/v1/reo_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6390/v1/seq_hwio.h: * - This is an extension of standard msmhwio.h to support relative addressing
staging/fw-api/hw/qca6390/v1/seq_hwio.h: * - As such, macros defined in this file must be used with 'seq_msmhwiobase.h',
staging/fw-api/hw/qca6390/v1/seq_hwio.h: *   'seq_msmhwioreg.h', and the C codes generated from SCALe Autoseq.
staging/fw-api/hw/qca6390/v1/seq_hwio.h: *   standard 'msmhwio.h', and the two sets of macros are compatible.
staging/fw-api/hw/qca6390/v1/wbm_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6390/v1/wbm_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6390/v1/wcss_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6390/v1/wfss_ce_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6390/v1/wfss_ce_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qca6490/v1/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6490/v1/mac_tcl_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6490/v1/mac_tcl_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6490/v1/reo_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6490/v1/reo_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6490/v1/seq_hwio.h: * - This is an extension of standard msmhwio.h to support relative addressing
staging/fw-api/hw/qca6490/v1/seq_hwio.h: * - As such, macros defined in this file must be used with 'seq_msmhwiobase.h',
staging/fw-api/hw/qca6490/v1/seq_hwio.h: *   'seq_msmhwioreg.h', and the C codes generated from SCALe Autoseq.
staging/fw-api/hw/qca6490/v1/seq_hwio.h: *   standard 'msmhwio.h', and the two sets of macros are compatible.
staging/fw-api/hw/qca6490/v1/wbm_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6490/v1/wbm_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6490/v1/wcss_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6490/v1/wfss_ce_channel_dst_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6490/v1/wfss_ce_channel_dst_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6490/v1/wfss_ce_channel_src_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6490/v1/wfss_ce_channel_src_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qca6750/v1/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qca6750/v1/mac_tcl_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6750/v1/mac_tcl_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6750/v1/reo_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6750/v1/reo_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6750/v1/seq_hwio.h: * - This is an extension of standard msmhwio.h to support relative addressing
staging/fw-api/hw/qca6750/v1/seq_hwio.h: * - As such, macros defined in this file must be used with 'seq_msmhwiobase.h',
staging/fw-api/hw/qca6750/v1/seq_hwio.h: *   'seq_msmhwioreg.h', and the C codes generated from SCALe Autoseq.
staging/fw-api/hw/qca6750/v1/seq_hwio.h: *   standard 'msmhwio.h', and the two sets of macros are compatible.
staging/fw-api/hw/qca6750/v1/wbm_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6750/v1/wbm_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca6750/v1/wcss_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qca8074/v1/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qca8074/v1/mac_tcl_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v1/mac_tcl_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v1/msmhwio.h:  @file msmhwio.h 
staging/fw-api/hw/qca8074/v1/msmhwio.h:  The msmhwio.h file is the legacy public API interface to the HW I/O (HWIO)
staging/fw-api/hw/qca8074/v1/msmhwio.h:  $Header: //components/rel/core.mpss/3.9.2/api/systemdrivers/msmhwio.h#1 $ $DateTime: 2016/01/19 23:36:58 $ $Author: pwbldsvc $
staging/fw-api/hw/qca8074/v1/reo_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v1/reo_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v1/seq_hwio.h: * - This is an extension of standard msmhwio.h to support relative addressing
staging/fw-api/hw/qca8074/v1/seq_hwio.h: * - As such, macros defined in this file must be used with 'seq_msmhwiobase.h',
staging/fw-api/hw/qca8074/v1/seq_hwio.h: *   'seq_msmhwioreg.h', and the C codes generated from SCALe Autoseq.
staging/fw-api/hw/qca8074/v1/seq_hwio.h: *   standard 'msmhwio.h', and the two sets of macros are compatible.
staging/fw-api/hw/qca8074/v1/wbm_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v1/wbm_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v1/wcss_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v1/wfss_ce_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v1/wfss_ce_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS 
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qca8074/v2/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qca8074/v2/mac_tcl_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v2/mac_tcl_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v2/reo_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v2/reo_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v2/seq_hwio.h: * - This is an extension of standard msmhwio.h to support relative addressing
staging/fw-api/hw/qca8074/v2/seq_hwio.h: * - As such, macros defined in this file must be used with 'seq_msmhwiobase.h',
staging/fw-api/hw/qca8074/v2/seq_hwio.h: *   'seq_msmhwioreg.h', and the C codes generated from SCALe Autoseq.
staging/fw-api/hw/qca8074/v2/seq_hwio.h: *   standard 'msmhwio.h', and the two sets of macros are compatible.
staging/fw-api/hw/qca8074/v2/wbm_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v2/wbm_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v2/wcss_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v2/wfss_ce_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca8074/v2/wfss_ce_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qca9574/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS 
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qca9574/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qca9574/mac_tcl_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca9574/mac_tcl_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca9574/reo_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca9574/reo_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca9574/seq_hwio.h: * - This is an extension of standard msmhwio.h to support relative addressing
staging/fw-api/hw/qca9574/seq_hwio.h: * - As such, macros defined in this file must be used with 'seq_msmhwiobase.h',
staging/fw-api/hw/qca9574/seq_hwio.h: *   'seq_msmhwioreg.h', and the C codes generated from SCALe Autoseq.
staging/fw-api/hw/qca9574/seq_hwio.h: *   standard 'msmhwio.h', and the two sets of macros are compatible.
staging/fw-api/hw/qca9574/wbm_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca9574/wbm_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qca9574/wcss_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca9574/wfss_ce_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qca9574/wfss_ce_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qcn6122/HALhwio.h:#define HWIO_SPRUCE_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_SPRUCE_##hwiosym##_IN
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_SPRUCE_##hwiosym##_INI(index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_SPRUCE_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_SPRUCE_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_SPRUCE_##hwiosym##_INM(mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_SPRUCE_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_SPRUCE_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_SPRUCE_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_SPRUCE_##hwiosym##_OUT(val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_SPRUCE_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_SPRUCE_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_SPRUCE_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_SPRUCE_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_SPRUCE_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_SPRUCE_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_SPRUCE_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_SPRUCE_##hwiosym##_ADDR
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_SPRUCE_##hwiosym##_ADDR(index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_SPRUCE_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_SPRUCE_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_SPRUCE_##hwiosym##_PHYS
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_SPRUCE_##hwiosym##_PHYS(index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_SPRUCE_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_SPRUCE_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_SPRUCE_##hwiosym##_OFFS 
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_SPRUCE_##hwiosym##_OFFS(index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_SPRUCE_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_SPRUCE_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_SPRUCE_##hwiosym##_RMSK
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_SPRUCE_##hwiosym##_RMSK(index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_SPRUCE_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_SPRUCE_##hwiosym##_SHFT
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_SPRUCE_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_SPRUCE_##hwiosym##_shadow
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_SPRUCE_##hwiosym##_SHDW(index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_SPRUCE_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_SPRUCE_##hwiosym##_IN(base)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_SPRUCE_##hwiosym##_INI(base, index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_SPRUCE_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_SPRUCE_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_SPRUCE_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_SPRUCE_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_SPRUCE_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_SPRUCE_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_SPRUCE_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_SPRUCE_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_SPRUCE_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_SPRUCE_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_SPRUCE_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_SPRUCE_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_SPRUCE_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_SPRUCE_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_SPRUCE_##hwiosym##_ADDR(base)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_SPRUCE_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_SPRUCE_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_SPRUCE_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_SPRUCE_##hwiosym##_PHYS(base)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_SPRUCE_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_SPRUCE_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qcn6122/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_SPRUCE_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qcn6122/mac_tcl_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn6122/mac_tcl_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn6122/reo_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn6122/reo_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn6122/rfa_from_wsi_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn6122/seq_hwio.h://xiuhongs: conflict with msmhwio.h for CDVI_SVTB
staging/fw-api/hw/qcn6122/seq_hwio.h://#include "msmhwio.h"
staging/fw-api/hw/qcn6122/wbm_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn6122/wbm_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn6122/wcss_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn6122/wcss_seq_hwiobase_ext.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn9000/HALhwio.h: * msm<ASIC>reg.h, msm<ASIC>io.h and msm<ASIC>redefs.h. For further background
staging/fw-api/hw/qcn9000/HALhwio.h: * This file, together with msmhwioreg.h, provides a portable interface
staging/fw-api/hw/qcn9000/HALhwio.h: * I/O software. The interface defined by msmhwio.h and msmhwioreg.h
staging/fw-api/hw/qcn9000/HALhwio.h: * msmhwioreg.h is an auto-generated file that may be subsequently edited
staging/fw-api/hw/qcn9000/HALhwio.h: * hand edit msmhwioreg.h or msm<ASIC>reg.h except to cut/paste registers
staging/fw-api/hw/qcn9000/HALhwio.h: * or bitmasks from msm<ASIC>reg.h to msm<ASIC>reg_port.h or from msmhwioreg.h
staging/fw-api/hw/qcn9000/HALhwio.h: * to msmhwioreg_port.h. One edits an msmreg.pl input file, possibly named
staging/fw-api/hw/qcn9000/HALhwio.h: * something like msmreg_port.dat, to add patterns which msmreg.pl matches
staging/fw-api/hw/qcn9000/HALhwio.h: * of hand edits on each successive re-parse of chip address file. See msmreg.pl
staging/fw-api/hw/qcn9000/HALhwio.h: * msmhwioreg.h also handles register access method changes by allowing users
staging/fw-api/hw/qcn9000/HALhwio.h: * 06/16/05   eav     Changed  __msmhwio_addri to call HWIO_##hwiosym##_ADDRI
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qcn9000/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS 
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI3(base, index1, index2, index3, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qcn9000/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qcn9000/HALhwio.h:    uint32 msm_sav;                   \
staging/fw-api/hw/qcn9000/HALhwio.h:    INTLOCK_SAV(msm_sav)
staging/fw-api/hw/qcn9000/HALhwio.h:    INTFREE_SAV(msm_sav);  \
staging/fw-api/hw/qcn9000/HALhwio.h:    INTFREE_SAV( msm_sav ),    \
staging/fw-api/hw/qcn9000/HALhwio.h:    INTLOCK_SAV( msm_sav )
staging/fw-api/hw/qcn9000/mac_tcl_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn9000/mac_tcl_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn9000/msmhwiobase.h:  @file msmhwiobase.h
staging/fw-api/hw/qcn9000/reo_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn9000/reo_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn9000/rfa_from_wsi_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn9000/seq_hwio.h: * - This is an extension of standard msmhwio.h to support relative addressing
staging/fw-api/hw/qcn9000/seq_hwio.h: * - As such, macros defined in this file must be used with 'seq_msmhwiobase.h',
staging/fw-api/hw/qcn9000/seq_hwio.h: *   'seq_msmhwioreg.h', and the C codes generated from SCALe Autoseq.
staging/fw-api/hw/qcn9000/seq_hwio.h: *   standard 'msmhwio.h', and the two sets of macros are compatible.
staging/fw-api/hw/qcn9000/wbm_reg_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn9000/wbm_reg_seq_hwioreg.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn9000/wcss_seq_hwiobase.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn9000/wcss_seq_hwiobase_ext.h:	#include "msmhwio.h"
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_ADDR(hwiosym)                               __msmhwio_addr(hwiosym)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_ADDRI(hwiosym, index)                       __msmhwio_addri(hwiosym, index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_ADDRI2(hwiosym, index1, index2)             __msmhwio_addri2(hwiosym, index1, index2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_ADDRI3(hwiosym, index1, index2, index3)     __msmhwio_addri3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_ADDRX(base, hwiosym)                           __msmhwio_addrx(base, hwiosym)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_ADDRXI(base, hwiosym, index)                   __msmhwio_addrxi(base, hwiosym, index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_ADDRXI2(base, hwiosym, index1, index2)         __msmhwio_addrxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_ADDRXI3(base, hwiosym, index1, index2, index3) __msmhwio_addrxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_PHYS(hwiosym)                               __msmhwio_phys(hwiosym)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_PHYSI(hwiosym, index)                       __msmhwio_physi(hwiosym, index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_PHYSI2(hwiosym, index1, index2)             __msmhwio_physi2(hwiosym, index1, index2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_PHYSI3(hwiosym, index1, index2, index3)     __msmhwio_physi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_PHYSX(base, hwiosym)                           __msmhwio_physx(base, hwiosym)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_PHYSXI(base, hwiosym, index)                   __msmhwio_physxi(base, hwiosym, index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_PHYSXI2(base, hwiosym, index1, index2)         __msmhwio_physxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_PHYSXI3(base, hwiosym, index1, index2, index3) __msmhwio_physxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OFFS(hwiosym)                               __msmhwio_offs(hwiosym)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OFFSI(hwiosym, index)                       __msmhwio_offsi(hwiosym, index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OFFSI2(hwiosym, index1, index2)             __msmhwio_offsi2(hwiosym, index1, index2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OFFSI3(hwiosym, index1, index2, index3)     __msmhwio_offsi3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_IN(hwiosym)                                         __msmhwio_in(hwiosym)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INI(hwiosym, index)                                 __msmhwio_ini(hwiosym, index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INI2(hwiosym, index1, index2)                       __msmhwio_ini2(hwiosym, index1, index2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INI3(hwiosym, index1, index2, index3)               __msmhwio_ini3(hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INM(hwiosym, mask)                                  __msmhwio_inm(hwiosym, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INMI(hwiosym, index, mask)                          __msmhwio_inmi(hwiosym, index, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INMI2(hwiosym, index1, index2, mask)                __msmhwio_inmi2(hwiosym, index1, index2, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INMI3(hwiosym, index1, index2, index3, mask)        __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INX(base, hwiosym)                                  __msmhwio_inx(base, hwiosym)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INXI(base, hwiosym, index)                          __msmhwio_inxi(base, hwiosym, index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INXI2(base, hwiosym, index1, index2)                __msmhwio_inxi2(base, hwiosym, index1, index2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INXI3(base, hwiosym, index1, index2, index3)        __msmhwio_inxi3(base, hwiosym, index1, index2, index3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INXM(base, hwiosym, mask)                           __msmhwio_inxm(base, hwiosym, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INXMI(base, hwiosym, index, mask)                   __msmhwio_inxmi(base, hwiosym, index, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INXMI2(base, hwiosym, index1, index2, mask)         __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_INXMI3(base, hwiosym, index1, index2, index3, mask) __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUT(hwiosym, val)                                   __msmhwio_out(hwiosym, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTI(hwiosym, index, val)                           __msmhwio_outi(hwiosym, index, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTI2(hwiosym, index1, index2, val)                 __msmhwio_outi2(hwiosym, index1, index2, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTI3(hwiosym, index1, index2, index3, val)         __msmhwio_outi3(hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTM(hwiosym, mask, val)                            __msmhwio_outm(hwiosym, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTMI(hwiosym, index, mask, val)                    __msmhwio_outmi(hwiosym, index, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTMI2(hwiosym, index1, index2, mask, val)          __msmhwio_outmi2(hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTMI3(hwiosym, index1, index2, index3, mask, val)  __msmhwio_outmi3(hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTX(base, hwiosym, val)                                   __msmhwio_outx(base, hwiosym, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTXI(base, hwiosym, index, val)                           __msmhwio_outxi(base, hwiosym, index, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTXI2(base, hwiosym, index1, index2, val)                 __msmhwio_outxi2(base, hwiosym, index1, index2, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTXI3(base, hwiosym, index1, index2, index3, val)         __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTXM(base, hwiosym, mask, val)                            __msmhwio_outxm(base, hwiosym, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTXM2(base, hwiosym, mask1, mask2, val1, val2)  __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTXM3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3) __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3, val1, val2, val3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTXM4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTXMI(base, hwiosym, index, mask, val)                    __msmhwio_outxmi(base, hwiosym, index, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTXMI2(base, hwiosym, index1, index2, mask, val)          __msmhwio_outxmi2(base, hwiosym, index1, index2, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_OUTXMI3(base, hwiosym, index1, index2, index3, mask, val)  __msmhwio_outxmi3(base, hwiosym, index1, index2, index3, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_RMSK(hwiosym)                               __msmhwio_rmsk(hwiosym)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_RMSKI(hwiosym, index)                       __msmhwio_rmski(hwiosym, index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_RSHFT(hwiosym)                              __msmhwio_rshft(hwiosym)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_SHFT(hwio_regsym, hwio_fldsym)              __msmhwio_shft(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_FMSK(hwio_regsym, hwio_fldsym)              __msmhwio_fmsk(hwio_regsym, hwio_fldsym)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_VAL(io, field, val)                         __msmhwio_val(io, field, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_SHDW(hwiosym)                               __msmhwio_shdw(hwiosym)
staging/fw-api/hw/qcn9224/HALhwio.h:#define HWIO_SHDWI(hwiosym, index)                       __msmhwio_shdwi(hwiosym, index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_in(hwiosym)                                   HWIO_##hwiosym##_IN
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_ini(hwiosym, index)                           HWIO_##hwiosym##_INI(index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_ini2(hwiosym, index1, index2)                 HWIO_##hwiosym##_INI2(index1, index2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_ini3(hwiosym, index1, index2, index3)         HWIO_##hwiosym##_INI3(index1, index2, index3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_inm(hwiosym, mask)                            HWIO_##hwiosym##_INM(mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_inmi(hwiosym, index, mask)                    HWIO_##hwiosym##_INMI(index, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_inmi2(hwiosym, index1, index2, mask)          HWIO_##hwiosym##_INMI2(index1, index2, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_inmi3(hwiosym, index1, index2, index3, mask)  HWIO_##hwiosym##_INMI3(index1, index2, index3, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_out(hwiosym, val)                             HWIO_##hwiosym##_OUT(val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outi(hwiosym, index, val)                     HWIO_##hwiosym##_OUTI(index,val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outi2(hwiosym, index1, index2, val)           HWIO_##hwiosym##_OUTI2(index1, index2, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outi3(hwiosym, index1, index2, index3, val)   HWIO_##hwiosym##_OUTI2(index1, index2, index3, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outm(hwiosym, mask, val)                      HWIO_##hwiosym##_OUTM(mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outmi(hwiosym, index, mask, val)              HWIO_##hwiosym##_OUTMI(index, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outmi2(hwiosym, idx1, idx2, mask, val)        HWIO_##hwiosym##_OUTMI2(idx1, idx2, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outmi3(hwiosym, idx1, idx2, idx3, mask, val)  HWIO_##hwiosym##_OUTMI3(idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_addr(hwiosym)                                 HWIO_##hwiosym##_ADDR
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_addri(hwiosym, index)                         HWIO_##hwiosym##_ADDR(index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_addri2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_ADDR(idx1, idx2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_addri3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_ADDR(idx1, idx2, idx3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_phys(hwiosym)                                 HWIO_##hwiosym##_PHYS
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_physi(hwiosym, index)                         HWIO_##hwiosym##_PHYS(index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_physi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_PHYS(idx1, idx2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_physi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_PHYS(idx1, idx2, idx3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_offs(hwiosym)                                 HWIO_##hwiosym##_OFFS 
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_offsi(hwiosym, index)                         HWIO_##hwiosym##_OFFS(index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_offsi2(hwiosym, idx1, idx2)                   HWIO_##hwiosym##_OFFS(idx1, idx2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_offsi3(hwiosym, idx1, idx2, idx3)             HWIO_##hwiosym##_OFFS(idx1, idx2, idx3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_rmsk(hwiosym)                                 HWIO_##hwiosym##_RMSK
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_rmski(hwiosym, index)                         HWIO_##hwiosym##_RMSK(index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_fmsk(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_BMSK
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_rshft(hwiosym)                                HWIO_##hwiosym##_SHFT
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_shft(hwiosym, hwiofldsym)                     HWIO_##hwiosym##_##hwiofldsym##_SHFT
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_shdw(hwiosym)                                 HWIO_##hwiosym##_shadow
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_shdwi(hwiosym, index)                         HWIO_##hwiosym##_SHDW(index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_val(hwiosym, hwiofld, hwioval)                HWIO_##hwiosym##_##hwiofld##_##hwioval##_FVAL
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_inx(base, hwiosym)                                  HWIO_##hwiosym##_IN(base)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_inxi(base, hwiosym, index)                          HWIO_##hwiosym##_INI(base, index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_inxi2(base, hwiosym, index1, index2)                HWIO_##hwiosym##_INI2(base, index1, index2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_inxi3(base, hwiosym, index1, index2, index3)        HWIO_##hwiosym##_INI3(base, index1, index2, index3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_inxm(base, hwiosym, mask)                           HWIO_##hwiosym##_INM(base, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_inxmi(base, hwiosym, index, mask)                   HWIO_##hwiosym##_INMI(base, index, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_inxmi2(base, hwiosym, index1, index2, mask)         HWIO_##hwiosym##_INMI2(base, index1, index2, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_inxmi3(base, hwiosym, index1, index2, index3, mask) HWIO_##hwiosym##_INMI3(base, index1, index2, index3, mask)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outx(base, hwiosym, val)                            HWIO_##hwiosym##_OUT(base, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outxi(base, hwiosym, index, val)                    HWIO_##hwiosym##_OUTI(base, index,val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outxi2(base, hwiosym, index1, index2, val)          HWIO_##hwiosym##_OUTI2(base, index1, index2, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outxi3(base, hwiosym, index1, index2, index3, val)  HWIO_##hwiosym##_OUTI2(base, index1, index2, index3, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outxm(base, hwiosym, mask, val)                     HWIO_##hwiosym##_OUTM(base, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outxm2(base, hwiosym, mask1, mask2, val1, val2)  {	\
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outxm3(base, hwiosym, mask1, mask2, mask3,  val1, val2, val3) { \
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outxm4(base, hwiosym, mask1, mask2, mask3, mask4, val1, val2, val3, val4) { \
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outxmi(base, hwiosym, index, mask, val)             HWIO_##hwiosym##_OUTMI(base, index, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outxmi2(base, hwiosym, idx1, idx2, mask, val)       HWIO_##hwiosym##_OUTMI2(base, idx1, idx2, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_outxmi3(base, hwiosym, idx1, idx2, idx3, mask, val) HWIO_##hwiosym##_OUTMI3(base, idx1, idx2, idx3, mask, val)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_addrx(base, hwiosym)                                HWIO_##hwiosym##_ADDR(base)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_addrxi(base, hwiosym, index)                        HWIO_##hwiosym##_ADDR(base, index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_addrxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_ADDR(base, idx1, idx2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_addrxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_ADDR(base, idx1, idx2, idx3)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_physx(base, hwiosym)                                HWIO_##hwiosym##_PHYS(base)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_physxi(base, hwiosym, index)                        HWIO_##hwiosym##_PHYS(base, index)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_physxi2(base, hwiosym, idx1, idx2)                  HWIO_##hwiosym##_PHYS(base, idx1, idx2)
staging/fw-api/hw/qcn9224/HALhwio.h:#define __msmhwio_physxi3(base, hwiosym, idx1, idx2, idx3)            HWIO_##hwiosym##_PHYS(base, idx1, idx2, idx3)
staging/fw-api/hw/qcn9224/wcss_seq_hwioreg_umac.h:#include "msmhwio.h"
staging/qca-wifi-host-cmn/hif/src/hif_irq_affinity.c: *      So, NAPI indicates to msm-irqbalancer that it wants to be blacklisted,
staging/qca-wifi-host-cmn/hif/src/hif_napi.c: *      So, NAPI indicates to msm-irqbalancer that it wants to be blacklisted,
staging/qca-wifi-host-cmn/hif/src/ipcie/if_ipci.c:#include <linux/msm_pcie.h>
staging/qca-wifi-host-cmn/hif/src/pcie/if_pci.c:#include <linux/msm_pcie.h>
staging/qca-wifi-host-cmn/hif/src/snoc/if_snoc.c:#include <uapi/linux/msm_ipa.h>
staging/qca-wifi-host-cmn/qdf/linux/src/i_qdf_time.h: * __qdf_get_log_timestamp() - get msm timer ticks
staging/qcacld-3.0/configs/qca6174_defconfig:# Perf      : Using appropriate msmXXXX-perf_defconfig
staging/qcacld-3.0/configs/default_defconfig:# Perf      : Using appropriate msmXXXX-perf_defconfig
staging/qcacld-3.0/configs/qca6390_defconfig:# Perf      : Using appropriate msmXXXX-perf_defconfig
staging/qcacld-3.0/core/hdd/inc/wlan_hdd_main.h: * @dfs_cac_block_tx: Is data tramsmission blocked due to DFS CAC?
staging/qcacld-3.0/core/hdd/inc/wlan_hdd_tx_rx.h:#define HDD_MSM_CFG(msm_cfg)	msm_cfg
staging/qcacld-3.0/core/hdd/inc/wlan_hdd_tx_rx.h:#define HDD_MSM_CFG(msm_cfg)	0
staging/qcacld-3.0/core/hdd/src/wlan_hdd_assoc.c:				    roam_info->tsm_ie.msmt_interval);
staging/qcacld-3.0/core/mac/inc/sir_api.h:	uint16_t msmt_interval;
staging/qcacld-3.0/core/mac/inc/sir_api.h:	uint16_t msmt_interval;
staging/qcacld-3.0/core/mac/src/cfg/cfgUtil/dot11f.frms:    msmt_interval,  2;
staging/qcacld-3.0/core/mac/src/include/dot11f.h:	uint16_t            msmt_interval;
staging/qcacld-3.0/core/mac/src/pe/lim/lim_api.c:	uint8_t limsmestate;
staging/qcacld-3.0/core/mac/src/pe/lim/lim_api.c:		cmd->limsmestate = session->limSmeState;
staging/qcacld-3.0/core/mac/src/pe/lim/lim_assoc_utils.c:	tsm_ie_ind->tsm_ie.msmt_interval = measurement_interval;
staging/qcacld-3.0/core/mac/src/pe/lim/lim_process_action_frame.c:					addts.tsmIE.msmt_interval);
staging/qcacld-3.0/core/mac/src/pe/lim/lim_process_action_frame.c:				addts.tsmIE.msmt_interval);
staging/qcacld-3.0/core/mac/src/pe/lim/lim_process_assoc_rsp_frame.c:				assoc_rsp->tsmIE.msmt_interval);
staging/qcacld-3.0/core/mac/src/sys/legacy/src/utils/src/dot11f.c:	framesntohs(pCtx, &pDst->msmt_interval, pBuf, 0);
staging/qcacld-3.0/core/mac/src/sys/legacy/src/utils/src/dot11f.c:		frameshtons(pCtx, pBuf, pSrc->msmt_interval, 0);
staging/qcacld-3.0/core/sme/src/common/sme_api.c:	roam_info->tsm_ie.msmt_interval = pSmeTsmIeInd->tsm_ie.msmt_interval;
staging/qcacld-3.0/core/wma/src/wma_features.c:	 * msmt_interval is in unit called TU (1 TU = 1024 us)
staging/qcacld-3.0/core/wma/src/wma_features.c:	 * max value of msmt_interval cannot make resulting
staging/qcacld-3.0/Kbuild:      KERNEL_PATH_4.4 :=  $(shell python -c "import os.path; print(os.path.exists('$(ANDROID_BUILD_TOP)/kernel/msm-4.4'))")
thermal/Makefile:obj-$(CONFIG_THERMAL_TSENS)	+= msm-tsens.o tsens2xxx.o tsens-dbg.o tsens-mtc.o tsens1xxx.o tsens-calib.o
thermal/qcom/Makefile:obj-y += msm_lmh_dcvs.o lmh_dbg.o
thermal/qcom/Makefile:obj-$(CONFIG_QTI_LIMITS_ISENSE_CDSP) += msm_isense_cdsp.o
thermal/qcom/bcl_peripheral.c:		.compatible = "qcom,msm-bcl-lmh",
thermal/qcom/bcl_soc.c:		.compatible = "qcom,msm-bcl-soc",
thermal/qcom/msm_isense_cdsp.c:static int limits_create_msm_limits_cdsp_sysfs(struct platform_device *pdev)
thermal/qcom/msm_isense_cdsp.c:	err = limits_create_msm_limits_cdsp_sysfs(pdev);
thermal/qcom/msm_isense_cdsp.c:	{ .compatible = "qcom,msm-limits-cdsp", },
thermal/qcom/msm_lmh_dcvs.c:	{ .compatible = "qcom,msm-hw-limits", },
thermal/qcom/qti_virtual_sensor.c:		.sensor_names = {"skin-msm-therm-usr",
thermal/qcom/rpm_smd_cooling_device.c:	struct msm_rpm_request		*rpm_handle;
thermal/qcom/rpm_smd_cooling_device.c:	ret = msm_rpm_add_kvp_data(rpm_smd_dev->rpm_handle, RPM_SMD_KEY,
thermal/qcom/rpm_smd_cooling_device.c:	msg_id = msm_rpm_send_request(rpm_smd_dev->rpm_handle);
thermal/qcom/rpm_smd_cooling_device.c:	ret = msm_rpm_wait_for_ack(msg_id);
thermal/qcom/rpm_smd_cooling_device.c:		msm_rpm_free_request(rpm_smd_dev->rpm_handle);
thermal/qcom/rpm_smd_cooling_device.c:	rpm_smd_dev->rpm_handle = msm_rpm_create_request(MSM_RPM_CTX_ACTIVE_SET,
thermal/qcom/tsens-v2.c:/* Kept around for backward compatibility with old msm8996.dtsi */
thermal/qcom/tsens.c:		.compatible = "qcom,msm8916-tsens",
thermal/qcom/tsens.c:		.compatible = "qcom,msm8974-tsens",
thermal/qcom/tsens.c:		.compatible = "qcom,msm8996-tsens",
thermal/tsens1xxx.c:#define TSENS_DRIVER_NAME			"msm-tsens"
thermal/tsens2xxx.c:#define TSENS_DRIVER_NAME			"msm-tsens"
thermal/tsens2xxx.c:static void msm_tsens_convert_temp(int last_temp, int *temp)
thermal/tsens2xxx.c:		msm_tsens_convert_temp(last_temp, temp);
thermal/tsens2xxx.c:		msm_tsens_convert_temp(last_temp, temp);
thermal/tsens2xxx.c:		msm_tsens_convert_temp(last_temp, temp);
thermal/tsens2xxx.c:	msm_tsens_convert_temp(last_temp, temp);
thermal/tsens2xxx.c:		msm_tsens_convert_temp(last_temp, temp);
thermal/tsens2xxx.c:		msm_tsens_convert_temp(last_temp, temp);
thermal/tsens2xxx.c:		msm_tsens_convert_temp(last_temp, temp);
thermal/tsens2xxx.c:	msm_tsens_convert_temp(last_temp, temp);
thermal/tsens2xxx.c:	msm_tsens_convert_temp(thrs & TSENS_TM_0C_THR_MASK, &reset_thr);
thermal/tsens2xxx.c:	msm_tsens_convert_temp(
thermal/msm-tsens.c:	{	.compatible = "qcom,msm8996-tsens",
thermal/msm-tsens.c:	{	.compatible = "qcom,msm8953-tsens",
thermal/msm-tsens.c:	{	.compatible = "qcom,msm8998-tsens",
thermal/msm-tsens.c:	{	.compatible = "qcom,msmhamster-tsens",
thermal/msm-tsens.c:	{	.compatible = "qcom,msm8937-tsens",
thermal/msm-tsens.c:		.name = "msm-tsens",
tty/serial/Kconfig:	  called msm_serial_hs.
tty/serial/Makefile:obj-$(CONFIG_SERIAL_MSM) += msm_serial.o
tty/serial/Makefile:obj-$(CONFIG_SERIAL_MSM_GENI) += msm_geni_serial.o
tty/serial/Makefile:obj-$(CONFIG_SERIAL_MSM_GENI_ELISH) += msm_geni_serial_elish.o
tty/serial/Makefile:obj-$(CONFIG_SERIAL_MSM_HS) += msm_serial_hs.o
tty/serial/Makefile:obj-$(CONFIG_SERIAL_MSM_GENI_EARLY_CONSOLE) += msm_geni_serial_console.o
tty/serial/msm_geni_serial_console.c:struct msm_geni_serial_earlycon_port {
tty/serial/msm_geni_serial_console.c:	container_of(uport, struct msm_geni_serial_earlycon_port, uport)
tty/serial/msm_geni_serial_console.c:static void msm_geni_serial_wr_char(struct uart_port *uport, int ch)
tty/serial/msm_geni_serial_console.c:static int msm_geni_serial_poll_bit(struct uart_port *uport,
tty/serial/msm_geni_serial_console.c:	struct msm_geni_serial_earlycon_port *port = NULL;
tty/serial/msm_geni_serial_console.c:static void msm_geni_serial_poll_cancel_tx(struct uart_port *uport)
tty/serial/msm_geni_serial_console.c:	done = msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial_console.c:		msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial_console.c:static void msm_geni_serial_setup_tx(struct uart_port *uport,
tty/serial/msm_geni_serial_console.c:__msm_geni_serial_console_write(struct uart_port *uport, const char *s,
tty/serial/msm_geni_serial_console.c:	msm_geni_serial_setup_tx(uport, bytes_to_send);
tty/serial/msm_geni_serial_console.c:		while (!msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial_console.c:					msm_geni_serial_wr_char);
tty/serial/msm_geni_serial_console.c:	msm_geni_serial_poll_cancel_tx(uport);
tty/serial/msm_geni_serial_console.c:msm_geni_serial_early_console_write(struct console *con, const char *s,
tty/serial/msm_geni_serial_console.c:	__msm_geni_serial_console_write(&dev->port, s, n);
tty/serial/msm_geni_serial_console.c:msm_geni_serial_earlycon_setup(struct earlycon_device *dev,
tty/serial/msm_geni_serial_console.c:	msm_geni_serial_poll_cancel_tx(uport);
tty/serial/msm_geni_serial_console.c:	dev->con->write = msm_geni_serial_early_console_write;
tty/serial/msm_geni_serial_console.c:OF_EARLYCON_DECLARE(msm_geni_serial, "qcom,msm-geni-console",
tty/serial/msm_geni_serial_console.c:		msm_geni_serial_earlycon_setup);
tty/serial/msm_geni_serial_elish.c:struct msm_geni_serial_ver_info {
tty/serial/msm_geni_serial_elish.c:struct msm_geni_serial_port {
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_ver_info ver_info;
tty/serial/msm_geni_serial_elish.c:static const struct uart_ops msm_geni_serial_pops;
tty/serial/msm_geni_serial_elish.c:static struct uart_driver msm_geni_console_driver;
tty/serial/msm_geni_serial_elish.c:static struct uart_driver msm_geni_serial_hs_driver;
tty/serial/msm_geni_serial_elish.c:static unsigned int msm_geni_serial_tx_empty(struct uart_port *port);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_power_on(struct uart_port *uport);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_power_off(struct uart_port *uport);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_poll_bit(struct uart_port *uport,
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_stop_rx(struct uart_port *uport);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_runtime_resume(struct device *dev);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_runtime_suspend(struct device *dev);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_get_ver_info(struct uart_port *uport);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_set_manual_flow(bool enable,
tty/serial/msm_geni_serial_elish.c:				struct msm_geni_serial_port *port);
tty/serial/msm_geni_serial_elish.c:	container_of(uport, struct msm_geni_serial_port, uport)
tty/serial/msm_geni_serial_elish.c:static struct msm_geni_serial_port msm_geni_console_port;
tty/serial/msm_geni_serial_elish.c:static struct msm_geni_serial_port msm_geni_serial_ports[GENI_UART_NR_PORTS];
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_handle_isr(struct uart_port *uport,
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_spinlocked(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_enable_interrupts(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:static bool msm_serial_try_disable_interrupts(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	if (!msm_geni_serial_spinlocked(uport))
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:		if (msm_port->m_cmd) {
tty/serial/msm_geni_serial_elish.c:			while (!msm_port->m_cmd_done && timeout > 0) {
tty/serial/msm_geni_serial_elish.c:				msm_geni_serial_handle_isr(uport, &flags, true);
tty/serial/msm_geni_serial_elish.c:		} else if (msm_port->s_cmd) {
tty/serial/msm_geni_serial_elish.c:			while (!msm_port->s_cmd_done && timeout > 0) {
tty/serial/msm_geni_serial_elish.c:				msm_geni_serial_handle_isr(uport, &flags, true);
tty/serial/msm_geni_serial_elish.c:		if (msm_port->m_cmd)
tty/serial/msm_geni_serial_elish.c:					(&msm_port->m_cmd_timeout,
tty/serial/msm_geni_serial_elish.c:		else if (msm_port->s_cmd)
tty/serial/msm_geni_serial_elish.c:					(&msm_port->s_cmd_timeout,
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_config_port(struct uart_port *uport, int cfg_flags)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	ret = msm_geni_serial_power_on(uport);
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_ioctl(struct uart_port *uport, unsigned int cmd,
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_break_ctl(struct uart_port *uport, int ctl)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:static unsigned int msm_geni_cons_get_mctrl(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:static unsigned int msm_geni_serial_get_mctrl(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_cons_set_mctrl(struct uart_port *uport,
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_set_mctrl(struct uart_port *uport,
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:static const char *msm_geni_serial_get_type(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:static struct msm_geni_serial_port *get_port_from_line(int line,
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = NULL;
tty/serial/msm_geni_serial_elish.c:		port = &msm_geni_console_port;
tty/serial/msm_geni_serial_elish.c:		port = &msm_geni_serial_ports[line];
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_power_on(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:			ret = msm_geni_serial_runtime_resume(uport->dev);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_power_off(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_poll_bit(struct uart_port *uport,
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = NULL;
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_setup_tx(struct uart_port *uport,
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_poll_tx_done(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	done = msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial_elish.c:		done = msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial_elish.c:			msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_get_char(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	if (!(msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial_elish.c:	if (!(msm_geni_serial_poll_bit(uport, SE_GENI_RX_FIFO_STATUS,
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_poll_put_char(struct uart_port *uport,
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_setup_tx(uport, 1);
tty/serial/msm_geni_serial_elish.c:	if (!msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial_elish.c:	msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_poll_tx_done(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_wr_char(struct uart_port *uport, int ch)
tty/serial/msm_geni_serial_elish.c:__msm_geni_serial_console_write(struct uart_port *uport, const char *s,
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_setup_tx(uport, bytes_to_send);
tty/serial/msm_geni_serial_elish.c:		while (!msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial_elish.c:						msm_geni_serial_wr_char);
tty/serial/msm_geni_serial_elish.c:	msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_poll_tx_done(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_console_write(struct console *co, const char *s,
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port;
tty/serial/msm_geni_serial_elish.c:		is_irq_masked = msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:		msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_poll_tx_done(uport);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:	__msm_geni_serial_console_write(uport, s, count);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_setup_tx(uport, port->cur_tx_remaining);
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:		*(msm_port->rx_fifo) =
tty/serial/msm_geni_serial_elish.c:		rx_char = (unsigned char *)msm_port->rx_fifo;
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_prep_dma_tx(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	dump_ipc(msm_port->ipc_log_tx, "DMA Tx",
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_setup_tx(uport, xmit_size);
tty/serial/msm_geni_serial_elish.c:	ret = geni_se_tx_dma_prep(msm_port->wrapper_dev, uport->membase,
tty/serial/msm_geni_serial_elish.c:			&xmit->buf[xmit->tail], xmit_size, &msm_port->tx_dma);
tty/serial/msm_geni_serial_elish.c:		msm_port->xmit_size = xmit_size;
tty/serial/msm_geni_serial_elish.c:		IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:		msm_port->m_cmd_done = false;
tty/serial/msm_geni_serial_elish.c:		msm_port->m_cmd = true;
tty/serial/msm_geni_serial_elish.c:		reinit_completion(&msm_port->m_cmd_timeout);
tty/serial/msm_geni_serial_elish.c:		is_irq_masked = msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->console_log,
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:			msm_port->m_cmd_done = false;
tty/serial/msm_geni_serial_elish.c:			reinit_completion(&msm_port->m_cmd_timeout);
tty/serial/msm_geni_serial_elish.c:				IPC_LOG_MSG(msm_port->console_log,
tty/serial/msm_geni_serial_elish.c:				IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:		if (msm_port->xfer_mode == SE_DMA) {
tty/serial/msm_geni_serial_elish.c:				msm_port->m_cmd_done = false;
tty/serial/msm_geni_serial_elish.c:				reinit_completion(&msm_port->m_cmd_timeout);
tty/serial/msm_geni_serial_elish.c:					IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:			if (msm_port->tx_dma) {
tty/serial/msm_geni_serial_elish.c:				geni_se_tx_dma_unprep(msm_port->wrapper_dev,
tty/serial/msm_geni_serial_elish.c:					msm_port->tx_dma, msm_port->xmit_size);
tty/serial/msm_geni_serial_elish.c:				msm_port->tx_dma = (dma_addr_t)NULL;
tty/serial/msm_geni_serial_elish.c:		msm_port->xmit_size = 0;
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:		msm_port->m_cmd = false;
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_start_tx(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:		IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:		IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:	if (msm_port->xfer_mode == FIFO_MODE) {
tty/serial/msm_geni_serial_elish.c:		if (!msm_geni_serial_tx_empty(uport))
tty/serial/msm_geni_serial_elish.c:		geni_write_reg_nolog(msm_port->tx_wm, uport->membase,
tty/serial/msm_geni_serial_elish.c:	} else if (msm_port->xfer_mode == SE_DMA) {
tty/serial/msm_geni_serial_elish.c:		if (msm_port->tx_dma)
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_prep_dma_tx(uport);
tty/serial/msm_geni_serial_elish.c:		IPC_LOG_MSG(msm_port->ipc_log_misc, "%s: ios: 0x%08x\n",
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	is_irq_masked = msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_stop_tx(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_stop_rx(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_start_rx(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_set_manual_flow(bool enable,
tty/serial/msm_geni_serial_elish.c:					struct msm_geni_serial_port *port)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_set_manual_flow(false, port);
tty/serial/msm_geni_serial_elish.c:	is_irq_masked = msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:		 * in the system. call msm_geni_serial_handle_isr to clear
tty/serial/msm_geni_serial_elish.c:			msm_geni_serial_handle_isr(uport, &flags, true);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_set_manual_flow(true, port);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_stop_rx(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	rx_bytes = (msm_port->tx_fifo_width * (rx_fifo_wc - 1)) >> 3;
tty/serial/msm_geni_serial_elish.c:			rx_last_byte_valid : msm_port->tx_fifo_width >> 3);
tty/serial/msm_geni_serial_elish.c:	ioread32_rep((uport->membase + SE_GENI_RX_FIFOn), msm_port->rx_fifo,
tty/serial/msm_geni_serial_elish.c:	rx_char = (unsigned char *)msm_port->rx_fifo;
tty/serial/msm_geni_serial_elish.c:	dump_ipc(msm_port->ipc_log_rx, "Rx", (char *)msm_port->rx_fifo, 0,
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_handle_rx(struct uart_port *uport, bool drop_rx)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_handle_tx(struct uart_port *uport, bool done,
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:		(uart_console(uport) ? 1 : (msm_port->tx_fifo_width >> 3));
tty/serial/msm_geni_serial_elish.c:		pending = msm_port->cur_tx_remaining;
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_stop_tx(uport);
tty/serial/msm_geni_serial_elish.c:	avail_fifo_bytes = msm_port->tx_fifo_depth - (tx_fifo_status &
tty/serial/msm_geni_serial_elish.c:	if (!msm_port->cur_tx_remaining) {
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_setup_tx(uport, pending);
tty/serial/msm_geni_serial_elish.c:		msm_port->cur_tx_remaining = pending;
tty/serial/msm_geni_serial_elish.c:		msm_port->cur_tx_remaining -= tx_bytes;
tty/serial/msm_geni_serial_elish.c:	if (!msm_port->cur_tx_remaining) {
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->ipc_log_rx,
tty/serial/msm_geni_serial_elish.c:			geni_se_dump_dbg_regs(&msm_port->serial_rsc,
tty/serial/msm_geni_serial_elish.c:				uport->membase, msm_port->ipc_log_misc);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_handle_dma_rx(struct uart_port *uport, bool drop_rx)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:		IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:	if (unlikely(!msm_port->rx_buf)) {
tty/serial/msm_geni_serial_elish.c:		IPC_LOG_MSG(msm_port->ipc_log_rx, "%s: NULL Rx_buf\n",
tty/serial/msm_geni_serial_elish.c:		IPC_LOG_MSG(msm_port->ipc_log_rx, "%s: Size %d\n",
tty/serial/msm_geni_serial_elish.c:	check_rx_buf((char *)msm_port->rx_buf, uport, rx_bytes);
tty/serial/msm_geni_serial_elish.c:	ret = tty_insert_flip_string(tport, (unsigned char *)(msm_port->rx_buf),
tty/serial/msm_geni_serial_elish.c:	dump_ipc(msm_port->ipc_log_rx, "DMA Rx", (char *)msm_port->rx_buf, 0,
tty/serial/msm_geni_serial_elish.c:	memset(msm_port->rx_buf, 0, rx_bytes);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_handle_dma_tx(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	xmit->tail = (xmit->tail + msm_port->xmit_size) & (UART_XMIT_SIZE - 1);
tty/serial/msm_geni_serial_elish.c:	geni_se_tx_dma_unprep(msm_port->wrapper_dev, msm_port->tx_dma,
tty/serial/msm_geni_serial_elish.c:				msm_port->xmit_size);
tty/serial/msm_geni_serial_elish.c:	uport->icount.tx += msm_port->xmit_size;
tty/serial/msm_geni_serial_elish.c:	msm_port->tx_dma = (dma_addr_t)NULL;
tty/serial/msm_geni_serial_elish.c:	msm_port->xmit_size = 0;
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_prep_dma_tx(uport);
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:			msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	spin_lock(&msm_port->rx_lock);
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:			msm_geni_serial_handle_dma_rx(uport,
tty/serial/msm_geni_serial_elish.c:				DMA_RX_BUF_SIZE, &msm_port->rx_dma);
tty/serial/msm_geni_serial_elish.c:				IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:	spin_unlock(&msm_port->rx_lock);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_handle_isr(struct uart_port *uport,
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:		IPC_LOG_MSG(msm_port->console_log,
tty/serial/msm_geni_serial_elish.c:		IPC_LOG_MSG(msm_port->console_log,
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->console_log,
tty/serial/msm_geni_serial_elish.c:		IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:		IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:			msm_geni_serial_handle_tx(uport,
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:			msm_geni_serial_handle_rx(uport, drop_rx);
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->ipc_log_irqstatus,
tty/serial/msm_geni_serial_elish.c:				msm_geni_serial_handle_dma_tx(uport);
tty/serial/msm_geni_serial_elish.c:		msm_port->m_cmd_done = true;
tty/serial/msm_geni_serial_elish.c:		complete(&msm_port->m_cmd_timeout);
tty/serial/msm_geni_serial_elish.c:		msm_port->s_cmd_done = true;
tty/serial/msm_geni_serial_elish.c:		complete(&msm_port->s_cmd_timeout);
tty/serial/msm_geni_serial_elish.c:static irqreturn_t msm_geni_serial_isr(int isr, void *dev)
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_handle_isr(uport, &flags, false);
tty/serial/msm_geni_serial_elish.c:static irqreturn_t msm_geni_wakeup_isr(int isr, void *dev)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:static int get_tx_fifo_size(struct msm_geni_serial_port *port)
tty/serial/msm_geni_serial_elish.c:static void set_rfr_wm(struct msm_geni_serial_port *port)
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_shutdown(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	IPC_LOG_MSG(msm_port->ipc_log_misc, "%s:\n", __func__);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_power_on(uport);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_stop_tx(uport);
tty/serial/msm_geni_serial_elish.c:		if (msm_port->ioctl_count) {
tty/serial/msm_geni_serial_elish.c:			for (i = 0; i < msm_port->ioctl_count; i++) {
tty/serial/msm_geni_serial_elish.c:				IPC_LOG_MSG(msm_port->ipc_log_pwr,
tty/serial/msm_geni_serial_elish.c:				msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial_elish.c:			msm_port->ioctl_count = 0;
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->ipc_log_pwr,
tty/serial/msm_geni_serial_elish.c:		if (msm_port->wakeup_irq > 0) {
tty/serial/msm_geni_serial_elish.c:			irq_set_irq_wake(msm_port->wakeup_irq, 0);
tty/serial/msm_geni_serial_elish.c:			disable_irq(msm_port->wakeup_irq);
tty/serial/msm_geni_serial_elish.c:			free_irq(msm_port->wakeup_irq, uport);
tty/serial/msm_geni_serial_elish.c:	IPC_LOG_MSG(msm_port->ipc_log_misc, "%s: End\n", __func__);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_port_setup(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	set_rfr_wm(msm_port);
tty/serial/msm_geni_serial_elish.c:		msm_port->xfer_mode = SE_DMA;
tty/serial/msm_geni_serial_elish.c:		if (!msm_port->rx_fifo) {
tty/serial/msm_geni_serial_elish.c:		msm_port->rx_buf =
tty/serial/msm_geni_serial_elish.c:			geni_se_iommu_alloc_buf(msm_port->wrapper_dev,
tty/serial/msm_geni_serial_elish.c:		if (!msm_port->rx_buf) {
tty/serial/msm_geni_serial_elish.c:			devm_kfree(uport->dev, msm_port->rx_fifo);
tty/serial/msm_geni_serial_elish.c:			msm_port->rx_fifo = NULL;
tty/serial/msm_geni_serial_elish.c:		msm_port->rx_dma = dma_address;
tty/serial/msm_geni_serial_elish.c:		msm_port->xfer_mode = FIFO_MODE;
tty/serial/msm_geni_serial_elish.c:		msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_poll_tx_done(uport);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:	ret = geni_se_init(uport->membase, msm_port->rx_wm, msm_port->rx_rfr);
tty/serial/msm_geni_serial_elish.c:	ret = geni_se_select_mode(uport->membase, msm_port->xfer_mode);
tty/serial/msm_geni_serial_elish.c:	msm_port->port_setup = true;
tty/serial/msm_geni_serial_elish.c:	if (msm_port->rx_dma) {
tty/serial/msm_geni_serial_elish.c:		geni_se_iommu_free_buf(msm_port->wrapper_dev,
tty/serial/msm_geni_serial_elish.c:			&msm_port->rx_dma, msm_port->rx_buf, DMA_RX_BUF_SIZE);
tty/serial/msm_geni_serial_elish.c:		msm_port->rx_dma = (dma_addr_t)NULL;
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_startup(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	IPC_LOG_MSG(msm_port->ipc_log_misc, "%s:\n", __func__);
tty/serial/msm_geni_serial_elish.c:	msm_port->startup_in_progress = true;
tty/serial/msm_geni_serial_elish.c:		ret = msm_geni_serial_power_on(&msm_port->uport);
tty/serial/msm_geni_serial_elish.c:	get_tx_fifo_size(msm_port);
tty/serial/msm_geni_serial_elish.c:	if (!msm_port->port_setup) {
tty/serial/msm_geni_serial_elish.c:		ret = msm_geni_serial_port_setup(uport);
tty/serial/msm_geni_serial_elish.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial_elish.c:	if (msm_port->wakeup_irq > 0) {
tty/serial/msm_geni_serial_elish.c:		ret = request_irq(msm_port->wakeup_irq, msm_geni_wakeup_isr,
tty/serial/msm_geni_serial_elish.c:		disable_irq(msm_port->wakeup_irq);
tty/serial/msm_geni_serial_elish.c:		ret = irq_set_irq_wake(msm_port->wakeup_irq, 1);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_power_off(&msm_port->uport);
tty/serial/msm_geni_serial_elish.c:	msm_port->startup_in_progress = false;
tty/serial/msm_geni_serial_elish.c:	IPC_LOG_MSG(msm_port->ipc_log_misc, "%s: ret:%d\n", __func__, ret);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_set_termios(struct uart_port *uport,
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:		int ret = msm_geni_serial_power_on(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_stop_rx(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_start_rx(uport);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial_elish.c:static unsigned int msm_geni_serial_tx_empty(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_power_on(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_stop_tx(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_stop_rx(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_start_rx(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial_elish.c:	int len = (sizeof(struct msm_geni_serial_ver_info) * 2);
tty/serial/msm_geni_serial_elish.c:static int __init msm_geni_console_setup(struct console *co, char *options)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *dev_port;
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_stop_rx(uport);
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_port_setup(uport);
tty/serial/msm_geni_serial_elish.c:msm_geni_serial_early_console_write(struct console *con, const char *s,
tty/serial/msm_geni_serial_elish.c:	__msm_geni_serial_console_write(&dev->port, s, n);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_cancel_rx(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	done = msm_geni_serial_poll_bit(uport, SE_GENI_S_IRQ_STATUS,
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_poll_bit(uport, SE_GENI_S_IRQ_STATUS,
tty/serial/msm_geni_serial_elish.c:	} else if (msm_geni_serial_poll_bit(uport,
tty/serial/msm_geni_serial_elish.c:msm_geni_serial_earlycon_setup(struct earlycon_device *dev,
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_poll_tx_done(uport);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_cancel_rx(uport);
tty/serial/msm_geni_serial_elish.c:	dev->con->write = msm_geni_serial_early_console_write;
tty/serial/msm_geni_serial_elish.c:OF_EARLYCON_DECLARE(msm_geni_serial, "qcom,msm-geni-console",
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_earlycon_setup);
tty/serial/msm_geni_serial_elish.c:	.write = msm_geni_serial_console_write,
tty/serial/msm_geni_serial_elish.c:	.setup = msm_geni_console_setup,
tty/serial/msm_geni_serial_elish.c:	.data = &msm_geni_console_driver,
tty/serial/msm_geni_serial_elish.c:static struct uart_driver msm_geni_console_driver = {
tty/serial/msm_geni_serial_elish.c:	.driver_name = "msm_geni_console",
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_debug_init(struct uart_port *uport, bool console)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	msm_port->dbg = debugfs_create_dir(dev_name(uport->dev), NULL);
tty/serial/msm_geni_serial_elish.c:	if (IS_ERR_OR_NULL(msm_port->dbg))
tty/serial/msm_geni_serial_elish.c:		if (!msm_port->ipc_log_rx) {
tty/serial/msm_geni_serial_elish.c:			msm_port->ipc_log_rx = ipc_log_context_create(
tty/serial/msm_geni_serial_elish.c:			if (!msm_port->ipc_log_rx)
tty/serial/msm_geni_serial_elish.c:		if (!msm_port->ipc_log_tx) {
tty/serial/msm_geni_serial_elish.c:			msm_port->ipc_log_tx = ipc_log_context_create(
tty/serial/msm_geni_serial_elish.c:			if (!msm_port->ipc_log_tx)
tty/serial/msm_geni_serial_elish.c:		if (!msm_port->ipc_log_pwr) {
tty/serial/msm_geni_serial_elish.c:			msm_port->ipc_log_pwr = ipc_log_context_create(
tty/serial/msm_geni_serial_elish.c:			if (!msm_port->ipc_log_pwr)
tty/serial/msm_geni_serial_elish.c:		if (!msm_port->ipc_log_misc) {
tty/serial/msm_geni_serial_elish.c:			msm_port->ipc_log_misc = ipc_log_context_create(
tty/serial/msm_geni_serial_elish.c:			if (!msm_port->ipc_log_misc)
tty/serial/msm_geni_serial_elish.c:		if (!msm_port->ipc_log_single) {
tty/serial/msm_geni_serial_elish.c:			msm_port->ipc_log_single = ipc_log_context_create(
tty/serial/msm_geni_serial_elish.c:			if (!msm_port->ipc_log_single)
tty/serial/msm_geni_serial_elish.c:		if (!msm_port->ipc_log_irqstatus) {
tty/serial/msm_geni_serial_elish.c:			msm_port->ipc_log_irqstatus = ipc_log_context_create(
tty/serial/msm_geni_serial_elish.c:			if (!msm_port->ipc_log_irqstatus)
tty/serial/msm_geni_serial_elish.c:		if (!msm_port->console_log) {
tty/serial/msm_geni_serial_elish.c:			msm_port->console_log = ipc_log_context_create(
tty/serial/msm_geni_serial_elish.c:			if (!msm_port->console_log)
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_cons_pm(struct uart_port *uport,
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:		se_geni_resources_on(&msm_port->serial_rsc);
tty/serial/msm_geni_serial_elish.c:		se_geni_resources_off(&msm_port->serial_rsc);
tty/serial/msm_geni_serial_elish.c:static const struct uart_ops msm_geni_console_pops = {
tty/serial/msm_geni_serial_elish.c:	.tx_empty = msm_geni_serial_tx_empty,
tty/serial/msm_geni_serial_elish.c:	.stop_tx = msm_geni_serial_stop_tx,
tty/serial/msm_geni_serial_elish.c:	.start_tx = msm_geni_serial_start_tx,
tty/serial/msm_geni_serial_elish.c:	.stop_rx = msm_geni_serial_stop_rx,
tty/serial/msm_geni_serial_elish.c:	.set_termios = msm_geni_serial_set_termios,
tty/serial/msm_geni_serial_elish.c:	.startup = msm_geni_serial_startup,
tty/serial/msm_geni_serial_elish.c:	.config_port = msm_geni_serial_config_port,
tty/serial/msm_geni_serial_elish.c:	.shutdown = msm_geni_serial_shutdown,
tty/serial/msm_geni_serial_elish.c:	.type = msm_geni_serial_get_type,
tty/serial/msm_geni_serial_elish.c:	.set_mctrl = msm_geni_cons_set_mctrl,
tty/serial/msm_geni_serial_elish.c:	.get_mctrl = msm_geni_cons_get_mctrl,
tty/serial/msm_geni_serial_elish.c:	.poll_get_char	= msm_geni_serial_get_char,
tty/serial/msm_geni_serial_elish.c:	.poll_put_char	= msm_geni_serial_poll_put_char,
tty/serial/msm_geni_serial_elish.c:	.pm = msm_geni_serial_cons_pm,
tty/serial/msm_geni_serial_elish.c:static const struct uart_ops msm_geni_serial_pops = {
tty/serial/msm_geni_serial_elish.c:	.tx_empty = msm_geni_serial_tx_empty,
tty/serial/msm_geni_serial_elish.c:	.stop_tx = msm_geni_serial_stop_tx,
tty/serial/msm_geni_serial_elish.c:	.start_tx = msm_geni_serial_start_tx,
tty/serial/msm_geni_serial_elish.c:	.stop_rx = msm_geni_serial_stop_rx,
tty/serial/msm_geni_serial_elish.c:	.set_termios = msm_geni_serial_set_termios,
tty/serial/msm_geni_serial_elish.c:	.startup = msm_geni_serial_startup,
tty/serial/msm_geni_serial_elish.c:	.config_port = msm_geni_serial_config_port,
tty/serial/msm_geni_serial_elish.c:	.shutdown = msm_geni_serial_shutdown,
tty/serial/msm_geni_serial_elish.c:	.type = msm_geni_serial_get_type,
tty/serial/msm_geni_serial_elish.c:	.set_mctrl = msm_geni_serial_set_mctrl,
tty/serial/msm_geni_serial_elish.c:	.get_mctrl = msm_geni_serial_get_mctrl,
tty/serial/msm_geni_serial_elish.c:	.break_ctl = msm_geni_serial_break_ctl,
tty/serial/msm_geni_serial_elish.c:	.ioctl = msm_geni_serial_ioctl,
tty/serial/msm_geni_serial_elish.c:static const struct of_device_id msm_geni_device_tbl[] = {
tty/serial/msm_geni_serial_elish.c:	{ .compatible = "qcom,msm-geni-console",
tty/serial/msm_geni_serial_elish.c:			.data = (void *)&msm_geni_console_driver},
tty/serial/msm_geni_serial_elish.c:	{ .compatible = "qcom,msm-geni-serial-hs",
tty/serial/msm_geni_serial_elish.c:			.data = (void *)&msm_geni_serial_hs_driver},
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_get_ver_info(struct uart_port *uport)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial_elish.c:	if (!msm_port->is_console)
tty/serial/msm_geni_serial_elish.c:		se_geni_clks_on(&msm_port->serial_rsc);
tty/serial/msm_geni_serial_elish.c:	msm_port->ver_info.m_fw_ver = get_se_m_fw(uport->membase);
tty/serial/msm_geni_serial_elish.c:	msm_port->ver_info.s_fw_ver = get_se_s_fw(uport->membase);
tty/serial/msm_geni_serial_elish.c:	IPC_LOG_MSG(msm_port->ipc_log_misc, "%s: FW Ver:0x%x%x\n",
tty/serial/msm_geni_serial_elish.c:		msm_port->ver_info.m_fw_ver, msm_port->ver_info.s_fw_ver);
tty/serial/msm_geni_serial_elish.c:	hw_ver = geni_se_qupv3_hw_version(msm_port->wrapper_dev,
tty/serial/msm_geni_serial_elish.c:		&msm_port->ver_info.hw_major_ver,
tty/serial/msm_geni_serial_elish.c:		&msm_port->ver_info.hw_minor_ver,
tty/serial/msm_geni_serial_elish.c:		&msm_port->ver_info.hw_step_ver);
tty/serial/msm_geni_serial_elish.c:		IPC_LOG_MSG(msm_port->ipc_log_misc, "%s: HW Ver:%x.%x.%x\n",
tty/serial/msm_geni_serial_elish.c:			__func__, msm_port->ver_info.hw_major_ver,
tty/serial/msm_geni_serial_elish.c:			msm_port->ver_info.hw_minor_ver,
tty/serial/msm_geni_serial_elish.c:			msm_port->ver_info.hw_step_ver);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial_elish.c:	if (!msm_port->is_console)
tty/serial/msm_geni_serial_elish.c:		se_geni_clks_off(&msm_port->serial_rsc);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_probe(struct platform_device *pdev)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *dev_port;
tty/serial/msm_geni_serial_elish.c:	id = of_match_device(msm_geni_device_tbl, &pdev->dev);
tty/serial/msm_geni_serial_elish.c:		(!strcmp(id->compatible, "qcom,msm-geni-console"))) {
tty/serial/msm_geni_serial_elish.c:					"msm_serial_geni%d", uport->line);
tty/serial/msm_geni_serial_elish.c:	ret = devm_request_irq(uport->dev, uport->irq, msm_geni_serial_isr,
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_debug_init(uport, is_console);
tty/serial/msm_geni_serial_elish.c:	ret = msm_geni_serial_get_ver_info(uport);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_remove(struct platform_device *pdev)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial_elish.c:static void msm_geni_serial_allow_rx(struct msm_geni_serial_port *port)
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_set_manual_flow(true, port);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_runtime_suspend(struct device *dev)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial_elish.c:	msm_geni_serial_allow_rx(port);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_runtime_resume(struct device *dev)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_sys_suspend_noirq(struct device *dev)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_sys_resume_noirq(struct device *dev)
tty/serial/msm_geni_serial_elish.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_runtime_suspend(struct device *dev)
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_runtime_resume(struct device *dev)
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_sys_suspend_noirq(struct device *dev)
tty/serial/msm_geni_serial_elish.c:static int msm_geni_serial_sys_resume_noirq(struct device *dev)
tty/serial/msm_geni_serial_elish.c:static const struct dev_pm_ops msm_geni_serial_pm_ops = {
tty/serial/msm_geni_serial_elish.c:	.runtime_suspend = msm_geni_serial_runtime_suspend,
tty/serial/msm_geni_serial_elish.c:	.runtime_resume = msm_geni_serial_runtime_resume,
tty/serial/msm_geni_serial_elish.c:	.suspend_noirq = msm_geni_serial_sys_suspend_noirq,
tty/serial/msm_geni_serial_elish.c:	.resume_noirq = msm_geni_serial_sys_resume_noirq,
tty/serial/msm_geni_serial_elish.c:static struct platform_driver msm_geni_serial_platform_driver = {
tty/serial/msm_geni_serial_elish.c:	.remove = msm_geni_serial_remove,
tty/serial/msm_geni_serial_elish.c:	.probe = msm_geni_serial_probe,
tty/serial/msm_geni_serial_elish.c:		.name = "msm_geni_serial",
tty/serial/msm_geni_serial_elish.c:		.of_match_table = msm_geni_device_tbl,
tty/serial/msm_geni_serial_elish.c:		.pm = &msm_geni_serial_pm_ops,
tty/serial/msm_geni_serial_elish.c:static struct uart_driver msm_geni_serial_hs_driver = {
tty/serial/msm_geni_serial_elish.c:	.driver_name = "msm_geni_serial_hs",
tty/serial/msm_geni_serial_elish.c:static int __init msm_geni_serial_init(void)
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_ports[i].uport.iotype = UPIO_MEM;
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_ports[i].uport.ops = &msm_geni_serial_pops;
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_ports[i].uport.flags = UPF_BOOT_AUTOCONF;
tty/serial/msm_geni_serial_elish.c:		msm_geni_serial_ports[i].uport.line = i;
tty/serial/msm_geni_serial_elish.c:		msm_geni_console_port.uport.iotype = UPIO_MEM;
tty/serial/msm_geni_serial_elish.c:		msm_geni_console_port.uport.ops = &msm_geni_console_pops;
tty/serial/msm_geni_serial_elish.c:		msm_geni_console_port.uport.flags = UPF_BOOT_AUTOCONF;
tty/serial/msm_geni_serial_elish.c:		msm_geni_console_port.uport.line = i;
tty/serial/msm_geni_serial_elish.c:	ret = console_register(&msm_geni_console_driver);
tty/serial/msm_geni_serial_elish.c:	ret = uart_register_driver(&msm_geni_serial_hs_driver);
tty/serial/msm_geni_serial_elish.c:		uart_unregister_driver(&msm_geni_console_driver);
tty/serial/msm_geni_serial_elish.c:	ret = platform_driver_register(&msm_geni_serial_platform_driver);
tty/serial/msm_geni_serial_elish.c:		console_unregister(&msm_geni_console_driver);
tty/serial/msm_geni_serial_elish.c:		uart_unregister_driver(&msm_geni_serial_hs_driver);
tty/serial/msm_geni_serial_elish.c:module_init(msm_geni_serial_init);
tty/serial/msm_geni_serial_elish.c:static void __exit msm_geni_serial_exit(void)
tty/serial/msm_geni_serial_elish.c:	platform_driver_unregister(&msm_geni_serial_platform_driver);
tty/serial/msm_geni_serial_elish.c:	uart_unregister_driver(&msm_geni_serial_hs_driver);
tty/serial/msm_geni_serial_elish.c:	console_unregister(&msm_geni_console_driver);
tty/serial/msm_geni_serial_elish.c:module_exit(msm_geni_serial_exit);
tty/serial/msm_geni_serial_elish.c:MODULE_ALIAS("tty:msm_geni_geni_serial");
tty/serial/msm_serial.c: * Driver for msm7k serial device and console
tty/serial/msm_serial.c:struct msm_dma {
tty/serial/msm_serial.c:struct msm_port {
tty/serial/msm_serial.c:	struct msm_dma		tx_dma;
tty/serial/msm_serial.c:	struct msm_dma		rx_dma;
tty/serial/msm_serial.c:#define UART_TO_MSM(uart_port)	container_of(uart_port, struct msm_port, uart)
tty/serial/msm_serial.c:void msm_write(struct uart_port *port, unsigned int val, unsigned int off)
tty/serial/msm_serial.c:unsigned int msm_read(struct uart_port *port, unsigned int off)
tty/serial/msm_serial.c:static void msm_serial_set_mnd_regs_tcxo(struct uart_port *port)
tty/serial/msm_serial.c:	msm_write(port, 0x06, UART_MREG);
tty/serial/msm_serial.c:	msm_write(port, 0xF1, UART_NREG);
tty/serial/msm_serial.c:	msm_write(port, 0x0F, UART_DREG);
tty/serial/msm_serial.c:	msm_write(port, 0x1A, UART_MNDREG);
tty/serial/msm_serial.c:static void msm_serial_set_mnd_regs_tcxoby4(struct uart_port *port)
tty/serial/msm_serial.c:	msm_write(port, 0x18, UART_MREG);
tty/serial/msm_serial.c:	msm_write(port, 0xF6, UART_NREG);
tty/serial/msm_serial.c:	msm_write(port, 0x0F, UART_DREG);
tty/serial/msm_serial.c:	msm_write(port, 0x0A, UART_MNDREG);
tty/serial/msm_serial.c:static void msm_serial_set_mnd_regs(struct uart_port *port)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm)
tty/serial/msm_serial.c:		msm_serial_set_mnd_regs_tcxo(port);
tty/serial/msm_serial.c:		msm_serial_set_mnd_regs_tcxoby4(port);
tty/serial/msm_serial.c:static void msm_handle_tx(struct uart_port *port);
tty/serial/msm_serial.c:static void msm_start_rx_dma(struct msm_port *msm_port);
tty/serial/msm_serial.c:static void msm_stop_dma(struct uart_port *port, struct msm_dma *dma)
tty/serial/msm_serial.c:	val = msm_read(port, UARTDM_DMEN);
tty/serial/msm_serial.c:	msm_write(port, val, UARTDM_DMEN);
tty/serial/msm_serial.c:static void msm_release_dma(struct msm_port *msm_port)
tty/serial/msm_serial.c:	struct msm_dma *dma;
tty/serial/msm_serial.c:	dma = &msm_port->tx_dma;
tty/serial/msm_serial.c:		msm_stop_dma(&msm_port->uart, dma);
tty/serial/msm_serial.c:	dma = &msm_port->rx_dma;
tty/serial/msm_serial.c:		msm_stop_dma(&msm_port->uart, dma);
tty/serial/msm_serial.c:static void msm_request_tx_dma(struct msm_port *msm_port, resource_size_t base)
tty/serial/msm_serial.c:	struct device *dev = msm_port->uart.dev;
tty/serial/msm_serial.c:	struct msm_dma *dma;
tty/serial/msm_serial.c:	dma = &msm_port->tx_dma;
tty/serial/msm_serial.c:	if (msm_port->is_uartdm < UARTDM_1P4)
tty/serial/msm_serial.c:static void msm_request_rx_dma(struct msm_port *msm_port, resource_size_t base)
tty/serial/msm_serial.c:	struct device *dev = msm_port->uart.dev;
tty/serial/msm_serial.c:	struct msm_dma *dma;
tty/serial/msm_serial.c:	dma = &msm_port->rx_dma;
tty/serial/msm_serial.c:	if (msm_port->is_uartdm < UARTDM_1P4)
tty/serial/msm_serial.c:static inline void msm_wait_for_xmitr(struct uart_port *port)
tty/serial/msm_serial.c:	while (!(msm_read(port, UART_SR) & UART_SR_TX_EMPTY)) {
tty/serial/msm_serial.c:		if (msm_read(port, UART_ISR) & UART_ISR_TX_READY)
tty/serial/msm_serial.c:	msm_write(port, UART_CR_CMD_RESET_TX_READY, UART_CR);
tty/serial/msm_serial.c:static void msm_stop_tx(struct uart_port *port)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	msm_port->imr &= ~UART_IMR_TXLEV;
tty/serial/msm_serial.c:	msm_write(port, msm_port->imr, UART_IMR);
tty/serial/msm_serial.c:static void msm_start_tx(struct uart_port *port)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	struct msm_dma *dma = &msm_port->tx_dma;
tty/serial/msm_serial.c:	msm_port->imr |= UART_IMR_TXLEV;
tty/serial/msm_serial.c:	msm_write(port, msm_port->imr, UART_IMR);
tty/serial/msm_serial.c:static void msm_reset_dm_count(struct uart_port *port, int count)
tty/serial/msm_serial.c:	msm_wait_for_xmitr(port);
tty/serial/msm_serial.c:	msm_write(port, count, UARTDM_NCF_TX);
tty/serial/msm_serial.c:	msm_read(port, UARTDM_NCF_TX);
tty/serial/msm_serial.c:static void msm_complete_tx_dma(void *args)
tty/serial/msm_serial.c:	struct msm_port *msm_port = args;
tty/serial/msm_serial.c:	struct uart_port *port = &msm_port->uart;
tty/serial/msm_serial.c:	struct msm_dma *dma = &msm_port->tx_dma;
tty/serial/msm_serial.c:	val = msm_read(port, UARTDM_DMEN);
tty/serial/msm_serial.c:	msm_write(port, val, UARTDM_DMEN);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm > UARTDM_1P3) {
tty/serial/msm_serial.c:		msm_write(port, UART_CR_CMD_RESET_TX, UART_CR);
tty/serial/msm_serial.c:		msm_write(port, UART_CR_TX_ENABLE, UART_CR);
tty/serial/msm_serial.c:	msm_port->imr |= UART_IMR_TXLEV;
tty/serial/msm_serial.c:	msm_write(port, msm_port->imr, UART_IMR);
tty/serial/msm_serial.c:	msm_handle_tx(port);
tty/serial/msm_serial.c:static int msm_handle_tx_dma(struct msm_port *msm_port, unsigned int count)
tty/serial/msm_serial.c:	struct circ_buf *xmit = &msm_port->uart.state->xmit;
tty/serial/msm_serial.c:	struct uart_port *port = &msm_port->uart;
tty/serial/msm_serial.c:	struct msm_dma *dma = &msm_port->tx_dma;
tty/serial/msm_serial.c:	dma->desc->callback = msm_complete_tx_dma;
tty/serial/msm_serial.c:	dma->desc->callback_param = msm_port;
tty/serial/msm_serial.c:	msm_port->imr &= ~UART_IMR_TXLEV;
tty/serial/msm_serial.c:	msm_write(port, msm_port->imr, UART_IMR);
tty/serial/msm_serial.c:	val = msm_read(port, UARTDM_DMEN);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm < UARTDM_1P4)
tty/serial/msm_serial.c:		msm_write(port, val, UARTDM_DMEN);
tty/serial/msm_serial.c:	msm_reset_dm_count(port, count);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm > UARTDM_1P3)
tty/serial/msm_serial.c:		msm_write(port, val, UARTDM_DMEN);
tty/serial/msm_serial.c:static void msm_complete_rx_dma(void *args)
tty/serial/msm_serial.c:	struct msm_port *msm_port = args;
tty/serial/msm_serial.c:	struct uart_port *port = &msm_port->uart;
tty/serial/msm_serial.c:	struct msm_dma *dma = &msm_port->rx_dma;
tty/serial/msm_serial.c:	val = msm_read(port, UARTDM_DMEN);
tty/serial/msm_serial.c:	msm_write(port, val, UARTDM_DMEN);
tty/serial/msm_serial.c:	if (msm_read(port, UART_SR) & UART_SR_OVERRUN) {
tty/serial/msm_serial.c:		msm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);
tty/serial/msm_serial.c:	count = msm_read(port, UARTDM_RX_TOTAL_SNAP);
tty/serial/msm_serial.c:		if (msm_port->break_detected && dma->virt[i] == 0) {
tty/serial/msm_serial.c:			msm_port->break_detected = false;
tty/serial/msm_serial.c:	msm_start_rx_dma(msm_port);
tty/serial/msm_serial.c:static void msm_start_rx_dma(struct msm_port *msm_port)
tty/serial/msm_serial.c:	struct msm_dma *dma = &msm_port->rx_dma;
tty/serial/msm_serial.c:	struct uart_port *uart = &msm_port->uart;
tty/serial/msm_serial.c:	dma->desc->callback = msm_complete_rx_dma;
tty/serial/msm_serial.c:	dma->desc->callback_param = msm_port;
tty/serial/msm_serial.c:	msm_port->imr &= ~(UART_IMR_RXLEV | UART_IMR_RXSTALE);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm < UARTDM_1P4)
tty/serial/msm_serial.c:		msm_port->imr |= UART_IMR_RXSTALE;
tty/serial/msm_serial.c:	msm_write(uart, msm_port->imr, UART_IMR);
tty/serial/msm_serial.c:	msm_write(uart, UART_CR_CMD_RESET_STALE_INT, UART_CR);
tty/serial/msm_serial.c:	msm_write(uart, UART_CR_CMD_STALE_EVENT_ENABLE, UART_CR);
tty/serial/msm_serial.c:	val = msm_read(uart, UARTDM_DMEN);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm < UARTDM_1P4)
tty/serial/msm_serial.c:		msm_write(uart, val, UARTDM_DMEN);
tty/serial/msm_serial.c:	msm_write(uart, UARTDM_RX_SIZE, UARTDM_DMRX);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm > UARTDM_1P3)
tty/serial/msm_serial.c:		msm_write(uart, val, UARTDM_DMEN);
tty/serial/msm_serial.c:static void msm_stop_rx(struct uart_port *port)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	struct msm_dma *dma = &msm_port->rx_dma;
tty/serial/msm_serial.c:	msm_port->imr &= ~(UART_IMR_RXLEV | UART_IMR_RXSTALE);
tty/serial/msm_serial.c:	msm_write(port, msm_port->imr, UART_IMR);
tty/serial/msm_serial.c:		msm_stop_dma(port, dma);
tty/serial/msm_serial.c:static void msm_enable_ms(struct uart_port *port)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	msm_port->imr |= UART_IMR_DELTA_CTS;
tty/serial/msm_serial.c:	msm_write(port, msm_port->imr, UART_IMR);
tty/serial/msm_serial.c:static void msm_handle_rx_dm(struct uart_port *port, unsigned int misr)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	if ((msm_read(port, UART_SR) & UART_SR_OVERRUN)) {
tty/serial/msm_serial.c:		msm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);
tty/serial/msm_serial.c:		count = msm_read(port, UARTDM_RX_TOTAL_SNAP) -
tty/serial/msm_serial.c:			msm_port->old_snap_state;
tty/serial/msm_serial.c:		msm_port->old_snap_state = 0;
tty/serial/msm_serial.c:		count = 4 * (msm_read(port, UART_RFWR));
tty/serial/msm_serial.c:		msm_port->old_snap_state += count;
tty/serial/msm_serial.c:		sr = msm_read(port, UART_SR);
tty/serial/msm_serial.c:			msm_port->old_snap_state -= count;
tty/serial/msm_serial.c:			if (msm_port->break_detected && buf[i] == 0) {
tty/serial/msm_serial.c:				msm_port->break_detected = false;
tty/serial/msm_serial.c:		msm_write(port, UART_CR_CMD_RESET_STALE_INT, UART_CR);
tty/serial/msm_serial.c:	msm_write(port, 0xFFFFFF, UARTDM_DMRX);
tty/serial/msm_serial.c:	msm_write(port, UART_CR_CMD_STALE_EVENT_ENABLE, UART_CR);
tty/serial/msm_serial.c:	msm_start_rx_dma(msm_port);
tty/serial/msm_serial.c:static void msm_handle_rx(struct uart_port *port)
tty/serial/msm_serial.c:	if ((msm_read(port, UART_SR) & UART_SR_OVERRUN)) {
tty/serial/msm_serial.c:		msm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);
tty/serial/msm_serial.c:	while ((sr = msm_read(port, UART_SR)) & UART_SR_RX_READY) {
tty/serial/msm_serial.c:		c = msm_read(port, UART_RF);
tty/serial/msm_serial.c:static void msm_handle_tx_pio(struct uart_port *port, unsigned int tx_count)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm)
tty/serial/msm_serial.c:	if (tx_count && msm_port->is_uartdm)
tty/serial/msm_serial.c:		msm_reset_dm_count(port, tx_count);
tty/serial/msm_serial.c:		if (!(msm_read(port, UART_SR) & UART_SR_TX_READY))
tty/serial/msm_serial.c:		if (msm_port->is_uartdm)
tty/serial/msm_serial.c:		msm_stop_tx(port);
tty/serial/msm_serial.c:static void msm_handle_tx(struct uart_port *port)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	struct circ_buf *xmit = &msm_port->uart.state->xmit;
tty/serial/msm_serial.c:	struct msm_dma *dma = &msm_port->tx_dma;
tty/serial/msm_serial.c:		if (msm_port->is_uartdm)
tty/serial/msm_serial.c:		if (msm_port->is_uartdm)
tty/serial/msm_serial.c:			msm_reset_dm_count(port, 1);
tty/serial/msm_serial.c:		msm_stop_tx(port);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm > UARTDM_1P3) {
tty/serial/msm_serial.c:		msm_handle_tx_pio(port, pio_count);
tty/serial/msm_serial.c:		err = msm_handle_tx_dma(msm_port, dma_count);
tty/serial/msm_serial.c:		msm_handle_tx_pio(port, pio_count);
tty/serial/msm_serial.c:static void msm_handle_delta_cts(struct uart_port *port)
tty/serial/msm_serial.c:	msm_write(port, UART_CR_CMD_RESET_CTS, UART_CR);
tty/serial/msm_serial.c:static irqreturn_t msm_uart_irq(int irq, void *dev_id)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	struct msm_dma *dma = &msm_port->rx_dma;
tty/serial/msm_serial.c:	misr = msm_read(port, UART_MISR);
tty/serial/msm_serial.c:	msm_write(port, 0, UART_IMR); /* disable interrupt */
tty/serial/msm_serial.c:		msm_port->break_detected = true;
tty/serial/msm_serial.c:		msm_write(port, UART_CR_CMD_RESET_RXBREAK_START, UART_CR);
tty/serial/msm_serial.c:			msm_write(port, val, UART_CR);
tty/serial/msm_serial.c:			msm_write(port, val, UART_CR);
tty/serial/msm_serial.c:		} else if (msm_port->is_uartdm) {
tty/serial/msm_serial.c:			msm_handle_rx_dm(port, misr);
tty/serial/msm_serial.c:			msm_handle_rx(port);
tty/serial/msm_serial.c:		msm_handle_tx(port);
tty/serial/msm_serial.c:		msm_handle_delta_cts(port);
tty/serial/msm_serial.c:	msm_write(port, msm_port->imr, UART_IMR); /* restore interrupt */
tty/serial/msm_serial.c:static unsigned int msm_tx_empty(struct uart_port *port)
tty/serial/msm_serial.c:	return (msm_read(port, UART_SR) & UART_SR_TX_EMPTY) ? TIOCSER_TEMT : 0;
tty/serial/msm_serial.c:static unsigned int msm_get_mctrl(struct uart_port *port)
tty/serial/msm_serial.c:static void msm_reset(struct uart_port *port)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	msm_write(port, UART_CR_CMD_RESET_RX, UART_CR);
tty/serial/msm_serial.c:	msm_write(port, UART_CR_CMD_RESET_TX, UART_CR);
tty/serial/msm_serial.c:	msm_write(port, UART_CR_CMD_RESET_ERR, UART_CR);
tty/serial/msm_serial.c:	msm_write(port, UART_CR_CMD_RESET_BREAK_INT, UART_CR);
tty/serial/msm_serial.c:	msm_write(port, UART_CR_CMD_RESET_CTS, UART_CR);
tty/serial/msm_serial.c:	msm_write(port, UART_CR_CMD_RESET_RFR, UART_CR);
tty/serial/msm_serial.c:	mr = msm_read(port, UART_MR1);
tty/serial/msm_serial.c:	msm_write(port, mr, UART_MR1);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm)
tty/serial/msm_serial.c:		msm_write(port, 0, UARTDM_DMEN);
tty/serial/msm_serial.c:static void msm_set_mctrl(struct uart_port *port, unsigned int mctrl)
tty/serial/msm_serial.c:	mr = msm_read(port, UART_MR1);
tty/serial/msm_serial.c:		msm_write(port, mr, UART_MR1);
tty/serial/msm_serial.c:		msm_write(port, UART_CR_CMD_RESET_RFR, UART_CR);
tty/serial/msm_serial.c:		msm_write(port, mr, UART_MR1);
tty/serial/msm_serial.c:static void msm_break_ctl(struct uart_port *port, int break_ctl)
tty/serial/msm_serial.c:		msm_write(port, UART_CR_CMD_START_BREAK, UART_CR);
tty/serial/msm_serial.c:		msm_write(port, UART_CR_CMD_STOP_BREAK, UART_CR);
tty/serial/msm_serial.c:struct msm_baud_map {
tty/serial/msm_serial.c:static const struct msm_baud_map *
tty/serial/msm_serial.c:msm_find_best_baud(struct uart_port *port, unsigned int baud,
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	const struct msm_baud_map *entry, *end, *best;
tty/serial/msm_serial.c:	static const struct msm_baud_map table[] = {
tty/serial/msm_serial.c:	target = clk_round_rate(msm_port->clk, 16 * baud);
tty/serial/msm_serial.c:			target = clk_round_rate(msm_port->clk, old + 1);
tty/serial/msm_serial.c:static int msm_set_baud_rate(struct uart_port *port, unsigned int baud,
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	const struct msm_baud_map *entry;
tty/serial/msm_serial.c:	entry = msm_find_best_baud(port, baud, &rate);
tty/serial/msm_serial.c:	clk_set_rate(msm_port->clk, rate);
tty/serial/msm_serial.c:	msm_write(port, entry->code, UART_CSR);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm) {
tty/serial/msm_serial.c:	msm_write(port, watermark, UART_IPR);
tty/serial/msm_serial.c:	msm_write(port, watermark, UART_RFWR);
tty/serial/msm_serial.c:	msm_write(port, 10, UART_TFWR);
tty/serial/msm_serial.c:	msm_write(port, UART_CR_CMD_PROTECTION_EN, UART_CR);
tty/serial/msm_serial.c:	msm_reset(port);
tty/serial/msm_serial.c:	msm_write(port, UART_CR_TX_ENABLE | UART_CR_RX_ENABLE, UART_CR);
tty/serial/msm_serial.c:	msm_port->imr = UART_IMR_RXLEV | UART_IMR_RXSTALE |
tty/serial/msm_serial.c:	msm_write(port, msm_port->imr, UART_IMR);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm) {
tty/serial/msm_serial.c:		msm_write(port, UART_CR_CMD_RESET_STALE_INT, UART_CR);
tty/serial/msm_serial.c:		msm_write(port, 0xFFFFFF, UARTDM_DMRX);
tty/serial/msm_serial.c:		msm_write(port, UART_CR_CMD_STALE_EVENT_ENABLE, UART_CR);
tty/serial/msm_serial.c:static int msm_startup(struct uart_port *port)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	snprintf(msm_port->name, sizeof(msm_port->name),
tty/serial/msm_serial.c:		 "msm_serial%d", port->line);
tty/serial/msm_serial.c:	ret = clk_prepare_enable(msm_port->clk);
tty/serial/msm_serial.c:	ret = clk_prepare_enable(msm_port->pclk);
tty/serial/msm_serial.c:	msm_serial_set_mnd_regs(port);
tty/serial/msm_serial.c:	data = msm_read(port, UART_MR1);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm)
tty/serial/msm_serial.c:	msm_write(port, data, UART_MR1);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm) {
tty/serial/msm_serial.c:		msm_request_tx_dma(msm_port, msm_port->uart.mapbase);
tty/serial/msm_serial.c:		msm_request_rx_dma(msm_port, msm_port->uart.mapbase);
tty/serial/msm_serial.c:	ret = request_irq(port->irq, msm_uart_irq, IRQF_TRIGGER_HIGH,
tty/serial/msm_serial.c:			  msm_port->name, port);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm)
tty/serial/msm_serial.c:		msm_release_dma(msm_port);
tty/serial/msm_serial.c:	clk_disable_unprepare(msm_port->pclk);
tty/serial/msm_serial.c:	clk_disable_unprepare(msm_port->clk);
tty/serial/msm_serial.c:	clk_disable_unprepare(msm_port->clk);
tty/serial/msm_serial.c:static void msm_shutdown(struct uart_port *port)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	msm_port->imr = 0;
tty/serial/msm_serial.c:	msm_write(port, 0, UART_IMR); /* disable interrupts */
tty/serial/msm_serial.c:	if (msm_port->is_uartdm)
tty/serial/msm_serial.c:		msm_release_dma(msm_port);
tty/serial/msm_serial.c:	clk_disable_unprepare(msm_port->pclk);
tty/serial/msm_serial.c:	clk_disable_unprepare(msm_port->clk);
tty/serial/msm_serial.c:static void msm_set_termios(struct uart_port *port, struct ktermios *termios,
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	struct msm_dma *dma = &msm_port->rx_dma;
tty/serial/msm_serial.c:		msm_stop_dma(port, dma);
tty/serial/msm_serial.c:	baud = msm_set_baud_rate(port, baud, &flags);
tty/serial/msm_serial.c:	mr = msm_read(port, UART_MR2);
tty/serial/msm_serial.c:	msm_write(port, mr, UART_MR2);
tty/serial/msm_serial.c:	mr = msm_read(port, UART_MR1);
tty/serial/msm_serial.c:	msm_write(port, mr, UART_MR1);
tty/serial/msm_serial.c:	msm_start_rx_dma(msm_port);
tty/serial/msm_serial.c:static const char *msm_type(struct uart_port *port)
tty/serial/msm_serial.c:static void msm_release_port(struct uart_port *port)
tty/serial/msm_serial.c:static int msm_request_port(struct uart_port *port)
tty/serial/msm_serial.c:	if (!request_mem_region(port->mapbase, size, "msm_serial"))
tty/serial/msm_serial.c:static void msm_config_port(struct uart_port *port, int flags)
tty/serial/msm_serial.c:		ret = msm_request_port(port);
tty/serial/msm_serial.c:static int msm_verify_port(struct uart_port *port, struct serial_struct *ser)
tty/serial/msm_serial.c:static void msm_power(struct uart_port *port, unsigned int state,
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:		if (clk_prepare_enable(msm_port->clk))
tty/serial/msm_serial.c:		if (clk_prepare_enable(msm_port->pclk)) {
tty/serial/msm_serial.c:			clk_disable_unprepare(msm_port->clk);
tty/serial/msm_serial.c:		clk_disable_unprepare(msm_port->clk);
tty/serial/msm_serial.c:		clk_disable_unprepare(msm_port->pclk);
tty/serial/msm_serial.c:		pr_err("msm_serial: Unknown PM state %d\n", state);
tty/serial/msm_serial.c:static int msm_poll_get_char_single(struct uart_port *port)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	unsigned int rf_reg = msm_port->is_uartdm ? UARTDM_RF : UART_RF;
tty/serial/msm_serial.c:	if (!(msm_read(port, UART_SR) & UART_SR_RX_READY))
tty/serial/msm_serial.c:	return msm_read(port, rf_reg) & 0xff;
tty/serial/msm_serial.c:static int msm_poll_get_char_dm(struct uart_port *port)
tty/serial/msm_serial.c:	} else if (!(msm_read(port, UART_SR) & UART_SR_RX_READY)) {
tty/serial/msm_serial.c:		count = msm_read(port, UARTDM_RXFS);
tty/serial/msm_serial.c:			msm_write(port, UART_CR_CMD_FORCE_STALE, UART_CR);
tty/serial/msm_serial.c:			slop = msm_read(port, UARTDM_RF);
tty/serial/msm_serial.c:			msm_write(port, UART_CR_CMD_RESET_STALE_INT, UART_CR);
tty/serial/msm_serial.c:			msm_write(port, 0xFFFFFF, UARTDM_DMRX);
tty/serial/msm_serial.c:			msm_write(port, UART_CR_CMD_STALE_EVENT_ENABLE,
tty/serial/msm_serial.c:		slop = msm_read(port, UARTDM_RF);
tty/serial/msm_serial.c:static int msm_poll_get_char(struct uart_port *port)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	imr = msm_read(port, UART_IMR);
tty/serial/msm_serial.c:	msm_write(port, 0, UART_IMR);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm)
tty/serial/msm_serial.c:		c = msm_poll_get_char_dm(port);
tty/serial/msm_serial.c:		c = msm_poll_get_char_single(port);
tty/serial/msm_serial.c:	msm_write(port, imr, UART_IMR);
tty/serial/msm_serial.c:static void msm_poll_put_char(struct uart_port *port, unsigned char c)
tty/serial/msm_serial.c:	struct msm_port *msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	imr = msm_read(port, UART_IMR);
tty/serial/msm_serial.c:	msm_write(port, 0, UART_IMR);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm)
tty/serial/msm_serial.c:		msm_reset_dm_count(port, 1);
tty/serial/msm_serial.c:	while (!(msm_read(port, UART_SR) & UART_SR_TX_READY))
tty/serial/msm_serial.c:	msm_write(port, c, msm_port->is_uartdm ? UARTDM_TF : UART_TF);
tty/serial/msm_serial.c:	while (!(msm_read(port, UART_SR) & UART_SR_TX_READY))
tty/serial/msm_serial.c:	msm_write(port, imr, UART_IMR);
tty/serial/msm_serial.c:static struct uart_ops msm_uart_pops = {
tty/serial/msm_serial.c:	.tx_empty = msm_tx_empty,
tty/serial/msm_serial.c:	.set_mctrl = msm_set_mctrl,
tty/serial/msm_serial.c:	.get_mctrl = msm_get_mctrl,
tty/serial/msm_serial.c:	.stop_tx = msm_stop_tx,
tty/serial/msm_serial.c:	.start_tx = msm_start_tx,
tty/serial/msm_serial.c:	.stop_rx = msm_stop_rx,
tty/serial/msm_serial.c:	.enable_ms = msm_enable_ms,
tty/serial/msm_serial.c:	.break_ctl = msm_break_ctl,
tty/serial/msm_serial.c:	.startup = msm_startup,
tty/serial/msm_serial.c:	.shutdown = msm_shutdown,
tty/serial/msm_serial.c:	.set_termios = msm_set_termios,
tty/serial/msm_serial.c:	.type = msm_type,
tty/serial/msm_serial.c:	.release_port = msm_release_port,
tty/serial/msm_serial.c:	.request_port = msm_request_port,
tty/serial/msm_serial.c:	.config_port = msm_config_port,
tty/serial/msm_serial.c:	.verify_port = msm_verify_port,
tty/serial/msm_serial.c:	.pm = msm_power,
tty/serial/msm_serial.c:	.poll_get_char	= msm_poll_get_char,
tty/serial/msm_serial.c:	.poll_put_char	= msm_poll_put_char,
tty/serial/msm_serial.c:static struct msm_port msm_uart_ports[] = {
tty/serial/msm_serial.c:			.ops = &msm_uart_pops,
tty/serial/msm_serial.c:			.ops = &msm_uart_pops,
tty/serial/msm_serial.c:			.ops = &msm_uart_pops,
tty/serial/msm_serial.c:#define UART_NR	ARRAY_SIZE(msm_uart_ports)
tty/serial/msm_serial.c:static inline struct uart_port *msm_get_port_from_line(unsigned int line)
tty/serial/msm_serial.c:	return &msm_uart_ports[line].uart;
tty/serial/msm_serial.c:static void __msm_console_write(struct uart_port *port, const char *s,
tty/serial/msm_serial.c:		msm_reset_dm_count(port, count);
tty/serial/msm_serial.c:		while (!(msm_read(port, UART_SR) & UART_SR_TX_READY))
tty/serial/msm_serial.c:static void msm_console_write(struct console *co, const char *s,
tty/serial/msm_serial.c:	struct msm_port *msm_port;
tty/serial/msm_serial.c:	port = msm_get_port_from_line(co->index);
tty/serial/msm_serial.c:	msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	__msm_console_write(port, s, count, msm_port->is_uartdm);
tty/serial/msm_serial.c:static int __init msm_console_setup(struct console *co, char *options)
tty/serial/msm_serial.c:	port = msm_get_port_from_line(co->index);
tty/serial/msm_serial.c:	msm_serial_set_mnd_regs(port);
tty/serial/msm_serial.c:	pr_info("msm_serial: console setup on port #%d\n", port->line);
tty/serial/msm_serial.c:msm_serial_early_write(struct console *con, const char *s, unsigned n)
tty/serial/msm_serial.c:	__msm_console_write(&dev->port, s, n, false);
tty/serial/msm_serial.c:msm_serial_early_console_setup(struct earlycon_device *device, const char *opt)
tty/serial/msm_serial.c:	device->con->write = msm_serial_early_write;
tty/serial/msm_serial.c:OF_EARLYCON_DECLARE(msm_serial, "qcom,msm-uart",
tty/serial/msm_serial.c:		    msm_serial_early_console_setup);
tty/serial/msm_serial.c:msm_serial_early_write_dm(struct console *con, const char *s, unsigned n)
tty/serial/msm_serial.c:	__msm_console_write(&dev->port, s, n, true);
tty/serial/msm_serial.c:msm_serial_early_console_setup_dm(struct earlycon_device *device,
tty/serial/msm_serial.c:	device->con->write = msm_serial_early_write_dm;
tty/serial/msm_serial.c:OF_EARLYCON_DECLARE(msm_serial_dm, "qcom,msm-uartdm",
tty/serial/msm_serial.c:		    msm_serial_early_console_setup_dm);
tty/serial/msm_serial.c:static struct uart_driver msm_uart_driver;
tty/serial/msm_serial.c:static struct console msm_console = {
tty/serial/msm_serial.c:	.write = msm_console_write,
tty/serial/msm_serial.c:	.setup = msm_console_setup,
tty/serial/msm_serial.c:	.data = &msm_uart_driver,
tty/serial/msm_serial.c:#define MSM_CONSOLE	(&msm_console)
tty/serial/msm_serial.c:static struct uart_driver msm_uart_driver = {
tty/serial/msm_serial.c:	.driver_name = "msm_serial",
tty/serial/msm_serial.c:static atomic_t msm_uart_next_id = ATOMIC_INIT(0);
tty/serial/msm_serial.c:static const struct of_device_id msm_uartdm_table[] = {
tty/serial/msm_serial.c:	{ .compatible = "qcom,msm-uartdm-v1.1", .data = (void *)UARTDM_1P1 },
tty/serial/msm_serial.c:	{ .compatible = "qcom,msm-uartdm-v1.2", .data = (void *)UARTDM_1P2 },
tty/serial/msm_serial.c:	{ .compatible = "qcom,msm-uartdm-v1.3", .data = (void *)UARTDM_1P3 },
tty/serial/msm_serial.c:	{ .compatible = "qcom,msm-uartdm-v1.4", .data = (void *)UARTDM_1P4 },
tty/serial/msm_serial.c:static int msm_serial_probe(struct platform_device *pdev)
tty/serial/msm_serial.c:	struct msm_port *msm_port;
tty/serial/msm_serial.c:		line = atomic_inc_return(&msm_uart_next_id) - 1;
tty/serial/msm_serial.c:	dev_info(&pdev->dev, "msm_serial: detected port #%d\n", line);
tty/serial/msm_serial.c:	port = msm_get_port_from_line(line);
tty/serial/msm_serial.c:	msm_port = UART_TO_MSM(port);
tty/serial/msm_serial.c:	id = of_match_device(msm_uartdm_table, &pdev->dev);
tty/serial/msm_serial.c:		msm_port->is_uartdm = (unsigned long)id->data;
tty/serial/msm_serial.c:		msm_port->is_uartdm = 0;
tty/serial/msm_serial.c:	msm_port->clk = devm_clk_get(&pdev->dev, "core");
tty/serial/msm_serial.c:	if (IS_ERR(msm_port->clk))
tty/serial/msm_serial.c:		return PTR_ERR(msm_port->clk);
tty/serial/msm_serial.c:	if (msm_port->is_uartdm) {
tty/serial/msm_serial.c:		msm_port->pclk = devm_clk_get(&pdev->dev, "iface");
tty/serial/msm_serial.c:		if (IS_ERR(msm_port->pclk))
tty/serial/msm_serial.c:			return PTR_ERR(msm_port->pclk);
tty/serial/msm_serial.c:	port->uartclk = clk_get_rate(msm_port->clk);
tty/serial/msm_serial.c:	return uart_add_one_port(&msm_uart_driver, port);
tty/serial/msm_serial.c:static int msm_serial_remove(struct platform_device *pdev)
tty/serial/msm_serial.c:	uart_remove_one_port(&msm_uart_driver, port);
tty/serial/msm_serial.c:static const struct of_device_id msm_match_table[] = {
tty/serial/msm_serial.c:	{ .compatible = "qcom,msm-uart" },
tty/serial/msm_serial.c:	{ .compatible = "qcom,msm-uartdm" },
tty/serial/msm_serial.c:MODULE_DEVICE_TABLE(of, msm_match_table);
tty/serial/msm_serial.c:static int __maybe_unused msm_serial_suspend(struct device *dev)
tty/serial/msm_serial.c:	struct msm_port *port = dev_get_drvdata(dev);
tty/serial/msm_serial.c:	uart_suspend_port(&msm_uart_driver, &port->uart);
tty/serial/msm_serial.c:static int __maybe_unused msm_serial_resume(struct device *dev)
tty/serial/msm_serial.c:	struct msm_port *port = dev_get_drvdata(dev);
tty/serial/msm_serial.c:	uart_resume_port(&msm_uart_driver, &port->uart);
tty/serial/msm_serial.c:static const struct dev_pm_ops msm_serial_dev_pm_ops = {
tty/serial/msm_serial.c:	SET_SYSTEM_SLEEP_PM_OPS(msm_serial_suspend, msm_serial_resume)
tty/serial/msm_serial.c:static struct platform_driver msm_platform_driver = {
tty/serial/msm_serial.c:	.remove = msm_serial_remove,
tty/serial/msm_serial.c:	.probe = msm_serial_probe,
tty/serial/msm_serial.c:		.name = "msm_serial",
tty/serial/msm_serial.c:		.pm = &msm_serial_dev_pm_ops,
tty/serial/msm_serial.c:		.of_match_table = msm_match_table,
tty/serial/msm_serial.c:static int __init msm_serial_init(void)
tty/serial/msm_serial.c:	ret = uart_register_driver(&msm_uart_driver);
tty/serial/msm_serial.c:	ret = platform_driver_register(&msm_platform_driver);
tty/serial/msm_serial.c:		uart_unregister_driver(&msm_uart_driver);
tty/serial/msm_serial.c:	pr_info("msm_serial: driver initialized\n");
tty/serial/msm_serial.c:static void __exit msm_serial_exit(void)
tty/serial/msm_serial.c:	platform_driver_unregister(&msm_platform_driver);
tty/serial/msm_serial.c:	uart_unregister_driver(&msm_uart_driver);
tty/serial/msm_serial.c:module_init(msm_serial_init);
tty/serial/msm_serial.c:module_exit(msm_serial_exit);
tty/serial/msm_serial.c:MODULE_DESCRIPTION("Driver for msm7x serial device");
tty/serial/msm_serial_hs.c:/* drivers/serial/msm_serial_hs.c
tty/serial/msm_serial_hs.c: * of operation. See msm_serial_hs_platform_data.rx_wakeup_irq.
tty/serial/msm_serial_hs.c:#include <linux/msm-sps.h>
tty/serial/msm_serial_hs.c:#include <linux/platform_data/msm_serial_hs.h>
tty/serial/msm_serial_hs.c:#include <linux/msm-bus.h>
tty/serial/msm_serial_hs.c:#include "msm_serial_hs_hwreg.h"
tty/serial/msm_serial_hs.c:	if (msm_uport->ipc_debug_mask >= DBG_LEV) { \
tty/serial/msm_serial_hs.c:		ipc_log_string(msm_uport->ipc_msm_hs_log_ctxt, x); \
tty/serial/msm_serial_hs.c:	if (msm_uport->ipc_debug_mask >= INFO_LEV) {\
tty/serial/msm_serial_hs.c:		ipc_log_string(msm_uport->ipc_msm_hs_log_ctxt, x); \
tty/serial/msm_serial_hs.c:	if (msm_uport->ipc_msm_hs_log_ctxt && \
tty/serial/msm_serial_hs.c:			msm_uport->ipc_debug_mask >= WARN_LEV) \
tty/serial/msm_serial_hs.c:		ipc_log_string(msm_uport->ipc_msm_hs_log_ctxt, x); \
tty/serial/msm_serial_hs.c:	if (msm_uport->ipc_msm_hs_log_ctxt && \
tty/serial/msm_serial_hs.c:			msm_uport->ipc_debug_mask >= ERR_LEV) { \
tty/serial/msm_serial_hs.c:		ipc_log_string(msm_uport->ipc_msm_hs_log_ctxt, x); \
tty/serial/msm_serial_hs.c:		msm_uport->ipc_debug_mask = FATAL_LEV; \
tty/serial/msm_serial_hs.c:struct msm_hs_sps_ep_conn_data {
tty/serial/msm_serial_hs.c:struct msm_hs_tx {
tty/serial/msm_serial_hs.c:	struct msm_hs_sps_ep_conn_data cons;
tty/serial/msm_serial_hs.c:struct msm_hs_rx {
tty/serial/msm_serial_hs.c:	struct msm_hs_sps_ep_conn_data prod;
tty/serial/msm_serial_hs.c:enum msm_hs_pm_state {
tty/serial/msm_serial_hs.c:struct msm_hs_wakeup {
tty/serial/msm_serial_hs.c:struct msm_hs_port {
tty/serial/msm_serial_hs.c:	struct msm_hs_tx tx;
tty/serial/msm_serial_hs.c:	struct msm_hs_rx rx;
tty/serial/msm_serial_hs.c:	struct msm_hs_wakeup wakeup;
tty/serial/msm_serial_hs.c:	struct msm_bus_scale_pdata *bus_scale_table;
tty/serial/msm_serial_hs.c:	enum msm_hs_pm_state pm_state;
tty/serial/msm_serial_hs.c:	void *ipc_msm_hs_log_ctxt;
tty/serial/msm_serial_hs.c:	void *ipc_msm_hs_pwr_ctxt;
tty/serial/msm_serial_hs.c:static const struct of_device_id msm_hs_match_table[] = {
tty/serial/msm_serial_hs.c:	{ .compatible = "qcom,msm-hsuart-v14"},
tty/serial/msm_serial_hs.c:static struct platform_driver msm_serial_hs_platform_driver;
tty/serial/msm_serial_hs.c:static struct uart_driver msm_hs_driver;
tty/serial/msm_serial_hs.c:static const struct uart_ops msm_hs_ops;
tty/serial/msm_serial_hs.c:static void msm_hs_start_rx_locked(struct uart_port *uport);
tty/serial/msm_serial_hs.c:static void msm_serial_hs_rx_work(struct kthread_work *work);
tty/serial/msm_serial_hs.c:static void msm_hs_bus_voting(struct msm_hs_port *msm_uport, unsigned int vote);
tty/serial/msm_serial_hs.c:static struct msm_hs_port *msm_hs_get_hs_port(int port_index);
tty/serial/msm_serial_hs.c:static void msm_hs_queue_rx_desc(struct msm_hs_port *msm_uport);
tty/serial/msm_serial_hs.c:static int disconnect_rx_endpoint(struct msm_hs_port *msm_uport);
tty/serial/msm_serial_hs.c:static int msm_hs_pm_resume(struct device *dev);
tty/serial/msm_serial_hs.c:	container_of((uart_port), struct msm_hs_port, uport)
tty/serial/msm_serial_hs.c:static int msm_hs_ioctl(struct uart_port *uport, unsigned int cmd,
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	if (!msm_uport)
tty/serial/msm_serial_hs.c:		ret = msm_hs_request_clock_on(&msm_uport->uport);
tty/serial/msm_serial_hs.c:		ret = msm_hs_request_clock_off(&msm_uport->uport);
tty/serial/msm_serial_hs.c:		if (msm_uport->pm_state != MSM_HS_PM_ACTIVE)
tty/serial/msm_serial_hs.c:static int msm_hs_clk_bus_vote(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	msm_hs_bus_voting(msm_uport, BUS_SCALING);
tty/serial/msm_serial_hs.c:	if (msm_uport->pclk) {
tty/serial/msm_serial_hs.c:		rc = clk_prepare_enable(msm_uport->pclk);
tty/serial/msm_serial_hs.c:			dev_err(msm_uport->uport.dev,
tty/serial/msm_serial_hs.c:	rc = clk_prepare_enable(msm_uport->clk);
tty/serial/msm_serial_hs.c:		dev_err(msm_uport->uport.dev,
tty/serial/msm_serial_hs.c:	clk_disable_unprepare(msm_uport->pclk);
tty/serial/msm_serial_hs.c:	msm_hs_bus_voting(msm_uport, BUS_RESET);
tty/serial/msm_serial_hs.c:static void msm_hs_clk_bus_unvote(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	clk_disable_unprepare(msm_uport->clk);
tty/serial/msm_serial_hs.c:	if (msm_uport->pclk)
tty/serial/msm_serial_hs.c:		clk_disable_unprepare(msm_uport->pclk);
tty/serial/msm_serial_hs.c:	msm_hs_bus_voting(msm_uport, BUS_RESET);
tty/serial/msm_serial_hs.c:static void msm_hs_resource_unvote(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &(msm_uport->uport);
tty/serial/msm_serial_hs.c:	int rc = atomic_read(&msm_uport->resource_count);
tty/serial/msm_serial_hs.c:	atomic_dec(&msm_uport->resource_count);
tty/serial/msm_serial_hs.c:static void msm_hs_resource_vote(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &(msm_uport->uport);
tty/serial/msm_serial_hs.c:	if (ret < 0 || msm_uport->pm_state != MSM_HS_PM_ACTIVE) {
tty/serial/msm_serial_hs.c:					msm_uport->pm_state);
tty/serial/msm_serial_hs.c:		msm_hs_pm_resume(uport->dev);
tty/serial/msm_serial_hs.c:	atomic_inc(&msm_uport->resource_count);
tty/serial/msm_serial_hs.c:static struct msm_hs_port *get_matching_hs_port(struct platform_device *pdev)
tty/serial/msm_serial_hs.c:	struct msm_serial_hs_platform_data *pdata = pdev->dev.platform_data;
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = msm_hs_get_hs_port(pdev->id);
tty/serial/msm_serial_hs.c:	if ((!msm_uport) || (msm_uport->uport.line != pdev->id
tty/serial/msm_serial_hs.c:	   && msm_uport->uport.line != pdata->userid)) {
tty/serial/msm_serial_hs.c:	return msm_uport;
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
tty/serial/msm_serial_hs.c:	if (msm_uport) {
tty/serial/msm_serial_hs.c:		if (msm_uport->pm_state != MSM_HS_PM_ACTIVE)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
tty/serial/msm_serial_hs.c:	if (msm_uport) {
tty/serial/msm_serial_hs.c:			msm_hs_request_clock_off(&msm_uport->uport);
tty/serial/msm_serial_hs.c:			msm_hs_request_clock_on(&msm_uport->uport);
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
tty/serial/msm_serial_hs.c:	if (msm_uport)
tty/serial/msm_serial_hs.c:					msm_uport->ipc_debug_mask);
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
tty/serial/msm_serial_hs.c:	if (msm_uport) {
tty/serial/msm_serial_hs.c:		msm_uport->ipc_debug_mask = buf[0] - '0';
tty/serial/msm_serial_hs.c:		if (msm_uport->ipc_debug_mask < FATAL_LEV ||
tty/serial/msm_serial_hs.c:				msm_uport->ipc_debug_mask > DBG_LEV) {
tty/serial/msm_serial_hs.c:			msm_uport->ipc_debug_mask = INFO_LEV;
tty/serial/msm_serial_hs.c:static inline bool is_use_low_power_wakeup(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	return msm_uport->wakeup.irq > 0;
tty/serial/msm_serial_hs.c:static void msm_hs_bus_voting(struct msm_hs_port *msm_uport, unsigned int vote)
tty/serial/msm_serial_hs.c:	if (msm_uport->bus_perf_client) {
tty/serial/msm_serial_hs.c:		ret = msm_bus_scale_client_update_request(
tty/serial/msm_serial_hs.c:				msm_uport->bus_perf_client, vote);
tty/serial/msm_serial_hs.c:static inline unsigned int msm_hs_read(struct uart_port *uport,
tty/serial/msm_serial_hs.c:static inline void msm_hs_write(struct uart_port *uport, unsigned int index,
tty/serial/msm_serial_hs.c:static void hex_dump_ipc(struct msm_hs_port *msm_uport, void *ipc_ctx,
tty/serial/msm_serial_hs.c:static void dump_uart_hs_registers(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &(msm_uport->uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->pm_state != MSM_HS_PM_ACTIVE) {
tty/serial/msm_serial_hs.c:			__func__, atomic_read(&msm_uport->resource_count));
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_MR1),
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_MR2),
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_TFWR),
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_RFWR),
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_DMEN),
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_IMR),
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_MISR),
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_NCF_TX));
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_SR),
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_ISR),
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_DMRX),
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_RX_TOTAL_SNAP),
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_TXFS),
tty/serial/msm_serial_hs.c:	msm_hs_read(uport, UART_DM_RXFS));
tty/serial/msm_serial_hs.c:	MSM_HS_DBG("rx.flush:%u\n", msm_uport->rx.flush);
tty/serial/msm_serial_hs.c:static int msm_serial_loopback_enable_set(void *data, u64 val)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = data;
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &(msm_uport->uport);
tty/serial/msm_serial_hs.c:	msm_hs_resource_vote(msm_uport);
tty/serial/msm_serial_hs.c:		ret = msm_hs_read(uport, UART_DM_MR2);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_MR2, ret);
tty/serial/msm_serial_hs.c:		ret = msm_hs_read(uport, UART_DM_MR2);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_MR2, ret);
tty/serial/msm_serial_hs.c:	msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:static int msm_serial_loopback_enable_get(void *data, u64 *val)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = data;
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &(msm_uport->uport);
tty/serial/msm_serial_hs.c:	msm_hs_resource_vote(msm_uport);
tty/serial/msm_serial_hs.c:	ret = msm_hs_read(&msm_uport->uport, UART_DM_MR2);
tty/serial/msm_serial_hs.c:	msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:DEFINE_DEBUGFS_ATTRIBUTE(loopback_enable_fops, msm_serial_loopback_enable_get,
tty/serial/msm_serial_hs.c:			msm_serial_loopback_enable_set, "%llu\n");
tty/serial/msm_serial_hs.c: * msm_serial_hs debugfs node: <debugfs_root>/msm_serial_hs/loopback.<id>
tty/serial/msm_serial_hs.c:static void msm_serial_debugfs_init(struct msm_hs_port *msm_uport,
tty/serial/msm_serial_hs.c:	msm_uport->loopback_dir = debugfs_create_file(node_name,
tty/serial/msm_serial_hs.c:						msm_uport,
tty/serial/msm_serial_hs.c:	if (IS_ERR_OR_NULL(msm_uport->loopback_dir))
tty/serial/msm_serial_hs.c:static int msm_hs_remove(struct platform_device *pdev)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport;
tty/serial/msm_serial_hs.c:	msm_uport = get_matching_hs_port(pdev);
tty/serial/msm_serial_hs.c:	if (!msm_uport)
tty/serial/msm_serial_hs.c:	dev = msm_uport->uport.dev;
tty/serial/msm_serial_hs.c:	debugfs_remove(msm_uport->loopback_dir);
tty/serial/msm_serial_hs.c:	dma_free_coherent(msm_uport->uport.dev,
tty/serial/msm_serial_hs.c:			msm_uport->rx.buffer, msm_uport->rx.rbuffer);
tty/serial/msm_serial_hs.c:	msm_uport->rx.buffer = NULL;
tty/serial/msm_serial_hs.c:	msm_uport->rx.rbuffer = 0;
tty/serial/msm_serial_hs.c:	destroy_workqueue(msm_uport->hsuart_wq);
tty/serial/msm_serial_hs.c:	mutex_destroy(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	uart_remove_one_port(&msm_hs_driver, &msm_uport->uport);
tty/serial/msm_serial_hs.c:	clk_put(msm_uport->clk);
tty/serial/msm_serial_hs.c:	if (msm_uport->pclk)
tty/serial/msm_serial_hs.c:		clk_put(msm_uport->pclk);
tty/serial/msm_serial_hs.c:	iounmap(msm_uport->uport.membase);
tty/serial/msm_serial_hs.c:static int msm_hs_spsconnect_tx(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &msm_uport->uport;
tty/serial/msm_serial_hs.c:	struct msm_hs_tx *tx = &msm_uport->tx;
tty/serial/msm_serial_hs.c:		MSM_HS_ERR("msm_serial_hs: sps_connect() failed for tx\n"
tty/serial/msm_serial_hs.c:		MSM_HS_ERR("msm_serial_hs: sps_connect() failed for tx\n"
tty/serial/msm_serial_hs.c:	spin_lock_irqsave(&(msm_uport->uport.lock), flags);
tty/serial/msm_serial_hs.c:	msm_uport->tx.flush = FLUSH_STOP;
tty/serial/msm_serial_hs.c:	spin_unlock_irqrestore(&(msm_uport->uport.lock), flags);
tty/serial/msm_serial_hs.c:	data = msm_hs_read(uport, UART_DM_DMEN);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_DMEN, data);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RESET_TX);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, START_TX_BAM_IFC);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, UARTDM_CR_TX_EN_BMSK);
tty/serial/msm_serial_hs.c:static int msm_hs_spsconnect_rx(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	struct msm_hs_rx *rx = &msm_uport->rx;
tty/serial/msm_serial_hs.c:		MSM_HS_ERR("msm_serial_hs: sps_connect() failed for rx\n"
tty/serial/msm_serial_hs.c:		MSM_HS_ERR("msm_serial_hs: sps_connect() failed for rx\n"
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.pending_flag)
tty/serial/msm_serial_hs.c:		__func__, msm_uport->rx.pending_flag);
tty/serial/msm_serial_hs.c:	msm_uport->rx.queued_flag = 0;
tty/serial/msm_serial_hs.c:	msm_uport->rx.pending_flag = 0;
tty/serial/msm_serial_hs.c:	msm_uport->rx.rx_inx = 0;
tty/serial/msm_serial_hs.c:	msm_uport->rx.flush = FLUSH_STOP;
tty/serial/msm_serial_hs.c:static void msm_hs_set_bps_locked(struct uart_port *uport,
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0x00);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0x11);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0x22);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0x33);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0x44);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0x55);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0x66);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0x77);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0x88);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0x99);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0xaa);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0xbb);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0xcc);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0xee);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0xff);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0xff);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0xff);
tty/serial/msm_serial_hs.c:	if (clk_set_rate(msm_uport->clk, uport->uartclk)) {
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_IPR, data);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RESET_TX);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RESET_RX);
tty/serial/msm_serial_hs.c:static void msm_hs_set_std_bps_locked(struct uart_port *uport,
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0x99);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0xaa);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0xbb);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0xcc);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0xdd);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0xee);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0xff);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CSR, 0x99);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_IPR, data);
tty/serial/msm_serial_hs.c:static void msm_hs_enable_flow_control(struct uart_port *uport, bool override)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->flow_control || override) {
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CR, RFR_LOW);
tty/serial/msm_serial_hs.c:		data = msm_hs_read(uport, UART_DM_MR1);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_MR1, data);
tty/serial/msm_serial_hs.c:static void msm_hs_disable_flow_control(struct uart_port *uport, bool override)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->flow_control || override) {
tty/serial/msm_serial_hs.c:		data = msm_hs_read(uport, UART_DM_MR1);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_MR1, data);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CR, RFR_HIGH);
tty/serial/msm_serial_hs.c:static void msm_hs_set_termios(struct uart_port *uport,
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	msm_hs_resource_vote(msm_uport);
tty/serial/msm_serial_hs.c:	mutex_lock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_IMR, 0);
tty/serial/msm_serial_hs.c:	msm_hs_disable_flow_control(uport, true);
tty/serial/msm_serial_hs.c:	data = msm_hs_read(uport, UART_DM_DMEN);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_DMEN, data);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RESET_RX);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, UARTDM_CR_RX_DISABLE_BMSK);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RESET_TX);
tty/serial/msm_serial_hs.c:	uport->uartclk = clk_get_rate(msm_uport->clk);
tty/serial/msm_serial_hs.c:		msm_hs_set_std_bps_locked(uport, bps);
tty/serial/msm_serial_hs.c:		msm_hs_set_bps_locked(uport, bps);
tty/serial/msm_serial_hs.c:	data = msm_hs_read(uport, UART_DM_MR2);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_MR2, data);
tty/serial/msm_serial_hs.c:	data = msm_hs_read(uport, UART_DM_DMEN);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_DMEN, data);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, UARTDM_CR_RX_EN_BMSK);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, START_TX_BAM_IFC);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, START_RX_BAM_IFC);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RFR_LOW);
tty/serial/msm_serial_hs.c:	data = msm_hs_read(uport, UART_DM_MR1);
tty/serial/msm_serial_hs.c:		msm_uport->flow_control = true;
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_MR1, data);
tty/serial/msm_serial_hs.c:	mutex_unlock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:unsigned int msm_hs_tx_empty(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	msm_hs_resource_vote(msm_uport);
tty/serial/msm_serial_hs.c:	data = msm_hs_read(uport, UART_DM_SR);
tty/serial/msm_serial_hs.c:	isr = msm_hs_read(uport, UART_DM_ISR);
tty/serial/msm_serial_hs.c:	msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:EXPORT_SYMBOL(msm_hs_tx_empty);
tty/serial/msm_serial_hs.c:static void msm_hs_stop_tx_locked(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	struct msm_hs_tx *tx = &msm_uport->tx;
tty/serial/msm_serial_hs.c:static int disconnect_rx_endpoint(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_rx *rx = &msm_uport->rx;
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.pending_flag)
tty/serial/msm_serial_hs.c:		__func__, msm_uport->rx.pending_flag);
tty/serial/msm_serial_hs.c:	msm_uport->rx.queued_flag = 0;
tty/serial/msm_serial_hs.c:	msm_uport->rx.pending_flag = 0;
tty/serial/msm_serial_hs.c:	msm_uport->rx.rx_inx = 0;
tty/serial/msm_serial_hs.c:	msm_uport->rx.flush = FLUSH_SHUTDOWN;
tty/serial/msm_serial_hs.c:	wake_up(&msm_uport->bam_disconnect_wait);
tty/serial/msm_serial_hs.c:	wake_up(&msm_uport->rx.wait);
tty/serial/msm_serial_hs.c:static int sps_tx_disconnect(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &msm_uport->uport;
tty/serial/msm_serial_hs.c:	struct msm_hs_tx *tx = &msm_uport->tx;
tty/serial/msm_serial_hs.c:	if (msm_uport->tx.flush == FLUSH_SHUTDOWN) {
tty/serial/msm_serial_hs.c:	msm_uport->tx.flush = FLUSH_SHUTDOWN;
tty/serial/msm_serial_hs.c:static void msm_hs_disable_rx(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	data = msm_hs_read(uport, UART_DM_DMEN);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_DMEN, data);
tty/serial/msm_serial_hs.c:static void msm_hs_stop_rx_locked(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->pm_state != MSM_HS_PM_ACTIVE)
tty/serial/msm_serial_hs.c:		msm_hs_disable_rx(uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.flush == FLUSH_NONE)
tty/serial/msm_serial_hs.c:		msm_uport->rx.flush = FLUSH_STOP;
tty/serial/msm_serial_hs.c:static void msm_hs_disconnect_rx(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	msm_hs_disable_rx(uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.flush == FLUSH_NONE)
tty/serial/msm_serial_hs.c:		msm_uport->rx.flush = FLUSH_STOP;
tty/serial/msm_serial_hs.c:	disconnect_rx_endpoint(msm_uport);
tty/serial/msm_serial_hs.c:	MSM_HS_DBG("%s(): rx->flush %d\n", __func__, msm_uport->rx.flush);
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = from_timer(msm_uport, arg,
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &msm_uport->uport;
tty/serial/msm_serial_hs.c:	if (msm_uport->pm_state != MSM_HS_PM_ACTIVE) {
tty/serial/msm_serial_hs.c:	isr = msm_hs_read(uport, UART_DM_ISR);
tty/serial/msm_serial_hs.c:	dump_uart_hs_registers(msm_uport);
tty/serial/msm_serial_hs.c:static void msm_hs_submit_tx_locked(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	struct msm_hs_tx *tx = &msm_uport->tx;
tty/serial/msm_serial_hs.c:	struct circ_buf *tx_buf = &msm_uport->uport.state->xmit;
tty/serial/msm_serial_hs.c:		msm_hs_stop_tx_locked(uport);
tty/serial/msm_serial_hs.c:	hex_dump_ipc(msm_uport, tx->ipc_tx_ctxt, "Tx",
tty/serial/msm_serial_hs.c:				msm_uport, flags);
tty/serial/msm_serial_hs.c:static void msm_hs_post_rx_desc(struct msm_hs_port *msm_uport, int inx)
tty/serial/msm_serial_hs.c:	struct msm_hs_rx *rx = &msm_uport->rx;
tty/serial/msm_serial_hs.c:		__func__, msm_uport->uport.line, inx,
tty/serial/msm_serial_hs.c:		UARTDM_RX_BUF_SIZE, msm_uport, flags);
tty/serial/msm_serial_hs.c:static void msm_hs_mark_next(struct msm_hs_port *msm_uport, int inx)
tty/serial/msm_serial_hs.c:	struct msm_hs_rx *rx = &msm_uport->rx;
tty/serial/msm_serial_hs.c:		msm_uport->rx.rx_inx = inx;
tty/serial/msm_serial_hs.c:		prev, rx->pending_flag, msm_uport->rx.rx_inx);
tty/serial/msm_serial_hs.c:static void msm_hs_queue_rx_desc(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_rx *rx = &msm_uport->rx;
tty/serial/msm_serial_hs.c:			msm_hs_post_rx_desc(msm_uport, rx->rx_inx);
tty/serial/msm_serial_hs.c:			msm_hs_post_rx_desc(msm_uport, i);
tty/serial/msm_serial_hs.c:static void msm_hs_start_rx_locked(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	struct msm_hs_rx *rx = &msm_uport->rx;
tty/serial/msm_serial_hs.c:	unsigned int buffer_pending = msm_uport->rx.buffer_pending;
tty/serial/msm_serial_hs.c:	if (msm_uport->pm_state != MSM_HS_PM_ACTIVE) {
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RESET_STALE_INT);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_DMRX, UARTDM_RX_BUF_SIZE);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, STALE_EVENT_ENABLE);
tty/serial/msm_serial_hs.c:	data = msm_hs_read(uport, UART_DM_DMEN);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_DMEN, data);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_IMR, msm_uport->imr_reg);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_RX_TRANS_CTRL, data);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, START_RX_BAM_IFC);
tty/serial/msm_serial_hs.c:	msm_uport->rx.flush = FLUSH_NONE;
tty/serial/msm_serial_hs.c:	msm_uport->rx_bam_inprogress = true;
tty/serial/msm_serial_hs.c:	msm_hs_queue_rx_desc(msm_uport);
tty/serial/msm_serial_hs.c:	msm_uport->rx_bam_inprogress = false;
tty/serial/msm_serial_hs.c:	wake_up(&msm_uport->rx.wait);
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport =
tty/serial/msm_serial_hs.c:		container_of(work, struct msm_hs_port,
tty/serial/msm_serial_hs.c:	struct tty_struct *tty = msm_uport->uport.state->port.tty;
tty/serial/msm_serial_hs.c:	spin_lock_irqsave(&msm_uport->uport.lock, flags);
tty/serial/msm_serial_hs.c:	if (!tty || msm_uport->rx.flush == FLUSH_SHUTDOWN) {
tty/serial/msm_serial_hs.c:				__func__, msm_uport->rx.flush);
tty/serial/msm_serial_hs.c:		spin_unlock_irqrestore(&msm_uport->uport.lock, flags);
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.buffer_pending == NONE_PENDING) {
tty/serial/msm_serial_hs.c:		spin_unlock_irqrestore(&msm_uport->uport.lock, flags);
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.buffer_pending & FIFO_OVERRUN) {
tty/serial/msm_serial_hs.c:			msm_uport->rx.buffer_pending &= ~FIFO_OVERRUN;
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.buffer_pending & PARITY_ERROR) {
tty/serial/msm_serial_hs.c:			msm_uport->rx.buffer_pending &= ~PARITY_ERROR;
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.buffer_pending & CHARS_NORMAL) {
tty/serial/msm_serial_hs.c:		rx_count = (msm_uport->rx.buffer_pending & 0xFFFF0000) >> 16;
tty/serial/msm_serial_hs.c:		rx_offset = (msm_uport->rx.buffer_pending & 0xFFD0) >> 5;
tty/serial/msm_serial_hs.c:			msm_uport->rx.buffer +
tty/serial/msm_serial_hs.c:			(msm_uport->rx.rx_inx * UARTDM_RX_BUF_SIZE)
tty/serial/msm_serial_hs.c:		msm_uport->rx.buffer_pending &= (FIFO_OVERRUN |
tty/serial/msm_serial_hs.c:			msm_uport->rx.buffer_pending |= CHARS_NORMAL |
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.buffer_pending) {
tty/serial/msm_serial_hs.c:		schedule_delayed_work(&msm_uport->rx.flip_insert_work,
tty/serial/msm_serial_hs.c:	} else if (msm_uport->rx.flush <= FLUSH_IGNORE) {
tty/serial/msm_serial_hs.c:		clear_bit(msm_uport->rx.rx_inx,
tty/serial/msm_serial_hs.c:			&msm_uport->rx.pending_flag);
tty/serial/msm_serial_hs.c:		msm_hs_start_rx_locked(&msm_uport->uport);
tty/serial/msm_serial_hs.c:		msm_hs_mark_next(msm_uport, msm_uport->rx.rx_inx+1);
tty/serial/msm_serial_hs.c:	spin_unlock_irqrestore(&msm_uport->uport.lock, flags);
tty/serial/msm_serial_hs.c:static void msm_serial_hs_rx_work(struct kthread_work *work)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport;
tty/serial/msm_serial_hs.c:	struct msm_hs_rx *rx;
tty/serial/msm_serial_hs.c:	const struct msm_serial_hs_platform_data *pdata;
tty/serial/msm_serial_hs.c:	msm_uport = container_of((struct kthread_work *) work,
tty/serial/msm_serial_hs.c:				 struct msm_hs_port, rx.kwork);
tty/serial/msm_serial_hs.c:	msm_hs_resource_vote(msm_uport);
tty/serial/msm_serial_hs.c:	uport = &msm_uport->uport;
tty/serial/msm_serial_hs.c:	notify = &msm_uport->notify;
tty/serial/msm_serial_hs.c:	rx = &msm_uport->rx;
tty/serial/msm_serial_hs.c:		msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:		status = msm_hs_read(uport, UART_DM_SR);
tty/serial/msm_serial_hs.c:				msm_uport->rx.buffer_pending |= TTY_OVERRUN;
tty/serial/msm_serial_hs.c:			MSM_HS_WARN("msm_serial_hs: parity error\n");
tty/serial/msm_serial_hs.c:					msm_uport->rx.buffer_pending
tty/serial/msm_serial_hs.c:			MSM_HS_DBG("msm_serial_hs: Rx break\n");
tty/serial/msm_serial_hs.c:					msm_uport->rx.buffer_pending
tty/serial/msm_serial_hs.c:			msm_hs_write(uport, UART_DM_CR,	RESET_ERROR_STATUS);
tty/serial/msm_serial_hs.c:		flush = msm_uport->rx.flush;
tty/serial/msm_serial_hs.c:			if (!msm_uport->rx.buffer_pending) {
tty/serial/msm_serial_hs.c:				msm_hs_start_rx_locked(uport);
tty/serial/msm_serial_hs.c:		rx_count = msm_uport->rx.iovec[msm_uport->rx.rx_inx].size;
tty/serial/msm_serial_hs.c:		hex_dump_ipc(msm_uport, rx->ipc_rx_ctxt, "Rx",
tty/serial/msm_serial_hs.c:			(msm_uport->rx.buffer +
tty/serial/msm_serial_hs.c:			(msm_uport->rx.rx_inx * UARTDM_RX_BUF_SIZE)),
tty/serial/msm_serial_hs.c:			msm_uport->rx.iovec[msm_uport->rx.rx_inx].addr,
tty/serial/msm_serial_hs.c:			if (!test_bit(msm_uport->rx.rx_inx,
tty/serial/msm_serial_hs.c:				&msm_uport->rx.pending_flag) &&
tty/serial/msm_serial_hs.c:			    !test_bit(msm_uport->rx.rx_inx,
tty/serial/msm_serial_hs.c:				&msm_uport->rx.queued_flag))
tty/serial/msm_serial_hs.c:			else if (test_bit(msm_uport->rx.rx_inx,
tty/serial/msm_serial_hs.c:					&msm_uport->rx.pending_flag) &&
tty/serial/msm_serial_hs.c:				!test_bit(msm_uport->rx.rx_inx,
tty/serial/msm_serial_hs.c:					&msm_uport->rx.queued_flag)) {
tty/serial/msm_serial_hs.c:					__func__, msm_uport->rx.rx_inx);
tty/serial/msm_serial_hs.c:					msm_uport->rx.buffer +
tty/serial/msm_serial_hs.c:					(msm_uport->rx.rx_inx *
tty/serial/msm_serial_hs.c:					msm_uport->rx.buffer_pending |=
tty/serial/msm_serial_hs.c:					msm_uport->rx.rx_inx);
tty/serial/msm_serial_hs.c:		if (!msm_uport->rx.buffer_pending) {
tty/serial/msm_serial_hs.c:			msm_uport->rx.flush = FLUSH_NONE;
tty/serial/msm_serial_hs.c:			msm_uport->rx_bam_inprogress = true;
tty/serial/msm_serial_hs.c:			clear_bit(msm_uport->rx.rx_inx,
tty/serial/msm_serial_hs.c:				&msm_uport->rx.pending_flag);
tty/serial/msm_serial_hs.c:			msm_hs_queue_rx_desc(msm_uport);
tty/serial/msm_serial_hs.c:			msm_hs_mark_next(msm_uport, msm_uport->rx.rx_inx+1);
tty/serial/msm_serial_hs.c:			msm_hs_write(uport, UART_DM_CR, START_RX_BAM_IFC);
tty/serial/msm_serial_hs.c:			msm_uport->rx_bam_inprogress = false;
tty/serial/msm_serial_hs.c:			wake_up(&msm_uport->rx.wait);
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.buffer_pending) {
tty/serial/msm_serial_hs.c:		schedule_delayed_work(&msm_uport->rx.flip_insert_work
tty/serial/msm_serial_hs.c:	/* tty_flip_buffer_push() might call msm_hs_start(), so unlock */
tty/serial/msm_serial_hs.c:	msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:static void msm_hs_start_tx_locked(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	struct msm_hs_tx *tx = &msm_uport->tx;
tty/serial/msm_serial_hs.c:		kthread_queue_work(&msm_uport->tx.kworker,
tty/serial/msm_serial_hs.c:			&msm_uport->tx.kwork);
tty/serial/msm_serial_hs.c:static void msm_hs_sps_tx_callback(struct sps_event_notify *notify)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport =
tty/serial/msm_serial_hs.c:		(struct msm_hs_port *)
tty/serial/msm_serial_hs.c:	msm_uport->notify = *notify;
tty/serial/msm_serial_hs.c:	del_timer(&msm_uport->tx.tx_timeout_timer);
tty/serial/msm_serial_hs.c:	kthread_queue_work(&msm_uport->tx.kworker, &msm_uport->tx.kwork);
tty/serial/msm_serial_hs.c:static void msm_serial_hs_tx_work(struct kthread_work *work)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport =
tty/serial/msm_serial_hs.c:			struct msm_hs_port, tx.kwork);
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &msm_uport->uport;
tty/serial/msm_serial_hs.c:	struct msm_hs_tx *tx = &msm_uport->tx;
tty/serial/msm_serial_hs.c:	msm_hs_resource_vote(msm_uport);
tty/serial/msm_serial_hs.c:		spin_lock_irqsave(&(msm_uport->uport.lock), flags);
tty/serial/msm_serial_hs.c:		msm_hs_submit_tx_locked(uport);
tty/serial/msm_serial_hs.c:		spin_unlock_irqrestore(&(msm_uport->uport.lock), flags);
tty/serial/msm_serial_hs.c:		msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:	spin_lock_irqsave(&(msm_uport->uport.lock), flags);
tty/serial/msm_serial_hs.c:	wake_up(&msm_uport->tx.wait);
tty/serial/msm_serial_hs.c:	 msm_hs_submit_tx_locked(uport);
tty/serial/msm_serial_hs.c:	spin_unlock_irqrestore(&(msm_uport->uport.lock), flags);
tty/serial/msm_serial_hs.c:	msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:msm_hs_mark_proc_rx_desc(struct msm_hs_port *msm_uport,
tty/serial/msm_serial_hs.c:	struct msm_hs_rx *rx = &msm_uport->rx;
tty/serial/msm_serial_hs.c:static void msm_hs_sps_rx_callback(struct sps_event_notify *notify)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport =
tty/serial/msm_serial_hs.c:		(struct msm_hs_port *)
tty/serial/msm_serial_hs.c:	struct msm_hs_rx *rx = &msm_uport->rx;
tty/serial/msm_serial_hs.c:	uport = &(msm_uport->uport);
tty/serial/msm_serial_hs.c:	msm_uport->notify = *notify;
tty/serial/msm_serial_hs.c:	msm_hs_mark_proc_rx_desc(msm_uport, notify);
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.flush == FLUSH_NONE) {
tty/serial/msm_serial_hs.c:		if (msm_uport->rx.pending_flag & ~(1 << inx)) {
tty/serial/msm_serial_hs.c:			msm_uport->rx.pending_flag & ~(1<<inx));
tty/serial/msm_serial_hs.c:		kthread_queue_work(&msm_uport->rx.kworker,
tty/serial/msm_serial_hs.c:				&msm_uport->rx.kwork);
tty/serial/msm_serial_hs.c:static unsigned int msm_hs_get_mctrl_locked(struct uart_port *uport)
tty/serial/msm_serial_hs.c:void msm_hs_set_mctrl_locked(struct uart_port *uport,
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->pm_state != MSM_HS_PM_ACTIVE) {
tty/serial/msm_serial_hs.c:		msm_hs_disable_flow_control(uport, false);
tty/serial/msm_serial_hs.c:		msm_hs_enable_flow_control(uport, false);
tty/serial/msm_serial_hs.c:void msm_hs_set_mctrl(struct uart_port *uport,
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	msm_hs_resource_vote(msm_uport);
tty/serial/msm_serial_hs.c:	msm_hs_set_mctrl_locked(uport, mctrl);
tty/serial/msm_serial_hs.c:	msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:EXPORT_SYMBOL(msm_hs_set_mctrl);
tty/serial/msm_serial_hs.c:static void msm_hs_enable_ms_locked(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->pm_state != MSM_HS_PM_ACTIVE) {
tty/serial/msm_serial_hs.c:	msm_uport->imr_reg |= UARTDM_ISR_DELTA_CTS_BMSK;
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_IMR, msm_uport->imr_reg);
tty/serial/msm_serial_hs.c:static void msm_hs_break_ctl(struct uart_port *uport, int ctl)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	msm_hs_resource_vote(msm_uport);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, ctl ? START_BREAK : STOP_BREAK);
tty/serial/msm_serial_hs.c:	msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:static void msm_hs_config_port(struct uart_port *uport, int cfg_flags)
tty/serial/msm_serial_hs.c:static void msm_hs_handle_delta_cts_locked(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	msm_hs_resource_vote(msm_uport);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RESET_CTS);
tty/serial/msm_serial_hs.c:	msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:static irqreturn_t msm_hs_isr(int irq, void *dev)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = (struct msm_hs_port *)dev;
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &msm_uport->uport;
tty/serial/msm_serial_hs.c:	struct msm_hs_tx *tx = &msm_uport->tx;
tty/serial/msm_serial_hs.c:	isr_status = msm_hs_read(uport, UART_DM_MISR);
tty/serial/msm_serial_hs.c:	dump_uart_hs_registers(msm_uport);
tty/serial/msm_serial_hs.c:		msm_uport->imr_reg &= ~UARTDM_ISR_RXLEV_BMSK;
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_IMR, msm_uport->imr_reg);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CR, STALE_EVENT_DISABLE);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CR, RESET_STALE_INT);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CR, CLEAR_TX_READY);
tty/serial/msm_serial_hs.c:		msm_uport->imr_reg &= ~UARTDM_ISR_TXLEV_BMSK;
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_IMR, msm_uport->imr_reg);
tty/serial/msm_serial_hs.c:		queue_work(msm_uport->hsuart_wq, &msm_uport->clock_off_w);
tty/serial/msm_serial_hs.c:		msm_hs_handle_delta_cts_locked(uport);
tty/serial/msm_serial_hs.c: * port structure (struct uart_port or struct msm_hs_port) given
tty/serial/msm_serial_hs.c: * the port index. msm_hs_get_uart port is called by clients.
tty/serial/msm_serial_hs.c: * The function msm_hs_get_hs_port is for internal use
tty/serial/msm_serial_hs.c:struct uart_port *msm_hs_get_uart_port(int port_index)
tty/serial/msm_serial_hs.c:	struct uart_state *state = msm_hs_driver.state + port_index;
tty/serial/msm_serial_hs.c:EXPORT_SYMBOL(msm_hs_get_uart_port);
tty/serial/msm_serial_hs.c:static struct msm_hs_port *msm_hs_get_hs_port(int port_index)
tty/serial/msm_serial_hs.c:	struct uart_port *uport = msm_hs_get_uart_port(port_index);
tty/serial/msm_serial_hs.c:void enable_wakeup_interrupt(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &(msm_uport->uport);
tty/serial/msm_serial_hs.c:	if (!is_use_low_power_wakeup(msm_uport))
tty/serial/msm_serial_hs.c:	if (msm_uport->wakeup.freed)
tty/serial/msm_serial_hs.c:	if (!(msm_uport->wakeup.enabled)) {
tty/serial/msm_serial_hs.c:		msm_uport->wakeup.ignore = 1;
tty/serial/msm_serial_hs.c:		msm_uport->wakeup.enabled = true;
tty/serial/msm_serial_hs.c:		enable_irq(msm_uport->wakeup.irq);
tty/serial/msm_serial_hs.c:void disable_wakeup_interrupt(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &(msm_uport->uport);
tty/serial/msm_serial_hs.c:	if (!is_use_low_power_wakeup(msm_uport))
tty/serial/msm_serial_hs.c:	if (msm_uport->wakeup.freed)
tty/serial/msm_serial_hs.c:	if (msm_uport->wakeup.enabled) {
tty/serial/msm_serial_hs.c:		disable_irq_nosync(msm_uport->wakeup.irq);
tty/serial/msm_serial_hs.c:		msm_uport->wakeup.enabled = false;
tty/serial/msm_serial_hs.c:void msm_hs_resource_off(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &(msm_uport->uport);
tty/serial/msm_serial_hs.c:	msm_hs_disable_flow_control(uport, false);
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.flush == FLUSH_NONE)
tty/serial/msm_serial_hs.c:		msm_hs_disconnect_rx(uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->tx.flush == FLUSH_NONE)
tty/serial/msm_serial_hs.c:		wait_event_timeout(msm_uport->tx.wait,
tty/serial/msm_serial_hs.c:			msm_uport->tx.flush == FLUSH_STOP, 500);
tty/serial/msm_serial_hs.c:	if (msm_uport->tx.flush != FLUSH_SHUTDOWN) {
tty/serial/msm_serial_hs.c:		data = msm_hs_read(uport, UART_DM_DMEN);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_DMEN, data);
tty/serial/msm_serial_hs.c:		sps_tx_disconnect(msm_uport);
tty/serial/msm_serial_hs.c:	if (!atomic_read(&msm_uport->client_req_state))
tty/serial/msm_serial_hs.c:		msm_hs_enable_flow_control(uport, false);
tty/serial/msm_serial_hs.c:void msm_hs_resource_on(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &(msm_uport->uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.flush == FLUSH_SHUTDOWN ||
tty/serial/msm_serial_hs.c:	msm_uport->rx.flush == FLUSH_STOP) {
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_CR, RESET_RX);
tty/serial/msm_serial_hs.c:		data = msm_hs_read(uport, UART_DM_DMEN);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_DMEN, data);
tty/serial/msm_serial_hs.c:	msm_hs_spsconnect_tx(msm_uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.flush == FLUSH_SHUTDOWN) {
tty/serial/msm_serial_hs.c:		msm_hs_spsconnect_rx(uport);
tty/serial/msm_serial_hs.c:		msm_hs_start_rx_locked(uport);
tty/serial/msm_serial_hs.c:int msm_hs_request_clock_off(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	mutex_lock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	if (msm_uport->pm_state == MSM_HS_PM_SYS_SUSPENDED) {
tty/serial/msm_serial_hs.c:	mutex_unlock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	if (atomic_read(&msm_uport->client_count) <= 0) {
tty/serial/msm_serial_hs.c:	if (msm_uport->obs)
tty/serial/msm_serial_hs.c:		atomic_set(&msm_uport->client_req_state, 1);
tty/serial/msm_serial_hs.c:	msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:	atomic_dec(&msm_uport->client_count);
tty/serial/msm_serial_hs.c:	client_count = atomic_read(&msm_uport->client_count);
tty/serial/msm_serial_hs.c:	LOG_USR_MSG(msm_uport->ipc_msm_hs_pwr_ctxt,
tty/serial/msm_serial_hs.c:EXPORT_SYMBOL(msm_hs_request_clock_off);
tty/serial/msm_serial_hs.c:int msm_hs_request_clock_on(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	mutex_lock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	if (msm_uport->pm_state == MSM_HS_PM_SYS_SUSPENDED) {
tty/serial/msm_serial_hs.c:	mutex_unlock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	msm_hs_resource_vote(UARTDM_TO_MSM(uport));
tty/serial/msm_serial_hs.c:	atomic_inc(&msm_uport->client_count);
tty/serial/msm_serial_hs.c:	client_count = atomic_read(&msm_uport->client_count);
tty/serial/msm_serial_hs.c:	LOG_USR_MSG(msm_uport->ipc_msm_hs_pwr_ctxt,
tty/serial/msm_serial_hs.c:	if (msm_uport->obs)
tty/serial/msm_serial_hs.c:		atomic_set(&msm_uport->client_req_state, 0);
tty/serial/msm_serial_hs.c:EXPORT_SYMBOL(msm_hs_request_clock_on);
tty/serial/msm_serial_hs.c:static irqreturn_t msm_hs_wakeup_isr(int irq, void *dev)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = (struct msm_hs_port *)dev;
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &msm_uport->uport;
tty/serial/msm_serial_hs.c:	if (msm_uport->wakeup.ignore)
tty/serial/msm_serial_hs.c:		msm_uport->wakeup.ignore = 0;
tty/serial/msm_serial_hs.c:		if (msm_uport->wakeup.inject_rx) {
tty/serial/msm_serial_hs.c:					     msm_uport->wakeup.rx_to_inject,
tty/serial/msm_serial_hs.c:			hex_dump_ipc(msm_uport, msm_uport->rx.ipc_rx_ctxt,
tty/serial/msm_serial_hs.c:				&msm_uport->wakeup.rx_to_inject, 0, 1);
tty/serial/msm_serial_hs.c:						msm_uport->wakeup.ignore);
tty/serial/msm_serial_hs.c:	if (wakeup && msm_uport->wakeup.inject_rx)
tty/serial/msm_serial_hs.c:static const char *msm_hs_type(struct uart_port *port)
tty/serial/msm_serial_hs.c: * msm_hs_unconfig_uart_gpios: Unconfigures UART GPIOs
tty/serial/msm_serial_hs.c:static void msm_hs_unconfig_uart_gpios(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	const struct msm_serial_hs_platform_data *pdata =
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->use_pinctrl) {
tty/serial/msm_serial_hs.c:		ret = pinctrl_select_state(msm_uport->pinctrl,
tty/serial/msm_serial_hs.c:				msm_uport->gpio_state_suspend);
tty/serial/msm_serial_hs.c: * msm_hs_config_uart_gpios - Configures UART GPIOs
tty/serial/msm_serial_hs.c:static int msm_hs_config_uart_gpios(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	const struct msm_serial_hs_platform_data *pdata =
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	if (!IS_ERR_OR_NULL(msm_uport->pinctrl)) {
tty/serial/msm_serial_hs.c:		msm_uport->use_pinctrl = true;
tty/serial/msm_serial_hs.c:		ret = pinctrl_select_state(msm_uport->pinctrl,
tty/serial/msm_serial_hs.c:				msm_uport->gpio_state_active);
tty/serial/msm_serial_hs.c:static void msm_hs_get_pinctrl_configs(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	msm_uport->pinctrl = devm_pinctrl_get(uport->dev);
tty/serial/msm_serial_hs.c:	if (IS_ERR_OR_NULL(msm_uport->pinctrl)) {
tty/serial/msm_serial_hs.c:		msm_uport->use_pinctrl = true;
tty/serial/msm_serial_hs.c:		set_state = pinctrl_lookup_state(msm_uport->pinctrl,
tty/serial/msm_serial_hs.c:		msm_uport->gpio_state_active = set_state;
tty/serial/msm_serial_hs.c:		set_state = pinctrl_lookup_state(msm_uport->pinctrl,
tty/serial/msm_serial_hs.c:		msm_uport->gpio_state_suspend = set_state;
tty/serial/msm_serial_hs.c:	msm_uport->pinctrl = NULL;
tty/serial/msm_serial_hs.c:static int msm_hs_startup(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	struct msm_hs_tx *tx = &msm_uport->tx;
tty/serial/msm_serial_hs.c:	struct msm_hs_rx *rx = &msm_uport->rx;
tty/serial/msm_serial_hs.c:	msm_hs_resource_vote(msm_uport);
tty/serial/msm_serial_hs.c:	if (is_use_low_power_wakeup(msm_uport)) {
tty/serial/msm_serial_hs.c:		ret = request_threaded_irq(msm_uport->wakeup.irq, NULL,
tty/serial/msm_serial_hs.c:					msm_hs_wakeup_isr,
tty/serial/msm_serial_hs.c:					"msm_hs_wakeup", msm_uport);
tty/serial/msm_serial_hs.c:		msm_uport->wakeup.freed = false;
tty/serial/msm_serial_hs.c:		disable_irq(msm_uport->wakeup.irq);
tty/serial/msm_serial_hs.c:		msm_uport->wakeup.enabled = false;
tty/serial/msm_serial_hs.c:		ret = irq_set_irq_wake(msm_uport->wakeup.irq, 1);
tty/serial/msm_serial_hs.c:	ret = msm_hs_config_uart_gpios(uport);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_DMEN, 0);
tty/serial/msm_serial_hs.c:	sps_tx_disconnect(msm_uport);
tty/serial/msm_serial_hs.c:	ret = msm_hs_spsconnect_tx(msm_uport);
tty/serial/msm_serial_hs.c:		MSM_HS_ERR("msm_serial_hs: SPS connect failed for TX\n");
tty/serial/msm_serial_hs.c:	kthread_flush_worker(&msm_uport->rx.kworker);
tty/serial/msm_serial_hs.c:		disconnect_rx_endpoint(msm_uport);
tty/serial/msm_serial_hs.c:	ret = msm_hs_spsconnect_rx(uport);
tty/serial/msm_serial_hs.c:		MSM_HS_ERR("msm_serial_hs: SPS connect failed for RX\n");
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_BCR, data);
tty/serial/msm_serial_hs.c:	data = msm_hs_read(uport, UART_DM_MR1);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_MR1, data);
tty/serial/msm_serial_hs.c:	data = msm_hs_read(uport, UART_DM_IPR);
tty/serial/msm_serial_hs.c:		msm_hs_write(uport, UART_DM_IPR, data);
tty/serial/msm_serial_hs.c:	msm_uport->flow_control = false;
tty/serial/msm_serial_hs.c:	msm_hs_disable_flow_control(uport, true);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RESET_TX);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RESET_RX);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RESET_ERROR_STATUS);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RESET_BREAK_INT);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RESET_STALE_INT);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RESET_CTS);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, RFR_LOW);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, UARTDM_CR_RX_EN_BMSK);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, UARTDM_CR_TX_EN_BMSK);
tty/serial/msm_serial_hs.c:	msm_uport->imr_reg |= UARTDM_ISR_CURRENT_CTS_BMSK;
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_TFWR, 4);
tty/serial/msm_serial_hs.c:	ret = request_irq(uport->irq, msm_hs_isr, IRQF_TRIGGER_HIGH,
tty/serial/msm_serial_hs.c:			  "msm_hs_uart", msm_uport);
tty/serial/msm_serial_hs.c:	atomic_set(&msm_uport->client_count, 0);
tty/serial/msm_serial_hs.c:	atomic_set(&msm_uport->client_req_state, 0);
tty/serial/msm_serial_hs.c:	LOG_USR_MSG(msm_uport->ipc_msm_hs_pwr_ctxt,
tty/serial/msm_serial_hs.c:	msm_hs_start_rx_locked(uport);
tty/serial/msm_serial_hs.c:	msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:	msm_hs_unconfig_uart_gpios(uport);
tty/serial/msm_serial_hs.c:	free_irq(uport->irq, msm_uport);
tty/serial/msm_serial_hs.c:	msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	struct msm_hs_tx *tx = &msm_uport->tx;
tty/serial/msm_serial_hs.c:	struct msm_hs_rx *rx = &msm_uport->rx;
tty/serial/msm_serial_hs.c:	init_waitqueue_head(&msm_uport->bam_disconnect_wait);
tty/serial/msm_serial_hs.c:			&rx->kworker, "msm_serial_hs_%d_rx_work", uport->line);
tty/serial/msm_serial_hs.c:	kthread_init_work(&rx->kwork, msm_serial_hs_rx_work);
tty/serial/msm_serial_hs.c:			&tx->kworker, "msm_serial_hs_%d_tx_work", uport->line);
tty/serial/msm_serial_hs.c:	kthread_init_work(&tx->kwork, msm_serial_hs_tx_work);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_RFWR, 32);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UARTDM_BADR_ADDR, 64);
tty/serial/msm_serial_hs.c:struct msm_serial_hs_platform_data
tty/serial/msm_serial_hs.c:	*msm_hs_dt_to_pdata(struct platform_device *pdev)
tty/serial/msm_serial_hs.c:	struct msm_serial_hs_platform_data *pdata;
tty/serial/msm_serial_hs.c:				"qcom,msm-obs");
tty/serial/msm_serial_hs.c: * @msm_uport - Pointer to msm_hs_port structure
tty/serial/msm_serial_hs.c:static void msm_hs_exit_ep_conn(struct msm_hs_port *msm_uport,
tty/serial/msm_serial_hs.c:				struct msm_hs_sps_ep_conn_data *ep)
tty/serial/msm_serial_hs.c:	dma_free_coherent(msm_uport->uport.dev,
tty/serial/msm_serial_hs.c: * @msm_uport - Pointer to msm_hs_port structure
tty/serial/msm_serial_hs.c:static int msm_hs_sps_init_ep_conn(struct msm_hs_port *msm_uport,
tty/serial/msm_serial_hs.c:				struct msm_hs_sps_ep_conn_data *ep,
tty/serial/msm_serial_hs.c:		sps_config->source = msm_uport->bam_handle;
tty/serial/msm_serial_hs.c:		sps_config->src_pipe_index = msm_uport->bam_rx_ep_pipe_index;
tty/serial/msm_serial_hs.c:		sps_event->callback = msm_hs_sps_rx_callback;
tty/serial/msm_serial_hs.c:		sps_config->destination = msm_uport->bam_handle;
tty/serial/msm_serial_hs.c:		sps_config->dest_pipe_index = msm_uport->bam_tx_ep_pipe_index;
tty/serial/msm_serial_hs.c:		sps_event->callback = msm_hs_sps_tx_callback;
tty/serial/msm_serial_hs.c:	sps_config->desc.base = dma_zalloc_coherent(msm_uport->uport.dev,
tty/serial/msm_serial_hs.c:		MSM_HS_ERR("msm_serial_hs: dma_zalloc_coherent() failed\n");
tty/serial/msm_serial_hs.c:	sps_event->user = (void *)msm_uport;
tty/serial/msm_serial_hs.c: * msm_uport - Pointer to msm_hs_port structure
tty/serial/msm_serial_hs.c:static int msm_hs_sps_init(struct msm_hs_port *msm_uport)
tty/serial/msm_serial_hs.c:	rc = sps_phy2h(msm_uport->bam_mem, &bam_handle);
tty/serial/msm_serial_hs.c:		bam.phys_addr = msm_uport->bam_mem;
tty/serial/msm_serial_hs.c:		bam.virt_addr = msm_uport->bam_base;
tty/serial/msm_serial_hs.c:		bam.irq = (u32)msm_uport->bam_irq;
tty/serial/msm_serial_hs.c:		MSM_HS_DBG("msm_serial_hs: bam physical base=0x%pa\n",
tty/serial/msm_serial_hs.c:		MSM_HS_DBG("msm_serial_hs: bam virtual base=0x%pa\n",
tty/serial/msm_serial_hs.c:			   __func__, msm_uport->bam_handle);
tty/serial/msm_serial_hs.c:	msm_uport->bam_handle = bam_handle;
tty/serial/msm_serial_hs.c:	rc = msm_hs_sps_init_ep_conn(msm_uport, &msm_uport->rx.prod,
tty/serial/msm_serial_hs.c:	rc = msm_hs_sps_init_ep_conn(msm_uport, &msm_uport->tx.cons,
tty/serial/msm_serial_hs.c:	msm_hs_exit_ep_conn(msm_uport, &msm_uport->rx.prod);
tty/serial/msm_serial_hs.c:	sps_deregister_bam_device(msm_uport->bam_handle);
tty/serial/msm_serial_hs.c: * used, the msm_hs_dt_to_pdata gets it and the boolean array
tty/serial/msm_serial_hs.c:static void obs_manage_irq(struct msm_hs_port *msm_uport, bool en)
tty/serial/msm_serial_hs.c:	struct uart_port *uport = &(msm_uport->uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->obs) {
tty/serial/msm_serial_hs.c:static void msm_hs_pm_suspend(struct device *dev)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
tty/serial/msm_serial_hs.c:	if (!msm_uport)
tty/serial/msm_serial_hs.c:	mutex_lock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	client_count = atomic_read(&msm_uport->client_count);
tty/serial/msm_serial_hs.c:	msm_uport->pm_state = MSM_HS_PM_SUSPENDED;
tty/serial/msm_serial_hs.c:	msm_hs_resource_off(msm_uport);
tty/serial/msm_serial_hs.c:	obs_manage_irq(msm_uport, false);
tty/serial/msm_serial_hs.c:	msm_hs_clk_bus_unvote(msm_uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->obs) {
tty/serial/msm_serial_hs.c:		ret = pinctrl_select_state(msm_uport->pinctrl,
tty/serial/msm_serial_hs.c:			msm_uport->gpio_state_suspend);
tty/serial/msm_serial_hs.c:	if (!atomic_read(&msm_uport->client_req_state))
tty/serial/msm_serial_hs.c:		enable_wakeup_interrupt(msm_uport);
tty/serial/msm_serial_hs.c:	LOG_USR_MSG(msm_uport->ipc_msm_hs_pwr_ctxt,
tty/serial/msm_serial_hs.c:	mutex_unlock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:static int msm_hs_pm_resume(struct device *dev)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
tty/serial/msm_serial_hs.c:	if (!msm_uport) {
tty/serial/msm_serial_hs.c:	mutex_lock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	client_count = atomic_read(&msm_uport->client_count);
tty/serial/msm_serial_hs.c:	if (msm_uport->pm_state == MSM_HS_PM_ACTIVE)
tty/serial/msm_serial_hs.c:	if (!atomic_read(&msm_uport->client_req_state))
tty/serial/msm_serial_hs.c:		disable_wakeup_interrupt(msm_uport);
tty/serial/msm_serial_hs.c:	if (msm_uport->obs) {
tty/serial/msm_serial_hs.c:		ret = pinctrl_select_state(msm_uport->pinctrl,
tty/serial/msm_serial_hs.c:				msm_uport->gpio_state_active);
tty/serial/msm_serial_hs.c:	ret = msm_hs_clk_bus_vote(msm_uport);
tty/serial/msm_serial_hs.c:	obs_manage_irq(msm_uport, true);
tty/serial/msm_serial_hs.c:	msm_uport->pm_state = MSM_HS_PM_ACTIVE;
tty/serial/msm_serial_hs.c:	msm_hs_resource_on(msm_uport);
tty/serial/msm_serial_hs.c:	LOG_USR_MSG(msm_uport->ipc_msm_hs_pwr_ctxt,
tty/serial/msm_serial_hs.c:	mutex_unlock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:static int msm_hs_pm_sys_suspend_noirq(struct device *dev)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
tty/serial/msm_serial_hs.c:	enum msm_hs_pm_state prev_pwr_state;
tty/serial/msm_serial_hs.c:	if (IS_ERR_OR_NULL(msm_uport))
tty/serial/msm_serial_hs.c:	mutex_lock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	clk_cnt = atomic_read(&msm_uport->resource_count);
tty/serial/msm_serial_hs.c:	client_count = atomic_read(&msm_uport->client_count);
tty/serial/msm_serial_hs.c:	if (msm_uport->pm_state == MSM_HS_PM_ACTIVE) {
tty/serial/msm_serial_hs.c:	prev_pwr_state = msm_uport->pm_state;
tty/serial/msm_serial_hs.c:	msm_uport->pm_state = MSM_HS_PM_SYS_SUSPENDED;
tty/serial/msm_serial_hs.c:	LOG_USR_MSG(msm_uport->ipc_msm_hs_pwr_ctxt,
tty/serial/msm_serial_hs.c:	mutex_unlock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:static int msm_hs_pm_sys_resume_noirq(struct device *dev)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = get_matching_hs_port(pdev);
tty/serial/msm_serial_hs.c:	if (IS_ERR_OR_NULL(msm_uport))
tty/serial/msm_serial_hs.c:	mutex_lock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	if (msm_uport->pm_state == MSM_HS_PM_SYS_SUSPENDED)
tty/serial/msm_serial_hs.c:		msm_uport->pm_state = MSM_HS_PM_SUSPENDED;
tty/serial/msm_serial_hs.c:	LOG_USR_MSG(msm_uport->ipc_msm_hs_pwr_ctxt,
tty/serial/msm_serial_hs.c:	mutex_unlock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:static void  msm_serial_hs_rt_init(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	mutex_lock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	msm_uport->pm_state = MSM_HS_PM_SUSPENDED;
tty/serial/msm_serial_hs.c:	mutex_unlock(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:static int msm_hs_runtime_suspend(struct device *dev)
tty/serial/msm_serial_hs.c:	msm_hs_pm_suspend(dev);
tty/serial/msm_serial_hs.c:static int msm_hs_runtime_resume(struct device *dev)
tty/serial/msm_serial_hs.c:	return msm_hs_pm_resume(dev);
tty/serial/msm_serial_hs.c:static void  msm_serial_hs_rt_init(struct uart_port *uport) {}
tty/serial/msm_serial_hs.c:static int msm_hs_runtime_suspend(struct device *dev) {}
tty/serial/msm_serial_hs.c:static int msm_hs_runtime_resume(struct device *dev) {}
tty/serial/msm_serial_hs.c:static int msm_hs_probe(struct platform_device *pdev)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport;
tty/serial/msm_serial_hs.c:	struct msm_serial_hs_platform_data *pdata = pdev->dev.platform_data;
tty/serial/msm_serial_hs.c:		pdata = msm_hs_dt_to_pdata(pdev);
tty/serial/msm_serial_hs.c:	msm_uport = devm_kzalloc(&pdev->dev, sizeof(struct msm_hs_port),
tty/serial/msm_serial_hs.c:	if (!msm_uport)
tty/serial/msm_serial_hs.c:	msm_uport->uport.type = PORT_UNKNOWN;
tty/serial/msm_serial_hs.c:	uport = &msm_uport->uport;
tty/serial/msm_serial_hs.c:		msm_uport->uart_type = BLSP_HSUART;
tty/serial/msm_serial_hs.c:	msm_hs_get_pinctrl_configs(uport);
tty/serial/msm_serial_hs.c:	msm_uport->bam_mem = bam_resource->start;
tty/serial/msm_serial_hs.c:	msm_uport->bam_base = ioremap(msm_uport->bam_mem,
tty/serial/msm_serial_hs.c:	if (unlikely(!msm_uport->bam_base)) {
tty/serial/msm_serial_hs.c:	scnprintf(name, sizeof(name), "%s%s", dev_name(msm_uport->uport.dev),
tty/serial/msm_serial_hs.c:	msm_uport->ipc_msm_hs_log_ctxt =
tty/serial/msm_serial_hs.c:	if (!msm_uport->ipc_msm_hs_log_ctxt) {
tty/serial/msm_serial_hs.c:		msm_uport->ipc_debug_mask = INFO_LEV;
tty/serial/msm_serial_hs.c:	msm_uport->bam_irq = bam_irqres;
tty/serial/msm_serial_hs.c:	msm_uport->bus_scale_table = msm_bus_cl_get_pdata(pdev);
tty/serial/msm_serial_hs.c:	if (!msm_uport->bus_scale_table) {
tty/serial/msm_serial_hs.c:		msm_uport->bus_perf_client =
tty/serial/msm_serial_hs.c:			msm_bus_scale_register_client
tty/serial/msm_serial_hs.c:				(msm_uport->bus_scale_table);
tty/serial/msm_serial_hs.c:		if (IS_ERR(&msm_uport->bus_perf_client)) {
tty/serial/msm_serial_hs.c:	msm_uport->wakeup.irq = pdata->wakeup_irq;
tty/serial/msm_serial_hs.c:	msm_uport->wakeup.ignore = 1;
tty/serial/msm_serial_hs.c:	msm_uport->wakeup.inject_rx = pdata->inject_rx_on_wakeup;
tty/serial/msm_serial_hs.c:	msm_uport->wakeup.rx_to_inject = pdata->rx_to_inject;
tty/serial/msm_serial_hs.c:	msm_uport->obs = pdata->obs;
tty/serial/msm_serial_hs.c:	msm_uport->bam_tx_ep_pipe_index =
tty/serial/msm_serial_hs.c:	msm_uport->bam_rx_ep_pipe_index =
tty/serial/msm_serial_hs.c:	msm_uport->wakeup.enabled = true;
tty/serial/msm_serial_hs.c:	uport->ops = &msm_hs_ops;
tty/serial/msm_serial_hs.c:	msm_uport->imr_reg = 0x0;
tty/serial/msm_serial_hs.c:	msm_uport->clk = clk_get(&pdev->dev, "core_clk");
tty/serial/msm_serial_hs.c:	if (IS_ERR(msm_uport->clk)) {
tty/serial/msm_serial_hs.c:		ret = PTR_ERR(msm_uport->clk);
tty/serial/msm_serial_hs.c:	msm_uport->pclk = clk_get(&pdev->dev, "iface_clk");
tty/serial/msm_serial_hs.c:	if (IS_ERR(msm_uport->pclk))
tty/serial/msm_serial_hs.c:		msm_uport->pclk = NULL;
tty/serial/msm_serial_hs.c:	msm_uport->hsuart_wq = alloc_workqueue("k_hsuart",
tty/serial/msm_serial_hs.c:	if (!msm_uport->hsuart_wq) {
tty/serial/msm_serial_hs.c:	mutex_init(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	ret = msm_hs_sps_init(msm_uport);
tty/serial/msm_serial_hs.c:	msm_uport->tx.flush = FLUSH_SHUTDOWN;
tty/serial/msm_serial_hs.c:	msm_uport->rx.flush = FLUSH_SHUTDOWN;
tty/serial/msm_serial_hs.c:	scnprintf(name, sizeof(name), "%s%s", dev_name(msm_uport->uport.dev),
tty/serial/msm_serial_hs.c:	msm_uport->tx.ipc_tx_ctxt =
tty/serial/msm_serial_hs.c:	if (!msm_uport->tx.ipc_tx_ctxt)
tty/serial/msm_serial_hs.c:	scnprintf(name, sizeof(name), "%s%s", dev_name(msm_uport->uport.dev),
tty/serial/msm_serial_hs.c:	msm_uport->rx.ipc_rx_ctxt = ipc_log_context_create(
tty/serial/msm_serial_hs.c:	if (!msm_uport->rx.ipc_rx_ctxt)
tty/serial/msm_serial_hs.c:	scnprintf(name, sizeof(name), "%s%s", dev_name(msm_uport->uport.dev),
tty/serial/msm_serial_hs.c:	msm_uport->ipc_msm_hs_pwr_ctxt = ipc_log_context_create(
tty/serial/msm_serial_hs.c:	if (!msm_uport->ipc_msm_hs_pwr_ctxt)
tty/serial/msm_serial_hs.c:	msm_uport->bam_irq = bam_irqres;
tty/serial/msm_serial_hs.c:	clk_set_rate(msm_uport->clk, msm_uport->uport.uartclk);
tty/serial/msm_serial_hs.c:	msm_hs_clk_bus_vote(msm_uport);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, CR_PROTECTION_EN);
tty/serial/msm_serial_hs.c:	data = msm_hs_read(uport, UART_DM_MR2);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_MR2, data);
tty/serial/msm_serial_hs.c:	msm_serial_debugfs_init(msm_uport, pdev->id);
tty/serial/msm_serial_hs.c:	msm_hs_unconfig_uart_gpios(uport);
tty/serial/msm_serial_hs.c:	ret = uart_add_one_port(&msm_hs_driver, uport);
tty/serial/msm_serial_hs.c:		msm_hs_clk_bus_unvote(msm_uport);
tty/serial/msm_serial_hs.c:		msm_serial_hs_rt_init(uport);
tty/serial/msm_serial_hs.c:	msm_hs_clk_bus_unvote(msm_uport);
tty/serial/msm_serial_hs.c:	mutex_destroy(&msm_uport->mtx);
tty/serial/msm_serial_hs.c:	destroy_workqueue(msm_uport->hsuart_wq);
tty/serial/msm_serial_hs.c:	if (msm_uport->pclk)
tty/serial/msm_serial_hs.c:		clk_put(msm_uport->pclk);
tty/serial/msm_serial_hs.c:	if (msm_uport->clk)
tty/serial/msm_serial_hs.c:		clk_put(msm_uport->clk);
tty/serial/msm_serial_hs.c:	msm_bus_scale_unregister_client(msm_uport->bus_perf_client);
tty/serial/msm_serial_hs.c:	iounmap(msm_uport->bam_base);
tty/serial/msm_serial_hs.c:static int __init msm_serial_hs_init(void)
tty/serial/msm_serial_hs.c:	ret = uart_register_driver(&msm_hs_driver);
tty/serial/msm_serial_hs.c:	debug_base = debugfs_create_dir("msm_serial_hs", NULL);
tty/serial/msm_serial_hs.c:		pr_err("msm_serial_hs: Cannot create debugfs dir\n");
tty/serial/msm_serial_hs.c:	ret = platform_driver_register(&msm_serial_hs_platform_driver);
tty/serial/msm_serial_hs.c:		uart_unregister_driver(&msm_hs_driver);
tty/serial/msm_serial_hs.c:	pr_debug("msm_serial_hs module loaded\n");
tty/serial/msm_serial_hs.c:static void msm_hs_shutdown(struct uart_port *uport)
tty/serial/msm_serial_hs.c:	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
tty/serial/msm_serial_hs.c:	if (is_use_low_power_wakeup(msm_uport))
tty/serial/msm_serial_hs.c:		irq_set_irq_wake(msm_uport->wakeup.irq, 0);
tty/serial/msm_serial_hs.c:	if (msm_uport->wakeup.enabled)
tty/serial/msm_serial_hs.c:		disable_irq(msm_uport->wakeup.irq);
tty/serial/msm_serial_hs.c:	msm_uport->wakeup.enabled = false;
tty/serial/msm_serial_hs.c:	msm_uport->wakeup.ignore = 1;
tty/serial/msm_serial_hs.c:	free_irq(uport->irq, msm_uport);
tty/serial/msm_serial_hs.c:	if (is_use_low_power_wakeup(msm_uport)) {
tty/serial/msm_serial_hs.c:		free_irq(msm_uport->wakeup.irq, msm_uport);
tty/serial/msm_serial_hs.c:	msm_uport->wakeup.freed = true;
tty/serial/msm_serial_hs.c:	kthread_flush_worker(&msm_uport->tx.kworker);
tty/serial/msm_serial_hs.c:	ret = wait_event_timeout(msm_uport->tx.wait,
tty/serial/msm_serial_hs.c:	msm_hs_resource_vote(msm_uport);
tty/serial/msm_serial_hs.c:	msm_hs_disable_flow_control(uport, false);
tty/serial/msm_serial_hs.c:	kthread_flush_worker(&msm_uport->rx.kworker);
tty/serial/msm_serial_hs.c:	if (msm_uport->rx.flush != FLUSH_SHUTDOWN) {
tty/serial/msm_serial_hs.c:		ret = wait_event_timeout(msm_uport->rx.wait,
tty/serial/msm_serial_hs.c:				!msm_uport->rx.pending_flag, 500);
tty/serial/msm_serial_hs.c:		msm_hs_disconnect_rx(uport);
tty/serial/msm_serial_hs.c:	cancel_delayed_work_sync(&msm_uport->rx.flip_insert_work);
tty/serial/msm_serial_hs.c:	flush_workqueue(msm_uport->hsuart_wq);
tty/serial/msm_serial_hs.c:	data = msm_hs_read(uport, UART_DM_DMEN);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_DMEN, data);
tty/serial/msm_serial_hs.c:	ret = sps_tx_disconnect(msm_uport);
tty/serial/msm_serial_hs.c:	msm_uport->tx.flush = FLUSH_SHUTDOWN;
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, UARTDM_CR_TX_DISABLE_BMSK);
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_CR, UARTDM_CR_RX_DISABLE_BMSK);
tty/serial/msm_serial_hs.c:	msm_uport->imr_reg = 0;
tty/serial/msm_serial_hs.c:	msm_hs_write(uport, UART_DM_IMR, msm_uport->imr_reg);
tty/serial/msm_serial_hs.c:	msm_uport->rx.buffer_pending = NONE_PENDING;
tty/serial/msm_serial_hs.c:	dma_unmap_single(uport->dev, msm_uport->tx.dma_base,
tty/serial/msm_serial_hs.c:	msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:	rc = atomic_read(&msm_uport->resource_count);
tty/serial/msm_serial_hs.c:		atomic_set(&msm_uport->resource_count, 1);
tty/serial/msm_serial_hs.c:		msm_hs_resource_unvote(msm_uport);
tty/serial/msm_serial_hs.c:	if (atomic_read(&msm_uport->client_req_state)) {
tty/serial/msm_serial_hs.c:		atomic_set(&msm_uport->client_req_state, 0);
tty/serial/msm_serial_hs.c:	if (atomic_read(&msm_uport->client_count)) {
tty/serial/msm_serial_hs.c:		atomic_set(&msm_uport->client_count, 0);
tty/serial/msm_serial_hs.c:		LOG_USR_MSG(msm_uport->ipc_msm_hs_pwr_ctxt,
tty/serial/msm_serial_hs.c:	msm_hs_unconfig_uart_gpios(uport);
tty/serial/msm_serial_hs.c:static void __exit msm_serial_hs_exit(void)
tty/serial/msm_serial_hs.c:	pr_debug("msm_serial_hs module removed\n");
tty/serial/msm_serial_hs.c:	platform_driver_unregister(&msm_serial_hs_platform_driver);
tty/serial/msm_serial_hs.c:	uart_unregister_driver(&msm_hs_driver);
tty/serial/msm_serial_hs.c:static const struct dev_pm_ops msm_hs_dev_pm_ops = {
tty/serial/msm_serial_hs.c:	.runtime_suspend = msm_hs_runtime_suspend,
tty/serial/msm_serial_hs.c:	.runtime_resume = msm_hs_runtime_resume,
tty/serial/msm_serial_hs.c:	.suspend_noirq = msm_hs_pm_sys_suspend_noirq,
tty/serial/msm_serial_hs.c:	.resume_noirq = msm_hs_pm_sys_resume_noirq,
tty/serial/msm_serial_hs.c:static struct platform_driver msm_serial_hs_platform_driver = {
tty/serial/msm_serial_hs.c:	.probe	= msm_hs_probe,
tty/serial/msm_serial_hs.c:	.remove = msm_hs_remove,
tty/serial/msm_serial_hs.c:		.name = "msm_serial_hs",
tty/serial/msm_serial_hs.c:		.pm   = &msm_hs_dev_pm_ops,
tty/serial/msm_serial_hs.c:		.of_match_table = msm_hs_match_table,
tty/serial/msm_serial_hs.c:static struct uart_driver msm_hs_driver = {
tty/serial/msm_serial_hs.c:	.driver_name = "msm_serial_hs",
tty/serial/msm_serial_hs.c:static const struct uart_ops msm_hs_ops = {
tty/serial/msm_serial_hs.c:	.tx_empty = msm_hs_tx_empty,
tty/serial/msm_serial_hs.c:	.set_mctrl = msm_hs_set_mctrl_locked,
tty/serial/msm_serial_hs.c:	.get_mctrl = msm_hs_get_mctrl_locked,
tty/serial/msm_serial_hs.c:	.stop_tx = msm_hs_stop_tx_locked,
tty/serial/msm_serial_hs.c:	.start_tx = msm_hs_start_tx_locked,
tty/serial/msm_serial_hs.c:	.stop_rx = msm_hs_stop_rx_locked,
tty/serial/msm_serial_hs.c:	.enable_ms = msm_hs_enable_ms_locked,
tty/serial/msm_serial_hs.c:	.break_ctl = msm_hs_break_ctl,
tty/serial/msm_serial_hs.c:	.startup = msm_hs_startup,
tty/serial/msm_serial_hs.c:	.shutdown = msm_hs_shutdown,
tty/serial/msm_serial_hs.c:	.set_termios = msm_hs_set_termios,
tty/serial/msm_serial_hs.c:	.type = msm_hs_type,
tty/serial/msm_serial_hs.c:	.config_port = msm_hs_config_port,
tty/serial/msm_serial_hs.c:	.ioctl = msm_hs_ioctl,
tty/serial/msm_serial_hs.c:module_init(msm_serial_hs_init);
tty/serial/msm_serial_hs.c:module_exit(msm_serial_hs_exit);
tty/serial/msm_serial_hs_hwreg.h:/* drivers/serial/msm_serial_hs_hwreg.h
tty/serial/msm_serial_hs_hwreg.h:enum msm_hsl_regs {
tty/serial/msm_serial_hs_hwreg.h:enum msm_hs_regs {
tty/serial/vt8500_serial.c: * Based on msm_serial.c, which is:
tty/serial/msm_geni_serial.c:struct msm_geni_serial_ver_info {
tty/serial/msm_geni_serial.c:struct msm_geni_serial_port {
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_ver_info ver_info;
tty/serial/msm_geni_serial.c:static void msm_geni_serial_worker(struct work_struct *work);
tty/serial/msm_geni_serial.c:static const struct uart_ops msm_geni_serial_pops;
tty/serial/msm_geni_serial.c:static struct uart_driver msm_geni_console_driver;
tty/serial/msm_geni_serial.c:static struct uart_driver msm_geni_serial_hs_driver;
tty/serial/msm_geni_serial.c:static unsigned int msm_geni_serial_tx_empty(struct uart_port *port);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_power_on(struct uart_port *uport);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_power_off(struct uart_port *uport);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_poll_bit(struct uart_port *uport,
tty/serial/msm_geni_serial.c:static void msm_geni_serial_stop_rx(struct uart_port *uport);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_runtime_resume(struct device *dev);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_runtime_suspend(struct device *dev);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_get_ver_info(struct uart_port *uport);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_set_manual_flow(bool enable,
tty/serial/msm_geni_serial.c:				struct msm_geni_serial_port *port);
tty/serial/msm_geni_serial.c:	container_of(uport, struct msm_geni_serial_port, uport)
tty/serial/msm_geni_serial.c:static struct msm_geni_serial_port msm_geni_console_port;
tty/serial/msm_geni_serial.c:static struct msm_geni_serial_port msm_geni_serial_ports[GENI_UART_NR_PORTS];
tty/serial/msm_geni_serial.c:static void msm_geni_serial_handle_isr(struct uart_port *uport,
tty/serial/msm_geni_serial.c:static void msm_geni_update_uart_error_code(struct msm_geni_serial_port *port,
tty/serial/msm_geni_serial.c:static int msm_geni_serial_spinlocked(struct uart_port *uport)
tty/serial/msm_geni_serial.c:static void msm_geni_serial_enable_interrupts(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = NULL;
tty/serial/msm_geni_serial.c:static bool msm_serial_try_disable_interrupts(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	if (!msm_geni_serial_spinlocked(uport))
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:		if (msm_port->m_cmd) {
tty/serial/msm_geni_serial.c:			while (!msm_port->m_cmd_done && timeout > 0) {
tty/serial/msm_geni_serial.c:				msm_geni_serial_handle_isr(uport, &flags, true);
tty/serial/msm_geni_serial.c:		} else if (msm_port->s_cmd) {
tty/serial/msm_geni_serial.c:			while (!msm_port->s_cmd_done && timeout > 0) {
tty/serial/msm_geni_serial.c:				msm_geni_serial_handle_isr(uport, &flags, true);
tty/serial/msm_geni_serial.c:		if (msm_port->m_cmd)
tty/serial/msm_geni_serial.c:					(&msm_port->m_cmd_timeout,
tty/serial/msm_geni_serial.c:		else if (msm_port->s_cmd)
tty/serial/msm_geni_serial.c:					(&msm_port->s_cmd_timeout,
tty/serial/msm_geni_serial.c:static void msm_geni_serial_config_port(struct uart_port *uport, int cfg_flags)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	ret = msm_geni_serial_power_on(uport);
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_worker(struct work_struct *work)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port;
tty/serial/msm_geni_serial.c:	port = container_of(work, struct msm_geni_serial_port, work);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_ioctl(struct uart_port *uport, unsigned int cmd,
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_break_ctl(struct uart_port *uport, int ctl)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:static unsigned int msm_geni_cons_get_mctrl(struct uart_port *uport)
tty/serial/msm_geni_serial.c:static unsigned int msm_geni_serial_get_mctrl(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:		msm_geni_update_uart_error_code(port,
tty/serial/msm_geni_serial.c:static void msm_geni_cons_set_mctrl(struct uart_port *uport,
tty/serial/msm_geni_serial.c:static void msm_geni_serial_set_mctrl(struct uart_port *uport,
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:static const char *msm_geni_serial_get_type(struct uart_port *uport)
tty/serial/msm_geni_serial.c:static struct msm_geni_serial_port *get_port_from_line(int line,
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = NULL;
tty/serial/msm_geni_serial.c:		port = &msm_geni_console_port;
tty/serial/msm_geni_serial.c:		port = &msm_geni_serial_ports[line];
tty/serial/msm_geni_serial.c:static int msm_geni_serial_power_on(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:			ret = msm_geni_serial_runtime_resume(uport->dev);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_power_off(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_poll_bit(struct uart_port *uport,
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = NULL;
tty/serial/msm_geni_serial.c:static void msm_geni_serial_setup_tx(struct uart_port *uport,
tty/serial/msm_geni_serial.c:static void msm_geni_serial_poll_tx_done(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	done = msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial.c:		done = msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial.c:			msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial.c:static int msm_geni_serial_get_char(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	if (!(msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial.c:	if (!(msm_geni_serial_poll_bit(uport, SE_GENI_RX_FIFO_STATUS,
tty/serial/msm_geni_serial.c:static void msm_geni_serial_poll_put_char(struct uart_port *uport,
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	msm_geni_serial_setup_tx(uport, 1);
tty/serial/msm_geni_serial.c:	if (!msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial.c:	msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial.c:	msm_geni_serial_poll_tx_done(uport);
tty/serial/msm_geni_serial.c:	msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_wr_char(struct uart_port *uport, int ch)
tty/serial/msm_geni_serial.c:__msm_geni_serial_console_write(struct uart_port *uport, const char *s,
tty/serial/msm_geni_serial.c:	msm_geni_serial_setup_tx(uport, bytes_to_send);
tty/serial/msm_geni_serial.c:		while (!msm_geni_serial_poll_bit(uport, SE_GENI_M_IRQ_STATUS,
tty/serial/msm_geni_serial.c:						msm_geni_serial_wr_char);
tty/serial/msm_geni_serial.c:	msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial.c:	msm_geni_serial_poll_tx_done(uport);
tty/serial/msm_geni_serial.c:	msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_console_write(struct console *co, const char *s,
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port;
tty/serial/msm_geni_serial.c:		is_irq_masked = msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial.c:		msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial.c:		msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial.c:		msm_geni_serial_poll_tx_done(uport);
tty/serial/msm_geni_serial.c:		msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial.c:	__msm_geni_serial_console_write(uport, s, count);
tty/serial/msm_geni_serial.c:		msm_geni_serial_setup_tx(uport, port->cur_tx_remaining);
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:		*(msm_port->rx_fifo) =
tty/serial/msm_geni_serial.c:		rx_char = (unsigned char *)msm_port->rx_fifo;
tty/serial/msm_geni_serial.c:static int msm_geni_serial_prep_dma_tx(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	dump_ipc(msm_port->ipc_log_tx, "DMA Tx",
tty/serial/msm_geni_serial.c:	msm_geni_serial_setup_tx(uport, xmit_size);
tty/serial/msm_geni_serial.c:	ret = geni_se_tx_dma_prep(msm_port->wrapper_dev, uport->membase,
tty/serial/msm_geni_serial.c:			&xmit->buf[xmit->tail], xmit_size, &msm_port->tx_dma);
tty/serial/msm_geni_serial.c:		msm_port->xmit_size = xmit_size;
tty/serial/msm_geni_serial.c:		IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:		msm_geni_update_uart_error_code(msm_port,
tty/serial/msm_geni_serial.c:		msm_port->m_cmd_done = false;
tty/serial/msm_geni_serial.c:		msm_port->m_cmd = true;
tty/serial/msm_geni_serial.c:		reinit_completion(&msm_port->m_cmd_timeout);
tty/serial/msm_geni_serial.c:		is_irq_masked = msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->console_log,
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:			msm_geni_update_uart_error_code(msm_port,
tty/serial/msm_geni_serial.c:			msm_port->m_cmd_done = false;
tty/serial/msm_geni_serial.c:			reinit_completion(&msm_port->m_cmd_timeout);
tty/serial/msm_geni_serial.c:				IPC_LOG_MSG(msm_port->console_log,
tty/serial/msm_geni_serial.c:				IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:				msm_geni_update_uart_error_code(msm_port,
tty/serial/msm_geni_serial.c:		if (msm_port->xfer_mode == SE_DMA) {
tty/serial/msm_geni_serial.c:				msm_port->m_cmd_done = false;
tty/serial/msm_geni_serial.c:				reinit_completion(&msm_port->m_cmd_timeout);
tty/serial/msm_geni_serial.c:					IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:					msm_geni_update_uart_error_code(
tty/serial/msm_geni_serial.c:					msm_port, UART_ERROR_TX_FSM_RESET_FAIL);
tty/serial/msm_geni_serial.c:			if (msm_port->tx_dma) {
tty/serial/msm_geni_serial.c:				geni_se_tx_dma_unprep(msm_port->wrapper_dev,
tty/serial/msm_geni_serial.c:					msm_port->tx_dma, msm_port->xmit_size);
tty/serial/msm_geni_serial.c:				msm_port->tx_dma = (dma_addr_t)NULL;
tty/serial/msm_geni_serial.c:		msm_port->xmit_size = 0;
tty/serial/msm_geni_serial.c:		msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial.c:		msm_port->m_cmd = false;
tty/serial/msm_geni_serial.c:static void msm_geni_serial_start_tx(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:		IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:		IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:	if (msm_port->xfer_mode == FIFO_MODE) {
tty/serial/msm_geni_serial.c:		if (!msm_geni_serial_tx_empty(uport))
tty/serial/msm_geni_serial.c:		geni_write_reg_nolog(msm_port->tx_wm, uport->membase,
tty/serial/msm_geni_serial.c:	} else if (msm_port->xfer_mode == SE_DMA) {
tty/serial/msm_geni_serial.c:		if (msm_port->tx_dma)
tty/serial/msm_geni_serial.c:		msm_geni_serial_prep_dma_tx(uport);
tty/serial/msm_geni_serial.c:		IPC_LOG_MSG(msm_port->ipc_log_misc, "%s: ios: 0x%08x\n",
tty/serial/msm_geni_serial.c:		msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	is_irq_masked = msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial.c:		msm_geni_update_uart_error_code(port,
tty/serial/msm_geni_serial.c:			msm_geni_update_uart_error_code(port,
tty/serial/msm_geni_serial.c:				msm_geni_update_uart_error_code(port,
tty/serial/msm_geni_serial.c:	msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial.c:		msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_stop_tx(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:		msm_geni_serial_stop_rx(uport);
tty/serial/msm_geni_serial.c:	msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_start_rx(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_set_manual_flow(bool enable,
tty/serial/msm_geni_serial.c:					struct msm_geni_serial_port *port)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:			msm_geni_serial_set_manual_flow(false, port);
tty/serial/msm_geni_serial.c:	is_irq_masked = msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial.c:		msm_geni_update_uart_error_code(port,
tty/serial/msm_geni_serial.c:		 * in the system. call msm_geni_serial_handle_isr to clear
tty/serial/msm_geni_serial.c:			msm_geni_serial_handle_isr(uport, &flags, true);
tty/serial/msm_geni_serial.c:			msm_geni_update_uart_error_code(port,
tty/serial/msm_geni_serial.c:				msm_geni_update_uart_error_code(port,
tty/serial/msm_geni_serial.c:	msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial.c:		msm_geni_serial_set_manual_flow(true, port);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_stop_rx(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	rx_bytes = (msm_port->tx_fifo_width * (rx_fifo_wc - 1)) >> 3;
tty/serial/msm_geni_serial.c:			rx_last_byte_valid : msm_port->tx_fifo_width >> 3);
tty/serial/msm_geni_serial.c:	ioread32_rep((uport->membase + SE_GENI_RX_FIFOn), msm_port->rx_fifo,
tty/serial/msm_geni_serial.c:	rx_char = (unsigned char *)msm_port->rx_fifo;
tty/serial/msm_geni_serial.c:		msm_geni_update_uart_error_code(msm_port,
tty/serial/msm_geni_serial.c:	dump_ipc(msm_port->ipc_log_rx, "Rx", (char *)msm_port->rx_fifo, 0,
tty/serial/msm_geni_serial.c:static int msm_geni_serial_handle_rx(struct uart_port *uport, bool drop_rx)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_handle_tx(struct uart_port *uport, bool done,
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:		(uart_console(uport) ? 1 : (msm_port->tx_fifo_width >> 3));
tty/serial/msm_geni_serial.c:		pending = msm_port->cur_tx_remaining;
tty/serial/msm_geni_serial.c:		msm_geni_serial_stop_tx(uport);
tty/serial/msm_geni_serial.c:	avail_fifo_bytes = msm_port->tx_fifo_depth - (tx_fifo_status &
tty/serial/msm_geni_serial.c:	if (!msm_port->cur_tx_remaining) {
tty/serial/msm_geni_serial.c:		msm_geni_serial_setup_tx(uport, pending);
tty/serial/msm_geni_serial.c:		msm_port->cur_tx_remaining = pending;
tty/serial/msm_geni_serial.c:		msm_port->cur_tx_remaining -= tx_bytes;
tty/serial/msm_geni_serial.c:	if (!msm_port->cur_tx_remaining) {
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->ipc_log_rx,
tty/serial/msm_geni_serial.c:			geni_se_dump_dbg_regs(&msm_port->serial_rsc,
tty/serial/msm_geni_serial.c:				uport->membase, msm_port->ipc_log_misc);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_handle_dma_rx(struct uart_port *uport, bool drop_rx)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:		IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:	if (unlikely(!msm_port->rx_buf)) {
tty/serial/msm_geni_serial.c:		IPC_LOG_MSG(msm_port->ipc_log_rx, "%s: NULL Rx_buf\n",
tty/serial/msm_geni_serial.c:		IPC_LOG_MSG(msm_port->ipc_log_rx, "%s: Size %d\n",
tty/serial/msm_geni_serial.c:	check_rx_buf((char *)msm_port->rx_buf, uport, rx_bytes);
tty/serial/msm_geni_serial.c:	ret = tty_insert_flip_string(tport, (unsigned char *)(msm_port->rx_buf),
tty/serial/msm_geni_serial.c:	dump_ipc(msm_port->ipc_log_rx, "DMA Rx", (char *)msm_port->rx_buf, 0,
tty/serial/msm_geni_serial.c:	memset(msm_port->rx_buf, 0, rx_bytes);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_handle_dma_tx(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	xmit->tail = (xmit->tail + msm_port->xmit_size) & (UART_XMIT_SIZE - 1);
tty/serial/msm_geni_serial.c:	geni_se_tx_dma_unprep(msm_port->wrapper_dev, msm_port->tx_dma,
tty/serial/msm_geni_serial.c:				msm_port->xmit_size);
tty/serial/msm_geni_serial.c:	uport->icount.tx += msm_port->xmit_size;
tty/serial/msm_geni_serial.c:	msm_port->tx_dma = (dma_addr_t)NULL;
tty/serial/msm_geni_serial.c:	msm_port->xmit_size = 0;
tty/serial/msm_geni_serial.c:		msm_geni_serial_prep_dma_tx(uport);
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:			msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	spin_lock(&msm_port->rx_lock);
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:			msm_geni_update_uart_error_code(msm_port,
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:			msm_geni_update_uart_error_code(msm_port,
tty/serial/msm_geni_serial.c:			msm_geni_serial_handle_dma_rx(uport,
tty/serial/msm_geni_serial.c:				IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:				DMA_RX_BUF_SIZE, &msm_port->rx_dma);
tty/serial/msm_geni_serial.c:				IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:			msm_geni_update_uart_error_code(msm_port,
tty/serial/msm_geni_serial.c:	spin_unlock(&msm_port->rx_lock);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_handle_isr(struct uart_port *uport,
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:		IPC_LOG_MSG(msm_port->console_log,
tty/serial/msm_geni_serial.c:		IPC_LOG_MSG(msm_port->console_log,
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->console_log,
tty/serial/msm_geni_serial.c:			msm_geni_update_uart_error_code(msm_port,
tty/serial/msm_geni_serial.c:		IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:		msm_geni_update_uart_error_code(msm_port,
tty/serial/msm_geni_serial.c:			msm_geni_serial_handle_tx(uport,
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:			msm_geni_serial_handle_rx(uport, drop_rx);
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->ipc_log_irqstatus,
tty/serial/msm_geni_serial.c:				msm_geni_serial_handle_dma_tx(uport);
tty/serial/msm_geni_serial.c:		msm_port->m_cmd_done = true;
tty/serial/msm_geni_serial.c:		complete(&msm_port->m_cmd_timeout);
tty/serial/msm_geni_serial.c:		msm_port->s_cmd_done = true;
tty/serial/msm_geni_serial.c:		complete(&msm_port->s_cmd_timeout);
tty/serial/msm_geni_serial.c:static irqreturn_t msm_geni_serial_isr(int isr, void *dev)
tty/serial/msm_geni_serial.c:	msm_geni_serial_handle_isr(uport, &flags, false);
tty/serial/msm_geni_serial.c:static irqreturn_t msm_geni_wakeup_isr(int isr, void *dev)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:static int get_tx_fifo_size(struct msm_geni_serial_port *port)
tty/serial/msm_geni_serial.c:static void set_rfr_wm(struct msm_geni_serial_port *port)
tty/serial/msm_geni_serial.c:static void msm_geni_serial_shutdown(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	IPC_LOG_MSG(msm_port->ipc_log_misc, "%s:\n", __func__);
tty/serial/msm_geni_serial.c:		msm_geni_serial_power_on(uport);
tty/serial/msm_geni_serial.c:		msm_geni_serial_stop_tx(uport);
tty/serial/msm_geni_serial.c:		if (msm_port->ioctl_count) {
tty/serial/msm_geni_serial.c:			for (i = 0; i < msm_port->ioctl_count; i++) {
tty/serial/msm_geni_serial.c:				IPC_LOG_MSG(msm_port->ipc_log_pwr,
tty/serial/msm_geni_serial.c:				msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial.c:			msm_port->ioctl_count = 0;
tty/serial/msm_geni_serial.c:		flush_workqueue(msm_port->qwork);
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->ipc_log_pwr,
tty/serial/msm_geni_serial.c:		if (msm_port->wakeup_irq > 0) {
tty/serial/msm_geni_serial.c:			irq_set_irq_wake(msm_port->wakeup_irq, 0);
tty/serial/msm_geni_serial.c:			disable_irq(msm_port->wakeup_irq);
tty/serial/msm_geni_serial.c:			free_irq(msm_port->wakeup_irq, uport);
tty/serial/msm_geni_serial.c:		msm_port->uart_error = UART_ERROR_DEFAULT;
tty/serial/msm_geni_serial.c:	IPC_LOG_MSG(msm_port->ipc_log_misc, "%s: End\n", __func__);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_port_setup(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	set_rfr_wm(msm_port);
tty/serial/msm_geni_serial.c:		msm_port->xfer_mode = SE_DMA;
tty/serial/msm_geni_serial.c:		if (!msm_port->rx_fifo) {
tty/serial/msm_geni_serial.c:		msm_port->rx_buf =
tty/serial/msm_geni_serial.c:			geni_se_iommu_alloc_buf(msm_port->wrapper_dev,
tty/serial/msm_geni_serial.c:		if (!msm_port->rx_buf) {
tty/serial/msm_geni_serial.c:			devm_kfree(uport->dev, msm_port->rx_fifo);
tty/serial/msm_geni_serial.c:			msm_port->rx_fifo = NULL;
tty/serial/msm_geni_serial.c:		msm_port->rx_dma = dma_address;
tty/serial/msm_geni_serial.c:		msm_port->xfer_mode = FIFO_MODE;
tty/serial/msm_geni_serial.c:		msm_serial_try_disable_interrupts(uport);
tty/serial/msm_geni_serial.c:		msm_geni_serial_poll_tx_done(uport);
tty/serial/msm_geni_serial.c:		msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial.c:	ret = geni_se_init(uport->membase, msm_port->rx_wm, msm_port->rx_rfr);
tty/serial/msm_geni_serial.c:	ret = geni_se_select_mode(uport->membase, msm_port->xfer_mode);
tty/serial/msm_geni_serial.c:	msm_port->port_setup = true;
tty/serial/msm_geni_serial.c:	if (msm_port->rx_dma) {
tty/serial/msm_geni_serial.c:		geni_se_iommu_free_buf(msm_port->wrapper_dev,
tty/serial/msm_geni_serial.c:			&msm_port->rx_dma, msm_port->rx_buf, DMA_RX_BUF_SIZE);
tty/serial/msm_geni_serial.c:		msm_port->rx_dma = (dma_addr_t)NULL;
tty/serial/msm_geni_serial.c:static int msm_geni_serial_startup(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	IPC_LOG_MSG(msm_port->ipc_log_misc, "%s:\n", __func__);
tty/serial/msm_geni_serial.c:	msm_port->startup_in_progress = true;
tty/serial/msm_geni_serial.c:		ret = msm_geni_serial_power_on(&msm_port->uport);
tty/serial/msm_geni_serial.c:	get_tx_fifo_size(msm_port);
tty/serial/msm_geni_serial.c:	if (!msm_port->port_setup) {
tty/serial/msm_geni_serial.c:		ret = msm_geni_serial_port_setup(uport);
tty/serial/msm_geni_serial.c:			IPC_LOG_MSG(msm_port->ipc_log_misc,
tty/serial/msm_geni_serial.c:	if (msm_port->wakeup_irq > 0) {
tty/serial/msm_geni_serial.c:		ret = request_irq(msm_port->wakeup_irq, msm_geni_wakeup_isr,
tty/serial/msm_geni_serial.c:		disable_irq(msm_port->wakeup_irq);
tty/serial/msm_geni_serial.c:		ret = irq_set_irq_wake(msm_port->wakeup_irq, 1);
tty/serial/msm_geni_serial.c:		msm_geni_serial_power_off(&msm_port->uport);
tty/serial/msm_geni_serial.c:	msm_port->startup_in_progress = false;
tty/serial/msm_geni_serial.c:	IPC_LOG_MSG(msm_port->ipc_log_misc, "%s: ret:%d\n", __func__, ret);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_set_termios(struct uart_port *uport,
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:		int ret = msm_geni_serial_power_on(uport);
tty/serial/msm_geni_serial.c:	msm_geni_serial_stop_rx(uport);
tty/serial/msm_geni_serial.c:		msm_geni_update_uart_error_code(port,
tty/serial/msm_geni_serial.c:	msm_geni_serial_start_rx(uport);
tty/serial/msm_geni_serial.c:		msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial.c:static unsigned int msm_geni_serial_tx_empty(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial.c:	msm_geni_serial_power_on(uport);
tty/serial/msm_geni_serial.c:	msm_geni_serial_stop_tx(uport);
tty/serial/msm_geni_serial.c:	msm_geni_serial_stop_rx(uport);
tty/serial/msm_geni_serial.c:	msm_geni_serial_start_rx(uport);
tty/serial/msm_geni_serial.c:	msm_geni_serial_power_off(uport);
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial.c:	int len = (sizeof(struct msm_geni_serial_ver_info) * 2);
tty/serial/msm_geni_serial.c:static int __init msm_geni_console_setup(struct console *co, char *options)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *dev_port;
tty/serial/msm_geni_serial.c:		msm_geni_serial_stop_rx(uport);
tty/serial/msm_geni_serial.c:		msm_geni_serial_port_setup(uport);
tty/serial/msm_geni_serial.c:msm_geni_serial_early_console_write(struct console *con, const char *s,
tty/serial/msm_geni_serial.c:	__msm_geni_serial_console_write(&dev->port, s, n);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_cancel_rx(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	done = msm_geni_serial_poll_bit(uport, SE_GENI_S_IRQ_STATUS,
tty/serial/msm_geni_serial.c:		msm_geni_serial_poll_bit(uport, SE_GENI_S_IRQ_STATUS,
tty/serial/msm_geni_serial.c:	} else if (msm_geni_serial_poll_bit(uport,
tty/serial/msm_geni_serial.c:msm_geni_serial_earlycon_setup(struct earlycon_device *dev,
tty/serial/msm_geni_serial.c:	msm_geni_serial_poll_tx_done(uport);
tty/serial/msm_geni_serial.c:	msm_geni_serial_cancel_rx(uport);
tty/serial/msm_geni_serial.c:	dev->con->write = msm_geni_serial_early_console_write;
tty/serial/msm_geni_serial.c:OF_EARLYCON_DECLARE(msm_geni_serial, "qcom,msm-geni-console",
tty/serial/msm_geni_serial.c:		msm_geni_serial_earlycon_setup);
tty/serial/msm_geni_serial.c:	.write = msm_geni_serial_console_write,
tty/serial/msm_geni_serial.c:	.setup = msm_geni_console_setup,
tty/serial/msm_geni_serial.c:	.data = &msm_geni_console_driver,
tty/serial/msm_geni_serial.c:static struct uart_driver msm_geni_console_driver = {
tty/serial/msm_geni_serial.c:	.driver_name = "msm_geni_console",
tty/serial/msm_geni_serial.c:static void msm_geni_serial_debug_init(struct uart_port *uport, bool console)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	msm_port->dbg = debugfs_create_dir(dev_name(uport->dev), NULL);
tty/serial/msm_geni_serial.c:	if (IS_ERR_OR_NULL(msm_port->dbg))
tty/serial/msm_geni_serial.c:		if (!msm_port->ipc_log_rx) {
tty/serial/msm_geni_serial.c:			msm_port->ipc_log_rx = ipc_log_context_create(
tty/serial/msm_geni_serial.c:			if (!msm_port->ipc_log_rx)
tty/serial/msm_geni_serial.c:		if (!msm_port->ipc_log_tx) {
tty/serial/msm_geni_serial.c:			msm_port->ipc_log_tx = ipc_log_context_create(
tty/serial/msm_geni_serial.c:			if (!msm_port->ipc_log_tx)
tty/serial/msm_geni_serial.c:		if (!msm_port->ipc_log_pwr) {
tty/serial/msm_geni_serial.c:			msm_port->ipc_log_pwr = ipc_log_context_create(
tty/serial/msm_geni_serial.c:			if (!msm_port->ipc_log_pwr)
tty/serial/msm_geni_serial.c:		if (!msm_port->ipc_log_misc) {
tty/serial/msm_geni_serial.c:			msm_port->ipc_log_misc = ipc_log_context_create(
tty/serial/msm_geni_serial.c:			if (!msm_port->ipc_log_misc)
tty/serial/msm_geni_serial.c:		if (!msm_port->ipc_log_single) {
tty/serial/msm_geni_serial.c:			msm_port->ipc_log_single = ipc_log_context_create(
tty/serial/msm_geni_serial.c:			if (!msm_port->ipc_log_single)
tty/serial/msm_geni_serial.c:		if (!msm_port->ipc_log_irqstatus) {
tty/serial/msm_geni_serial.c:			msm_port->ipc_log_irqstatus = ipc_log_context_create(
tty/serial/msm_geni_serial.c:			if (!msm_port->ipc_log_irqstatus)
tty/serial/msm_geni_serial.c:		if (!msm_port->console_log) {
tty/serial/msm_geni_serial.c:			msm_port->console_log = ipc_log_context_create(
tty/serial/msm_geni_serial.c:			if (!msm_port->console_log)
tty/serial/msm_geni_serial.c:static void msm_geni_serial_cons_pm(struct uart_port *uport,
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:		se_geni_resources_on(&msm_port->serial_rsc);
tty/serial/msm_geni_serial.c:		se_geni_resources_off(&msm_port->serial_rsc);
tty/serial/msm_geni_serial.c:static const struct uart_ops msm_geni_console_pops = {
tty/serial/msm_geni_serial.c:	.tx_empty = msm_geni_serial_tx_empty,
tty/serial/msm_geni_serial.c:	.stop_tx = msm_geni_serial_stop_tx,
tty/serial/msm_geni_serial.c:	.start_tx = msm_geni_serial_start_tx,
tty/serial/msm_geni_serial.c:	.stop_rx = msm_geni_serial_stop_rx,
tty/serial/msm_geni_serial.c:	.set_termios = msm_geni_serial_set_termios,
tty/serial/msm_geni_serial.c:	.startup = msm_geni_serial_startup,
tty/serial/msm_geni_serial.c:	.config_port = msm_geni_serial_config_port,
tty/serial/msm_geni_serial.c:	.shutdown = msm_geni_serial_shutdown,
tty/serial/msm_geni_serial.c:	.type = msm_geni_serial_get_type,
tty/serial/msm_geni_serial.c:	.set_mctrl = msm_geni_cons_set_mctrl,
tty/serial/msm_geni_serial.c:	.get_mctrl = msm_geni_cons_get_mctrl,
tty/serial/msm_geni_serial.c:	.poll_get_char	= msm_geni_serial_get_char,
tty/serial/msm_geni_serial.c:	.poll_put_char	= msm_geni_serial_poll_put_char,
tty/serial/msm_geni_serial.c:	.pm = msm_geni_serial_cons_pm,
tty/serial/msm_geni_serial.c:static const struct uart_ops msm_geni_serial_pops = {
tty/serial/msm_geni_serial.c:	.tx_empty = msm_geni_serial_tx_empty,
tty/serial/msm_geni_serial.c:	.stop_tx = msm_geni_serial_stop_tx,
tty/serial/msm_geni_serial.c:	.start_tx = msm_geni_serial_start_tx,
tty/serial/msm_geni_serial.c:	.stop_rx = msm_geni_serial_stop_rx,
tty/serial/msm_geni_serial.c:	.set_termios = msm_geni_serial_set_termios,
tty/serial/msm_geni_serial.c:	.startup = msm_geni_serial_startup,
tty/serial/msm_geni_serial.c:	.config_port = msm_geni_serial_config_port,
tty/serial/msm_geni_serial.c:	.shutdown = msm_geni_serial_shutdown,
tty/serial/msm_geni_serial.c:	.type = msm_geni_serial_get_type,
tty/serial/msm_geni_serial.c:	.set_mctrl = msm_geni_serial_set_mctrl,
tty/serial/msm_geni_serial.c:	.get_mctrl = msm_geni_serial_get_mctrl,
tty/serial/msm_geni_serial.c:	.break_ctl = msm_geni_serial_break_ctl,
tty/serial/msm_geni_serial.c:	.ioctl = msm_geni_serial_ioctl,
tty/serial/msm_geni_serial.c:static const struct of_device_id msm_geni_device_tbl[] = {
tty/serial/msm_geni_serial.c:	{ .compatible = "qcom,msm-geni-console",
tty/serial/msm_geni_serial.c:			.data = (void *)&msm_geni_console_driver},
tty/serial/msm_geni_serial.c:	{ .compatible = "qcom,msm-geni-serial-hs",
tty/serial/msm_geni_serial.c:			.data = (void *)&msm_geni_serial_hs_driver},
tty/serial/msm_geni_serial.c:static int msm_geni_serial_get_ver_info(struct uart_port *uport)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *msm_port = GET_DEV_PORT(uport);
tty/serial/msm_geni_serial.c:	if (!msm_port->is_console)
tty/serial/msm_geni_serial.c:		se_geni_clks_on(&msm_port->serial_rsc);
tty/serial/msm_geni_serial.c:	msm_port->ver_info.m_fw_ver = get_se_m_fw(uport->membase);
tty/serial/msm_geni_serial.c:	msm_port->ver_info.s_fw_ver = get_se_s_fw(uport->membase);
tty/serial/msm_geni_serial.c:	IPC_LOG_MSG(msm_port->ipc_log_misc, "%s: FW Ver:0x%x%x\n",
tty/serial/msm_geni_serial.c:		msm_port->ver_info.m_fw_ver, msm_port->ver_info.s_fw_ver);
tty/serial/msm_geni_serial.c:	hw_ver = geni_se_qupv3_hw_version(msm_port->wrapper_dev,
tty/serial/msm_geni_serial.c:		&msm_port->ver_info.hw_major_ver,
tty/serial/msm_geni_serial.c:		&msm_port->ver_info.hw_minor_ver,
tty/serial/msm_geni_serial.c:		&msm_port->ver_info.hw_step_ver);
tty/serial/msm_geni_serial.c:		IPC_LOG_MSG(msm_port->ipc_log_misc, "%s: HW Ver:%x.%x.%x\n",
tty/serial/msm_geni_serial.c:			__func__, msm_port->ver_info.hw_major_ver,
tty/serial/msm_geni_serial.c:			msm_port->ver_info.hw_minor_ver,
tty/serial/msm_geni_serial.c:			msm_port->ver_info.hw_step_ver);
tty/serial/msm_geni_serial.c:	msm_geni_serial_enable_interrupts(uport);
tty/serial/msm_geni_serial.c:	if (!msm_port->is_console)
tty/serial/msm_geni_serial.c:		se_geni_clks_off(&msm_port->serial_rsc);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_probe(struct platform_device *pdev)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *dev_port;
tty/serial/msm_geni_serial.c:	id = of_match_device(msm_geni_device_tbl, &pdev->dev);
tty/serial/msm_geni_serial.c:		(!strcmp(id->compatible, "qcom,msm-geni-console"))) {
tty/serial/msm_geni_serial.c:		msm_geni_update_uart_error_code(dev_port,
tty/serial/msm_geni_serial.c:		msm_geni_update_uart_error_code(dev_port,
tty/serial/msm_geni_serial.c:		msm_geni_update_uart_error_code(dev_port,
tty/serial/msm_geni_serial.c:		msm_geni_update_uart_error_code(dev_port,
tty/serial/msm_geni_serial.c:					"msm_serial_geni%d", uport->line);
tty/serial/msm_geni_serial.c:	ret = devm_request_irq(uport->dev, uport->irq, msm_geni_serial_isr,
tty/serial/msm_geni_serial.c:		 * irq should disable untill msm_geni_serial_port_setup
tty/serial/msm_geni_serial.c:		 * called in msm_geni_serial_startup.
tty/serial/msm_geni_serial.c:	msm_geni_serial_debug_init(uport, is_console);
tty/serial/msm_geni_serial.c:	ret = msm_geni_serial_get_ver_info(uport);
tty/serial/msm_geni_serial.c:		INIT_WORK(&dev_port->work, msm_geni_serial_worker);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_remove(struct platform_device *pdev)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial.c:static void msm_geni_serial_allow_rx(struct msm_geni_serial_port *port)
tty/serial/msm_geni_serial.c:	msm_geni_serial_set_manual_flow(true, port);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_runtime_suspend(struct device *dev)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial.c:		msm_geni_serial_allow_rx(port);
tty/serial/msm_geni_serial.c:	msm_geni_serial_allow_rx(port);
tty/serial/msm_geni_serial.c:		msm_geni_update_uart_error_code(port,
tty/serial/msm_geni_serial.c:static int msm_geni_serial_runtime_resume(struct device *dev)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial.c:		msm_geni_update_uart_error_code(port,
tty/serial/msm_geni_serial.c:static int msm_geni_serial_sys_suspend_noirq(struct device *dev)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_sys_resume_noirq(struct device *dev)
tty/serial/msm_geni_serial.c:	struct msm_geni_serial_port *port = platform_get_drvdata(pdev);
tty/serial/msm_geni_serial.c:static int msm_geni_serial_runtime_suspend(struct device *dev)
tty/serial/msm_geni_serial.c:static int msm_geni_serial_runtime_resume(struct device *dev)
tty/serial/msm_geni_serial.c:static int msm_geni_serial_sys_suspend_noirq(struct device *dev)
tty/serial/msm_geni_serial.c:static int msm_geni_serial_sys_resume_noirq(struct device *dev)
tty/serial/msm_geni_serial.c:static const struct dev_pm_ops msm_geni_serial_pm_ops = {
tty/serial/msm_geni_serial.c:	.runtime_suspend = msm_geni_serial_runtime_suspend,
tty/serial/msm_geni_serial.c:	.runtime_resume = msm_geni_serial_runtime_resume,
tty/serial/msm_geni_serial.c:	.suspend_noirq = msm_geni_serial_sys_suspend_noirq,
tty/serial/msm_geni_serial.c:	.resume_noirq = msm_geni_serial_sys_resume_noirq,
tty/serial/msm_geni_serial.c:static struct platform_driver msm_geni_serial_platform_driver = {
tty/serial/msm_geni_serial.c:	.remove = msm_geni_serial_remove,
tty/serial/msm_geni_serial.c:	.probe = msm_geni_serial_probe,
tty/serial/msm_geni_serial.c:		.name = "msm_geni_serial",
tty/serial/msm_geni_serial.c:		.of_match_table = msm_geni_device_tbl,
tty/serial/msm_geni_serial.c:		.pm = &msm_geni_serial_pm_ops,
tty/serial/msm_geni_serial.c:static struct uart_driver msm_geni_serial_hs_driver = {
tty/serial/msm_geni_serial.c:	.driver_name = "msm_geni_serial_hs",
tty/serial/msm_geni_serial.c:static int __init msm_geni_serial_init(void)
tty/serial/msm_geni_serial.c:		msm_geni_serial_ports[i].uport.iotype = UPIO_MEM;
tty/serial/msm_geni_serial.c:		msm_geni_serial_ports[i].uport.ops = &msm_geni_serial_pops;
tty/serial/msm_geni_serial.c:		msm_geni_serial_ports[i].uport.flags = UPF_BOOT_AUTOCONF;
tty/serial/msm_geni_serial.c:		msm_geni_serial_ports[i].uport.line = i;
tty/serial/msm_geni_serial.c:		msm_geni_console_port.uport.iotype = UPIO_MEM;
tty/serial/msm_geni_serial.c:		msm_geni_console_port.uport.ops = &msm_geni_console_pops;
tty/serial/msm_geni_serial.c:		msm_geni_console_port.uport.flags = UPF_BOOT_AUTOCONF;
tty/serial/msm_geni_serial.c:		msm_geni_console_port.uport.line = i;
tty/serial/msm_geni_serial.c:	ret = console_register(&msm_geni_console_driver);
tty/serial/msm_geni_serial.c:	ret = uart_register_driver(&msm_geni_serial_hs_driver);
tty/serial/msm_geni_serial.c:		uart_unregister_driver(&msm_geni_console_driver);
tty/serial/msm_geni_serial.c:	ret = platform_driver_register(&msm_geni_serial_platform_driver);
tty/serial/msm_geni_serial.c:		console_unregister(&msm_geni_console_driver);
tty/serial/msm_geni_serial.c:		uart_unregister_driver(&msm_geni_serial_hs_driver);
tty/serial/msm_geni_serial.c:module_init(msm_geni_serial_init);
tty/serial/msm_geni_serial.c:static void __exit msm_geni_serial_exit(void)
tty/serial/msm_geni_serial.c:	platform_driver_unregister(&msm_geni_serial_platform_driver);
tty/serial/msm_geni_serial.c:	uart_unregister_driver(&msm_geni_serial_hs_driver);
tty/serial/msm_geni_serial.c:	console_unregister(&msm_geni_console_driver);
tty/serial/msm_geni_serial.c:module_exit(msm_geni_serial_exit);
tty/serial/msm_geni_serial.c:MODULE_ALIAS("tty:msm_geni_geni_serial");
uio/Makefile:obj-$(CONFIG_UIO_MSM_SHAREDMEM) += msm_sharedmem/
uio/msm_sharedmem/Makefile:obj-$(CONFIG_UIO_MSM_SHAREDMEM) := msm_sharedmem.o
uio/msm_sharedmem/msm_sharedmem.c:#define DRIVER_NAME "msm_sharedmem"
uio/msm_sharedmem/msm_sharedmem.c:static int msm_sharedmem_probe(struct platform_device *pdev)
uio/msm_sharedmem/msm_sharedmem.c:static int msm_sharedmem_remove(struct platform_device *pdev)
uio/msm_sharedmem/msm_sharedmem.c:static const struct of_device_id msm_sharedmem_of_match[] = {
uio/msm_sharedmem/msm_sharedmem.c:MODULE_DEVICE_TABLE(of, msm_sharedmem_of_match);
uio/msm_sharedmem/msm_sharedmem.c:static struct platform_driver msm_sharedmem_driver = {
uio/msm_sharedmem/msm_sharedmem.c:	.probe          = msm_sharedmem_probe,
uio/msm_sharedmem/msm_sharedmem.c:	.remove         = msm_sharedmem_remove,
uio/msm_sharedmem/msm_sharedmem.c:		.of_match_table = msm_sharedmem_of_match,
uio/msm_sharedmem/msm_sharedmem.c:static int __init msm_sharedmem_init(void)
uio/msm_sharedmem/msm_sharedmem.c:	result = platform_driver_register(&msm_sharedmem_driver);
uio/msm_sharedmem/msm_sharedmem.c:static void __exit msm_sharedmem_exit(void)
uio/msm_sharedmem/msm_sharedmem.c:	platform_driver_unregister(&msm_sharedmem_driver);
uio/msm_sharedmem/msm_sharedmem.c:module_init(msm_sharedmem_init);
uio/msm_sharedmem/msm_sharedmem.c:module_exit(msm_sharedmem_exit);
usb/chipidea/Makefile:obj-$(CONFIG_USB_CHIPIDEA)	+= ci_hdrc_msm.o
usb/chipidea/ci_hdrc_msm.c:struct ci_hdrc_msm {
usb/chipidea/ci_hdrc_msm.c:ci_hdrc_msm_por_reset(struct reset_controller_dev *r, unsigned long id)
usb/chipidea/ci_hdrc_msm.c:	struct ci_hdrc_msm *ci_msm = container_of(r, struct ci_hdrc_msm, rcdev);
usb/chipidea/ci_hdrc_msm.c:	void __iomem *addr = ci_msm->base;
usb/chipidea/ci_hdrc_msm.c:static const struct reset_control_ops ci_hdrc_msm_reset_ops = {
usb/chipidea/ci_hdrc_msm.c:	.reset = ci_hdrc_msm_por_reset,
usb/chipidea/ci_hdrc_msm.c:static int ci_hdrc_msm_notify_event(struct ci_hdrc *ci, unsigned event)
usb/chipidea/ci_hdrc_msm.c:	struct ci_hdrc_msm *msm_ci = dev_get_drvdata(dev);
usb/chipidea/ci_hdrc_msm.c:		if (msm_ci->secondary_phy) {
usb/chipidea/ci_hdrc_msm.c:			u32 val = readl_relaxed(msm_ci->base + HS_PHY_SEC_CTRL);
usb/chipidea/ci_hdrc_msm.c:			writel_relaxed(val, msm_ci->base + HS_PHY_SEC_CTRL);
usb/chipidea/ci_hdrc_msm.c:		if (!msm_ci->hsic)
usb/chipidea/ci_hdrc_msm.c:static int ci_hdrc_msm_mux_phy(struct ci_hdrc_msm *ci,
usb/chipidea/ci_hdrc_msm.c:static int ci_hdrc_msm_probe(struct platform_device *pdev)
usb/chipidea/ci_hdrc_msm.c:	struct ci_hdrc_msm *ci;
usb/chipidea/ci_hdrc_msm.c:	dev_dbg(&pdev->dev, "ci_hdrc_msm_probe\n");
usb/chipidea/ci_hdrc_msm.c:	ci->pdata.name = "ci_hdrc_msm";
usb/chipidea/ci_hdrc_msm.c:	ci->pdata.notify_event = ci_hdrc_msm_notify_event;
usb/chipidea/ci_hdrc_msm.c:	ci->rcdev.ops = &ci_hdrc_msm_reset_ops;
usb/chipidea/ci_hdrc_msm.c:	ret = ci_hdrc_msm_mux_phy(ci, pdev);
usb/chipidea/ci_hdrc_msm.c:static int ci_hdrc_msm_remove(struct platform_device *pdev)
usb/chipidea/ci_hdrc_msm.c:	struct ci_hdrc_msm *ci = platform_get_drvdata(pdev);
usb/chipidea/ci_hdrc_msm.c:static const struct of_device_id msm_ci_dt_match[] = {
usb/chipidea/ci_hdrc_msm.c:MODULE_DEVICE_TABLE(of, msm_ci_dt_match);
usb/chipidea/ci_hdrc_msm.c:static struct platform_driver ci_hdrc_msm_driver = {
usb/chipidea/ci_hdrc_msm.c:	.probe = ci_hdrc_msm_probe,
usb/chipidea/ci_hdrc_msm.c:	.remove = ci_hdrc_msm_remove,
usb/chipidea/ci_hdrc_msm.c:		.name = "msm_hsusb",
usb/chipidea/ci_hdrc_msm.c:		.of_match_table = msm_ci_dt_match,
usb/chipidea/ci_hdrc_msm.c:module_platform_driver(ci_hdrc_msm_driver);
usb/chipidea/ci_hdrc_msm.c:MODULE_ALIAS("platform:msm_hsusb");
usb/chipidea/ci_hdrc_msm.c:MODULE_ALIAS("platform:ci13xxx_msm");
usb/chipidea/ci_hdrc_zevio.c: * Based off drivers/usb/chipidea/ci_hdrc_msm.c
usb/dwc3/Makefile:CFLAGS_dwc3-msm.o                       := -Idrivers/usb/host -Idrivers/base/power
usb/dwc3/Makefile:obj-$(CONFIG_USB_DWC3_MSM)		+= dwc3-msm.o dbm.o
usb/dwc3/core.c:	/* will be enabled in dwc3_msm_resume() */
usb/dwc3/dbm.c:static inline void msm_dbm_write_ep_reg_field(struct dbm *dbm,
usb/dwc3/dbm.c:#define msm_dbm_write_reg_field(d, r, m, v) \
usb/dwc3/dbm.c:	msm_dbm_write_ep_reg_field(d, r, 0, m, v)
usb/dwc3/dbm.c:static inline u32 msm_dbm_read_ep_reg(struct dbm *dbm, enum dbm_reg reg, int ep)
usb/dwc3/dbm.c:#define msm_dbm_read_reg(d, r) msm_dbm_read_ep_reg(d, r, 0)
usb/dwc3/dbm.c:static inline void msm_dbm_write_ep_reg(struct dbm *dbm, enum dbm_reg reg,
usb/dwc3/dbm.c:#define msm_dbm_write_reg(d, r, v) msm_dbm_write_ep_reg(d, r, 0, v)
usb/dwc3/dbm.c:	msm_dbm_write_reg_field(dbm, DBM_SOFT_RESET, DBM_SFT_RST_MASK, reset);
usb/dwc3/dbm.c:		msm_dbm_write_reg_field(dbm, DBM_SOFT_RESET,
usb/dwc3/dbm.c:		msm_dbm_write_reg_field(dbm, DBM_SOFT_RESET,
usb/dwc3/dbm.c:	msm_dbm_write_reg_field(dbm, DBM_DBG_CNFG,
usb/dwc3/dbm.c:	msm_dbm_write_ep_reg_field(dbm, DBM_EP_CFG, dbm_ep,
usb/dwc3/dbm.c:	msm_dbm_write_ep_reg_field(dbm, DBM_EP_CFG, dbm_ep, USB3_EPNUM,
usb/dwc3/dbm.c:		msm_dbm_write_ep_reg_field(dbm, DBM_EP_CFG, dbm_ep,
usb/dwc3/dbm.c:		msm_dbm_write_reg_field(dbm, DBM_PIPE_CFG, 0x000000ff, 0xe4);
usb/dwc3/dbm.c:	msm_dbm_write_ep_reg_field(dbm, DBM_EP_CFG, dbm_ep, DBM_EN_EP, 1);
usb/dwc3/dbm.c:	data = msm_dbm_read_reg(dbm, DBM_DISABLE_UPDXFER);
usb/dwc3/dbm.c:	msm_dbm_write_reg(dbm, DBM_DISABLE_UPDXFER, data);
usb/dwc3/dbm.c:	data = msm_dbm_read_ep_reg(dbm, DBM_EP_CFG, dbm_ep);
usb/dwc3/dbm.c:	msm_dbm_write_ep_reg(dbm, DBM_EP_CFG, dbm_ep, data);
usb/dwc3/dbm.c:	if (msm_dbm_read_reg(dbm, DBM_GEVNTSIZ))
usb/dwc3/dbm.c:		msm_dbm_write_reg(dbm, DBM_GEVNTADR_LSB, addr_lo);
usb/dwc3/dbm.c:		msm_dbm_write_reg(dbm, DBM_GEVNTADR_MSB, addr_hi);
usb/dwc3/dbm.c:		msm_dbm_write_reg(dbm, DBM_GEVNTADR, addr_lo);
usb/dwc3/dbm.c:	msm_dbm_write_reg_field(dbm, DBM_GEVNTSIZ, DBM_GEVNTSIZ_MASK, size);
usb/dwc3/dbm.c:	data = msm_dbm_read_reg(dbm, DBM_DISABLE_UPDXFER);
usb/dwc3/dbm.c:	msm_dbm_write_reg(dbm, DBM_DISABLE_UPDXFER, data);
usb/dwc3/dbm.c:		msm_dbm_write_ep_reg(dbm, DBM_DATA_FIFO_LSB, dbm_ep, lo);
usb/dwc3/dbm.c:		msm_dbm_write_ep_reg(dbm, DBM_DATA_FIFO_MSB, dbm_ep, hi);
usb/dwc3/dbm.c:		msm_dbm_write_ep_reg(dbm, DBM_DATA_FIFO, dbm_ep, addr);
usb/dwc3/dbm.c:	msm_dbm_write_ep_reg_field(dbm, DBM_DATA_FIFO_SIZE, dbm_ep,
usb/dwc3/dbm.c:	msm_dbm_write_reg(dbm, DBM_GEN_CFG, speed);
usb/dwc3/dbm.c:	msm_dbm_write_reg(dbm, DBM_DATA_FIFO_ADDR_EN, 0x000000FF);
usb/dwc3/dbm.c:	msm_dbm_write_reg(dbm, DBM_DATA_FIFO_SIZE_EN, 0x000000FF);
usb/dwc3/dwc3-qcom.c:	{ .compatible = "qcom,msm8996-dwc3" },
usb/dwc3/dwc3-msm.c:#include <linux/msm-bus.h>
usb/dwc3/dwc3-msm.c:struct dwc3_msm_req_complete {
usb/dwc3/dwc3-msm.c:enum msm_usb_irq {
usb/dwc3/dwc3-msm.c:struct dwc3_msm;
usb/dwc3/dwc3-msm.c:	struct dwc3_msm		*mdwc;
usb/dwc3/dwc3-msm.c:struct dwc3_msm {
usb/dwc3/dwc3-msm.c:	struct msm_bus_scale_pdata	*bus_scale_table;
usb/dwc3/dwc3-msm.c:static void dwc3_pwr_event_handler(struct dwc3_msm *mdwc);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_gadget_vbus_draw(struct dwc3_msm *mdwc, unsigned int mA);
usb/dwc3/dwc3-msm.c:static void dwc3_msm_notify_event(struct dwc3 *dwc, unsigned int event,
usb/dwc3/dwc3-msm.c:static int dwc3_otg_start_host(struct dwc3_msm *mdwc, int on);
usb/dwc3/dwc3-msm.c:static inline u32 dwc3_msm_read_reg(void __iomem *base, u32 offset)
usb/dwc3/dwc3-msm.c:static inline u32 dwc3_msm_read_reg_field(void __iomem *base,
usb/dwc3/dwc3-msm.c:static inline void dwc3_msm_write_reg(void __iomem *base, u32 offset, u32 val)
usb/dwc3/dwc3-msm.c:static inline void dwc3_msm_write_reg_field(void __iomem *base, u32 offset,
usb/dwc3/dwc3-msm.c:static bool dwc3_msm_is_ss_rhport_connected(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:	reg = dwc3_msm_read_reg(mdwc->base, USB3_HCSPARAMS1);
usb/dwc3/dwc3-msm.c:		reg = dwc3_msm_read_reg(mdwc->base, USB3_PORTSC + i*0x10);
usb/dwc3/dwc3-msm.c:static bool dwc3_msm_is_host_superspeed(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:	reg = dwc3_msm_read_reg(mdwc->base, USB3_HCSPARAMS1);
usb/dwc3/dwc3-msm.c:		reg = dwc3_msm_read_reg(mdwc->base, USB3_PORTSC + i*0x10);
usb/dwc3/dwc3-msm.c:static inline bool dwc3_msm_is_dev_superspeed(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:	speed = dwc3_msm_read_reg(mdwc->base, DWC3_DSTS) & DWC3_DSTS_CONNECTSPD;
usb/dwc3/dwc3-msm.c:static inline bool dwc3_msm_is_superspeed(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:		return dwc3_msm_is_host_superspeed(mdwc);
usb/dwc3/dwc3-msm.c:	return dwc3_msm_is_dev_superspeed(mdwc);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_dbm_disable_updxfer(struct dwc3 *dwc, u8 usb_ep)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:int msm_data_fifo_config(struct usb_ep *ep, unsigned long addr,
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c: * Cleanups for msm endpoint on request complete.
usb/dwc3/dwc3-msm.c:static void dwc3_msm_req_complete_func(struct usb_ep *ep,
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm_req_complete *req_complete = NULL;
usb/dwc3/dwc3-msm.c: * @mdwc - pointer to dwc3_msm instance.
usb/dwc3/dwc3-msm.c:static int __dwc3_msm_dbm_ep_reset(struct dwc3_msm *mdwc, struct dwc3_ep *dep)
usb/dwc3/dwc3-msm.c:int msm_dwc3_reset_dbm_ep(struct usb_ep *ep)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:	return __dwc3_msm_dbm_ep_reset(mdwc, dep);
usb/dwc3/dwc3-msm.c:EXPORT_SYMBOL(msm_dwc3_reset_dbm_ep);
usb/dwc3/dwc3-msm.c: * See the header of the dwc3_msm_ep_queue function.
usb/dwc3/dwc3-msm.c:static int __dwc3_msm_ep_queue(struct dwc3_ep *dep, struct dwc3_request *req)
usb/dwc3/dwc3-msm.c:static int dwc3_msm_ep_queue(struct usb_ep *ep,
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm_req_complete *req_complete;
usb/dwc3/dwc3-msm.c:			"ep [%s,%d] was unconfigured as msm endpoint\n",
usb/dwc3/dwc3-msm.c:	request->complete = dwc3_msm_req_complete_func;
usb/dwc3/dwc3-msm.c:	size = dwc3_msm_read_reg(mdwc->base, DWC3_GEVNTSIZ(0));
usb/dwc3/dwc3-msm.c:		dwc3_msm_read_reg(mdwc->base, DWC3_GEVNTADRLO(0)),
usb/dwc3/dwc3-msm.c:		dwc3_msm_read_reg(mdwc->base, DWC3_GEVNTADRHI(0)),
usb/dwc3/dwc3-msm.c:	ret = __dwc3_msm_ep_queue(dep, req);
usb/dwc3/dwc3-msm.c:			"error %d after calling __dwc3_msm_ep_queue\n", ret);
usb/dwc3/dwc3-msm.c:	superspeed = dwc3_msm_is_dev_superspeed(mdwc);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg(mdwc->base, GSI_RING_BASE_ADDR_L(mdwc->gsi_reg, n),
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg(mdwc->base, GSI_RING_BASE_ADDR_H(mdwc->gsi_reg, n),
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg(mdwc->base, GSI_DBL_ADDR_H(mdwc->gsi_reg, n),
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg(mdwc->base, GSI_DBL_ADDR_L(mdwc->gsi_reg, n),
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg(mdwc->base, GSI_DBL_ADDR_H(mdwc->gsi_reg, n),
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg(mdwc->base, GSI_DBL_ADDR_L(mdwc->gsi_reg, n),
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg_field(mdwc->base, GSI_GENERAL_CFG_REG(mdwc->gsi_reg),
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg_field(mdwc->base, GSI_GENERAL_CFG_REG(mdwc->gsi_reg),
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg_field(mdwc->base, GSI_GENERAL_CFG_REG(mdwc->gsi_reg),
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg_field(mdwc->base, GSI_GENERAL_CFG_REG(mdwc->gsi_reg),
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg_field(mdwc->base, GSI_GENERAL_CFG_REG(mdwc->gsi_reg),
usb/dwc3/dwc3-msm.c:static bool gsi_check_ready_to_suspend(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:	while (dwc3_msm_read_reg_field(mdwc->base,
usb/dwc3/dwc3-msm.c:static int dwc3_msm_gsi_ep_op(struct usb_ep *ep,
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:int msm_ep_config(struct usb_ep *ep, struct usb_request *request)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:			"ep [%s,%d] already configured as msm endpoint\n",
usb/dwc3/dwc3-msm.c:	new_ep_ops->queue = dwc3_msm_ep_queue;
usb/dwc3/dwc3-msm.c:	new_ep_ops->gsi_ep_op = dwc3_msm_gsi_ep_op;
usb/dwc3/dwc3-msm.c:EXPORT_SYMBOL(msm_ep_config);
usb/dwc3/dwc3-msm.c: * dwc3_msm_ep_config function.
usb/dwc3/dwc3-msm.c:int msm_ep_unconfig(struct usb_ep *ep)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:			"ep [%s,%d] was not configured as msm endpoint\n",
usb/dwc3/dwc3-msm.c:EXPORT_SYMBOL(msm_ep_unconfig);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = container_of(w, struct dwc3_msm,
usb/dwc3/dwc3-msm.c:static int msm_dwc3_usbdev_notify(struct notifier_block *self,
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = container_of(self, struct dwc3_msm, usbdev_nb);
usb/dwc3/dwc3-msm.c:bool msm_dwc3_reset_ep_after_lpm(struct usb_gadget *gadget)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:EXPORT_SYMBOL(msm_dwc3_reset_ep_after_lpm);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_config_gdsc(struct dwc3_msm *mdwc, int on)
usb/dwc3/dwc3-msm.c:static int dwc3_msm_link_clk_reset(struct dwc3_msm *mdwc, bool assert)
usb/dwc3/dwc3-msm.c:static void dwc3_msm_vbus_draw_work(struct work_struct *w)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = container_of(w, struct dwc3_msm,
usb/dwc3/dwc3-msm.c:	dwc3_msm_gadget_vbus_draw(mdwc, dwc->vbus_draw);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:static void dwc3_msm_notify_event(struct dwc3 *dwc, unsigned int event,
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dwc->dev->parent);
usb/dwc3/dwc3-msm.c:		reg = dwc3_msm_read_reg(mdwc->base, DWC3_GCTL);
usb/dwc3/dwc3-msm.c:		dwc3_msm_write_reg(mdwc->base, DWC3_GCTL, reg);
usb/dwc3/dwc3-msm.c:			dwc3_msm_write_reg(mdwc->base, QSCRATCH_GENERAL_CFG,
usb/dwc3/dwc3-msm.c:				dwc3_msm_read_reg(mdwc->base,
usb/dwc3/dwc3-msm.c:			dwc3_msm_write_reg(mdwc->base, QSCRATCH_GENERAL_CFG,
usb/dwc3/dwc3-msm.c:				dwc3_msm_read_reg(mdwc->base,
usb/dwc3/dwc3-msm.c:			dwc3_msm_write_reg(mdwc->base, QSCRATCH_GENERAL_CFG,
usb/dwc3/dwc3-msm.c:				dwc3_msm_read_reg(mdwc->base,
usb/dwc3/dwc3-msm.c:			dwc3_msm_write_reg_field(mdwc->base,
usb/dwc3/dwc3-msm.c:		dwc3_msm_dbm_disable_updxfer(dwc, value);
usb/dwc3/dwc3-msm.c:		dwc3_msm_write_reg_field(mdwc->base,
usb/dwc3/dwc3-msm.c:		dwc3_msm_write_reg_field(mdwc->base,
usb/dwc3/dwc3-msm.c:static void dwc3_msm_block_reset(struct dwc3_msm *mdwc, bool core_reset)
usb/dwc3/dwc3-msm.c:		ret = dwc3_msm_link_clk_reset(mdwc, 1);
usb/dwc3/dwc3-msm.c:		ret = dwc3_msm_link_clk_reset(mdwc, 0);
usb/dwc3/dwc3-msm.c:		dwc3_msm_write_reg_field(mdwc->base, QSCRATCH_GENERAL_CFG,
usb/dwc3/dwc3-msm.c:static void dwc3_msm_power_collapse_por(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:		val = dwc3_msm_read_reg_field(mdwc->base,
usb/dwc3/dwc3-msm.c:		val = dwc3_msm_read_reg_field(mdwc->base,
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg_field(mdwc->base, PWR_EVNT_IRQ_MASK_REG,
usb/dwc3/dwc3-msm.c:static int dwc3_msm_prepare_suspend(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:			&& dwc3_msm_is_superspeed(mdwc) && !mdwc->in_restart) {
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg(mdwc->base, PWR_EVNT_IRQ_STAT_REG,
usb/dwc3/dwc3-msm.c:	reg = dwc3_msm_read_reg(mdwc->base, DWC3_GUSB2PHYCFG(0));
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg(mdwc->base, DWC3_GUSB2PHYCFG(0),
usb/dwc3/dwc3-msm.c:		reg = dwc3_msm_read_reg(mdwc->base, PWR_EVNT_IRQ_STAT_REG);
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg(mdwc->base, PWR_EVNT_IRQ_STAT_REG,
usb/dwc3/dwc3-msm.c:static void dwc3_set_phy_speed_flags(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:		reg = dwc3_msm_read_reg(mdwc->base, USB3_HCSPARAMS1);
usb/dwc3/dwc3-msm.c:			reg = dwc3_msm_read_reg(mdwc->base,
usb/dwc3/dwc3-msm.c:static void msm_dwc3_perf_vote_update(struct dwc3_msm *mdwc,
usb/dwc3/dwc3-msm.c:static void configure_usb_wakeup_interrupt(struct dwc3_msm *mdwc,
usb/dwc3/dwc3-msm.c:static void configure_usb_wakeup_interrupts(struct dwc3_msm *mdwc, bool enable)
usb/dwc3/dwc3-msm.c:static void configure_nonpdc_usb_interrupt(struct dwc3_msm *mdwc,
usb/dwc3/dwc3-msm.c:static void dwc3_msm_set_pwr_events(struct dwc3_msm *mdwc, bool on)
usb/dwc3/dwc3-msm.c:	irq_stat = dwc3_msm_read_reg(mdwc->base, PWR_EVNT_IRQ_STAT_REG);
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg(mdwc->base, PWR_EVNT_IRQ_STAT_REG, irq_stat);
usb/dwc3/dwc3-msm.c:	irq_mask = dwc3_msm_read_reg(mdwc->base, PWR_EVNT_IRQ_MASK_REG);
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg(mdwc->base, PWR_EVNT_IRQ_MASK_REG, irq_mask);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_update_bus_bw(struct dwc3_msm *mdwc, enum bus_vote bv)
usb/dwc3/dwc3-msm.c:	ret = msm_bus_scale_client_update_request(
usb/dwc3/dwc3-msm.c:static int dwc3_msm_suspend(struct dwc3_msm *mdwc, bool enable_wakeup)
usb/dwc3/dwc3-msm.c:	msm_dwc3_perf_vote_update(mdwc, false);
usb/dwc3/dwc3-msm.c:	ret = dwc3_msm_prepare_suspend(mdwc);
usb/dwc3/dwc3-msm.c:			!dwc3_msm_is_superspeed(mdwc)));
usb/dwc3/dwc3-msm.c:		if (dwc3_msm_is_superspeed(mdwc))
usb/dwc3/dwc3-msm.c:		dwc3_msm_set_pwr_events(mdwc, true);
usb/dwc3/dwc3-msm.c:		dwc3_msm_config_gdsc(mdwc, 0);
usb/dwc3/dwc3-msm.c:		dwc3_msm_config_gdsc(mdwc, 0);
usb/dwc3/dwc3-msm.c:	dwc3_msm_update_bus_bw(mdwc, BUS_VOTE_NONE);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_resume(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:		dwc3_msm_update_bus_bw(mdwc, BUS_VOTE_SVS);
usb/dwc3/dwc3-msm.c:		dwc3_msm_update_bus_bw(mdwc, mdwc->default_bus_vote);
usb/dwc3/dwc3-msm.c:		dwc3_msm_config_gdsc(mdwc, 1);
usb/dwc3/dwc3-msm.c:		dwc3_msm_config_gdsc(mdwc, 1);
usb/dwc3/dwc3-msm.c:		dwc3_msm_set_pwr_events(mdwc, false);
usb/dwc3/dwc3-msm.c:		dwc3_msm_power_collapse_por(mdwc);
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg(mdwc->base, DWC3_GUSB2PHYCFG(0),
usb/dwc3/dwc3-msm.c:		dwc3_msm_read_reg(mdwc->base, DWC3_GUSB2PHYCFG(0)) &
usb/dwc3/dwc3-msm.c:static void dwc3_ext_event_notify(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = container_of(w, struct dwc3_msm, resume_work);
usb/dwc3/dwc3-msm.c:	 * dwc3_msm_resume() in case we are here due to system
usb/dwc3/dwc3-msm.c:		dwc3_msm_resume(mdwc);
usb/dwc3/dwc3-msm.c:static void dwc3_pwr_event_handler(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:	irq_stat = dwc3_msm_read_reg(mdwc->base, PWR_EVNT_IRQ_STAT_REG);
usb/dwc3/dwc3-msm.c:			ls = dwc3_msm_read_reg_field(mdwc->base,
usb/dwc3/dwc3-msm.c:			ls = dwc3_msm_read_reg_field(mdwc->base,
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg(mdwc->base, PWR_EVNT_IRQ_STAT_REG, irq_clear);
usb/dwc3/dwc3-msm.c:static irqreturn_t msm_dwc3_pwr_irq_thread(int irq, void *_mdwc)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = _mdwc;
usb/dwc3/dwc3-msm.c:static irqreturn_t msm_dwc3_pwr_irq(int irq, void *data)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = data;
usb/dwc3/dwc3-msm.c:	 * clocks, dwc3_msm_resume will call dwc3_pwr_event_handler to handle
usb/dwc3/dwc3-msm.c:		/* set this to call dwc3_msm_resume() */
usb/dwc3/dwc3-msm.c:static int get_psy_type(struct dwc3_msm *mdwc);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_get_clk_gdsc(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:static int dwc3_msm_id_notifier(struct notifier_block *nb,
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = enb->mdwc;
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc =
usb/dwc3/dwc3-msm.c:		container_of(w, struct dwc3_msm, sdp_check.work);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_vbus_notifier(struct notifier_block *nb,
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = enb->mdwc;
usb/dwc3/dwc3-msm.c:			dwc3_msm_gadget_vbus_draw(mdwc, 500);
usb/dwc3/dwc3-msm.c:			dwc3_msm_gadget_vbus_draw(mdwc, 0);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_extcon_register(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:						dwc3_msm_vbus_notifier;
usb/dwc3/dwc3-msm.c:		mdwc->extcon[idx].id_nb.notifier_call = dwc3_msm_id_notifier;
usb/dwc3/dwc3-msm.c:			dwc3_msm_vbus_notifier(&mdwc->extcon[idx].vbus_nb,
usb/dwc3/dwc3-msm.c:			dwc3_msm_id_notifier(&mdwc->extcon[idx].id_nb,
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:static void msm_dwc3_perf_vote_work(struct work_struct *w);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:		dwc3_msm_update_bus_bw(mdwc, bv);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = container_of(nb, struct dwc3_msm, dpdm_nb);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = container_of(rst_work, struct dwc3_msm, rst_work);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = container_of(w, struct dwc3_msm, rst_work.work);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_probe(struct platform_device *pdev)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc;
usb/dwc3/dwc3-msm.c:	INIT_WORK(&mdwc->vbus_draw_work, dwc3_msm_vbus_draw_work);
usb/dwc3/dwc3-msm.c:	INIT_DELAYED_WORK(&mdwc->perf_vote_work, msm_dwc3_perf_vote_work);
usb/dwc3/dwc3-msm.c:	ret = dwc3_msm_get_clk_gdsc(mdwc);
usb/dwc3/dwc3-msm.c:					msm_dwc3_pwr_irq,
usb/dwc3/dwc3-msm.c:					msm_dwc3_pwr_irq_thread,
usb/dwc3/dwc3-msm.c:			dwc3_msm_config_gdsc(mdwc, 1);
usb/dwc3/dwc3-msm.c:			dwc3_msm_config_gdsc(mdwc, 0);
usb/dwc3/dwc3-msm.c:	if (of_property_read_u32(node, "qcom,dwc-usb3-msm-tx-fifo-size",
usb/dwc3/dwc3-msm.c:	dwc3_set_notifier(&dwc3_msm_notify_event);
usb/dwc3/dwc3-msm.c:	/* Assumes dwc3 is the first DT child of dwc3-msm */
usb/dwc3/dwc3-msm.c:	mdwc->bus_scale_table = msm_bus_cl_get_pdata(pdev);
usb/dwc3/dwc3-msm.c:			msm_bus_scale_register_client(mdwc->bus_scale_table);
usb/dwc3/dwc3-msm.c:		ret = dwc3_msm_extcon_register(mdwc);
usb/dwc3/dwc3-msm.c:		msm_bus_scale_unregister_client(mdwc->bus_perf_client);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_remove(struct platform_device *pdev)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm	*mdwc = platform_get_drvdata(pdev);
usb/dwc3/dwc3-msm.c:	msm_dwc3_perf_vote_update(mdwc, false);
usb/dwc3/dwc3-msm.c:		msm_bus_scale_unregister_client(mdwc->bus_perf_client);
usb/dwc3/dwc3-msm.c:	dwc3_msm_config_gdsc(mdwc, 0);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_host_notifier(struct notifier_block *nb,
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = container_of(nb, struct dwc3_msm, host_nb);
usb/dwc3/dwc3-msm.c:			if (!dwc3_msm_is_ss_rhport_connected(mdwc)) {
usb/dwc3/dwc3-msm.c:				dwc3_msm_update_bus_bw(mdwc, BUS_VOTE_SVS);
usb/dwc3/dwc3-msm.c:			dwc3_msm_update_bus_bw(mdwc, mdwc->default_bus_vote);
usb/dwc3/dwc3-msm.c:static void msm_dwc3_perf_vote_update(struct dwc3_msm *mdwc, bool perf_mode)
usb/dwc3/dwc3-msm.c:static void msm_dwc3_perf_vote_work(struct work_struct *w)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = container_of(w, struct dwc3_msm,
usb/dwc3/dwc3-msm.c:	msm_dwc3_perf_vote_update(mdwc, in_perf_mode);
usb/dwc3/dwc3-msm.c: * @mdwc: Pointer to the dwc3_msm structure.
usb/dwc3/dwc3-msm.c:static int dwc3_otg_start_host(struct dwc3_msm *mdwc, int on)
usb/dwc3/dwc3-msm.c:		mdwc->host_nb.notifier_call = dwc3_msm_host_notifier;
usb/dwc3/dwc3-msm.c:		mdwc->usbdev_nb.notifier_call = msm_dwc3_usbdev_notify;
usb/dwc3/dwc3-msm.c:			dwc3_msm_write_reg_field(mdwc->base,
usb/dwc3/dwc3-msm.c:			dwc3_msm_write_reg_field(mdwc->base,
usb/dwc3/dwc3-msm.c:				dwc3_msm_read_reg(mdwc->base,
usb/dwc3/dwc3-msm.c:		msm_dwc3_perf_vote_update(mdwc, true);
usb/dwc3/dwc3-msm.c:		msm_dwc3_perf_vote_update(mdwc, false);
usb/dwc3/dwc3-msm.c:static void dwc3_override_vbus_status(struct dwc3_msm *mdwc, bool vbus_present)
usb/dwc3/dwc3-msm.c:	dwc3_msm_write_reg_field(mdwc->base, HS_PHY_CTRL_REG,
usb/dwc3/dwc3-msm.c:		dwc3_msm_write_reg_field(mdwc->base, SS_PHY_CTRL_REG,
usb/dwc3/dwc3-msm.c: * @mdwc: Pointer to the dwc3_msm structure.
usb/dwc3/dwc3-msm.c:static int dwc3_otg_start_peripheral(struct dwc3_msm *mdwc, int on)
usb/dwc3/dwc3-msm.c:		dwc3_msm_block_reset(mdwc, false);
usb/dwc3/dwc3-msm.c:			dwc3_msm_write_reg_field(mdwc->base,
usb/dwc3/dwc3-msm.c:			dwc3_msm_write_reg_field(mdwc->base,
usb/dwc3/dwc3-msm.c:				dwc3_msm_read_reg(mdwc->base,
usb/dwc3/dwc3-msm.c:		msm_dwc3_perf_vote_update(mdwc, true);
usb/dwc3/dwc3-msm.c:		msm_dwc3_perf_vote_update(mdwc, false);
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = enb->mdwc;
usb/dwc3/dwc3-msm.c:static int get_psy_type(struct dwc3_msm *mdwc)
usb/dwc3/dwc3-msm.c:static int dwc3_msm_gadget_vbus_draw(struct dwc3_msm *mdwc, unsigned int mA)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = container_of(w, struct dwc3_msm, sm_work.work);
usb/dwc3/dwc3-msm.c:			dwc3_msm_resume(mdwc);
usb/dwc3/dwc3-msm.c:				dwc3_msm_gadget_vbus_draw(mdwc, 0);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_pm_suspend(struct device *dev)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	dev_dbg(dev, "dwc3-msm PM suspend\n");
usb/dwc3/dwc3-msm.c:	ret = dwc3_msm_suspend(mdwc, false);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_pm_resume(struct device *dev)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	dev_dbg(dev, "dwc3-msm PM resume\n");
usb/dwc3/dwc3-msm.c:	dwc3_msm_resume(mdwc);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_runtime_idle(struct device *dev)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	dev_dbg(dev, "DWC3-msm runtime idle\n");
usb/dwc3/dwc3-msm.c:static int dwc3_msm_runtime_suspend(struct device *dev)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	dev_dbg(dev, "DWC3-msm runtime suspend\n");
usb/dwc3/dwc3-msm.c:	return dwc3_msm_suspend(mdwc, true);
usb/dwc3/dwc3-msm.c:static int dwc3_msm_runtime_resume(struct device *dev)
usb/dwc3/dwc3-msm.c:	struct dwc3_msm *mdwc = dev_get_drvdata(dev);
usb/dwc3/dwc3-msm.c:	dev_dbg(dev, "DWC3-msm runtime resume\n");
usb/dwc3/dwc3-msm.c:	return dwc3_msm_resume(mdwc);
usb/dwc3/dwc3-msm.c:static const struct dev_pm_ops dwc3_msm_dev_pm_ops = {
usb/dwc3/dwc3-msm.c:	SET_SYSTEM_SLEEP_PM_OPS(dwc3_msm_pm_suspend, dwc3_msm_pm_resume)
usb/dwc3/dwc3-msm.c:	SET_RUNTIME_PM_OPS(dwc3_msm_runtime_suspend, dwc3_msm_runtime_resume,
usb/dwc3/dwc3-msm.c:				dwc3_msm_runtime_idle)
usb/dwc3/dwc3-msm.c:		.compatible = "qcom,dwc-usb3-msm",
usb/dwc3/dwc3-msm.c:static struct platform_driver dwc3_msm_driver = {
usb/dwc3/dwc3-msm.c:	.probe		= dwc3_msm_probe,
usb/dwc3/dwc3-msm.c:	.remove		= dwc3_msm_remove,
usb/dwc3/dwc3-msm.c:		.name	= "msm-dwc3",
usb/dwc3/dwc3-msm.c:		.pm	= &dwc3_msm_dev_pm_ops,
usb/dwc3/dwc3-msm.c:static int dwc3_msm_init(void)
usb/dwc3/dwc3-msm.c:	return platform_driver_register(&dwc3_msm_driver);
usb/dwc3/dwc3-msm.c:module_init(dwc3_msm_init);
usb/dwc3/dwc3-msm.c:static void __exit dwc3_msm_exit(void)
usb/dwc3/dwc3-msm.c:	platform_driver_unregister(&dwc3_msm_driver);
usb/dwc3/dwc3-msm.c:module_exit(dwc3_msm_exit);
usb/gadget/Makefile:obj-$(CONFIG_USB_CI13XXX_MSM)   += ci13xxx_msm.o
usb/gadget/ci13xxx_msm.c:#include <linux/usb/msm_hsusb_hw.h>
usb/gadget/ci13xxx_msm.c:static irqreturn_t msm_udc_irq(int irq, void *data)
usb/gadget/ci13xxx_msm.c:static void ci13xxx_msm_suspend(void)
usb/gadget/ci13xxx_msm.c:static void ci13xxx_msm_resume(void)
usb/gadget/ci13xxx_msm.c:static void ci13xxx_msm_disconnect(void)
usb/gadget/ci13xxx_msm.c:static void ci13xxx_msm_set_l1(struct ci13xxx *udc)
usb/gadget/ci13xxx_msm.c:static void ci13xxx_msm_connect(void)
usb/gadget/ci13xxx_msm.c:static void ci13xxx_msm_reset(void)
usb/gadget/ci13xxx_msm.c:		ci13xxx_msm_set_l1(udc);
usb/gadget/ci13xxx_msm.c:static void ci13xxx_msm_mark_err_event(void)
usb/gadget/ci13xxx_msm.c:	struct msm_otg *otg;
usb/gadget/ci13xxx_msm.c:	otg = container_of(udc->transceiver, struct msm_otg, phy);
usb/gadget/ci13xxx_msm.c:static void ci13xxx_msm_notify_event(struct ci13xxx *udc, unsigned int event)
usb/gadget/ci13xxx_msm.c:		ci13xxx_msm_reset();
usb/gadget/ci13xxx_msm.c:		ci13xxx_msm_disconnect();
usb/gadget/ci13xxx_msm.c:		ci13xxx_msm_resume();
usb/gadget/ci13xxx_msm.c:		ci13xxx_msm_connect();
usb/gadget/ci13xxx_msm.c:		ci13xxx_msm_suspend();
usb/gadget/ci13xxx_msm.c:		ci13xxx_msm_resume();
usb/gadget/ci13xxx_msm.c:		ci13xxx_msm_mark_err_event();
usb/gadget/ci13xxx_msm.c:static bool ci13xxx_msm_in_lpm(struct ci13xxx *udc)
usb/gadget/ci13xxx_msm.c:	struct msm_otg *otg;
usb/gadget/ci13xxx_msm.c:	otg = container_of(udc->transceiver, struct msm_otg, phy);
usb/gadget/ci13xxx_msm.c:static irqreturn_t ci13xxx_msm_resume_irq(int irq, void *data)
usb/gadget/ci13xxx_msm.c:		ci13xxx_msm_resume();
usb/gadget/ci13xxx_msm.c:static struct ci13xxx_udc_driver ci13xxx_msm_udc_driver = {
usb/gadget/ci13xxx_msm.c:	.name			= "ci13xxx_msm",
usb/gadget/ci13xxx_msm.c:	.notify_event		= ci13xxx_msm_notify_event,
usb/gadget/ci13xxx_msm.c:	.in_lpm                 = ci13xxx_msm_in_lpm,
usb/gadget/ci13xxx_msm.c:static int ci13xxx_msm_install_wake_gpio(struct platform_device *pdev,
usb/gadget/ci13xxx_msm.c:	ret = request_irq(wake_irq, ci13xxx_msm_resume_irq,
usb/gadget/ci13xxx_msm.c:static void ci13xxx_msm_uninstall_wake_gpio(struct platform_device *pdev)
usb/gadget/ci13xxx_msm.c:static int ci13xxx_msm_probe(struct platform_device *pdev)
usb/gadget/ci13xxx_msm.c:			ci13xxx_msm_udc_driver.nz_itc = 0;
usb/gadget/ci13xxx_msm.c:			ci13xxx_msm_udc_driver.nz_itc =
usb/gadget/ci13xxx_msm.c:			ci13xxx_msm_udc_driver.flags |=
usb/gadget/ci13xxx_msm.c:			ci13xxx_msm_udc_driver.flags &=
usb/gadget/ci13xxx_msm.c:	ret = udc_probe(&ci13xxx_msm_udc_driver, &pdev->dev, _udc_ctxt.regs);
usb/gadget/ci13xxx_msm.c:		ret = ci13xxx_msm_install_wake_gpio(pdev, res);
usb/gadget/ci13xxx_msm.c:	ret = request_irq(_udc_ctxt.irq, msm_udc_irq, IRQF_SHARED, pdev->name,
usb/gadget/ci13xxx_msm.c:	ci13xxx_msm_uninstall_wake_gpio(pdev);
usb/gadget/ci13xxx_msm.c:int ci13xxx_msm_remove(struct platform_device *pdev)
usb/gadget/ci13xxx_msm.c:	ci13xxx_msm_uninstall_wake_gpio(pdev);
usb/gadget/ci13xxx_msm.c:void ci13xxx_msm_shutdown(struct platform_device *pdev)
usb/gadget/ci13xxx_msm.c:void msm_hw_soft_reset(void)
usb/gadget/ci13xxx_msm.c:void msm_hw_bam_disable(bool bam_disable)
usb/gadget/ci13xxx_msm.c:void msm_usb_irq_disable(bool disable)
usb/gadget/ci13xxx_msm.c:	msm_usb_irq_disable(false);
usb/gadget/ci13xxx_msm.c:static struct platform_driver ci13xxx_msm_driver = {
usb/gadget/ci13xxx_msm.c:	.probe = ci13xxx_msm_probe,
usb/gadget/ci13xxx_msm.c:		.name = "msm_hsusb",
usb/gadget/ci13xxx_msm.c:	.remove = ci13xxx_msm_remove,
usb/gadget/ci13xxx_msm.c:	.shutdown = ci13xxx_msm_shutdown,
usb/gadget/ci13xxx_msm.c:MODULE_ALIAS("platform:msm_hsusb");
usb/gadget/ci13xxx_msm.c:static int __init ci13xxx_msm_init(void)
usb/gadget/ci13xxx_msm.c:	return platform_driver_register(&ci13xxx_msm_driver);
usb/gadget/ci13xxx_msm.c:module_init(ci13xxx_msm_init);
usb/gadget/ci13xxx_msm.c:static void __exit ci13xxx_msm_exit(void)
usb/gadget/ci13xxx_msm.c:	platform_driver_unregister(&ci13xxx_msm_driver);
usb/gadget/ci13xxx_msm.c:module_exit(ci13xxx_msm_exit);
usb/gadget/ci13xxx_udc.c:#include <linux/usb/msm_hsusb.h>
usb/gadget/ci13xxx_udc.c:			msm_usb_bam_enable(CI_CTRL,
usb/gadget/ci13xxx_udc.c:		msm_usb_bam_enable(CI_CTRL, _gadget->bam2bam_func_enabled);
usb/gadget/function/f_cdev.c:#define MODULE_NAME "msm_usb_bridge"
usb/gadget/function/f_diag.c:	np = of_find_compatible_node(NULL, NULL, "qcom,msm-imem-diag-dload");
usb/gadget/function/f_gsi.c:		msm_ep_config(gsi->d_port.in_ep, NULL);
usb/gadget/function/f_gsi.c:		msm_ep_config(gsi->d_port.out_ep, NULL);
usb/gadget/function/f_qc_rndis.c:	msm_ep_unconfig(rndis->bam_port.out);
usb/gadget/function/f_qc_rndis.c:	msm_ep_unconfig(rndis->bam_port.in);
usb/gadget/function/u_bam_dmux.c:#include <linux/usb/msm_hsusb.h>
usb/gadget/function/u_bam_dmux.c:		ret = msm_bam_dmux_write(d->id, skb);
usb/gadget/function/u_bam_dmux.c:	msm_bam_dmux_close(d->id);
usb/gadget/function/u_bam_dmux.c:	ret = msm_bam_dmux_open(d->id, port, gbam_notify);
usb/gadget/function/u_bam_dmux.c:			msm_bam_dmux_close(d->id);
usb/gadget/function/u_data_ipa.c:			msm_ep_unconfig(port->port_usb->in);
usb/gadget/function/u_data_ipa.c:			msm_ep_unconfig(port->port_usb->out);
usb/gadget/function/u_data_ipa.c:	msm_data_fifo_config(ep, data_fifo.phys_base, data_fifo.size,
usb/gadget/function/u_data_ipa.c:			msm_dwc3_reset_ep_after_lpm(gadget);
usb/gadget/function/u_data_ipa.c:			ret = msm_ep_config(gport->out, port->rx_req);
usb/gadget/function/u_data_ipa.c:				pr_err("msm_ep_config() failed for OUT EP\n");
usb/gadget/function/u_data_ipa.c:			goto unconfig_msm_ep_out;
usb/gadget/function/u_data_ipa.c:			ret = msm_ep_config(gport->in, port->tx_req);
usb/gadget/function/u_data_ipa.c:				pr_err("msm_ep_config() failed for IN EP\n");
usb/gadget/function/u_data_ipa.c:				goto unconfig_msm_ep_out;
usb/gadget/function/u_data_ipa.c:			goto unconfig_msm_ep_in;
usb/gadget/function/u_data_ipa.c:				msm_dwc3_reset_ep_after_lpm(gadget);
usb/gadget/function/u_data_ipa.c:				msm_dwc3_reset_ep_after_lpm(gadget);
usb/gadget/function/u_data_ipa.c:unconfig_msm_ep_in:
usb/gadget/function/u_data_ipa.c:		msm_ep_unconfig(port->port_usb->in);
usb/gadget/function/u_data_ipa.c:unconfig_msm_ep_out:
usb/gadget/function/u_data_ipa.c:		msm_ep_unconfig(port->port_usb->out);
usb/gadget/function/u_data_ipa.c:		if (msm_dwc3_reset_ep_after_lpm(gadget)) {
usb/gadget/function/u_data_ipa.c:	if (msm_dwc3_reset_ep_after_lpm(gadget)) {
usb/gadget/function/u_data_ipa.c:		msm_dwc3_reset_dbm_ep(port->port_usb->in);
usb/gadget/function/u_data_ipa.c:		msm_ep_unconfig(port->port_usb->in);
usb/gadget/function/u_data_ipa.c:		msm_ep_unconfig(port->port_usb->out);
usb/gadget/function/u_qdss.c:		msm_data_fifo_config(qdss->port.data,
usb/gadget/function/u_qdss.c:	res = msm_ep_config(ep, qdss->endless_req);
usb/gadget/function/u_qdss.c:		pr_err("msm_ep_config failed\n");
usb/gadget/function/u_qdss.c:	res = msm_ep_unconfig(ep);
usb/gadget/function/u_qdss.c:		pr_err("msm_ep_unconfig failed\n");
usb/gadget/udc/Kconfig:	  dynamically linked module called "ci13xxx_msm" and force all
usb/host/Makefile:obj-$(CONFIG_USB_EHCI_MSM)      += ehci-msm.o
usb/host/ehci-msm.c:#include <linux/usb/msm_hsusb_hw.h>
usb/host/ehci-msm.c:static const char hcd_name[] = "ehci-msm";
usb/host/ehci-msm.c:static struct hc_driver __read_mostly msm_hc_driver;
usb/host/ehci-msm.c:static int ehci_msm_reset(struct usb_hcd *hcd)
usb/host/ehci-msm.c:static int ehci_msm_probe(struct platform_device *pdev)
usb/host/ehci-msm.c:	dev_dbg(&pdev->dev, "ehci_msm proble\n");
usb/host/ehci-msm.c:	hcd = usb_create_hcd(&msm_hc_driver, &pdev->dev, dev_name(&pdev->dev));
usb/host/ehci-msm.c:static int ehci_msm_remove(struct platform_device *pdev)
usb/host/ehci-msm.c:static int ehci_msm_runtime_suspend(struct device *dev)
usb/host/ehci-msm.c:	dev_dbg(dev, "ehci-msm PM suspend\n");
usb/host/ehci-msm.c:static int ehci_msm_runtime_resume(struct device *dev)
usb/host/ehci-msm.c:	dev_dbg(dev, "ehci-msm PM resume\n");
usb/host/ehci-msm.c:#define ehci_msm_pm_suspend	NULL
usb/host/ehci-msm.c:#define ehci_msm_pm_resume	NULL
usb/host/ehci-msm.c:static const struct dev_pm_ops ehci_msm_dev_pm_ops = {
usb/host/ehci-msm.c:	SET_RUNTIME_PM_OPS(ehci_msm_runtime_suspend, ehci_msm_runtime_resume,
usb/host/ehci-msm.c:static const struct acpi_device_id msm_ehci_acpi_ids[] = {
usb/host/ehci-msm.c:MODULE_DEVICE_TABLE(acpi, msm_ehci_acpi_ids);
usb/host/ehci-msm.c:static const struct of_device_id msm_ehci_dt_match[] = {
usb/host/ehci-msm.c:MODULE_DEVICE_TABLE(of, msm_ehci_dt_match);
usb/host/ehci-msm.c:static struct platform_driver ehci_msm_driver = {
usb/host/ehci-msm.c:	.probe	= ehci_msm_probe,
usb/host/ehci-msm.c:	.remove	= ehci_msm_remove,
usb/host/ehci-msm.c:		   .name = "msm_hsusb_host",
usb/host/ehci-msm.c:		   .pm = &ehci_msm_dev_pm_ops,
usb/host/ehci-msm.c:		   .of_match_table = msm_ehci_dt_match,
usb/host/ehci-msm.c:		   .acpi_match_table = ACPI_PTR(msm_ehci_acpi_ids),
usb/host/ehci-msm.c:static const struct ehci_driver_overrides msm_overrides __initconst = {
usb/host/ehci-msm.c:	.reset = ehci_msm_reset,
usb/host/ehci-msm.c:static int __init ehci_msm_init(void)
usb/host/ehci-msm.c:	ehci_init_driver(&msm_hc_driver, &msm_overrides);
usb/host/ehci-msm.c:	return platform_driver_register(&ehci_msm_driver);
usb/host/ehci-msm.c:module_init(ehci_msm_init);
usb/host/ehci-msm.c:static void __exit ehci_msm_cleanup(void)
usb/host/ehci-msm.c:	platform_driver_unregister(&ehci_msm_driver);
usb/host/ehci-msm.c:module_exit(ehci_msm_cleanup);
usb/host/ehci-msm.c:MODULE_ALIAS("platform:msm-ehci");
usb/misc/Kconfig:	  and peripheral mode based GPIO state of genoa msm.
usb/misc/ks_bridge.c:	if (!strncasecmp("msm_hsic_host", name, BUSNAME_LEN))
usb/misc/ks_bridge.c:	if (!strncasecmp("msm_ehci_host.0", name, BUSNAME_LEN))
usb/misc/vbus-extcon-genoa.c: *		0: device mode cable is disconnected so msm can run
usb/misc/vbus-extcon-genoa.c: *		1: device mode cable is disconnected so msm will
usb/misc/vbus-extcon-genoa.c: *		0:  device mode cable is connected so msm will
usb/misc/vbus-extcon-genoa.c:		.name		= "genoa-msm-vbus-det",
usb/phy/Makefile:obj-$(CONFIG_MSM_QUSB_PHY)		+= phy-msm-qusb.o phy-msm-qusb-v2.o
usb/phy/Makefile:obj-$(CONFIG_USB_MSM_SSPHY_QMP)     	+= phy-msm-ssusb-qmp.o
usb/phy/Makefile:obj-$(CONFIG_MSM_HSUSB_PHY)		+= phy-msm-snps-hs.o
usb/phy/Makefile:obj-$(CONFIG_USB_MSM_OTG)               += phy-msm-usb.o
usb/phy/phy-msm-qusb-v2.c:static void msm_usb_write_readback(void __iomem *base, u32 offset,
usb/phy/phy-msm-qusb-v2.c:static int msm_qusb_phy_drive_dp_pulse(struct usb_phy *phy,
usb/phy/phy-msm-qusb-v2.c:	msm_usb_write_readback(qphy->base, qphy->phy_reg[PWR_CTRL1],
usb/phy/phy-msm-qusb-v2.c:	msm_usb_write_readback(qphy->base, qphy->phy_reg[DEBUG_CTRL4],
usb/phy/phy-msm-qusb-v2.c:	msm_usb_write_readback(qphy->base, qphy->phy_reg[DEBUG_CTRL4],
usb/phy/phy-msm-qusb-v2.c:	msm_usb_write_readback(qphy->base, qphy->phy_reg[DEBUG_CTRL3],
usb/phy/phy-msm-qusb-v2.c:	msm_usb_write_readback(qphy->base, qphy->phy_reg[PWR_CTRL1],
usb/phy/phy-msm-qusb-v2.c:	msm_usb_write_readback(qphy->base, qphy->phy_reg[INTR_CTRL],
usb/phy/phy-msm-qusb-v2.c:	msm_usb_write_readback(qphy->base, qphy->phy_reg[INTR_CTRL],
usb/phy/phy-msm-qusb-v2.c:	msm_usb_write_readback(qphy->base, qphy->phy_reg[INTR_CTRL],
usb/phy/phy-msm-qusb-v2.c:	msm_usb_write_readback(qphy->base, qphy->phy_reg[DEBUG_CTRL3],
usb/phy/phy-msm-qusb-v2.c:	msm_usb_write_readback(qphy->base, qphy->phy_reg[DEBUG_CTRL4],
usb/phy/phy-msm-qusb-v2.c:	msm_usb_write_readback(qphy->base, qphy->phy_reg[PWR_CTRL1],
usb/phy/phy-msm-qusb-v2.c:	qphy->phy.label			= "msm-qusb-phy-v2";
usb/phy/phy-msm-qusb-v2.c:	qphy->phy.drive_dp_pulse	= msm_qusb_phy_drive_dp_pulse;
usb/phy/phy-msm-qusb-v2.c:		.name	= "msm-qusb-phy-v2",
usb/phy/phy-msm-qusb.c:	qphy->phy.label			= "msm-qusb-phy";
usb/phy/phy-msm-qusb.c:		.name	= "msm-qusb-phy",
usb/phy/phy-msm-snps-hs.c:struct msm_hsphy {
usb/phy/phy-msm-snps-hs.c:static void msm_hsphy_enable_clocks(struct msm_hsphy *phy, bool on)
usb/phy/phy-msm-snps-hs.c:static int msm_hsphy_config_vdd(struct msm_hsphy *phy, int high)
usb/phy/phy-msm-snps-hs.c:static int msm_hsphy_enable_power(struct msm_hsphy *phy, bool on)
usb/phy/phy-msm-snps-hs.c:	ret = msm_hsphy_config_vdd(phy, true);
usb/phy/phy-msm-snps-hs.c:	ret = msm_hsphy_config_vdd(phy, false);
usb/phy/phy-msm-snps-hs.c:static void msm_usb_write_readback(void __iomem *base, u32 offset,
usb/phy/phy-msm-snps-hs.c:static void msm_hsphy_reset(struct msm_hsphy *phy)
usb/phy/phy-msm-snps-hs.c:static int msm_hsphy_init(struct usb_phy *uphy)
usb/phy/phy-msm-snps-hs.c:	struct msm_hsphy *phy = container_of(uphy, struct msm_hsphy, phy);
usb/phy/phy-msm-snps-hs.c:	ret = msm_hsphy_enable_power(phy, true);
usb/phy/phy-msm-snps-hs.c:	msm_hsphy_enable_clocks(phy, true);
usb/phy/phy-msm-snps-hs.c:	msm_hsphy_reset(phy);
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_CFG0,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_UTMI_CTRL5,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_HS_PHY_CTRL_COMMON0,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_HS_PHY_CTRL_COMMON1,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_REFCLK_CTRL,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_HS_PHY_CTRL_COMMON1,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_HS_PHY_CTRL1,
usb/phy/phy-msm-snps-hs.c:			msm_usb_write_readback(phy->base,
usb/phy/phy-msm-snps-hs.c:		msm_usb_write_readback(phy->base,
usb/phy/phy-msm-snps-hs.c:		msm_usb_write_readback(phy->base,
usb/phy/phy-msm-snps-hs.c:		msm_usb_write_readback(phy->base,
usb/phy/phy-msm-snps-hs.c:		msm_usb_write_readback(phy->base,
usb/phy/phy-msm-snps-hs.c:		msm_usb_write_readback(phy->base,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_HS_PHY_CTRL_COMMON2,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_HS_PHY_CTRL2,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_UTMI_CTRL0,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_UTMI_CTRL5,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_HS_PHY_CTRL2,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_CFG0,
usb/phy/phy-msm-snps-hs.c:static int msm_hsphy_set_suspend(struct usb_phy *uphy, int suspend)
usb/phy/phy-msm-snps-hs.c:	struct msm_hsphy *phy = container_of(uphy, struct msm_hsphy, phy);
usb/phy/phy-msm-snps-hs.c:				msm_usb_write_readback(phy->base,
usb/phy/phy-msm-snps-hs.c:				msm_usb_write_readback(phy->base,
usb/phy/phy-msm-snps-hs.c:			msm_hsphy_enable_clocks(phy, false);
usb/phy/phy-msm-snps-hs.c:				msm_hsphy_enable_clocks(phy, false);
usb/phy/phy-msm-snps-hs.c:				msm_hsphy_enable_power(phy, false);
usb/phy/phy-msm-snps-hs.c:		msm_hsphy_enable_clocks(phy, true);
usb/phy/phy-msm-snps-hs.c:static int msm_hsphy_notify_connect(struct usb_phy *uphy,
usb/phy/phy-msm-snps-hs.c:	struct msm_hsphy *phy = container_of(uphy, struct msm_hsphy, phy);
usb/phy/phy-msm-snps-hs.c:static int msm_hsphy_notify_disconnect(struct usb_phy *uphy,
usb/phy/phy-msm-snps-hs.c:	struct msm_hsphy *phy = container_of(uphy, struct msm_hsphy, phy);
usb/phy/phy-msm-snps-hs.c:static int msm_hsphy_drive_dp_pulse(struct usb_phy *uphy,
usb/phy/phy-msm-snps-hs.c:	struct msm_hsphy *phy = container_of(uphy, struct msm_hsphy, phy);
usb/phy/phy-msm-snps-hs.c:	ret = msm_hsphy_enable_power(phy, true);
usb/phy/phy-msm-snps-hs.c:	msm_hsphy_enable_clocks(phy, true);
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_CFG0,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_CFG0,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_UTMI_CTRL0,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_UTMI_CTRL0,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_UTMI_CTRL1,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_UTMI_CTRL0,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_UTMI_CTRL1,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_CFG0,
usb/phy/phy-msm-snps-hs.c:	msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_CFG0,
usb/phy/phy-msm-snps-hs.c:	msm_hsphy_enable_clocks(phy, false);
usb/phy/phy-msm-snps-hs.c:	ret = msm_hsphy_enable_power(phy, false);
usb/phy/phy-msm-snps-hs.c:static int msm_hsphy_dpdm_regulator_enable(struct regulator_dev *rdev)
usb/phy/phy-msm-snps-hs.c:	struct msm_hsphy *phy = rdev_get_drvdata(rdev);
usb/phy/phy-msm-snps-hs.c:		ret = msm_hsphy_enable_power(phy, true);
usb/phy/phy-msm-snps-hs.c:		msm_hsphy_enable_clocks(phy, true);
usb/phy/phy-msm-snps-hs.c:		msm_hsphy_reset(phy);
usb/phy/phy-msm-snps-hs.c:		msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_HS_PHY_CTRL2,
usb/phy/phy-msm-snps-hs.c:		msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_UTMI_CTRL0,
usb/phy/phy-msm-snps-hs.c:		msm_usb_write_readback(phy->base, USB2_PHY_USB_PHY_CFG0,
usb/phy/phy-msm-snps-hs.c:		msm_hsphy_enable_clocks(phy, false);
usb/phy/phy-msm-snps-hs.c:static int msm_hsphy_dpdm_regulator_disable(struct regulator_dev *rdev)
usb/phy/phy-msm-snps-hs.c:	struct msm_hsphy *phy = rdev_get_drvdata(rdev);
usb/phy/phy-msm-snps-hs.c:			msm_hsphy_reset(phy);
usb/phy/phy-msm-snps-hs.c:			msm_hsphy_enable_clocks(phy, false);
usb/phy/phy-msm-snps-hs.c:			ret = msm_hsphy_enable_power(phy, false);
usb/phy/phy-msm-snps-hs.c:static int msm_hsphy_dpdm_regulator_is_enabled(struct regulator_dev *rdev)
usb/phy/phy-msm-snps-hs.c:	struct msm_hsphy *phy = rdev_get_drvdata(rdev);
usb/phy/phy-msm-snps-hs.c:static struct regulator_ops msm_hsphy_dpdm_regulator_ops = {
usb/phy/phy-msm-snps-hs.c:	.enable		= msm_hsphy_dpdm_regulator_enable,
usb/phy/phy-msm-snps-hs.c:	.disable	= msm_hsphy_dpdm_regulator_disable,
usb/phy/phy-msm-snps-hs.c:	.is_enabled	= msm_hsphy_dpdm_regulator_is_enabled,
usb/phy/phy-msm-snps-hs.c:static int msm_hsphy_regulator_init(struct msm_hsphy *phy)
usb/phy/phy-msm-snps-hs.c:	phy->dpdm_rdesc.ops = &msm_hsphy_dpdm_regulator_ops;
usb/phy/phy-msm-snps-hs.c:static void msm_hsphy_create_debugfs(struct msm_hsphy *phy)
usb/phy/phy-msm-snps-hs.c:static int msm_hsphy_probe(struct platform_device *pdev)
usb/phy/phy-msm-snps-hs.c:	struct msm_hsphy *phy;
usb/phy/phy-msm-snps-hs.c:	phy->phy.init			= msm_hsphy_init;
usb/phy/phy-msm-snps-hs.c:	phy->phy.set_suspend		= msm_hsphy_set_suspend;
usb/phy/phy-msm-snps-hs.c:	phy->phy.notify_connect		= msm_hsphy_notify_connect;
usb/phy/phy-msm-snps-hs.c:	phy->phy.notify_disconnect	= msm_hsphy_notify_disconnect;
usb/phy/phy-msm-snps-hs.c:	phy->phy.drive_dp_pulse		= msm_hsphy_drive_dp_pulse;
usb/phy/phy-msm-snps-hs.c:	ret = msm_hsphy_regulator_init(phy);
usb/phy/phy-msm-snps-hs.c:	msm_hsphy_create_debugfs(phy);
usb/phy/phy-msm-snps-hs.c:static int msm_hsphy_remove(struct platform_device *pdev)
usb/phy/phy-msm-snps-hs.c:	struct msm_hsphy *phy = platform_get_drvdata(pdev);
usb/phy/phy-msm-snps-hs.c:	msm_hsphy_enable_clocks(phy, false);
usb/phy/phy-msm-snps-hs.c:	msm_hsphy_enable_power(phy, false);
usb/phy/phy-msm-snps-hs.c:static const struct of_device_id msm_usb_id_table[] = {
usb/phy/phy-msm-snps-hs.c:MODULE_DEVICE_TABLE(of, msm_usb_id_table);
usb/phy/phy-msm-snps-hs.c:static struct platform_driver msm_hsphy_driver = {
usb/phy/phy-msm-snps-hs.c:	.probe		= msm_hsphy_probe,
usb/phy/phy-msm-snps-hs.c:	.remove		= msm_hsphy_remove,
usb/phy/phy-msm-snps-hs.c:		.name	= "msm-usb-hsphy",
usb/phy/phy-msm-snps-hs.c:		.of_match_table = of_match_ptr(msm_usb_id_table),
usb/phy/phy-msm-snps-hs.c:module_platform_driver(msm_hsphy_driver);
usb/phy/phy-msm-ssusb-qmp.c:struct msm_ssphy_qmp {
usb/phy/phy-msm-ssusb-qmp.c:static const struct of_device_id msm_usb_id_table[] = {
usb/phy/phy-msm-ssusb-qmp.c:MODULE_DEVICE_TABLE(of, msm_usb_id_table);
usb/phy/phy-msm-ssusb-qmp.c:static void usb_qmp_powerup_phy(struct msm_ssphy_qmp *phy);
usb/phy/phy-msm-ssusb-qmp.c:static void msm_ssphy_qmp_enable_clks(struct msm_ssphy_qmp *phy, bool on);
usb/phy/phy-msm-ssusb-qmp.c:static inline char *get_cable_status_str(struct msm_ssphy_qmp *phy)
usb/phy/phy-msm-ssusb-qmp.c:static void msm_ssusb_qmp_clr_lfps_rxterm_int(struct msm_ssphy_qmp *phy)
usb/phy/phy-msm-ssusb-qmp.c:static void msm_ssusb_qmp_clamp_enable(struct msm_ssphy_qmp *phy, bool val)
usb/phy/phy-msm-ssusb-qmp.c:static void msm_ssusb_qmp_enable_autonomous(struct msm_ssphy_qmp *phy,
usb/phy/phy-msm-ssusb-qmp.c:		msm_ssusb_qmp_clr_lfps_rxterm_int(phy);
usb/phy/phy-msm-ssusb-qmp.c:		msm_ssusb_qmp_clamp_enable(phy, true);
usb/phy/phy-msm-ssusb-qmp.c:		msm_ssusb_qmp_clamp_enable(phy, false);
usb/phy/phy-msm-ssusb-qmp.c:		msm_ssusb_qmp_clr_lfps_rxterm_int(phy);
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssusb_qmp_ldo_enable(struct msm_ssphy_qmp *phy, int on)
usb/phy/phy-msm-ssusb-qmp.c:	struct msm_ssphy_qmp *phy = container_of(uphy, struct msm_ssphy_qmp,
usb/phy/phy-msm-ssusb-qmp.c:static void msm_ssphy_qmp_setmode(struct msm_ssphy_qmp *phy, u32 mode)
usb/phy/phy-msm-ssusb-qmp.c:static void usb_qmp_update_portselect_phymode(struct msm_ssphy_qmp *phy)
usb/phy/phy-msm-ssusb-qmp.c:			msm_ssphy_qmp_setmode(phy, USB3_DP_COMBO_MODE);
usb/phy/phy-msm-ssusb-qmp.c:static void usb_qmp_powerup_phy(struct msm_ssphy_qmp *phy)
usb/phy/phy-msm-ssusb-qmp.c:		 * msm_ssphy_qmp_init() writes 0x0 to DP_COM_SW_RESET before
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssphy_qmp_init(struct usb_phy *uphy)
usb/phy/phy-msm-ssusb-qmp.c:	struct msm_ssphy_qmp *phy = container_of(uphy, struct msm_ssphy_qmp,
usb/phy/phy-msm-ssusb-qmp.c:	ret = msm_ssusb_qmp_ldo_enable(phy, 1);
usb/phy/phy-msm-ssusb-qmp.c:		"msm_ssusb_qmp_ldo_enable(1) failed, ret=%d\n",
usb/phy/phy-msm-ssusb-qmp.c:	msm_ssphy_qmp_enable_clks(phy, true);
usb/phy/phy-msm-ssusb-qmp.c:	msm_ssphy_qmp_enable_clks(phy, false);
usb/phy/phy-msm-ssusb-qmp.c:	msm_ssusb_qmp_ldo_enable(phy, 0);
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssphy_qmp_dp_combo_reset(struct usb_phy *uphy)
usb/phy/phy-msm-ssusb-qmp.c:	struct msm_ssphy_qmp *phy = container_of(uphy, struct msm_ssphy_qmp,
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssphy_qmp_reset(struct usb_phy *uphy)
usb/phy/phy-msm-ssusb-qmp.c:	struct msm_ssphy_qmp *phy = container_of(uphy, struct msm_ssphy_qmp,
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssphy_power_enable(struct msm_ssphy_qmp *phy, bool on)
usb/phy/phy-msm-ssusb-qmp.c:			ret = msm_ssusb_qmp_ldo_enable(phy, 1);
usb/phy/phy-msm-ssusb-qmp.c:				"msm_ssusb_qmp_ldo_enable(1) failed, ret=%d\n",
usb/phy/phy-msm-ssusb-qmp.c:			ret = msm_ssusb_qmp_ldo_enable(phy, 0);
usb/phy/phy-msm-ssusb-qmp.c:					"msm_ssusb_qmp_ldo_enable(0) failed, ret=%d\n",
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssphy_qmp_set_suspend(struct usb_phy *uphy, int suspend)
usb/phy/phy-msm-ssusb-qmp.c:	struct msm_ssphy_qmp *phy = container_of(uphy, struct msm_ssphy_qmp,
usb/phy/phy-msm-ssusb-qmp.c:			msm_ssusb_qmp_enable_autonomous(phy, 1);
usb/phy/phy-msm-ssusb-qmp.c:				msm_ssphy_qmp_setmode(phy, USB3_MODE);
usb/phy/phy-msm-ssusb-qmp.c:		msm_ssphy_qmp_enable_clks(phy, false);
usb/phy/phy-msm-ssusb-qmp.c:		msm_ssphy_power_enable(phy, 0);
usb/phy/phy-msm-ssusb-qmp.c:		msm_ssphy_power_enable(phy, 1);
usb/phy/phy-msm-ssusb-qmp.c:		msm_ssphy_qmp_enable_clks(phy, true);
usb/phy/phy-msm-ssusb-qmp.c:			msm_ssusb_qmp_enable_autonomous(phy, 0);
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssphy_qmp_notify_connect(struct usb_phy *uphy,
usb/phy/phy-msm-ssusb-qmp.c:	struct msm_ssphy_qmp *phy = container_of(uphy, struct msm_ssphy_qmp,
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssphy_qmp_notify_disconnect(struct usb_phy *uphy,
usb/phy/phy-msm-ssusb-qmp.c:	struct msm_ssphy_qmp *phy = container_of(uphy, struct msm_ssphy_qmp,
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssphy_qmp_vbus_notifier(struct notifier_block *nb,
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssphy_qmp_dp_notifier(struct notifier_block *nb,
usb/phy/phy-msm-ssusb-qmp.c:	struct msm_ssphy_qmp *phy = container_of(nb,
usb/phy/phy-msm-ssusb-qmp.c:			struct msm_ssphy_qmp, dp_nb);
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssphy_qmp_extcon_register(struct msm_ssphy_qmp *phy,
usb/phy/phy-msm-ssusb-qmp.c:		dev_err(dev, "failed to get phandle for msm_ssphy_qmp\n");
usb/phy/phy-msm-ssusb-qmp.c:	phy->phy.vbus_nb.notifier_call = msm_ssphy_qmp_vbus_notifier;
usb/phy/phy-msm-ssusb-qmp.c:	phy->dp_nb.notifier_call = msm_ssphy_qmp_dp_notifier;
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssphy_qmp_get_clks(struct msm_ssphy_qmp *phy, struct device *dev)
usb/phy/phy-msm-ssusb-qmp.c:static void msm_ssphy_qmp_enable_clks(struct msm_ssphy_qmp *phy, bool on)
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssphy_qmp_probe(struct platform_device *pdev)
usb/phy/phy-msm-ssusb-qmp.c:	struct msm_ssphy_qmp *phy;
usb/phy/phy-msm-ssusb-qmp.c:	ret = msm_ssphy_qmp_get_clks(phy, dev);
usb/phy/phy-msm-ssusb-qmp.c:	phy->phy.init			= msm_ssphy_qmp_init;
usb/phy/phy-msm-ssusb-qmp.c:	phy->phy.set_suspend		= msm_ssphy_qmp_set_suspend;
usb/phy/phy-msm-ssusb-qmp.c:	phy->phy.notify_connect		= msm_ssphy_qmp_notify_connect;
usb/phy/phy-msm-ssusb-qmp.c:	phy->phy.notify_disconnect	= msm_ssphy_qmp_notify_disconnect;
usb/phy/phy-msm-ssusb-qmp.c:		phy->phy.reset		= msm_ssphy_qmp_dp_combo_reset;
usb/phy/phy-msm-ssusb-qmp.c:		phy->phy.reset		= msm_ssphy_qmp_reset;
usb/phy/phy-msm-ssusb-qmp.c:	ret = msm_ssphy_qmp_extcon_register(phy, dev);
usb/phy/phy-msm-ssusb-qmp.c:static int msm_ssphy_qmp_remove(struct platform_device *pdev)
usb/phy/phy-msm-ssusb-qmp.c:	struct msm_ssphy_qmp *phy = platform_get_drvdata(pdev);
usb/phy/phy-msm-ssusb-qmp.c:	msm_ssphy_qmp_enable_clks(phy, false);
usb/phy/phy-msm-ssusb-qmp.c:	msm_ssusb_qmp_ldo_enable(phy, 0);
usb/phy/phy-msm-ssusb-qmp.c:static struct platform_driver msm_ssphy_qmp_driver = {
usb/phy/phy-msm-ssusb-qmp.c:	.probe		= msm_ssphy_qmp_probe,
usb/phy/phy-msm-ssusb-qmp.c:	.remove		= msm_ssphy_qmp_remove,
usb/phy/phy-msm-ssusb-qmp.c:		.name	= "msm-usb-ssphy-qmp",
usb/phy/phy-msm-ssusb-qmp.c:		.of_match_table = of_match_ptr(msm_usb_id_table),
usb/phy/phy-msm-ssusb-qmp.c:module_platform_driver(msm_ssphy_qmp_driver);
usb/phy/phy-msm-usb.c:#include <linux/usb/msm_hsusb.h>
usb/phy/phy-msm-usb.c:#include <linux/usb/msm_hsusb_hw.h>
usb/phy/phy-msm-usb.c:#include <linux/msm-bus.h>
usb/phy/phy-msm-usb.c:enum msm_usb_phy_type {
usb/phy/phy-msm-usb.c: * struct msm_otg_platform_data - platform device data
usb/phy/phy-msm-usb.c: *              for msm_otg driver.
usb/phy/phy-msm-usb.c:struct msm_otg_platform_data {
usb/phy/phy-msm-usb.c:	enum msm_usb_phy_type phy_type;
usb/phy/phy-msm-usb.c:	struct msm_bus_scale_pdata *bus_scale_table;
usb/phy/phy-msm-usb.c:#define DRIVER_NAME	"msm_otg"
usb/phy/phy-msm-usb.c:enum msm_otg_phy_reg_mode {
usb/phy/phy-msm-usb.c:static struct msm_otg *the_msm_otg;
usb/phy/phy-msm-usb.c:msm_otg_dbg_log_event(struct usb_phy *phy, char *event, int d1, int d2)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(phy, struct msm_otg, phy);
usb/phy/phy-msm-usb.c:static int msm_hsusb_ldo_init(struct msm_otg *motg, int init)
usb/phy/phy-msm-usb.c:static int msm_hsusb_config_vddcx(int high)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = the_msm_otg;
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "CONFIG VDDCX", min_vol, max_vol);
usb/phy/phy-msm-usb.c:static int msm_hsusb_ldo_enable(struct msm_otg *motg,
usb/phy/phy-msm-usb.c:	enum msm_otg_phy_reg_mode mode)
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "USB REG MODE", mode, ret);
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(phy, struct msm_otg, phy);
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(phy, struct msm_otg, phy);
usb/phy/phy-msm-usb.c:static struct usb_phy_io_ops msm_otg_io_ops = {
usb/phy/phy-msm-usb.c:static void ulpi_init(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy, "ULPI WRITE", seq[0], seq[1]);
usb/phy/phy-msm-usb.c:static int msm_otg_phy_clk_reset(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static int msm_otg_link_clk_reset(struct msm_otg *motg, bool assert)
usb/phy/phy-msm-usb.c:static int msm_otg_phy_reset(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:	ret = msm_otg_link_clk_reset(motg, 1);
usb/phy/phy-msm-usb.c:	msm_otg_phy_clk_reset(motg);
usb/phy/phy-msm-usb.c:	ret = msm_otg_link_clk_reset(motg, 0);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PHY RESET SUCCESS",
usb/phy/phy-msm-usb.c:static int msm_otg_link_reset(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:static void msm_usb_phy_reset(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static void msm_chg_block_on(struct msm_otg *);
usb/phy/phy-msm-usb.c:static int msm_otg_reset(struct usb_phy *phy)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(phy, struct msm_otg, phy);
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "USB RESET", phy->otg->state,
usb/phy/phy-msm-usb.c:	ret = msm_otg_phy_reset(motg);
usb/phy/phy-msm-usb.c:	ret = msm_otg_link_reset(motg);
usb/phy/phy-msm-usb.c:	msm_usb_phy_reset(motg);
usb/phy/phy-msm-usb.c:	msm_usb_phy_reset(motg);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "USB RESET DONE", phy->otg->state,
usb/phy/phy-msm-usb.c:	msm_usb_bam_enable(CI_CTRL, false);
usb/phy/phy-msm-usb.c:		msm_chg_block_on(motg);
usb/phy/phy-msm-usb.c:static void msm_otg_kick_sm_work(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static int msm_otg_set_suspend(struct usb_phy *phy, int suspend)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(phy, struct msm_otg, phy);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(phy, "SET SUSPEND", suspend, phy->otg->state);
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(phy, "PERIPHERAL BUS SUSPEND",
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(phy, "PERIPHERAL BUS RESUME",
usb/phy/phy-msm-usb.c:	msm_otg_kick_sm_work(motg);
usb/phy/phy-msm-usb.c:static int msm_otg_bus_freq_set(struct msm_otg *motg, enum usb_noc_mode mode)
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy, "OTG BUS FREQ SET", i, rate);
usb/phy/phy-msm-usb.c:static int msm_otg_bus_freq_get(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static void msm_otg_bus_clks_enable(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static void msm_otg_bus_clks_disable(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static void msm_otg_bus_vote(struct msm_otg *motg, enum usb_bus_vote vote)
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "BUS VOTE", vote,
usb/phy/phy-msm-usb.c:		ret = msm_bus_scale_client_update_request(
usb/phy/phy-msm-usb.c:		msm_otg_bus_clks_enable(motg);
usb/phy/phy-msm-usb.c:		msm_otg_bus_clks_disable(motg);
usb/phy/phy-msm-usb.c:static void msm_otg_enable_phy_hv_int(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PHY HV INTR ENABLED",
usb/phy/phy-msm-usb.c:static void msm_otg_disable_phy_hv_int(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PHY HV INTR DISABLED",
usb/phy/phy-msm-usb.c:static void msm_otg_enter_phy_retention(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "USB PHY ENTER RETENTION",
usb/phy/phy-msm-usb.c:static void msm_otg_exit_phy_retention(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:		msm_otg_reset(&motg->phy);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "USB PHY EXIT RETENTION",
usb/phy/phy-msm-usb.c:static void msm_id_status_w(struct work_struct *w);
usb/phy/phy-msm-usb.c:static irqreturn_t msm_otg_phy_irq_handler(int irq, void *data)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = data;
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PHY ID IRQ",
usb/phy/phy-msm-usb.c:		msm_otg_kick_sm_work(motg);
usb/phy/phy-msm-usb.c:		msm_id_status_w(&motg->id_status_work.work);
usb/phy/phy-msm-usb.c:static void msm_otg_set_vbus_state(int online);
usb/phy/phy-msm-usb.c:static void msm_otg_perf_vote_update(struct msm_otg *motg, bool perf_mode);
usb/phy/phy-msm-usb.c:static int get_psy_type(struct msm_otg *motg);
usb/phy/phy-msm-usb.c:static int msm_otg_suspend(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(phy, "LPM ENTER START",
usb/phy/phy-msm-usb.c:		msm_otg_perf_vote_update(motg, false);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(phy, "CHARGER CONNECTED",
usb/phy/phy-msm-usb.c:		msm_otg_reset(phy);
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(phy, "LPM ENTER ABORTED",
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(phy, "PHY SUSPEND FAILED",
usb/phy/phy-msm-usb.c:				msm_otg_reset(phy);
usb/phy/phy-msm-usb.c:		msm_otg_enable_phy_hv_int(motg);
usb/phy/phy-msm-usb.c:			msm_otg_enter_phy_retention(motg);
usb/phy/phy-msm-usb.c:		msm_otg_enable_phy_hv_int(motg);
usb/phy/phy-msm-usb.c:			msm_otg_enter_phy_retention(motg);
usb/phy/phy-msm-usb.c:		msm_hsusb_ldo_enable(motg, USB_PHY_REG_OFF);
usb/phy/phy-msm-usb.c:		msm_hsusb_ldo_enable(motg, USB_PHY_REG_LPM_ON);
usb/phy/phy-msm-usb.c:		msm_hsusb_config_vddcx(0);
usb/phy/phy-msm-usb.c:	msm_otg_bus_vote(motg, USB_NO_PERF_VOTE);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(phy, "LPM ENTER DONE",
usb/phy/phy-msm-usb.c:			msm_otg_set_vbus_state(motg->vbus_state);
usb/phy/phy-msm-usb.c:			msm_id_status_w(&motg->id_status_work.work);
usb/phy/phy-msm-usb.c:static int msm_otg_resume(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(phy, "LPM EXIT START", motg->inputs,
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(phy, "USB NOT IN LPM",
usb/phy/phy-msm-usb.c:		msm_otg_bus_vote(motg, USB_MAX_PERF_VOTE);
usb/phy/phy-msm-usb.c:		msm_otg_bus_vote(motg, USB_MIN_PERF_VOTE);
usb/phy/phy-msm-usb.c:		msm_hsusb_ldo_enable(motg, USB_PHY_REG_ON);
usb/phy/phy-msm-usb.c:		msm_hsusb_ldo_enable(motg, USB_PHY_REG_LPM_OFF);
usb/phy/phy-msm-usb.c:		msm_hsusb_config_vddcx(1);
usb/phy/phy-msm-usb.c:		msm_otg_disable_phy_hv_int(motg);
usb/phy/phy-msm-usb.c:		msm_otg_exit_phy_retention(motg);
usb/phy/phy-msm-usb.c:		msm_otg_disable_phy_hv_int(motg);
usb/phy/phy-msm-usb.c:		msm_otg_reset(phy);
usb/phy/phy-msm-usb.c:		msm_id_status_w(&motg->id_status_work.work);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(phy, "LPM EXIT DONE",
usb/phy/phy-msm-usb.c:static int get_psy_type(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static int msm_otg_notify_chg_type(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "SET USB PWR SUPPLY TYPE",
usb/phy/phy-msm-usb.c:static void msm_otg_notify_charger(struct msm_otg *motg, unsigned int mA)
usb/phy/phy-msm-usb.c:	if (msm_otg_notify_chg_type(motg))
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "AVAIL CURR FROM USB", mA, 0);
usb/phy/phy-msm-usb.c:static void msm_otg_notify_charger_work(struct work_struct *w)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(w,
usb/phy/phy-msm-usb.c:				struct msm_otg, notify_charger_work);
usb/phy/phy-msm-usb.c:	msm_otg_notify_charger(motg, motg->notify_current_mA);
usb/phy/phy-msm-usb.c:static int msm_otg_set_power(struct usb_phy *phy, unsigned int mA)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(phy, struct msm_otg, phy);
usb/phy/phy-msm-usb.c:static void msm_hsusb_vbus_power(struct msm_otg *motg, bool on);
usb/phy/phy-msm-usb.c:static void msm_otg_perf_vote_update(struct msm_otg *motg, bool perf_mode)
usb/phy/phy-msm-usb.c:		msm_otg_bus_vote(motg, USB_MAX_PERF_VOTE);
usb/phy/phy-msm-usb.c:		msm_otg_bus_vote(motg, USB_MIN_PERF_VOTE);
usb/phy/phy-msm-usb.c:static void msm_otg_perf_vote_work(struct work_struct *w)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(w, struct msm_otg,
usb/phy/phy-msm-usb.c:	msm_otg_perf_vote_update(motg, in_perf_mode);
usb/phy/phy-msm-usb.c:static void msm_otg_start_host(struct usb_otg *otg, int on)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(otg->usb_phy, struct msm_otg, phy);
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PM RT: StartHost GET",
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy, "HOST ON",
usb/phy/phy-msm-usb.c:		msm_hsusb_vbus_power(motg, 1);
usb/phy/phy-msm-usb.c:		msm_otg_reset(&motg->phy);
usb/phy/phy-msm-usb.c:		msm_otg_perf_vote_update(motg, true);
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy, "HOST OFF",
usb/phy/phy-msm-usb.c:		msm_hsusb_vbus_power(motg, 0);
usb/phy/phy-msm-usb.c:		msm_otg_perf_vote_update(motg, false);
usb/phy/phy-msm-usb.c:		msm_otg_reset(&motg->phy);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PM RT: StartHost PUT",
usb/phy/phy-msm-usb.c:static void msm_hsusb_vbus_power(struct msm_otg *motg, bool on)
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "VBUS POWER", on, vbus_is_on);
usb/phy/phy-msm-usb.c:static int msm_otg_set_host(struct usb_otg *otg, struct usb_bus *host)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(otg->usb_phy, struct msm_otg, phy);
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(&motg->phy,
usb/phy/phy-msm-usb.c:			msm_otg_start_host(otg, 0);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "HOST DRIVER REGISTERED",
usb/phy/phy-msm-usb.c:static void msm_otg_start_peripheral(struct usb_otg *otg, int on)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(otg->usb_phy, struct msm_otg, phy);
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PM RT: StartPeri GET",
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy, "GADGET ON",
usb/phy/phy-msm-usb.c:			msm_otg_bus_vote(motg, USB_MAX_PERF_VOTE);
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy, "GADGET OFF",
usb/phy/phy-msm-usb.c:		msm_otg_bus_vote(motg, USB_MIN_PERF_VOTE);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PM RT: StartPeri PUT",
usb/phy/phy-msm-usb.c:static int msm_otg_set_peripheral(struct usb_otg *otg,
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(otg->usb_phy, struct msm_otg, phy);
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(&motg->phy,
usb/phy/phy-msm-usb.c:			msm_otg_start_peripheral(otg, 0);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PERIPHERAL DRIVER REGISTERED",
usb/phy/phy-msm-usb.c:static bool msm_otg_read_pmic_id_state(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static bool msm_otg_read_phy_id_state(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static bool msm_chg_check_secondary_det(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static void msm_chg_enable_secondary_det(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static bool msm_chg_check_primary_det(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static void msm_chg_enable_primary_det(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static bool msm_chg_check_dcd(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static void msm_chg_disable_dcd(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static void msm_chg_enable_dcd(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:static void msm_chg_block_on(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PHY NON DRIVE", 0, 0);
usb/phy/phy-msm-usb.c:static void msm_chg_block_off(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PHY MODE NORMAL", 0, 0);
usb/phy/phy-msm-usb.c:static void msm_otg_set_mode_nondriving(struct msm_otg *motg,
usb/phy/phy-msm-usb.c:	msm_otg_exit_phy_retention(motg);
usb/phy/phy-msm-usb.c:		msm_chg_block_on(motg);
usb/phy/phy-msm-usb.c:		msm_chg_block_off(motg);
usb/phy/phy-msm-usb.c:	msm_otg_enter_phy_retention(motg);
usb/phy/phy-msm-usb.c:static void msm_chg_detect_work(struct work_struct *w)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(w, struct msm_otg, chg_work.work);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(phy, "CHG DETECTION WORK",
usb/phy/phy-msm-usb.c:		msm_chg_block_on(motg);
usb/phy/phy-msm-usb.c:			msm_chg_block_off(motg);
usb/phy/phy-msm-usb.c:		msm_chg_enable_dcd(motg);
usb/phy/phy-msm-usb.c:		is_dcd = msm_chg_check_dcd(motg);
usb/phy/phy-msm-usb.c:			msm_chg_disable_dcd(motg);
usb/phy/phy-msm-usb.c:			msm_chg_enable_primary_det(motg);
usb/phy/phy-msm-usb.c:		vout = msm_chg_check_primary_det(motg);
usb/phy/phy-msm-usb.c:				msm_chg_enable_secondary_det(motg);
usb/phy/phy-msm-usb.c:		vout = msm_chg_check_secondary_det(motg);
usb/phy/phy-msm-usb.c:		msm_chg_block_off(motg);
usb/phy/phy-msm-usb.c:			msm_otg_notify_charger(motg, dcp_max_current);
usb/phy/phy-msm-usb.c:			msm_otg_notify_charger(motg, dcp_max_current);
usb/phy/phy-msm-usb.c:			msm_otg_notify_charger(motg, IDEV_CHG_MAX);
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(phy, "CHG WORK PUT: CHG_TYPE",
usb/phy/phy-msm-usb.c:			msm_otg_notify_charger(motg, 0);
usb/phy/phy-msm-usb.c:			msm_chg_block_off(motg);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(phy, "CHG WORK: QUEUE", motg->chg_type, delay);
usb/phy/phy-msm-usb.c:static void msm_otg_init_sm(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:				if (msm_otg_read_pmic_id_state(motg))
usb/phy/phy-msm-usb.c:				if (msm_otg_read_phy_id_state(motg)) {
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "SM INIT", pdata->mode, motg->inputs);
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(w, struct msm_otg, sdp_check.work);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "Q RW SDP CHK", motg->vbus_state, 0);
usb/phy/phy-msm-usb.c:	msm_otg_set_vbus_state(motg->vbus_state);
usb/phy/phy-msm-usb.c:msm_otg_phy_drive_dp_pulse(struct msm_otg *motg, unsigned int pulse_width);
usb/phy/phy-msm-usb.c:static void msm_otg_sm_work(struct work_struct *w)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(w, struct msm_otg, sm_work);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(phy, "SM WORK:", otg->state, motg->inputs);
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(phy, "SM WORK: USB IS IN LPM",
usb/phy/phy-msm-usb.c:			msm_otg_resume(motg);
usb/phy/phy-msm-usb.c:		msm_otg_reset(otg->usb_phy);
usb/phy/phy-msm-usb.c:		msm_otg_init_sm(motg);
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(phy, "PM RUNTIME: UNDEF PUT",
usb/phy/phy-msm-usb.c:			msm_otg_phy_drive_dp_pulse(motg, DP_PULSE_WIDTH_MSEC);
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(phy, "!ID",
usb/phy/phy-msm-usb.c:				msm_otg_dbg_log_event(phy,
usb/phy/phy-msm-usb.c:			msm_otg_start_host(otg, 1);
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(phy, "B_SESS_VLD",
usb/phy/phy-msm-usb.c:				msm_otg_dbg_log_event(phy,
usb/phy/phy-msm-usb.c:			msm_otg_start_peripheral(otg, 1);
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(phy, "RT: Cable DISC",
usb/phy/phy-msm-usb.c:			msm_otg_notify_charger(motg, 0);
usb/phy/phy-msm-usb.c:			msm_otg_start_peripheral(otg, 0);
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(phy, "RT PM: B_PERI A PUT",
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(phy, "BUS_SUSPEND: PM RT PUT",
usb/phy/phy-msm-usb.c:			msm_otg_start_peripheral(otg, 0);
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(phy, "BUS_RESUME: PM RT GET",
usb/phy/phy-msm-usb.c:			msm_otg_start_host(otg, 0);
usb/phy/phy-msm-usb.c:static irqreturn_t msm_otg_irq(int irq, void *data)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = data;
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy, "OTG IRQ IS IN LPM",
usb/phy/phy-msm-usb.c:		msm_otg_kick_sm_work(motg);
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(&motg->phy, "ID SET",
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(&motg->phy, "ID CLEAR",
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(&motg->phy, "BSV SET",
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(&motg->phy, "BSV CLEAR",
usb/phy/phy-msm-usb.c:msm_otg_phy_drive_dp_pulse(struct msm_otg *motg, unsigned int pulse_width)
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "DRIVE DP PULSE",
usb/phy/phy-msm-usb.c:		ret = msm_hsusb_ldo_enable(motg, USB_PHY_REG_ON);
usb/phy/phy-msm-usb.c:		msm_hsusb_config_vddcx(1);
usb/phy/phy-msm-usb.c:	msm_otg_exit_phy_retention(motg);
usb/phy/phy-msm-usb.c:		msm_hsusb_config_vddcx(0);
usb/phy/phy-msm-usb.c:		msm_hsusb_ldo_enable(motg, USB_PHY_REG_OFF);
usb/phy/phy-msm-usb.c:		msm_otg_reset(&motg->phy);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "DP PULSE DRIVEN",
usb/phy/phy-msm-usb.c:static void msm_otg_set_vbus_state(int online)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = the_msm_otg;
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy, "EXTCON: BSV SET",
usb/phy/phy-msm-usb.c:			msm_otg_phy_drive_dp_pulse(motg, DP_PULSE_WIDTH_MSEC);
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy, "EXTCON: BSV CLEAR",
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "CHECK VBUS EVENT DURING SUSPEND",
usb/phy/phy-msm-usb.c:		msm_otg_kick_sm_work(motg);
usb/phy/phy-msm-usb.c:static void msm_id_status_w(struct work_struct *w)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(w, struct msm_otg,
usb/phy/phy-msm-usb.c:		motg->id_state = msm_otg_read_pmic_id_state(motg);
usb/phy/phy-msm-usb.c:		motg->id_state = msm_otg_read_phy_id_state(motg);
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(&motg->phy, "ID SET",
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(&motg->phy, "ID CLEAR",
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy,
usb/phy/phy-msm-usb.c:		msm_otg_kick_sm_work(motg);
usb/phy/phy-msm-usb.c:static irqreturn_t msm_id_irq(int irq, void *data)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = data;
usb/phy/phy-msm-usb.c:int msm_otg_pm_notify(struct notifier_block *notify_block,
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(
usb/phy/phy-msm-usb.c:		notify_block, struct msm_otg, pm_notify);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PM NOTIFY",
usb/phy/phy-msm-usb.c:static int msm_otg_mode_show(struct seq_file *s, void *unused)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = s->private;
usb/phy/phy-msm-usb.c:static int msm_otg_mode_open(struct inode *inode, struct file *file)
usb/phy/phy-msm-usb.c:	return single_open(file, msm_otg_mode_show, inode->i_private);
usb/phy/phy-msm-usb.c:static ssize_t msm_otg_mode_write(struct file *file, const char __user *ubuf,
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = s->private;
usb/phy/phy-msm-usb.c:const struct file_operations msm_otg_mode_fops = {
usb/phy/phy-msm-usb.c:	.open = msm_otg_mode_open,
usb/phy/phy-msm-usb.c:	.write = msm_otg_mode_write,
usb/phy/phy-msm-usb.c:static int msm_otg_show_otg_state(struct seq_file *s, void *unused)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = s->private;
usb/phy/phy-msm-usb.c:static int msm_otg_otg_state_open(struct inode *inode, struct file *file)
usb/phy/phy-msm-usb.c:	return single_open(file, msm_otg_show_otg_state, inode->i_private);
usb/phy/phy-msm-usb.c:const struct file_operations msm_otg_state_fops = {
usb/phy/phy-msm-usb.c:	.open = msm_otg_otg_state_open,
usb/phy/phy-msm-usb.c:static int msm_otg_bus_show(struct seq_file *s, void *unused)
usb/phy/phy-msm-usb.c:static int msm_otg_bus_open(struct inode *inode, struct file *file)
usb/phy/phy-msm-usb.c:	return single_open(file, msm_otg_bus_show, inode->i_private);
usb/phy/phy-msm-usb.c:static ssize_t msm_otg_bus_write(struct file *file, const char __user *ubuf,
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = s->private;
usb/phy/phy-msm-usb.c:		msm_otg_bus_vote(motg, USB_MIN_PERF_VOTE);
usb/phy/phy-msm-usb.c:static int msm_otg_dbg_buff_show(struct seq_file *s, void *unused)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = s->private;
usb/phy/phy-msm-usb.c:static int msm_otg_dbg_buff_open(struct inode *inode, struct file *file)
usb/phy/phy-msm-usb.c:	return single_open(file, msm_otg_dbg_buff_show, inode->i_private);
usb/phy/phy-msm-usb.c:const struct file_operations msm_otg_dbg_buff_fops = {
usb/phy/phy-msm-usb.c:	.open = msm_otg_dbg_buff_open,
usb/phy/phy-msm-usb.c:static int msm_otg_dpdm_regulator_enable(struct regulator_dev *rdev)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = rdev_get_drvdata(rdev);
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy, "Disable Pulldown",
usb/phy/phy-msm-usb.c:		ret = msm_hsusb_ldo_enable(motg, USB_PHY_REG_3P3_ON);
usb/phy/phy-msm-usb.c:			msm_otg_set_mode_nondriving(motg, true);
usb/phy/phy-msm-usb.c:			msm_otg_dbg_log_event(&motg->phy, "NonDrv err",
usb/phy/phy-msm-usb.c:static int msm_otg_dpdm_regulator_disable(struct regulator_dev *rdev)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = rdev_get_drvdata(rdev);
usb/phy/phy-msm-usb.c:			msm_otg_set_mode_nondriving(motg, false);
usb/phy/phy-msm-usb.c:		ret = msm_hsusb_ldo_enable(motg, USB_PHY_REG_3P3_OFF);
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy, "EN Pulldown",
usb/phy/phy-msm-usb.c:static int msm_otg_dpdm_regulator_is_enabled(struct regulator_dev *rdev)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = rdev_get_drvdata(rdev);
usb/phy/phy-msm-usb.c:static struct regulator_ops msm_otg_dpdm_regulator_ops = {
usb/phy/phy-msm-usb.c:	.enable		= msm_otg_dpdm_regulator_enable,
usb/phy/phy-msm-usb.c:	.disable	= msm_otg_dpdm_regulator_disable,
usb/phy/phy-msm-usb.c:	.is_enabled	= msm_otg_dpdm_regulator_is_enabled,
usb/phy/phy-msm-usb.c:static int usb_phy_regulator_init(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	motg->dpdm_rdesc.ops = &msm_otg_dpdm_regulator_ops;
usb/phy/phy-msm-usb.c:const struct file_operations msm_otg_bus_fops = {
usb/phy/phy-msm-usb.c:	.open = msm_otg_bus_open,
usb/phy/phy-msm-usb.c:	.write = msm_otg_bus_write,
usb/phy/phy-msm-usb.c:static struct dentry *msm_otg_dbg_root;
usb/phy/phy-msm-usb.c:static int msm_otg_debugfs_init(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	struct dentry *msm_otg_dentry;
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:	msm_otg_dbg_root = debugfs_create_dir("msm_otg", NULL);
usb/phy/phy-msm-usb.c:	if (!msm_otg_dbg_root || IS_ERR(msm_otg_dbg_root))
usb/phy/phy-msm-usb.c:		msm_otg_dentry = debugfs_create_file("mode", 0644,
usb/phy/phy-msm-usb.c:			msm_otg_dbg_root, motg, &msm_otg_mode_fops);
usb/phy/phy-msm-usb.c:		if (!msm_otg_dentry) {
usb/phy/phy-msm-usb.c:			debugfs_remove(msm_otg_dbg_root);
usb/phy/phy-msm-usb.c:			msm_otg_dbg_root = NULL;
usb/phy/phy-msm-usb.c:	msm_otg_dentry = debugfs_create_file("bus_voting", 0644,
usb/phy/phy-msm-usb.c:			msm_otg_dbg_root, motg, &msm_otg_bus_fops);
usb/phy/phy-msm-usb.c:	if (!msm_otg_dentry) {
usb/phy/phy-msm-usb.c:		debugfs_remove_recursive(msm_otg_dbg_root);
usb/phy/phy-msm-usb.c:	msm_otg_dentry = debugfs_create_file("otg_state", 0444,
usb/phy/phy-msm-usb.c:			msm_otg_dbg_root, motg, &msm_otg_state_fops);
usb/phy/phy-msm-usb.c:	if (!msm_otg_dentry) {
usb/phy/phy-msm-usb.c:		debugfs_remove_recursive(msm_otg_dbg_root);
usb/phy/phy-msm-usb.c:	msm_otg_dentry = debugfs_create_file("dbg_buff", 0444,
usb/phy/phy-msm-usb.c:			msm_otg_dbg_root, motg, &msm_otg_dbg_buff_fops);
usb/phy/phy-msm-usb.c:	if (!msm_otg_dentry) {
usb/phy/phy-msm-usb.c:		debugfs_remove_recursive(msm_otg_dbg_root);
usb/phy/phy-msm-usb.c:static void msm_otg_debugfs_cleanup(void)
usb/phy/phy-msm-usb.c:	debugfs_remove_recursive(msm_otg_dbg_root);
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = the_msm_otg;
usb/phy/phy-msm-usb.c:		msm_otg_bus_freq_set(motg, USB_NOC_NOM_VOTE);
usb/phy/phy-msm-usb.c:		msm_otg_bus_freq_set(motg, USB_NOC_SVS_VOTE);
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy, "OTG PERF SET",
usb/phy/phy-msm-usb.c:struct msm_otg_scm_cmd_buf {
usb/phy/phy-msm-usb.c:static void msm_otg_pnoc_errata_fix(struct msm_otg *motg)
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:static u64 msm_otg_dma_mask = DMA_BIT_MASK(32);
usb/phy/phy-msm-usb.c:static struct platform_device *msm_otg_add_pdev(
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *otg_pdata;
usb/phy/phy-msm-usb.c:	struct msm_otg *motg;
usb/phy/phy-msm-usb.c:	pdev->dev.dma_mask = &msm_otg_dma_mask;
usb/phy/phy-msm-usb.c:	if (!strcmp(name, "msm_hsusb")) {
usb/phy/phy-msm-usb.c:			(struct msm_otg_platform_data *)
usb/phy/phy-msm-usb.c:static int msm_otg_setup_devices(struct platform_device *ofdev,
usb/phy/phy-msm-usb.c:	const char *gadget_name = "msm_hsusb";
usb/phy/phy-msm-usb.c:	const char *host_name = "msm_hsusb_host";
usb/phy/phy-msm-usb.c:		gadget_pdev = msm_otg_add_pdev(ofdev, gadget_name);
usb/phy/phy-msm-usb.c:		host_pdev = msm_otg_add_pdev(ofdev, host_name);
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = the_msm_otg;
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = the_msm_otg;
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata = motg->pdata;
usb/phy/phy-msm-usb.c:static int msm_otg_vbus_notifier(struct notifier_block *nb, unsigned long event,
usb/phy/phy-msm-usb.c:	msm_otg_set_vbus_state(!!event);
usb/phy/phy-msm-usb.c:static int msm_otg_id_notifier(struct notifier_block *nb, unsigned long event,
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = container_of(phy, struct msm_otg, phy);
usb/phy/phy-msm-usb.c:	msm_id_status_w(&motg->id_status_work.work);
usb/phy/phy-msm-usb.c:struct msm_otg_platform_data *msm_otg_dt_to_pdata(struct platform_device *pdev)
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata;
usb/phy/phy-msm-usb.c:static int msm_otg_probe(struct platform_device *pdev)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg;
usb/phy/phy-msm-usb.c:	struct msm_otg_platform_data *pdata;
usb/phy/phy-msm-usb.c:	dev_info(&pdev->dev, "msm_otg probe\n");
usb/phy/phy-msm-usb.c:	motg = kzalloc(sizeof(struct msm_otg), GFP_KERNEL);
usb/phy/phy-msm-usb.c:	pdata = msm_otg_dt_to_pdata(pdev);
usb/phy/phy-msm-usb.c:	pdata->bus_scale_table = msm_bus_cl_get_pdata(pdev);
usb/phy/phy-msm-usb.c:	the_msm_otg = motg;
usb/phy/phy-msm-usb.c:		    msm_bus_scale_register_client(motg->pdata->bus_scale_table);
usb/phy/phy-msm-usb.c:			msm_otg_bus_vote(motg, USB_MIN_PERF_VOTE);
usb/phy/phy-msm-usb.c:	ret = msm_otg_bus_freq_get(motg);
usb/phy/phy-msm-usb.c:		ret = msm_otg_bus_freq_set(motg, motg->default_noc_mode);
usb/phy/phy-msm-usb.c:	ret = msm_hsusb_config_vddcx(1);
usb/phy/phy-msm-usb.c:	ret = msm_hsusb_ldo_init(motg, 1);
usb/phy/phy-msm-usb.c:	ret = msm_hsusb_ldo_enable(motg, USB_PHY_REG_ON);
usb/phy/phy-msm-usb.c:	msm_otg_pnoc_errata_fix(motg);
usb/phy/phy-msm-usb.c:	INIT_WORK(&motg->sm_work, msm_otg_sm_work);
usb/phy/phy-msm-usb.c:	INIT_DELAYED_WORK(&motg->chg_work, msm_chg_detect_work);
usb/phy/phy-msm-usb.c:	INIT_DELAYED_WORK(&motg->id_status_work, msm_id_status_w);
usb/phy/phy-msm-usb.c:	INIT_DELAYED_WORK(&motg->perf_vote_work, msm_otg_perf_vote_work);
usb/phy/phy-msm-usb.c:	INIT_WORK(&motg->notify_charger_work, msm_otg_notify_charger_work);
usb/phy/phy-msm-usb.c:	ret = devm_request_irq(&pdev->dev, motg->irq, msm_otg_irq, IRQF_SHARED,
usb/phy/phy-msm-usb.c:					"msm_otg", motg);
usb/phy/phy-msm-usb.c:			msm_otg_phy_irq_handler, IRQF_TRIGGER_RISING,
usb/phy/phy-msm-usb.c:			"msm_otg_phy_irq", motg);
usb/phy/phy-msm-usb.c:	ret = devm_request_irq(&pdev->dev, motg->async_irq, msm_otg_irq,
usb/phy/phy-msm-usb.c:				IRQF_TRIGGER_RISING, "msm_otg", motg);
usb/phy/phy-msm-usb.c:	phy->init = msm_otg_reset;
usb/phy/phy-msm-usb.c:	phy->set_power = msm_otg_set_power;
usb/phy/phy-msm-usb.c:	phy->set_suspend = msm_otg_set_suspend;
usb/phy/phy-msm-usb.c:	phy->dbg_event = msm_otg_dbg_log_event;
usb/phy/phy-msm-usb.c:	phy->io_ops = &msm_otg_io_ops;
usb/phy/phy-msm-usb.c:	phy->otg->set_host = msm_otg_set_host;
usb/phy/phy-msm-usb.c:	phy->otg->set_peripheral = msm_otg_set_peripheral;
usb/phy/phy-msm-usb.c:	phy->vbus_nb.notifier_call = msm_otg_vbus_notifier;
usb/phy/phy-msm-usb.c:	phy->id_nb.notifier_call = msm_otg_id_notifier;
usb/phy/phy-msm-usb.c:					  msm_id_irq,
usb/phy/phy-msm-usb.c:					  "msm_otg", motg);
usb/phy/phy-msm-usb.c:	ret = msm_otg_debugfs_init(motg);
usb/phy/phy-msm-usb.c:		ret = msm_otg_setup_devices(pdev, pdata->mode, true);
usb/phy/phy-msm-usb.c:			msm_otg_id_notifier(&motg->phy.id_nb,
usb/phy/phy-msm-usb.c:			msm_otg_vbus_notifier(&motg->phy.vbus_nb,
usb/phy/phy-msm-usb.c:	motg->pm_notify.notifier_call = msm_otg_pm_notify;
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(phy, "OTG PROBE", motg->caps, motg->lpm_flags);
usb/phy/phy-msm-usb.c:	msm_otg_debugfs_cleanup();
usb/phy/phy-msm-usb.c:	msm_hsusb_ldo_enable(motg, USB_PHY_REG_OFF);
usb/phy/phy-msm-usb.c:	msm_hsusb_ldo_init(motg, 0);
usb/phy/phy-msm-usb.c:		msm_otg_bus_vote(motg, USB_NO_PERF_VOTE);
usb/phy/phy-msm-usb.c:		msm_bus_scale_unregister_client(motg->bus_perf_client);
usb/phy/phy-msm-usb.c:static int msm_otg_remove(struct platform_device *pdev)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = platform_get_drvdata(pdev);
usb/phy/phy-msm-usb.c:		msm_otg_setup_devices(pdev, motg->pdata->mode, false);
usb/phy/phy-msm-usb.c:	msm_otg_debugfs_cleanup();
usb/phy/phy-msm-usb.c:	msm_otg_perf_vote_update(motg, false);
usb/phy/phy-msm-usb.c:	msm_hsusb_ldo_enable(motg, USB_PHY_REG_OFF);
usb/phy/phy-msm-usb.c:	msm_hsusb_ldo_init(motg, 0);
usb/phy/phy-msm-usb.c:		msm_otg_bus_vote(motg, USB_NO_PERF_VOTE);
usb/phy/phy-msm-usb.c:		msm_bus_scale_unregister_client(motg->bus_perf_client);
usb/phy/phy-msm-usb.c:static void msm_otg_shutdown(struct platform_device *pdev)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = platform_get_drvdata(pdev);
usb/phy/phy-msm-usb.c:	msm_hsusb_vbus_power(motg, 0);
usb/phy/phy-msm-usb.c:static int msm_otg_runtime_idle(struct device *dev)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = dev_get_drvdata(dev);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(phy, "RUNTIME IDLE", phy->otg->state, 0);
usb/phy/phy-msm-usb.c:static int msm_otg_runtime_suspend(struct device *dev)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = dev_get_drvdata(dev);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "RUNTIME SUSPEND",
usb/phy/phy-msm-usb.c:	return msm_otg_suspend(motg);
usb/phy/phy-msm-usb.c:static int msm_otg_runtime_resume(struct device *dev)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = dev_get_drvdata(dev);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "RUNTIME RESUME",
usb/phy/phy-msm-usb.c:	return msm_otg_resume(motg);
usb/phy/phy-msm-usb.c:static int msm_otg_pm_suspend(struct device *dev)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = dev_get_drvdata(dev);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PM SUSPEND START",
usb/phy/phy-msm-usb.c:static int msm_otg_pm_resume(struct device *dev)
usb/phy/phy-msm-usb.c:	struct msm_otg *motg = dev_get_drvdata(dev);
usb/phy/phy-msm-usb.c:	msm_otg_dbg_log_event(&motg->phy, "PM RESUME START",
usb/phy/phy-msm-usb.c:		msm_otg_dbg_log_event(&motg->phy, "PM RESUME BY USB",
usb/phy/phy-msm-usb.c:static const struct dev_pm_ops msm_otg_dev_pm_ops = {
usb/phy/phy-msm-usb.c:	SET_SYSTEM_SLEEP_PM_OPS(msm_otg_pm_suspend, msm_otg_pm_resume)
usb/phy/phy-msm-usb.c:	SET_RUNTIME_PM_OPS(msm_otg_runtime_suspend, msm_otg_runtime_resume,
usb/phy/phy-msm-usb.c:				msm_otg_runtime_idle)
usb/phy/phy-msm-usb.c:static const struct of_device_id msm_otg_dt_match[] = {
usb/phy/phy-msm-usb.c:static struct platform_driver msm_otg_driver = {
usb/phy/phy-msm-usb.c:	.probe = msm_otg_probe,
usb/phy/phy-msm-usb.c:	.remove = msm_otg_remove,
usb/phy/phy-msm-usb.c:	.shutdown = msm_otg_shutdown,
usb/phy/phy-msm-usb.c:		.pm = &msm_otg_dev_pm_ops,
usb/phy/phy-msm-usb.c:		.of_match_table = msm_otg_dt_match,
usb/phy/phy-msm-usb.c:module_platform_driver(msm_otg_driver);
video/fbdev/Kconfig:source "drivers/video/fbdev/msm/Kconfig"
video/fbdev/Makefile:obj-y                             += msm/
video/fbdev/Makefile:obj-$(CONFIG_MSM_DBA)             += msm/msm_dba/
video/fbdev/msm/Kconfig:source "drivers/video/fbdev/msm/msm_dba/Kconfig"
video/fbdev/msm/Kconfig:	Say Y here if this is msm7201 variant platform.
video/fbdev/msm/Makefile:obj-$(CONFIG_MSM_DBA) += msm_dba/
video/fbdev/msm/Makefile:mdss-dsi-objs += msm_mdss_io_8974.o
video/fbdev/msm/mdss.h:#include <linux/msm_ion.h>
video/fbdev/msm/mdss.h:#include <linux/msm_mdp.h>
video/fbdev/msm/mdss.h:#include <linux/msm-bus.h>
video/fbdev/msm/mdss.h:	struct msm_bus_scale_pdata *bus_scale_table;
video/fbdev/msm/mdss.h:	struct msm_bus_scale_pdata *reg_bus_scale_table;
video/fbdev/msm/mdss.h:	struct msm_bus_scale_pdata *hw_rt_bus_scale_table;
video/fbdev/msm/mdss_cec_core.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_compat_utils.c:					struct msmfb_overlay_blt32)
video/fbdev/msm/mdss_compat_utils.c:					struct msmfb_overlay_3d32)
video/fbdev/msm/mdss_compat_utils.c:						struct msmfb_mixer_info_req32)
video/fbdev/msm/mdss_compat_utils.c:#define MSMFB_MDP_PP32 _IOWR(MSMFB_IOCTL_MAGIC, 156, struct msmfb_mdp_pp32)
video/fbdev/msm/mdss_compat_utils.c:static int __pp_compat_alloc(struct msmfb_mdp_pp32 __user *pp32,
video/fbdev/msm/mdss_compat_utils.c:					struct msmfb_mdp_pp __user **pp,
video/fbdev/msm/mdss_compat_utils.c:	alloc_size = sizeof(struct msmfb_mdp_pp);
video/fbdev/msm/mdss_compat_utils.c:				sizeof(struct msmfb_mdp_pp)),
video/fbdev/msm/mdss_compat_utils.c:					sizeof(struct msmfb_mdp_pp) +
video/fbdev/msm/mdss_compat_utils.c:					sizeof(struct msmfb_mdp_pp) +
video/fbdev/msm/mdss_compat_utils.c:					sizeof(struct msmfb_mdp_pp) +
video/fbdev/msm/mdss_compat_utils.c:					sizeof(struct msmfb_mdp_pp)),
video/fbdev/msm/mdss_compat_utils.c:					sizeof(struct msmfb_mdp_pp)),
video/fbdev/msm/mdss_compat_utils.c:				sizeof(struct msmfb_mdp_pp)),
video/fbdev/msm/mdss_compat_utils.c:				sizeof(struct msmfb_mdp_pp)),
video/fbdev/msm/mdss_compat_utils.c:				sizeof(struct msmfb_mdp_pp)),
video/fbdev/msm/mdss_compat_utils.c:	struct msmfb_mdp_pp32 __user *pp32;
video/fbdev/msm/mdss_compat_utils.c:	struct msmfb_mdp_pp __user *pp;
video/fbdev/msm/mdss_compat_utils.h:struct msmfb_overlay_blt32 {
video/fbdev/msm/mdss_compat_utils.h:struct msmfb_overlay_3d32 {
video/fbdev/msm/mdss_compat_utils.h:struct msmfb_mixer_info_req32 {
video/fbdev/msm/mdss_compat_utils.h:struct msmfb_metadata32 {
video/fbdev/msm/mdss_compat_utils.h:struct msmfb_mdp_pp32 {
video/fbdev/msm/mdss_compat_utils.h:	struct msmfb_img src;
video/fbdev/msm/mdss_dba_utils.c:#include <video/msm_dba.h>
video/fbdev/msm/mdss_dba_utils.c:	struct msm_dba_ops ops;
video/fbdev/msm/mdss_dba_utils.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_dba_utils.c:	mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_dba_utils.c:	struct msm_ext_disp_audio_edid_blk audio_blk;
video/fbdev/msm/mdss_dba_utils.c:static void mdss_dba_utils_dba_cb(void *data, enum msm_dba_callback_event event)
video/fbdev/msm/mdss_dba_utils.c:	struct msm_ext_disp_audio_edid_blk blk;
video/fbdev/msm/mdss_dba_utils.c:	struct msm_hdmi_mode_timing_info timing;
video/fbdev/msm/mdss_dba_utils.c:	struct msm_dba_video_cfg video_cfg;
video/fbdev/msm/mdss_dba_utils.c:	struct msm_dba_reg_info info;
video/fbdev/msm/mdss_dba_utils.c:		udata->dba_data = msm_dba_register_client(&info, &udata->ops);
video/fbdev/msm/mdss_dba_utils.c:			msm_dba_deregister_client(udata->dba_data);
video/fbdev/msm/mdss_debug.c:				struct msm_fb_data_type *mfd = NULL;
video/fbdev/msm/mdss_debug.c:			 * For msm8916/8939, additional offset of 0x10
video/fbdev/msm/mdss_dp.c:#include <linux/msm_ext_display.h>
video/fbdev/msm/mdss_dp.c:		rc = msm_dss_get_clk(dev, core_power_data->clk_config,
video/fbdev/msm/mdss_dp.c:		rc = msm_dss_get_clk(dev, ctrl_power_data->clk_config,
video/fbdev/msm/mdss_dp.c:		msm_dss_put_clk(ctrl_power_data->clk_config,
video/fbdev/msm/mdss_dp.c:		msm_dss_put_clk(core_power_data->clk_config,
video/fbdev/msm/mdss_dp.c:	msm_dss_put_clk(core_power_data->clk_config,
video/fbdev/msm/mdss_dp.c:		ret = msm_dss_clk_set_rate(
video/fbdev/msm/mdss_dp.c:		ret = msm_dss_enable_clk(
video/fbdev/msm/mdss_dp.c:		ret = msm_dss_enable_clk(
video/fbdev/msm/mdss_dp.c:		ret = msm_dss_enable_vreg(
video/fbdev/msm/mdss_dp.c:					msm_dss_enable_vreg(
video/fbdev/msm/mdss_dp.c:		rc = msm_dss_config_vreg(&pdev->dev,
video/fbdev/msm/mdss_dp.c:				msm_dss_config_vreg(&pdev->dev,
video/fbdev/msm/mdss_dp.c:	struct msm_ext_disp_audio_setup_params *params)
video/fbdev/msm/mdss_dp.c:	struct msm_ext_disp_audio_edid_blk *blk)
video/fbdev/msm/mdss_dp.c:	struct msm_ext_disp_init_data *ext;
video/fbdev/msm/mdss_dp.c:	struct msm_ext_disp_audio_codec_ops *ops;
video/fbdev/msm/mdss_dp.c:	const char *phandle = "qcom,msm_ext_disp";
video/fbdev/msm/mdss_dp.c:	ret = msm_ext_disp_register_intf(dp->ext_pdev, ext);
video/fbdev/msm/mdss_dp.c:	struct msm_hdmi_mode_timing_info timing = {0};
video/fbdev/msm/mdss_dp.c:	struct msm_ext_disp_data *ext_data;
video/fbdev/msm/mdss_dp.c:	struct msm_ext_disp_init_data *ext;
video/fbdev/msm/mdss_dp.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_dp.c:		mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_dp.c:	rc = msm_dss_ioremap_byname(pdev, &dp_drv->ctrl_io, "dp_ctrl");
video/fbdev/msm/mdss_dp.c:	rc = msm_dss_ioremap_byname(pdev, &dp_drv->phy_io, "dp_phy");
video/fbdev/msm/mdss_dp.c:	rc = msm_dss_ioremap_byname(pdev, &dp_drv->tcsr_reg_io,
video/fbdev/msm/mdss_dp.c:	if (msm_dss_ioremap_byname(pdev, &dp_drv->dp_cc_io, "dp_mmss_cc")) {
video/fbdev/msm/mdss_dp.c:	if (msm_dss_ioremap_byname(pdev, &dp_drv->qfprom_io,
video/fbdev/msm/mdss_dp.c:	if (msm_dss_ioremap_byname(pdev, &dp_drv->hdcp_io,
video/fbdev/msm/mdss_dp.c:	struct msm_ext_disp_init_data *ext = &dp->ext_audio_data;
video/fbdev/msm/mdss_dp.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_dp.c:	mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_dp.c:static const struct of_device_id msm_mdss_dp_dt_match[] = {
video/fbdev/msm/mdss_dp.c:MODULE_DEVICE_TABLE(of, msm_mdss_dp_dt_match);
video/fbdev/msm/mdss_dp.c:		.of_match_table = msm_mdss_dp_dt_match,
video/fbdev/msm/mdss_dp.h:#include "video/msm_hdmi_modes.h"
video/fbdev/msm/mdss_dp.h:	struct msm_ext_disp_init_data ext_audio_data;
video/fbdev/msm/mdss_dsi_host.c:#include <linux/msm-bus.h>
video/fbdev/msm/mdss_dsi_host.c:		rc = msm_bus_scale_client_update_request(sdata->bus_handle,
video/fbdev/msm/mdss_dsi_host.c:			 * For targets other than msm8994,
video/fbdev/msm/mdss_dsi_status.c:	struct msm_fb_data_type *mfd = arg;
video/fbdev/msm/mdss_dsi_status.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_fb.c:#include <linux/msm_mdp.h>
video/fbdev/msm/mdss_fb.c:static struct msm_mdp_interface *mdp_instance;
video/fbdev/msm/mdss_fb.c:static int mdss_fb_register(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.c:static int mdss_fb_suspend_sub(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.c:static int mdss_fb_alloc_fb_ion_memory(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:static void mdss_fb_release_fences(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.c:static int mdss_fb_pan_idle(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.c:static int mdss_fb_send_panel_event(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:static void mdss_fb_set_mdp_sync_pt_threshold(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:void mdss_fb_bl_update_notify(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:static int mdss_fb_notify_update(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = dev_get_drvdata(led_cdev->dev->parent);
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = dev_get_drvdata(led_cdev->dev->parent);
video/fbdev/msm/mdss_fb.c:static ssize_t msm_fb_type_show(struct device *dev,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_fb.c:			struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static ssize_t msm_fb_split_store(struct device *dev,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_fb.c:static ssize_t msm_fb_split_show(struct device *dev,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_fb.c:static void mdss_fb_get_split(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static ssize_t msm_fb_src_split_info_show(struct device *dev,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_fb.c:static ssize_t msm_fb_thermal_level_show(struct device *dev,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_fb.c:static ssize_t msm_fb_thermal_level_store(struct device *dev,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_fb.c:	sysfs_notify(&mfd->fbi->dev->kobj, NULL, "msm_fb_thermal_level");
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = container_of(dw, struct msm_fb_data_type,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_fb.c:static ssize_t msm_fb_panel_info_show(struct device *dev,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_fb.c:static ssize_t msm_fb_panel_status_show(struct device *dev,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_fb.c:static ssize_t msm_fb_panel_status_store(struct device *dev,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_fb.c:static int mdss_fb_blanking_mode_switch(struct msm_fb_data_type *mfd, int mode)
video/fbdev/msm/mdss_fb.c:static ssize_t msm_fb_dfps_mode_store(struct device *dev,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_fb.c:static ssize_t msm_fb_dfps_mode_show(struct device *dev,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_fb.c:static ssize_t msm_fb_persist_mode_store(struct device *dev,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_fb.c:static ssize_t msm_fb_persist_mode_show(struct device *dev,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_fb.c:static DEVICE_ATTR_RO(msm_fb_type);
video/fbdev/msm/mdss_fb.c:static DEVICE_ATTR_RW(msm_fb_split);
video/fbdev/msm/mdss_fb.c:static DEVICE_ATTR_RO(msm_fb_panel_info);
video/fbdev/msm/mdss_fb.c:static DEVICE_ATTR_RO(msm_fb_src_split_info);
video/fbdev/msm/mdss_fb.c:static DEVICE_ATTR_RW(msm_fb_thermal_level);
video/fbdev/msm/mdss_fb.c:static DEVICE_ATTR_RW(msm_fb_panel_status);
video/fbdev/msm/mdss_fb.c:static DEVICE_ATTR_RW(msm_fb_dfps_mode);
video/fbdev/msm/mdss_fb.c:static DEVICE_ATTR_RW(msm_fb_persist_mode);
video/fbdev/msm/mdss_fb.c:	&dev_attr_msm_fb_type.attr,
video/fbdev/msm/mdss_fb.c:	&dev_attr_msm_fb_split.attr,
video/fbdev/msm/mdss_fb.c:	&dev_attr_msm_fb_panel_info.attr,
video/fbdev/msm/mdss_fb.c:	&dev_attr_msm_fb_src_split_info.attr,
video/fbdev/msm/mdss_fb.c:	&dev_attr_msm_fb_thermal_level.attr,
video/fbdev/msm/mdss_fb.c:	&dev_attr_msm_fb_panel_status.attr,
video/fbdev/msm/mdss_fb.c:	&dev_attr_msm_fb_dfps_mode.attr,
video/fbdev/msm/mdss_fb.c:	&dev_attr_msm_fb_persist_mode.attr,
video/fbdev/msm/mdss_fb.c:static int mdss_fb_create_sysfs(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static void mdss_fb_remove_sysfs(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = platform_get_drvdata(pdev);
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = handle->handler->private;
video/fbdev/msm/mdss_fb.c:static int mdss_fb_register_input_handler(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static void mdss_fb_unregister_input_handler(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static void mdss_fb_set_split_mode(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:static int mdss_fb_init_panel_modes(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = NULL;
video/fbdev/msm/mdss_fb.c:	fbi = framebuffer_alloc(sizeof(struct msm_fb_data_type), NULL);
video/fbdev/msm/mdss_fb.c:	mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_fb.c:static void mdss_fb_set_mdp_sync_pt_threshold(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_fb.c:	mfd = (struct msm_fb_data_type *)platform_get_drvdata(pdev);
video/fbdev/msm/mdss_fb.c:		pr_err("msm_fb_remove: can't stop the device %d\n",
video/fbdev/msm/mdss_fb.c:static int mdss_fb_send_panel_event(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:static int mdss_fb_suspend_sub(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static int mdss_fb_resume_sub(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = platform_get_drvdata(pdev);
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = platform_get_drvdata(pdev);
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = dev_get_drvdata(dev);
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = dev_get_drvdata(dev);
video/fbdev/msm/mdss_fb.c:static void mdss_fb_scale_bl(struct msm_fb_data_type *mfd, u32 *bl_lvl)
video/fbdev/msm/mdss_fb.c:void mdss_fb_set_backlight(struct msm_fb_data_type *mfd, u32 bkl_lvl)
video/fbdev/msm/mdss_fb.c:void mdss_fb_update_backlight(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static int mdss_fb_start_disp_thread(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static void mdss_fb_stop_disp_thread(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static void mdss_panel_validate_debugfs_info(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static int mdss_fb_blank_blank(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:static int mdss_fb_blank_unblank(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:void mdss_fb_free_fb_ion_memory(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:int mdss_fb_alloc_fb_ion_memory(struct msm_fb_data_type *mfd, size_t fb_size)
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:static int mdss_fb_alloc_fbmem_iommu(struct msm_fb_data_type *mfd, int dom)
video/fbdev/msm/mdss_fb.c:static int mdss_fb_alloc_fbmem(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static int mdss_fb_register(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:		pr_err("msm_fb_init: fb %d unknown image type!\n",
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:static void mdss_fb_power_setting_idle(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static void __mdss_fb_copy_fence(struct msm_sync_pt_data *sync_pt_data,
video/fbdev/msm/mdss_fb.c:static int __mdss_fb_wait_for_fence_sub(struct msm_sync_pt_data *sync_pt_data,
video/fbdev/msm/mdss_fb.c:int mdss_fb_wait_for_fence(struct msm_sync_pt_data *sync_pt_data)
video/fbdev/msm/mdss_fb.c:void mdss_fb_signal_timeline(struct msm_sync_pt_data *sync_pt_data)
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_fb.c:static void mdss_fb_release_fences(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:	struct msm_sync_pt_data *sync_pt_data = &mfd->mdp_sync_pt_data;
video/fbdev/msm/mdss_fb.c:static void mdss_fb_release_kickoff(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:	struct msm_sync_pt_data *sync_pt_data;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_fb.c:	sync_pt_data = container_of(p, struct msm_sync_pt_data, notifier);
video/fbdev/msm/mdss_fb.c:	mfd = container_of(sync_pt_data, struct msm_fb_data_type,
video/fbdev/msm/mdss_fb.c:static int mdss_fb_pan_idle(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static int mdss_fb_wait_for_kickoff(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:	mfd->msm_fb_backup.info = *info;
video/fbdev/msm/mdss_fb.c:	mfd->msm_fb_backup.disp_commit = *disp_commit;
video/fbdev/msm/mdss_fb.c:u32 mdss_fb_get_mode_switch(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:static int __ioctl_transition_dyn_mode_state(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:static inline bool mdss_fb_is_wb_config_same(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:	struct msm_mdp_interface *mdp5_interface = &mfd->mdp;
video/fbdev/msm/mdss_fb.c:static void mdss_fb_update_resolution(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:	mfd->msm_fb_backup.atomic_commit = true;
video/fbdev/msm/mdss_fb.c:	mfd->msm_fb_backup.disp_commit.l_roi =  commit_v1->left_roi;
video/fbdev/msm/mdss_fb.c:	mfd->msm_fb_backup.disp_commit.r_roi =  commit_v1->right_roi;
video/fbdev/msm/mdss_fb.c:	mfd->msm_fb_backup.disp_commit.flags =  commit_v1->flags;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:static int __mdss_fb_perform_commit(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:	struct msm_sync_pt_data *sync_pt_data = &mfd->mdp_sync_pt_data;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_backup_type *fb_backup = &mfd->msm_fb_backup;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = data;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:static int mdss_fb_videomode_switch(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:int mdss_fb_dcm(struct msm_fb_data_type *mfd, int req_state)
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:static int mdss_fb_handle_buf_sync_ioctl(struct msm_sync_pt_data *sync_pt_data,
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_fb.c:	mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:int mdss_fb_switch_check(struct msm_fb_data_type *mfd, u32 mode)
video/fbdev/msm/mdss_fb.c:static int mdss_fb_immediate_mode_switch(struct msm_fb_data_type *mfd, u32 mode)
video/fbdev/msm/mdss_fb.c:static int mdss_fb_mode_switch(struct msm_fb_data_type *mfd, u32 mode)
video/fbdev/msm/mdss_fb.c:static int __ioctl_wait_idle(struct msm_fb_data_type *mfd, u32 cmd)
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_fb.c:	mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:int mdss_fb_register_mdp_instance(struct msm_mdp_interface *mdp)
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_fb.c:	mfd = (struct msm_fb_data_type *)info->par;
video/fbdev/msm/mdss_fb.c:	if (fb_get_options("msmfb", NULL))
video/fbdev/msm/mdss_fb.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_fb.c:void mdss_fb_report_panel_dead(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:void mdss_fb_calc_fps(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.c:void mdss_fb_idle_pc(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:#include <linux/msm_mdp_ext.h>
video/fbdev/msm/mdss_fb.h:struct msm_sync_pt_data {
video/fbdev/msm/mdss_fb.h:		(struct msm_sync_pt_data *sync_pt_data);
video/fbdev/msm/mdss_fb.h:struct msm_fb_data_type;
video/fbdev/msm/mdss_fb.h:struct msm_mdp_interface {
video/fbdev/msm/mdss_fb.h:	int (*fb_mem_alloc_fnc)(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.h:	int (*init_fnc)(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.h:	int (*on_fnc)(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.h:	int (*off_fnc)(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.h:	int (*release_fnc)(struct msm_fb_data_type *mfd, struct file *file);
video/fbdev/msm/mdss_fb.h:	int (*mode_switch)(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.h:	int (*mode_switch_post)(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.h:	int (*kickoff_fnc)(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.h:	int (*atomic_validate)(struct msm_fb_data_type *mfd, struct file *file,
video/fbdev/msm/mdss_fb.h:	bool (*is_config_same)(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.h:	int (*pre_commit)(struct msm_fb_data_type *mfd, struct file *file,
video/fbdev/msm/mdss_fb.h:	int (*pre_commit_fnc)(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.h:	int (*ioctl_handler)(struct msm_fb_data_type *mfd, u32 cmd, void *arg);
video/fbdev/msm/mdss_fb.h:	void (*dma_fnc)(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.h:	int (*cursor_update)(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.h:	int (*async_position_update)(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.h:	int (*lut_update)(struct msm_fb_data_type *mfd, struct fb_cmap *cmap);
video/fbdev/msm/mdss_fb.h:	int (*do_histogram)(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.h:	int (*ad_calc_bl)(struct msm_fb_data_type *mfd, int bl_in,
video/fbdev/msm/mdss_fb.h:	int (*splash_init_fnc)(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.h:	int (*configure_panel)(struct msm_fb_data_type *mfd, int mode,
video/fbdev/msm/mdss_fb.h:	int (*input_event_handler)(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.h:	int (*pp_release_fnc)(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.h:	void (*signal_retire_fence)(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.h:	int (*enable_panel_disable_mode)(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_fb.h:struct msm_fb_backup_type {
video/fbdev/msm/mdss_fb.h:struct msm_fb_fps_info {
video/fbdev/msm/mdss_fb.h:struct msm_fb_data_type {
video/fbdev/msm/mdss_fb.h:	struct msm_fb_fps_info fps_info;
video/fbdev/msm/mdss_fb.h:	struct msm_mdp_interface mdp;
video/fbdev/msm/mdss_fb.h:	struct msm_sync_pt_data mdp_sync_pt_data;
video/fbdev/msm/mdss_fb.h:	struct msm_fb_splash_info splash_info;
video/fbdev/msm/mdss_fb.h:	struct msm_fb_backup_type msm_fb_backup;
video/fbdev/msm/mdss_fb.h:static inline void mdss_fb_update_notify_update(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:static inline bool is_panel_split_link(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:static inline bool is_panel_split(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:static inline bool is_split_lm(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:static inline bool is_pingpong_split(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:static inline bool is_dual_lm_single_display(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:static inline bool mdss_fb_is_power_off(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:	struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:static inline bool mdss_fb_is_power_on(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:static inline bool mdss_fb_is_power_on_lp(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:static inline bool mdss_fb_is_power_on_ulp(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:static inline bool mdss_fb_is_hdmi_primary(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:static inline void mdss_fb_init_fps_info(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_fb.h:void mdss_fb_set_backlight(struct msm_fb_data_type *mfd, u32 bkl_lvl);
video/fbdev/msm/mdss_fb.h:void mdss_fb_update_backlight(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.h:int mdss_fb_wait_for_fence(struct msm_sync_pt_data *sync_pt_data);
video/fbdev/msm/mdss_fb.h:void mdss_fb_signal_timeline(struct msm_sync_pt_data *sync_pt_data);
video/fbdev/msm/mdss_fb.h:int mdss_fb_register_mdp_instance(struct msm_mdp_interface *mdp);
video/fbdev/msm/mdss_fb.h:int mdss_fb_dcm(struct msm_fb_data_type *mfd, int req_state);
video/fbdev/msm/mdss_fb.h:u32 mdss_fb_get_mode_switch(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.h:void mdss_fb_report_panel_dead(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.h:void mdss_fb_calc_fps(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_fb.h:void mdss_fb_idle_pc(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_hdcp.h:#include <video/msm_hdmi_modes.h>
video/fbdev/msm/mdss_hdcp.h:	struct msm_hdmi_mode_timing_info *timing;
video/fbdev/msm/mdss_hdcp_1x.c:#include "video/msm_hdmi_hdcp_mgr.h"
video/fbdev/msm/mdss_hdcp_1x.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_hdmi_audio.c:	struct msm_ext_disp_audio_setup_params params;
video/fbdev/msm/mdss_hdmi_audio.c:	struct msm_ext_disp_audio_setup_params *params;
video/fbdev/msm/mdss_hdmi_audio.c:	struct msm_ext_disp_audio_setup_params *params)
video/fbdev/msm/mdss_hdmi_audio.h:#include <linux/msm_ext_display.h>
video/fbdev/msm/mdss_hdmi_audio.h:		struct msm_ext_disp_audio_setup_params *params);
video/fbdev/msm/mdss_hdmi_edid.c:		struct msm_hdmi_mode_timing_info *timing, u32 out_format)
video/fbdev/msm/mdss_hdmi_edid.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_hdmi_edid.c:	mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_hdmi_edid.c:	struct msm_hdmi_mode_timing_info info = {0};
video/fbdev/msm/mdss_hdmi_edid.c:	struct msm_hdmi_mode_timing_info info = {0};
video/fbdev/msm/mdss_hdmi_edid.c:	struct msm_hdmi_mode_timing_info info = {0};
video/fbdev/msm/mdss_hdmi_edid.c:		struct msm_hdmi_mode_timing_info info_dbg = {0};
video/fbdev/msm/mdss_hdmi_edid.c:	struct msm_hdmi_mode_timing_info timing;
video/fbdev/msm/mdss_hdmi_edid.c:	struct msm_hdmi_mode_timing_info timing = {0};
video/fbdev/msm/mdss_hdmi_edid.c:			msm_hdmi_mode_2string(video_format));
video/fbdev/msm/mdss_hdmi_edid.c:		video_format, msm_hdmi_mode_2string(video_format),
video/fbdev/msm/mdss_hdmi_edid.c:	struct msm_hdmi_mode_timing_info timing = {0};
video/fbdev/msm/mdss_hdmi_edid.c:		video_format, msm_hdmi_mode_2string(video_format),
video/fbdev/msm/mdss_hdmi_edid.c:	struct msm_hdmi_mode_timing_info timing = {0};
video/fbdev/msm/mdss_hdmi_edid.c:			msm_hdmi_mode_2string(video_format));
video/fbdev/msm/mdss_hdmi_edid.c:		video_format, msm_hdmi_mode_2string(video_format),
video/fbdev/msm/mdss_hdmi_edid.c:				msm_hdmi_mode_2string(video_format));
video/fbdev/msm/mdss_hdmi_edid.c:				msm_hdmi_mode_2string(video_format));
video/fbdev/msm/mdss_hdmi_edid.c:		struct msm_ext_disp_audio_edid_blk *blk)
video/fbdev/msm/mdss_hdmi_edid.h:#include <linux/msm_ext_display.h>
video/fbdev/msm/mdss_hdmi_edid.h: * @format - pixel format (refer to msm_hdmi_modes.h)
video/fbdev/msm/mdss_hdmi_edid.h:	struct msm_ext_disp_audio_edid_blk *blk);
video/fbdev/msm/mdss_hdmi_hdcp2p2.c:#include "video/msm_hdmi_hdcp_mgr.h"
video/fbdev/msm/mdss_hdmi_mhl.h:struct msm_hdmi_mhl_ops {
video/fbdev/msm/mdss_hdmi_mhl.h:int msm_hdmi_register_mhl(struct platform_device *pdev,
video/fbdev/msm/mdss_hdmi_mhl.h:			  struct msm_hdmi_mhl_ops *ops, void *data);
video/fbdev/msm/mdss_hdmi_panel.c:#include "video/msm_hdmi_modes.h"
video/fbdev/msm/mdss_hdmi_panel.c:	struct msm_hdmi_mode_timing_info *timing;
video/fbdev/msm/mdss_hdmi_panel.c:	struct msm_hdmi_mode_timing_info *timing;
video/fbdev/msm/mdss_hdmi_panel.c:	struct msm_hdmi_mode_timing_info *timing;
video/fbdev/msm/mdss_hdmi_panel.c:	struct msm_hdmi_mode_timing_info *timing;
video/fbdev/msm/mdss_hdmi_panel.c:	struct msm_hdmi_mode_timing_info *timing = NULL;
video/fbdev/msm/mdss_hdmi_panel.c:	struct msm_hdmi_mode_timing_info *timing = panel->vid_cfg.timing;
video/fbdev/msm/mdss_hdmi_panel.c:	struct msm_hdmi_mode_timing_info *info;
video/fbdev/msm/mdss_hdmi_panel.h:	struct msm_hdmi_mode_timing_info *timing;
video/fbdev/msm/mdss_hdmi_tx.c:#include <linux/msm_mdp.h>
video/fbdev/msm/mdss_hdmi_tx.c:#include <linux/msm_ext_display.h>
video/fbdev/msm/mdss_hdmi_tx.c:	struct msm_ext_disp_audio_setup_params *params);
video/fbdev/msm/mdss_hdmi_tx.c:	struct msm_ext_disp_audio_edid_blk *blk);
video/fbdev/msm/mdss_hdmi_tx.c:	struct msm_ext_disp_data *ext_data;
video/fbdev/msm/mdss_hdmi_tx.c:	struct msm_ext_disp_init_data *ext;
video/fbdev/msm/mdss_hdmi_tx.c:	struct msm_fb_data_type *mfd = NULL;
video/fbdev/msm/mdss_hdmi_tx.c:		mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_hdmi_tx.c:	rc = msm_dss_clk_set_rate(power_data->clk_config, power_data->num_clk);
video/fbdev/msm/mdss_hdmi_tx.c:	struct msm_ext_disp_init_data *ext;
video/fbdev/msm/mdss_hdmi_tx.c:	struct msm_ext_disp_audio_codec_ops *ops;
video/fbdev/msm/mdss_hdmi_tx.c:	const char *phandle = "qcom,msm_ext_disp";
video/fbdev/msm/mdss_hdmi_tx.c:	ret = msm_ext_disp_register_intf(hdmi_ctrl->ext_pdev, ext);
video/fbdev/msm/mdss_hdmi_tx.c:	struct msm_hdmi_mode_timing_info timing = {0};
video/fbdev/msm/mdss_hdmi_tx.c:		rc = msm_dss_config_vreg(&hdmi_ctrl->pdev->dev,
video/fbdev/msm/mdss_hdmi_tx.c:			msm_dss_config_vreg(&hdmi_ctrl->pdev->dev,
video/fbdev/msm/mdss_hdmi_tx.c:		rc = msm_dss_get_clk(&hdmi_ctrl->pdev->dev,
video/fbdev/msm/mdss_hdmi_tx.c:			msm_dss_config_vreg(&hdmi_ctrl->pdev->dev,
video/fbdev/msm/mdss_hdmi_tx.c:		msm_dss_put_clk(power_data->clk_config, power_data->num_clk);
video/fbdev/msm/mdss_hdmi_tx.c:		rc = msm_dss_config_vreg(&hdmi_ctrl->pdev->dev,
video/fbdev/msm/mdss_hdmi_tx.c:		rc = msm_dss_enable_vreg(power_data->vreg_config,
video/fbdev/msm/mdss_hdmi_tx.c:		rc = msm_dss_enable_gpio(power_data->gpio_config,
video/fbdev/msm/mdss_hdmi_tx.c:		rc = msm_dss_clk_set_rate(power_data->clk_config,
video/fbdev/msm/mdss_hdmi_tx.c:		rc = msm_dss_enable_clk(power_data->clk_config,
video/fbdev/msm/mdss_hdmi_tx.c:		msm_dss_enable_clk(power_data->clk_config,
video/fbdev/msm/mdss_hdmi_tx.c:		msm_dss_enable_gpio(power_data->gpio_config,
video/fbdev/msm/mdss_hdmi_tx.c:		msm_dss_enable_vreg(power_data->vreg_config,
video/fbdev/msm/mdss_hdmi_tx.c:	msm_dss_enable_gpio(power_data->gpio_config, power_data->num_gpio, 0);
video/fbdev/msm/mdss_hdmi_tx.c:	msm_dss_enable_vreg(power_data->vreg_config, power_data->num_vreg, 0);
video/fbdev/msm/mdss_hdmi_tx.c:		DEV_ERR("%s: core hdmi_msm_enable_power failed rc = %d\n",
video/fbdev/msm/mdss_hdmi_tx.c:		DEV_ERR("%s: cec hdmi_msm_enable_power failed rc = %d\n",
video/fbdev/msm/mdss_hdmi_tx.c:	struct msm_ext_disp_audio_setup_params *params)
video/fbdev/msm/mdss_hdmi_tx.c:			sizeof(struct msm_ext_disp_audio_setup_params));
video/fbdev/msm/mdss_hdmi_tx.c:	struct msm_ext_disp_audio_edid_blk *blk)
video/fbdev/msm/mdss_hdmi_tx.c:int msm_hdmi_register_mhl(struct platform_device *pdev,
video/fbdev/msm/mdss_hdmi_tx.c:			  struct msm_hdmi_mhl_ops *ops, void *data)
video/fbdev/msm/mdss_hdmi_tx.c:		sizeof(struct msm_ext_disp_audio_setup_params));
video/fbdev/msm/mdss_hdmi_tx.c:			msm_dss_iounmap(&hdmi_ctrl->pdata.io[i]);
video/fbdev/msm/mdss_hdmi_tx.c:		rc = msm_dss_ioremap_byname(hdmi_ctrl->pdev, &pdata->io[i],
video/fbdev/msm/mdss_hdmi_tx.c:			msm_dss_enable_vreg(
video/fbdev/msm/mdss_hdmi_tx.c:			msm_dss_enable_gpio(
video/fbdev/msm/mdss_hdmi_tx.c:			msm_dss_enable_clk(
video/fbdev/msm/mdss_hdmi_tx.h:	struct msm_hdmi_mode_timing_info timing;
video/fbdev/msm/mdss_hdmi_tx.h:	struct msm_ext_disp_audio_setup_params audio_params;
video/fbdev/msm/mdss_hdmi_tx.h:	struct msm_ext_disp_init_data ext_audio_data;
video/fbdev/msm/mdss_hdmi_util.c:#include <linux/msm_mdp.h>
video/fbdev/msm/mdss_hdmi_util.c:#include <linux/msm_mdp_ext.h>
video/fbdev/msm/mdss_hdmi_util.c:	struct msm_hdmi_mode_timing_info timing;
video/fbdev/msm/mdss_hdmi_util.c:		struct msm_hdmi_mode_timing_info info = {0};
video/fbdev/msm/mdss_hdmi_util.c:int hdmi_utils_get_timeout_in_hysnc(struct msm_hdmi_mode_timing_info *timing,
video/fbdev/msm/mdss_hdmi_util.c:static struct msm_hdmi_mode_timing_info hdmi_resv_timings[
video/fbdev/msm/mdss_hdmi_util.c:	struct msm_hdmi_mode_timing_info *mode, int id)
video/fbdev/msm/mdss_hdmi_util.c:		struct msm_hdmi_mode_timing_info *info = &hdmi_resv_timings[i];
video/fbdev/msm/mdss_hdmi_util.c:int hdmi_set_resv_timing_info(struct msm_hdmi_mode_timing_info *mode)
video/fbdev/msm/mdss_hdmi_util.c:		struct msm_hdmi_mode_timing_info *info = &hdmi_resv_timings[i];
video/fbdev/msm/mdss_hdmi_util.c:	struct msm_hdmi_mode_timing_info *info;
video/fbdev/msm/mdss_hdmi_util.c:		struct msm_hdmi_mode_timing_info *info = &hdmi_resv_timings[i];
video/fbdev/msm/mdss_hdmi_util.c:int msm_hdmi_get_timing_info(
video/fbdev/msm/mdss_hdmi_util.c:	struct msm_hdmi_mode_timing_info *mode, int id)
video/fbdev/msm/mdss_hdmi_util.c:int hdmi_get_supported_mode(struct msm_hdmi_mode_timing_info *info,
video/fbdev/msm/mdss_hdmi_util.c:	ret = msm_hdmi_get_timing_info(info, mode);
video/fbdev/msm/mdss_hdmi_util.c:const char *msm_hdmi_mode_2string(u32 mode)
video/fbdev/msm/mdss_hdmi_util.c:	static struct msm_hdmi_mode_timing_info ri = {0};
video/fbdev/msm/mdss_hdmi_util.c:int hdmi_get_video_id_code(struct msm_hdmi_mode_timing_info *timing_in,
video/fbdev/msm/mdss_hdmi_util.c:	struct msm_hdmi_mode_timing_info supported_timing = {0};
video/fbdev/msm/mdss_hdmi_util.c:			msm_hdmi_mode_2string((u32)vic));
video/fbdev/msm/mdss_hdmi_util.h:#include "video/msm_hdmi_modes.h"
video/fbdev/msm/mdss_hdmi_util.h:static inline int hdmi_tx_get_v_total(const struct msm_hdmi_mode_timing_info *t)
video/fbdev/msm/mdss_hdmi_util.h:static inline int hdmi_tx_get_h_total(const struct msm_hdmi_mode_timing_info *t)
video/fbdev/msm/mdss_hdmi_util.h:int hdmi_get_video_id_code(struct msm_hdmi_mode_timing_info *timing_in,
video/fbdev/msm/mdss_hdmi_util.h:int hdmi_get_supported_mode(struct msm_hdmi_mode_timing_info *info,
video/fbdev/msm/mdss_hdmi_util.h:const char *msm_hdmi_mode_2string(u32 mode);
video/fbdev/msm/mdss_hdmi_util.h:int hdmi_set_resv_timing_info(struct msm_hdmi_mode_timing_info *mode);
video/fbdev/msm/mdss_hdmi_util.h:int hdmi_utils_get_timeout_in_hysnc(struct msm_hdmi_mode_timing_info *timing,
video/fbdev/msm/mdss_io_util.c:static struct resource *msm_mdss_get_res_byname(struct platform_device *pdev,
video/fbdev/msm/mdss_io_util.c:} /* msm_mdss_get_res_byname */
video/fbdev/msm/mdss_io_util.c:EXPORT_SYMBOL(msm_mdss_get_res_byname);
video/fbdev/msm/mdss_io_util.c:int msm_dss_ioremap_byname(struct platform_device *pdev,
video/fbdev/msm/mdss_io_util.c:	res = msm_mdss_get_res_byname(pdev, IORESOURCE_MEM, name);
video/fbdev/msm/mdss_io_util.c:		DEV_ERR("%pS->%s: '%s' msm_mdss_get_res_byname failed\n",
video/fbdev/msm/mdss_io_util.c:} /* msm_dss_ioremap_byname */
video/fbdev/msm/mdss_io_util.c:EXPORT_SYMBOL(msm_dss_ioremap_byname);
video/fbdev/msm/mdss_io_util.c:void msm_dss_iounmap(struct dss_io_data *io_data)
video/fbdev/msm/mdss_io_util.c:} /* msm_dss_iounmap */
video/fbdev/msm/mdss_io_util.c:EXPORT_SYMBOL(msm_dss_iounmap);
video/fbdev/msm/mdss_io_util.c:int msm_dss_config_vreg(struct device *dev, struct dss_vreg *in_vreg,
video/fbdev/msm/mdss_io_util.c:} /* msm_dss_config_vreg */
video/fbdev/msm/mdss_io_util.c:EXPORT_SYMBOL(msm_dss_config_vreg);
video/fbdev/msm/mdss_io_util.c:int msm_dss_config_vreg_opt_mode(struct dss_vreg *in_vreg, int num_vreg,
video/fbdev/msm/mdss_io_util.c:EXPORT_SYMBOL(msm_dss_config_vreg_opt_mode);
video/fbdev/msm/mdss_io_util.c:int msm_dss_enable_vreg(struct dss_vreg *in_vreg, int num_vreg, int enable)
video/fbdev/msm/mdss_io_util.c:} /* msm_dss_enable_vreg */
video/fbdev/msm/mdss_io_util.c:EXPORT_SYMBOL(msm_dss_enable_vreg);
video/fbdev/msm/mdss_io_util.c:int msm_dss_enable_gpio(struct dss_gpio *in_gpio, int num_gpio, int enable)
video/fbdev/msm/mdss_io_util.c:} /* msm_dss_enable_gpio */
video/fbdev/msm/mdss_io_util.c:EXPORT_SYMBOL(msm_dss_enable_gpio);
video/fbdev/msm/mdss_io_util.c:void msm_dss_put_clk(struct dss_clk *clk_arry, int num_clk)
video/fbdev/msm/mdss_io_util.c:} /* msm_dss_put_clk */
video/fbdev/msm/mdss_io_util.c:EXPORT_SYMBOL(msm_dss_put_clk);
video/fbdev/msm/mdss_io_util.c:int msm_dss_get_clk(struct device *dev, struct dss_clk *clk_arry, int num_clk)
video/fbdev/msm/mdss_io_util.c:	msm_dss_put_clk(clk_arry, num_clk);
video/fbdev/msm/mdss_io_util.c:} /* msm_dss_get_clk */
video/fbdev/msm/mdss_io_util.c:EXPORT_SYMBOL(msm_dss_get_clk);
video/fbdev/msm/mdss_io_util.c:int msm_dss_clk_set_rate(struct dss_clk *clk_arry, int num_clk)
video/fbdev/msm/mdss_io_util.c:} /* msm_dss_clk_set_rate */
video/fbdev/msm/mdss_io_util.c:EXPORT_SYMBOL(msm_dss_clk_set_rate);
video/fbdev/msm/mdss_io_util.c:int msm_dss_enable_clk(struct dss_clk *clk_arry, int num_clk, int enable)
video/fbdev/msm/mdss_io_util.c:				msm_dss_enable_clk(&clk_arry[i],
video/fbdev/msm/mdss_io_util.c:} /* msm_dss_enable_clk */
video/fbdev/msm/mdss_io_util.c:EXPORT_SYMBOL(msm_dss_enable_clk);
video/fbdev/msm/mdss_mdp.c:#include <linux/msm-bus.h>
video/fbdev/msm/mdss_mdp.c:#include <linux/msm-bus-board.h>
video/fbdev/msm/mdss_mdp.c:struct msm_mdp_interface mdp5 = {
video/fbdev/msm/mdss_mdp.c:static struct msm_bus_vectors mdp_reg_bus_vectors[] = {
video/fbdev/msm/mdss_mdp.c:static struct msm_bus_paths mdp_reg_bus_usecases[ARRAY_SIZE(
video/fbdev/msm/mdss_mdp.c:static struct msm_bus_scale_pdata mdp_reg_bus_scale_table = {
video/fbdev/msm/mdss_mdp.c:	struct msm_bus_scale_pdata *reg_bus_pdata;
video/fbdev/msm/mdss_mdp.c:			msm_bus_scale_register_client(mdata->bus_scale_table);
video/fbdev/msm/mdss_mdp.c:			msm_bus_scale_register_client(
video/fbdev/msm/mdss_mdp.c:			msm_bus_scale_register_client(
video/fbdev/msm/mdss_mdp.c:		msm_bus_scale_unregister_client(mdata->bus_hdl);
video/fbdev/msm/mdss_mdp.c:		msm_bus_scale_unregister_client(mdata->reg_bus_hdl);
video/fbdev/msm/mdss_mdp.c:		msm_bus_scale_unregister_client(mdata->hw_rt_bus_hdl);
video/fbdev/msm/mdss_mdp.c:		struct msm_bus_vectors *vect = NULL;
video/fbdev/msm/mdss_mdp.c:		struct msm_bus_scale_pdata *bw_table =
video/fbdev/msm/mdss_mdp.c:		ATRACE_BEGIN("msm_bus_scale_req");
video/fbdev/msm/mdss_mdp.c:		rc = msm_bus_scale_client_update_request(mdss_res->bus_hdl,
video/fbdev/msm/mdss_mdp.c:		ATRACE_END("msm_bus_scale_req");
video/fbdev/msm/mdss_mdp.c:		ret = msm_bus_scale_client_update_request(mdss_res->reg_bus_hdl,
video/fbdev/msm/mdss_mdp.c:		rc = msm_bus_scale_client_update_request(mdata->hw_rt_bus_hdl,
video/fbdev/msm/mdss_mdp.c:		msm_bus_scale_client_update_context(mdata->bus_hdl,
video/fbdev/msm/mdss_mdp.c:		msm_bus_scale_client_update_context(mdata->bus_hdl,
video/fbdev/msm/mdss_mdp.c:				msm_bus_scale_client_update_request(
video/fbdev/msm/mdss_mdp.c:			msm_bus_scale_client_update_request(
video/fbdev/msm/mdss_mdp.c:	rc = msm_dss_ioremap_byname(pdev, &mdata->mdss_io, "mdp_phys");
video/fbdev/msm/mdss_mdp.c:	rc = msm_dss_ioremap_byname(pdev, &mdata->vbif_io, "vbif_phys");
video/fbdev/msm/mdss_mdp.c:	rc = msm_dss_ioremap_byname(pdev, &mdata->vbif_nrt_io, "vbif_nrt_phys");
video/fbdev/msm/mdss_mdp.c:			"qcom,msm-bus,num-paths", &paths);
video/fbdev/msm/mdss_mdp.c:		pr_err("Error. qcom,msm-bus,num-paths prop not found.rc=%d\n",
video/fbdev/msm/mdss_mdp.c:	mdata->bus_scale_table = msm_bus_cl_get_pdata(pdev);
video/fbdev/msm/mdss_mdp.c:		pr_err("msm_bus_cl_get_pdata failed. rc=%d\n", rc);
video/fbdev/msm/mdss_mdp.c:			msm_bus_pdata_from_node(pdev, node);
video/fbdev/msm/mdss_mdp.c:			msm_bus_pdata_from_node(pdev, node);
video/fbdev/msm/mdss_mdp.h:#include <linux/msm_mdp.h>
video/fbdev/msm/mdss_mdp.h:#include <linux/msm_mdp_ext.h>
video/fbdev/msm/mdss_mdp.h:	struct msm_sync_pt_data cwb_sync_pt_data;
video/fbdev/msm/mdss_mdp.h:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_mdp.h:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_mdp.h:	struct msm_fb_data_type *bl_mfd;
video/fbdev/msm/mdss_mdp.h:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_mdp.h:static inline bool mdss_mdp_is_roi_changed(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp.h:static inline u32 left_lm_w_from_mfd(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_overlay_init(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_dfps_update_params(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_layer_atomic_validate(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_layer_pre_commit(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_layer_atomic_validate_wfd(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_layer_pre_commit_wfd(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:bool mdss_mdp_wfd_is_config_same(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_async_position_update(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_overlay_req_check(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_overlay_vsync_ctrl(struct msm_fb_data_type *mfd, int en);
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_overlay_pipe_setup(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:void mdss_mdp_handoff_cleanup_pipes(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_overlay_release(struct msm_fb_data_type *mfd, int ndx);
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_overlay_start(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp.h:	struct msm_fb_data_type *mfd, int pipe_ndx);
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_cwb_validate(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_overlay_kickoff(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:struct mdss_mdp_data *mdss_mdp_overlay_buf_alloc(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:void mdss_mdp_overlay_buf_free(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:					struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_async_ctl_flush(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_pp_overlay_init(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_pp_resume(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_mfd_valid_dspp(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_pa_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_pa_v2_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_pcc_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_igc_lut_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_argc_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_hist_lut_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_pp_default_overlay_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_dither_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_gamut_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_pa_dither_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_ad_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_ad_bl_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_ad_input(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_calib_mode(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp.h:	struct msmfb_data *planes, int num_planes, u64 flags,
video/fbdev/msm/mdss_mdp.h:u32 mdss_get_panel_framerate(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp.h:int mdss_mdp_layer_pre_commit_cwb(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_cdm.h:#include <linux/msm_mdp.h>
video/fbdev/msm/mdss_mdp_debug.c:static struct debug_bus dbg_bus_msm8998[] = {
video/fbdev/msm/mdss_mdp_debug.c:static struct vbif_debug_bus vbif_dbg_bus_msm8998[] = {
video/fbdev/msm/mdss_mdp_debug.c:		mdata->dbg_bus = dbg_bus_msm8998;
video/fbdev/msm/mdss_mdp_debug.c:		mdata->dbg_bus_size = ARRAY_SIZE(dbg_bus_msm8998);
video/fbdev/msm/mdss_mdp_debug.c:		mdata->vbif_dbg_bus = vbif_dbg_bus_msm8998;
video/fbdev/msm/mdss_mdp_debug.c:		mdata->vbif_dbg_bus_size = ARRAY_SIZE(vbif_dbg_bus_msm8998);
video/fbdev/msm/mdss_mdp_debug.c:		struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_debug.c:		struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_debug.c:static void __dump_buf_data(struct seq_file *s, struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_debug.h:#include <linux/msm_mdp.h>
video/fbdev/msm/mdss_mdp_formats.h:#include <linux/msm_mdp.h>
video/fbdev/msm/mdss_mdp_intf_video.c:#include <video/msm_hdmi_modes.h>
video/fbdev/msm/mdss_mdp_intf_video.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_mdp_layer.c:#include <linux/msm_mdp.h>
video/fbdev/msm/mdss_mdp_layer.c:static int mdss_mdp_validate_destination_scaler(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:static int mdss_mdp_avr_validate(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:static int __async_update_position_check(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:static int __cursor_layer_check(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:static int __layer_xres_check(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:static int __layer_param_check(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:static int __validate_single_layer(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:static int __configure_pipe_params(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:static struct mdss_fence *__create_fence(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:	struct msm_sync_pt_data *sync_pt_data, u32 fence_type,
video/fbdev/msm/mdss_mdp_layer.c:static int __handle_buffer_fences(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:	struct msm_sync_pt_data *sync_pt_data = NULL;
video/fbdev/msm/mdss_mdp_layer.c:static struct mdss_mdp_data *__map_layer_buffer(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:	struct msmfb_data image;
video/fbdev/msm/mdss_mdp_layer.c:	struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:static int __multirect_validate_mode(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:static int __validate_multirect_param(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:static int __update_multirect_info(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:static int __validate_multirect(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:static int __validate_layers(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:int mdss_mdp_layer_pre_commit(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:int mdss_mdp_layer_atomic_validate(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:int mdss_mdp_layer_pre_commit_cwb(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:int mdss_mdp_layer_pre_commit_wfd(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:	struct msm_sync_pt_data *sync_pt_data = NULL;
video/fbdev/msm/mdss_mdp_layer.c:int mdss_mdp_layer_atomic_validate_wfd(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_layer.c:int mdss_mdp_async_position_update(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:#include <linux/msm_mdp.h>
video/fbdev/msm/mdss_mdp_overlay.c:#include <linux/msm-bus.h>
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_free_fb_pipe(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_fb_parse_dt(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_off(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_overlay.c:static void __overlay_kickoff_requeue(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_overlay.c:static void __vsync_retire_signal(struct msm_fb_data_type *mfd, int val);
video/fbdev/msm/mdss_mdp_overlay.c:static int __vsync_set_vsync_handler(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_update_panel_info(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_set_cfg(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = pipe->mixer_left->ctl->mfd;
video/fbdev/msm/mdss_mdp_overlay.c:		struct msm_fb_data_type *mfd, u32 ndx)
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_get(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_ov_xres_check(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:int mdss_mdp_overlay_req_check(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:int mdss_mdp_overlay_pipe_setup(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_set(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:struct mdss_mdp_data *mdss_mdp_overlay_buf_alloc(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:struct mdss_mdp_data *__mdp_overlay_buf_alloc(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static void mdss_mdp_overlay_buf_deinit(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:void mdss_mdp_overlay_buf_free(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static void __mdp_overlay_buf_free(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static inline void __pipe_buf_mark_cleanup(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static void __mdss_mdp_overlay_free_list_purge(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static void __overlay_pipe_cleanup(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static void mdss_mdp_overlay_cleanup(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:void mdss_mdp_handoff_cleanup_pipes(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:int mdss_mdp_overlay_start(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static void __unstage_pipe_and_clean_buf(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int __dest_scaler_setup(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static int __overlay_queue_pipes(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static void __overlay_kickoff_requeue(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)data;
video/fbdev/msm/mdss_mdp_overlay.c:int mdss_mode_switch(struct msm_fb_data_type *mfd, u32 mode)
video/fbdev/msm/mdss_mdp_overlay.c:int mdss_mode_switch_post(struct msm_fb_data_type *mfd, u32 mode)
video/fbdev/msm/mdss_mdp_overlay.c:static void __validate_and_set_roi(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static void __overlay_cleanup_secure_pipe(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static void __overlay_set_secure_transition_state(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static int __overlay_secure_ctrl(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:int mdss_mdp_overlay_kickoff(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:int mdss_mdp_overlay_release(struct msm_fb_data_type *mfd, int ndx)
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_unset(struct msm_fb_data_type *mfd, int ndx)
video/fbdev/msm/mdss_mdp_overlay.c:static int __mdss_mdp_overlay_release_all(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_queue(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:				  struct msmfb_overlay_data *req)
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_play(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:				 struct msmfb_overlay_data *req)
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_free_fb_pipe(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_get_fb_pipe(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static void mdss_mdp_overlay_pan_display(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = NULL;
video/fbdev/msm/mdss_mdp_overlay.c:int mdss_mdp_overlay_vsync_ctrl(struct msm_fb_data_type *mfd, int en)
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:int mdss_mdp_dfps_update_params(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:static inline int mdss_mdp_ad_is_supported(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:static ssize_t msm_disable_panel_show(struct device *dev,
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_enable_panel_disable_mode(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static ssize_t msm_disable_panel_store(struct device *dev,
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:static ssize_t msm_cmd_autorefresh_en_show(struct device *dev,
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:static ssize_t msm_cmd_autorefresh_en_store(struct device *dev,
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:static ssize_t msm_misr_en_show(struct device *dev,
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:static ssize_t msm_misr_en_store(struct device *dev,
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_mdp_overlay.c:static DEVICE_ATTR_RW(msm_misr_en);
video/fbdev/msm/mdss_mdp_overlay.c:static DEVICE_ATTR_RW(msm_cmd_autorefresh_en);
video/fbdev/msm/mdss_mdp_overlay.c:static DEVICE_ATTR_RW(msm_disable_panel);
video/fbdev/msm/mdss_mdp_overlay.c:	&dev_attr_msm_misr_en.attr,
video/fbdev/msm/mdss_mdp_overlay.c:	&dev_attr_msm_cmd_autorefresh_en.attr,
video/fbdev/msm/mdss_mdp_overlay.c:	&dev_attr_msm_disable_panel.attr,
video/fbdev/msm/mdss_mdp_overlay.c:static void mdss_mdp_curor_pipe_cleanup(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:int mdss_mdp_cursor_flush(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_cursor_pipe_setup(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_hw_cursor_pipe_update(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_hw_cursor_update(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_bl_scale_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_pp_ioctl(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:	struct msmfb_mdp_pp mdp_pp;
video/fbdev/msm/mdss_mdp_overlay.c:		ret = copy_to_user(argp, &mdp_pp, sizeof(struct msmfb_mdp_pp));
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_histo_ioctl(struct msm_fb_data_type *mfd, u32 cmd,
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_fb_set_metadata(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:				struct msmfb_metadata *metadata)
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_fb_set_panel_ppm(struct msm_fb_data_type *mfd, s32 ppm)
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_fb_get_hw_caps(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_fb_get_metadata(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:				struct msmfb_metadata *metadata)
video/fbdev/msm/mdss_mdp_overlay.c:static int __mdss_mdp_clean_dirty_pipes(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_precommit(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static int __mdss_overlay_src_split_sort(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int __handle_overlay_prepare(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int __handle_ioctl_overlay_prepare(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_ioctl_handler(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:	struct msmfb_metadata metadata;
video/fbdev/msm/mdss_mdp_overlay.c:	struct msmfb_overlay_data data;
video/fbdev/msm/mdss_mdp_overlay.c: * @mfd: msm frame buffer data structure associated with the fb device.
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static void mdss_mdp_set_lm_flag(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static void mdss_mdp_handle_invalid_switch_state(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_on(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_handoff_cleanup_ctl(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_off(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static int __mdss_mdp_ctl_handoff(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_handoff(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd = ctl->mfd;
video/fbdev/msm/mdss_mdp_overlay.c:static void __vsync_retire_signal(struct msm_fb_data_type *mfd, int val)
video/fbdev/msm/mdss_mdp_overlay.c:__vsync_retire_get_fence(struct msm_sync_pt_data *sync_pt_data)
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_mdp_overlay.c:static int __vsync_set_vsync_handler(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static int __vsync_retire_setup(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_update_panel_info(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:int mdss_mdp_input_event_handler(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static void mdss_mdp_signal_retire_fence(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_overlay.c:int mdss_mdp_overlay_init(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:	struct msm_mdp_interface *mdp5_interface = &mfd->mdp;
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_overlay_fb_parse_dt(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_overlay.c:static int mdss_mdp_set_cfg(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pipe.c:	/* do not apply for msm8998, sdm660 & sdm630 in command mode */
video/fbdev/msm/mdss_mdp_pp.c:#include <linux/msm-bus.h>
video/fbdev/msm/mdss_mdp_pp.c:#include <linux/msm-bus-board.h>
video/fbdev/msm/mdss_mdp_pp.c:static struct msm_fb_data_type *mdss_get_mfd_from_index(int index);
video/fbdev/msm/mdss_mdp_pp.c:static int mdss_mdp_mfd_valid_ad(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_pp.c:static int mdss_mdp_get_ad(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:static int pp_ad_invalidate_input(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_pp.c:static int pp_ad_setup_hw_nums(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:static int mdss_mdp_ad_setup(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_pp.c:static int pp_ad_calc_bl(struct msm_fb_data_type *mfd, int bl_in, int *bl_out,
video/fbdev/msm/mdss_mdp_pp.c:static int mdss_mdp_panel_default_dither_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:static int mdss_mdp_limited_lut_igc_config(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_pp.c:static inline int pp_validate_dspp_mfd_block(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:static int pp_mfd_release_all(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_pp.c:static int pp_mfd_ad_release_all(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_pp.c:static int mdss_mdp_ad_ipc_reset(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_pp.c:	 * Starting from msm8998, the histogram enable bit has been moved
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_pp_resume(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_pp_overlay_init(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_pp_default_overlay_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:static int pp_ad_calc_bl(struct msm_fb_data_type *mfd, int bl_in, int *bl_out,
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_pa_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_pa_v2_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_pcc_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:static int mdss_mdp_limited_lut_igc_config(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_igc_lut_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_argc_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_hist_lut_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:static int mdss_mdp_panel_default_dither_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_dither_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_gamut_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:static struct msm_fb_data_type *mdss_get_mfd_from_index(int index)
video/fbdev/msm/mdss_mdp_pp.c:	struct msm_fb_data_type *out = NULL;
video/fbdev/msm/mdss_mdp_pp.c:static int mdss_mdp_get_ad(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:static int pp_ad_invalidate_input(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_ad_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:	struct msm_fb_data_type *bl_mfd;
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_ad_bl_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_ad_input(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:static int pp_ad_setup_hw_nums(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:static int mdss_mdp_ad_ipc_reset(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_pp.c:static int mdss_mdp_ad_setup(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_pp.c:	struct msm_fb_data_type *bl_mfd;
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_calib_mode(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_mfd_valid_dspp(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_pp.c:static int mdss_mdp_mfd_valid_ad(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_pp.c:static int pp_mfd_release_all(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_pp.c:static int pp_mfd_ad_release_all(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_pp.c:static inline int pp_validate_dspp_mfd_block(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.c:int mdss_mdp_pa_dither_config(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_pp.h:#include <linux/msm_mdp.h>
video/fbdev/msm/mdss_mdp_splash_logo.c:static int mdss_mdp_splash_alloc_memory(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_splash_logo.c:	struct msm_fb_splash_info *sinfo;
video/fbdev/msm/mdss_mdp_splash_logo.c:static void mdss_mdp_splash_free_memory(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_splash_logo.c:	struct msm_fb_splash_info *sinfo;
video/fbdev/msm/mdss_mdp_splash_logo.c:static int mdss_mdp_splash_iommu_attach(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_splash_logo.c:static void mdss_mdp_splash_unmap_splash_mem(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_splash_logo.c:void mdss_mdp_release_splash_pipe(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_splash_logo.c:	struct msm_fb_splash_info *sinfo;
video/fbdev/msm/mdss_mdp_splash_logo.c:int mdss_mdp_splash_cleanup(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_splash_logo.c:					struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_splash_logo.c:static int mdss_mdp_splash_kickoff(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_splash_logo.c:	struct msm_fb_splash_info *sinfo;
video/fbdev/msm/mdss_mdp_splash_logo.c:static int mdss_mdp_display_splash_image(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_splash_logo.c:	struct msm_fb_splash_info *sinfo;
video/fbdev/msm/mdss_mdp_splash_logo.c:	struct msm_fb_splash_info *sinfo = container_of(self,
video/fbdev/msm/mdss_mdp_splash_logo.c:					struct msm_fb_splash_info, notifier);
video/fbdev/msm/mdss_mdp_splash_logo.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_mdp_splash_logo.c:	mfd = container_of(sinfo, struct msm_fb_data_type, splash_info);
video/fbdev/msm/mdss_mdp_splash_logo.c:	struct msm_fb_data_type *mfd = data;
video/fbdev/msm/mdss_mdp_splash_logo.c:static __ref int mdss_mdp_splash_parse_dt(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_splash_logo.c:int mdss_mdp_splash_init(struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_splash_logo.h:struct msm_fb_splash_info {
video/fbdev/msm/mdss_mdp_splash_logo.h:struct msm_fb_data_type;
video/fbdev/msm/mdss_mdp_splash_logo.h:void mdss_mdp_release_splash_pipe(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_splash_logo.h:int mdss_mdp_splash_cleanup(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_splash_logo.h:int mdss_mdp_splash_init(struct msm_fb_data_type *mfd);
video/fbdev/msm/mdss_mdp_util.c:#include <media/msm_media_info.h>
video/fbdev/msm/mdss_mdp_util.c:static int mdss_mdp_get_img(struct msmfb_data *img,
video/fbdev/msm/mdss_mdp_util.c:		struct msmfb_data *planes, int num_planes, u64 flags,
video/fbdev/msm/mdss_mdp_util.c:	struct msmfb_data *planes, int num_planes, u64 flags,
video/fbdev/msm/mdss_mdp_wfd.c:bool mdss_mdp_wfd_is_config_same(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_wfd.c:	struct msmfb_data planes[MAX_PLANES];
video/fbdev/msm/mdss_mdp_wfd.c:int mdss_mdp_cwb_validate(struct msm_fb_data_type *mfd,
video/fbdev/msm/mdss_mdp_wfd.h:#include <linux/msm_mdp_ext.h>
video/fbdev/msm/mdss_qpic_panel.h:#include <linux/msm-sps.h>
video/fbdev/msm/mdss_rgb.c:#include <linux/msm-bus.h>
video/fbdev/msm/mdss_rgb.c:	rgb_data->bus_scale_table = msm_bus_cl_get_pdata(pdev);
video/fbdev/msm/mdss_rgb.c:		pr_err("%s: msm_bus_cl_get_pdata() failed, rc=%d\n", __func__,
video/fbdev/msm/mdss_rgb.c:		msm_bus_scale_register_client(rgb_data->bus_scale_table);
video/fbdev/msm/mdss_rgb.c:			msm_bus_scale_client_update_request(sdata->bus_handle,
video/fbdev/msm/mdss_rgb.c:		msm_bus_scale_unregister_client(sdata->bus_handle);
video/fbdev/msm/mdss_rgb.c:		rc = msm_dss_config_vreg(&pdev->dev,
video/fbdev/msm/mdss_rgb.c:				msm_dss_config_vreg(&pdev->dev,
video/fbdev/msm/mdss_rgb.c:		if (msm_dss_config_vreg(&pdev->dev,
video/fbdev/msm/mdss_rgb.c:	ret = msm_dss_enable_vreg(
video/fbdev/msm/mdss_rgb.c:	ret = msm_dss_enable_vreg(
video/fbdev/msm/mdss_rgb.c:	rc = msm_dss_config_vreg(&ctrl_pdev->dev,
video/fbdev/msm/mdss_rgb.c:	rc = msm_dss_ioremap_byname(ctrl_pdev, &rgb_data->phy_io, "dsi_phy");
video/fbdev/msm/mdss_rgb.h:	struct msm_bus_scale_pdata *bus_scale_table;
video/fbdev/msm/mdss_rotator.c:#include <linux/msm-bus.h>
video/fbdev/msm/mdss_rotator.c:#include <linux/msm-bus-board.h>
video/fbdev/msm/mdss_rotator.c:static struct msm_bus_vectors rot_reg_bus_vectors[] = {
video/fbdev/msm/mdss_rotator.c:static struct msm_bus_paths rot_reg_bus_usecases[ARRAY_SIZE(
video/fbdev/msm/mdss_rotator.c:static struct msm_bus_scale_pdata rot_reg_bus_scale_table = {
video/fbdev/msm/mdss_rotator.c:		struct msm_bus_vectors *vect = NULL;
video/fbdev/msm/mdss_rotator.c:		struct msm_bus_scale_pdata *bw_table =
video/fbdev/msm/mdss_rotator.c:	ATRACE_BEGIN("msm_bus_scale_req_rot");
video/fbdev/msm/mdss_rotator.c:	ret = msm_bus_scale_client_update_request(bus->bus_hdl,
video/fbdev/msm/mdss_rotator.c:	ATRACE_END("msm_bus_scale_req_rot");
video/fbdev/msm/mdss_rotator.c:		ATRACE_BEGIN("msm_bus_scale_req_rot_reg");
video/fbdev/msm/mdss_rotator.c:		ret = msm_bus_scale_client_update_request(mgr->reg_bus.bus_hdl,
video/fbdev/msm/mdss_rotator.c:		ATRACE_END("msm_bus_scale_req_rot_reg");
video/fbdev/msm/mdss_rotator.c:	ret = msm_dss_enable_vreg(mgr->module_power.vreg_config,
video/fbdev/msm/mdss_rotator.c:			msm_bus_scale_client_update_context(
video/fbdev/msm/mdss_rotator.c:			msm_bus_scale_client_update_context(
video/fbdev/msm/mdss_rotator.c:	struct msmfb_data planes[MAX_PLANES];
video/fbdev/msm/mdss_rotator.c:	mgr->data_bus.bus_scale_pdata = msm_bus_cl_get_pdata(dev);
video/fbdev/msm/mdss_rotator.c:			pr_err("msm_bus_cl_get_pdata failed. ret=%d\n", ret);
video/fbdev/msm/mdss_rotator.c:				msm_bus_pdata_from_node(dev, node);
video/fbdev/msm/mdss_rotator.c:	msm_dss_config_vreg(dev, mp->vreg_config, mp->num_vreg, 0);
video/fbdev/msm/mdss_rotator.c:	msm_dss_config_vreg(dev, mp->vreg_config, mp->num_vreg, 1);
video/fbdev/msm/mdss_rotator.c:		msm_bus_scale_unregister_client(mgr->data_bus.bus_hdl);
video/fbdev/msm/mdss_rotator.c:		msm_bus_scale_unregister_client(mgr->reg_bus.bus_hdl);
video/fbdev/msm/mdss_rotator.c:		msm_bus_scale_register_client(
video/fbdev/msm/mdss_rotator.c:			msm_bus_scale_register_client(
video/fbdev/msm/mdss_rotator_internal.h:	struct msm_bus_scale_pdata *bus_scale_pdata;
video/fbdev/msm/mdss_smmu.c:#include <linux/msm_dma_iommu_mapping.h>
video/fbdev/msm/mdss_smmu.c:struct msm_smmu_notifier_data {
video/fbdev/msm/mdss_smmu.c:	msm_smmu_handler_t callback;
video/fbdev/msm/mdss_smmu.c:	struct msm_smmu_notifier_data *notify;
video/fbdev/msm/mdss_smmu.c:int mdss_smmu_request_mappings(msm_smmu_handler_t callback)
video/fbdev/msm/mdss_smmu.c:	struct msm_smmu_notifier_data *ndata;
video/fbdev/msm/mdss_smmu.c:		ndata = kzalloc(sizeof(struct msm_smmu_notifier_data),
video/fbdev/msm/mdss_smmu.c:		rc = msm_dss_enable_vreg(mp->vreg_config, mp->num_vreg, true);
video/fbdev/msm/mdss_smmu.c:		rc = msm_dss_enable_clk(mp->clk_config, mp->num_clk, true);
video/fbdev/msm/mdss_smmu.c:			msm_dss_enable_vreg(mp->vreg_config, mp->num_vreg,
video/fbdev/msm/mdss_smmu.c:		msm_dss_enable_clk(mp->clk_config, mp->num_clk, false);
video/fbdev/msm/mdss_smmu.c:		msm_dss_enable_vreg(mp->vreg_config, mp->num_vreg, false);
video/fbdev/msm/mdss_smmu.c:			msm_dma_unmap_all_for_dev(mdss_smmu->base.dev);
video/fbdev/msm/mdss_smmu.c:				msm_dma_unmap_all_for_dev(mdss_smmu->base.dev);
video/fbdev/msm/mdss_smmu.c: * msm_map_dma_buf is depricated with smmu v2 and it uses dma_map_sg instead
video/fbdev/msm/mdss_smmu.c:	msm_dma_unmap_sg_attrs(mdss_smmu->base.dev, table->sgl, table->nents,
video/fbdev/msm/mdss_smmu.c: * domain and uses dma_map_single as msm_iommu_map_contig_buffer is depricated
video/fbdev/msm/mdss_smmu.c:	rc = msm_dss_config_vreg(&pdev->dev, mp->vreg_config,
video/fbdev/msm/mdss_smmu.c:		msm_dss_config_vreg(&pdev->dev, mp->vreg_config, mp->num_vreg,
video/fbdev/msm/mdss_smmu.c:		msm_dss_config_vreg(&pdev->dev, mp->vreg_config, mp->num_vreg,
video/fbdev/msm/mdss_smmu.c:	msm_dss_config_vreg(&pdev->dev, mp->vreg_config, mp->num_vreg,
video/fbdev/msm/mdss_smmu.c:	struct msm_smmu_notifier_data *node;
video/fbdev/msm/mdss_smmu.c:		node = list_entry(pos, struct msm_smmu_notifier_data, _user);
video/fbdev/msm/mdss_smmu.h:#include <linux/msm_mdp.h>
video/fbdev/msm/mdss_wb.c:#include <linux/msm_mdp.h>
video/fbdev/msm/mhl_msc.c:		struct msm_hdmi_mhl_ops *ops = mhl_ctrl->hdmi_mhl_ops;
video/fbdev/msm/mhl_sii8334.c:#include <linux/usb/msm_hsusb.h>
video/fbdev/msm/mhl_sii8334.c:	struct msm_hdmi_mhl_ops *hdmi_mhl_ops = mhl_ctrl->hdmi_mhl_ops;
video/fbdev/msm/mhl_sii8334.c:static void mhl_msm_connection(struct mhl_tx_ctrl *mhl_ctrl)
video/fbdev/msm/mhl_sii8334.c:	 * msm conn has been established
video/fbdev/msm/mhl_sii8334.c:static void mhl_msm_disconnection(struct mhl_tx_ctrl *mhl_ctrl)
video/fbdev/msm/mhl_sii8334.c:static int mhl_msm_read_rgnd_int(struct mhl_tx_ctrl *mhl_ctrl)
video/fbdev/msm/mhl_sii8334.c:	struct msm_hdmi_mhl_ops *hdmi_mhl_ops = mhl_ctrl->hdmi_mhl_ops;
video/fbdev/msm/mhl_sii8334.c:		mhl_msm_connection(mhl_ctrl);
video/fbdev/msm/mhl_sii8334.c:		mhl_msm_disconnection(mhl_ctrl);
video/fbdev/msm/mhl_sii8334.c:		mhl_msm_read_rgnd_int(mhl_ctrl);
video/fbdev/msm/mhl_sii8334.c:	struct msm_hdmi_mhl_ops *hdmi_mhl_ops = NULL;
video/fbdev/msm/mhl_sii8334.c:				    sizeof(struct msm_hdmi_mhl_ops),
video/fbdev/msm/mhl_sii8334.c:		rc = msm_hdmi_register_mhl(mhl_ctrl->pdata->hdmi_pdev,
video/fbdev/msm/mhl_sii8334.c:	if (msm_register_usb_ext_notification(mhl_info)) {
video/fbdev/msm/msm_dba/Makefile:obj-$(CONFIG_MSM_DBA) += msm_dba.o msm_dba_init.o msm_dba_helpers.o msm_dba_debug.o
video/fbdev/msm/msm_dba/adv7533.c:#include "msm_dba_internal.h"
video/fbdev/msm/msm_dba/adv7533.c:	struct msm_dba_device_info dev_info;
video/fbdev/msm/msm_dba/adv7533.c:	ret = msm_dba_helper_i2c_write_byte(pdata->i2c_client, addr, reg, val);
video/fbdev/msm/msm_dba/adv7533.c:	ret = msm_dba_helper_i2c_read(pdata->i2c_client, addr, reg, buf, size);
video/fbdev/msm/msm_dba/adv7533.c:static int adv7533_dump_debug_info(struct msm_dba_device_info *dev, u32 flags)
video/fbdev/msm/msm_dba/adv7533.c:static void adv7533_notify_clients(struct msm_dba_device_info *dev,
video/fbdev/msm/msm_dba/adv7533.c:		enum msm_dba_callback_event event)
video/fbdev/msm/msm_dba/adv7533.c:	struct msm_dba_client_info *c;
video/fbdev/msm/msm_dba/adv7533.c:		c = list_entry(pos, struct msm_dba_client_info, list);
video/fbdev/msm/msm_dba/adv7533.c:	struct msm_dba_device_info *dev;
video/fbdev/msm/msm_dba/adv7533.c:	struct msm_dba_client_info *cinfo =
video/fbdev/msm/msm_dba/adv7533.c:		(struct msm_dba_client_info *)client;
video/fbdev/msm/msm_dba/adv7533.c:	struct msm_dba_video_cfg *cfg)
video/fbdev/msm/msm_dba/adv7533.c:		rc = msm_dss_config_vreg(&pdata->i2c_client->dev,
video/fbdev/msm/msm_dba/adv7533.c:		rc = msm_dss_config_vreg(&pdata->i2c_client->dev,
video/fbdev/msm/msm_dba/adv7533.c:		rc = msm_dss_enable_vreg(power_data->vreg_config,
video/fbdev/msm/msm_dba/adv7533.c:		rc = msm_dss_enable_vreg(power_data->vreg_config,
video/fbdev/msm/msm_dba/adv7533.c:	struct msm_dba_video_cfg *cfg, u32 flags)
video/fbdev/msm/msm_dba/adv7533.c:	struct msm_dba_audio_cfg *cfg, u32 flags)
video/fbdev/msm/msm_dba/adv7533.c:static int adv7533_write_reg(struct msm_dba_device_info *dev,
video/fbdev/msm/msm_dba/adv7533.c:static int adv7533_read_reg(struct msm_dba_device_info *dev,
video/fbdev/msm/msm_dba/adv7533.c:	struct msm_dba_ops *client_ops;
video/fbdev/msm/msm_dba/adv7533.c:	struct msm_dba_device_ops *dev_ops;
video/fbdev/msm/msm_dba/adv7533.c:	return msm_dba_add_probed_device(&pdata->dev_info);
video/fbdev/msm/msm_dba/adv7533.c:	msm_dba_remove_probed_device(&pdata->dev_info);
video/fbdev/msm/msm_dba/adv7533.c:	ret = msm_dba_helper_sysfs_init(&client->dev);
video/fbdev/msm/msm_dba/adv7533.c:	msm_dba_helper_sysfs_remove(&client->dev);
video/fbdev/msm/msm_dba/adv7533.c:	struct msm_dba_device_info *dev;
video/fbdev/msm/msm_dba/msm_dba.c:#include <video/msm_dba.h>
video/fbdev/msm/msm_dba/msm_dba.c:#include <msm_dba_internal.h>
video/fbdev/msm/msm_dba/msm_dba.c:void *msm_dba_register_client(struct msm_dba_reg_info *info,
video/fbdev/msm/msm_dba/msm_dba.c:			      struct msm_dba_ops *ops)
video/fbdev/msm/msm_dba/msm_dba.c:	struct msm_dba_device_info *device = NULL;
video/fbdev/msm/msm_dba/msm_dba.c:	struct msm_dba_client_info *client = NULL;
video/fbdev/msm/msm_dba/msm_dba.c:	rc = msm_dba_get_probed_device(info, &device);
video/fbdev/msm/msm_dba/msm_dba.c:EXPORT_SYMBOL(msm_dba_register_client);
video/fbdev/msm/msm_dba/msm_dba.c:int msm_dba_deregister_client(void *client)
video/fbdev/msm/msm_dba/msm_dba.c:	struct msm_dba_client_info *handle = client;
video/fbdev/msm/msm_dba/msm_dba.c:	struct msm_dba_client_info *node = NULL;
video/fbdev/msm/msm_dba/msm_dba.c:		node = list_entry(position, struct msm_dba_client_info, list);
video/fbdev/msm/msm_dba/msm_dba.c:EXPORT_SYMBOL(msm_dba_deregister_client);
video/fbdev/msm/msm_dba/msm_dba_debug.c:#include <video/msm_dba.h>
video/fbdev/msm/msm_dba/msm_dba_debug.c:#include "msm_dba_internal.h"
video/fbdev/msm/msm_dba/msm_dba_debug.c:static inline struct msm_dba_device_info *to_dba_dev(struct device *dev)
video/fbdev/msm/msm_dba/msm_dba_debug.c:	struct msm_dba_device_info *device = to_dba_dev(dev);
video/fbdev/msm/msm_dba/msm_dba_debug.c:	struct msm_dba_device_info *device = to_dba_dev(dev);
video/fbdev/msm/msm_dba/msm_dba_debug.c:	struct msm_dba_client_info *c;
video/fbdev/msm/msm_dba/msm_dba_debug.c:		c = list_entry(pos, struct msm_dba_client_info, list);
video/fbdev/msm/msm_dba/msm_dba_debug.c:	struct msm_dba_device_info *device = to_dba_dev(dev);
video/fbdev/msm/msm_dba/msm_dba_debug.c:	struct msm_dba_client_info *c;
video/fbdev/msm/msm_dba/msm_dba_debug.c:		c = list_entry(pos, struct msm_dba_client_info, list);
video/fbdev/msm/msm_dba/msm_dba_debug.c:	struct msm_dba_device_info *device = to_dba_dev(dev);
video/fbdev/msm/msm_dba/msm_dba_debug.c:	struct msm_dba_client_info *c;
video/fbdev/msm/msm_dba/msm_dba_debug.c:		c = list_entry(pos, struct msm_dba_client_info, list);
video/fbdev/msm/msm_dba/msm_dba_debug.c:	struct msm_dba_device_info *device = to_dba_dev(dev);
video/fbdev/msm/msm_dba/msm_dba_debug.c:	struct msm_dba_client_info *c;
video/fbdev/msm/msm_dba/msm_dba_debug.c:		c = list_entry(pos, struct msm_dba_client_info, list);
video/fbdev/msm/msm_dba/msm_dba_debug.c:	struct msm_dba_device_info *device = to_dba_dev(dev);
video/fbdev/msm/msm_dba/msm_dba_debug.c:	struct msm_dba_device_info *device = to_dba_dev(dev);
video/fbdev/msm/msm_dba/msm_dba_debug.c:	struct msm_dba_device_info *device = to_dba_dev(dev);
video/fbdev/msm/msm_dba/msm_dba_debug.c:	struct msm_dba_device_info *device = to_dba_dev(dev);
video/fbdev/msm/msm_dba/msm_dba_debug.c:static struct attribute *msm_dba_sysfs_attrs[] = {
video/fbdev/msm/msm_dba/msm_dba_debug.c:static struct attribute_group msm_dba_sysfs_attr_grp = {
video/fbdev/msm/msm_dba/msm_dba_debug.c:	.attrs = msm_dba_sysfs_attrs,
video/fbdev/msm/msm_dba/msm_dba_debug.c:int msm_dba_helper_sysfs_init(struct device *dev)
video/fbdev/msm/msm_dba/msm_dba_debug.c:	rc = sysfs_create_group(&dev->kobj, &msm_dba_sysfs_attr_grp);
video/fbdev/msm/msm_dba/msm_dba_debug.c:void msm_dba_helper_sysfs_remove(struct device *dev)
video/fbdev/msm/msm_dba/msm_dba_debug.c:	sysfs_remove_group(&dev->kobj, &msm_dba_sysfs_attr_grp);
video/fbdev/msm/msm_dba/msm_dba_helpers.c:#include <video/msm_dba.h>
video/fbdev/msm/msm_dba/msm_dba_helpers.c:#include "msm_dba_internal.h"
video/fbdev/msm/msm_dba/msm_dba_helpers.c:static void msm_dba_helper_hdcp_handler(struct work_struct *work)
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_device_info *dev;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	dev = container_of(work, struct msm_dba_device_info, hdcp_work);
video/fbdev/msm/msm_dba/msm_dba_helpers.c:static void msm_dba_helper_issue_cb(struct msm_dba_device_info *dev,
video/fbdev/msm/msm_dba/msm_dba_helpers.c:				    struct msm_dba_client_info *client,
video/fbdev/msm/msm_dba/msm_dba_helpers.c:				    enum msm_dba_callback_event event)
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_client_info *c;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:		c = list_entry(pos, struct msm_dba_client_info, list);
video/fbdev/msm/msm_dba/msm_dba_helpers.c:static irqreturn_t msm_dba_helper_irq_handler(int irq, void *dev)
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_device_info *device = dev;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:		msm_dba_helper_issue_cb(device, NULL, mask);
video/fbdev/msm/msm_dba/msm_dba_helpers.c:int msm_dba_helper_i2c_write_byte(struct i2c_client *client,
video/fbdev/msm/msm_dba/msm_dba_helpers.c:int msm_dba_helper_i2c_write_buffer(struct i2c_client *client,
video/fbdev/msm/msm_dba/msm_dba_helpers.c:int msm_dba_helper_i2c_read(struct i2c_client *client,
video/fbdev/msm/msm_dba/msm_dba_helpers.c:int msm_dba_helper_power_on(void *client, bool on, u32 flags)
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_client_info *c = client;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_device_info *device;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_client_info *node;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:			node = list_entry(pos, struct msm_dba_client_info,
video/fbdev/msm/msm_dba/msm_dba_helpers.c:int msm_dba_helper_video_on(void *client, bool on,
video/fbdev/msm/msm_dba/msm_dba_helpers.c:			    struct msm_dba_video_cfg *cfg, u32 flags)
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_client_info *c = client;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_device_info *device;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_client_info *node;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:			node = list_entry(pos, struct msm_dba_client_info,
video/fbdev/msm/msm_dba/msm_dba_helpers.c:int msm_dba_helper_interrupts_enable(void *client, bool on,
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_client_info *c = client;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_device_info *device;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:int msm_dba_helper_register_irq(struct msm_dba_device_info *dev,
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	rc = request_threaded_irq(irq, NULL, msm_dba_helper_irq_handler,
video/fbdev/msm/msm_dba/msm_dba_helpers.c:int msm_dba_helper_get_caps(void *client, struct msm_dba_capabilities *caps)
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_client_info *c = client;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_device_info *device;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:int msm_dba_register_hdcp_monitor(struct msm_dba_device_info *dev, bool enable)
video/fbdev/msm/msm_dba/msm_dba_helpers.c:		INIT_WORK(&dev->hdcp_work, msm_dba_helper_hdcp_handler);
video/fbdev/msm/msm_dba/msm_dba_helpers.c:int msm_dba_helper_force_reset(void *client, u32 flags)
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_client_info *c = client;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	struct msm_dba_device_info *device;
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	msm_dba_helper_issue_cb(device, c, MSM_DBA_CB_PRE_RESET);
video/fbdev/msm/msm_dba/msm_dba_helpers.c:	msm_dba_helper_issue_cb(device, c, MSM_DBA_CB_POST_RESET);
video/fbdev/msm/msm_dba/msm_dba_init.c:#include <video/msm_dba.h>
video/fbdev/msm/msm_dba/msm_dba_init.c:#include "msm_dba_internal.h"
video/fbdev/msm/msm_dba/msm_dba_init.c:struct msm_dba_device_list {
video/fbdev/msm/msm_dba/msm_dba_init.c:	struct msm_dba_device_info *dev;
video/fbdev/msm/msm_dba/msm_dba_init.c:int msm_dba_add_probed_device(struct msm_dba_device_info *dev)
video/fbdev/msm/msm_dba/msm_dba_init.c:	struct msm_dba_device_list *node;
video/fbdev/msm/msm_dba/msm_dba_init.c:int msm_dba_get_probed_device(struct msm_dba_reg_info *reg,
video/fbdev/msm/msm_dba/msm_dba_init.c:			      struct msm_dba_device_info **dev)
video/fbdev/msm/msm_dba/msm_dba_init.c:	struct msm_dba_device_list *node;
video/fbdev/msm/msm_dba/msm_dba_init.c:		node = list_entry(position, struct msm_dba_device_list, list);
video/fbdev/msm/msm_dba/msm_dba_init.c:int msm_dba_remove_probed_device(struct msm_dba_device_info *dev)
video/fbdev/msm/msm_dba/msm_dba_init.c:	struct msm_dba_device_list *node;
video/fbdev/msm/msm_dba/msm_dba_init.c:		node = list_entry(position, struct msm_dba_device_list, list);
video/fbdev/msm/msm_dba/msm_dba_internal.h:#include <video/msm_dba.h>
video/fbdev/msm/msm_dba/msm_dba_internal.h:struct msm_dba_client_info;
video/fbdev/msm/msm_dba/msm_dba_internal.h:struct msm_dba_device_info;
video/fbdev/msm/msm_dba/msm_dba_internal.h: * struct msm_dba_device_ops - Function pointers to device specific operations
video/fbdev/msm/msm_dba/msm_dba_internal.h: * @dev_power_on: Power on operation called by msm_dba_helper_power_on. Mutex
video/fbdev/msm/msm_dba/msm_dba_internal.h: * @dev_video_on: Video on operation called by msm_dba_helper_video_on. Mutex
video/fbdev/msm/msm_dba/msm_dba_internal.h: *		        the bridge driver uses msm_dba_helper_register_irq
video/fbdev/msm/msm_dba/msm_dba_internal.h:struct msm_dba_device_ops {
video/fbdev/msm/msm_dba/msm_dba_internal.h:	int (*dev_power_on)(struct msm_dba_device_info *dev, bool on);
video/fbdev/msm/msm_dba/msm_dba_internal.h:	int (*dev_video_on)(struct msm_dba_device_info *dev,
video/fbdev/msm/msm_dba/msm_dba_internal.h:			    struct msm_dba_video_cfg *cfg, bool on);
video/fbdev/msm/msm_dba/msm_dba_internal.h:	int (*handle_interrupts)(struct msm_dba_device_info *dev, u32 *mask);
video/fbdev/msm/msm_dba/msm_dba_internal.h:	int (*unmask_interrupts)(struct msm_dba_device_info *dev, u32 mask);
video/fbdev/msm/msm_dba/msm_dba_internal.h:	int (*hdcp_reset)(struct msm_dba_device_info *dev);
video/fbdev/msm/msm_dba/msm_dba_internal.h:	int (*hdcp_retry)(struct msm_dba_device_info *dev, u32 flags);
video/fbdev/msm/msm_dba/msm_dba_internal.h:	int (*write_reg)(struct msm_dba_device_info *dev, u32 reg, u32 val);
video/fbdev/msm/msm_dba/msm_dba_internal.h:	int (*read_reg)(struct msm_dba_device_info *dev, u32 reg, u32 *val);
video/fbdev/msm/msm_dba/msm_dba_internal.h:	int (*force_reset)(struct msm_dba_device_info *dev, u32 flags);
video/fbdev/msm/msm_dba/msm_dba_internal.h:	int (*dump_debug_info)(struct msm_dba_device_info *dev, u32 flags);
video/fbdev/msm/msm_dba/msm_dba_internal.h: * struct msm_dba_device_info - Device specific information
video/fbdev/msm/msm_dba/msm_dba_internal.h:struct msm_dba_device_info {
video/fbdev/msm/msm_dba/msm_dba_internal.h:	struct msm_dba_capabilities caps;
video/fbdev/msm/msm_dba/msm_dba_internal.h:	struct msm_dba_device_ops dev_ops;
video/fbdev/msm/msm_dba/msm_dba_internal.h:	struct msm_dba_ops client_ops;
video/fbdev/msm/msm_dba/msm_dba_internal.h:	int (*reg_fxn)(struct msm_dba_client_info *client);
video/fbdev/msm/msm_dba/msm_dba_internal.h:	int (*dereg_fxn)(struct msm_dba_client_info *client);
video/fbdev/msm/msm_dba/msm_dba_internal.h: * struct msm_dba_client_info - Client specific information
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_register_client.
video/fbdev/msm/msm_dba/msm_dba_internal.h:struct msm_dba_client_info {
video/fbdev/msm/msm_dba/msm_dba_internal.h:	struct msm_dba_device_info *dev;
video/fbdev/msm/msm_dba/msm_dba_internal.h:	msm_dba_cb cb;
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_add_probed_device() - Add a new device to the probed devices list.
video/fbdev/msm/msm_dba/msm_dba_internal.h: *	  msm_dba_remove_probed_device() is called.
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_add_probed_device(struct msm_dba_device_info *info);
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_remove_probed_device() - Remove a device from the probed devices list
video/fbdev/msm/msm_dba/msm_dba_internal.h: *	  same pointer used for msm_dba_add_probed_device().
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_remove_probed_device(struct msm_dba_device_info *info);
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_get_probed_device() - Check if a device is present in the device list
video/fbdev/msm/msm_dba/msm_dba_internal.h: * When clients of the MSM DBA driver call msm_dba_register_client(), the MSM
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_get_probed_device(struct msm_dba_reg_info *reg,
video/fbdev/msm/msm_dba/msm_dba_internal.h:			      struct msm_dba_device_info **info);
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_helper_i2c_read() - perform an i2c read transaction
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_helper_i2c_read(struct i2c_client *client,
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_helper_i2c_write_buffer() - write buffer to i2c slave.
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_helper_i2c_write_buffer(struct i2c_client *client,
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_helper_i2c_write_byte() - write to a register on an i2c slave.
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_helper_i2c_write_byte(struct i2c_client *client,
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_helper_power_on() - power on bridge chip
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_ops. Internally, this function does some bookkeeping to figure out
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_helper_power_on(void *client, bool on, u32 flags);
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_helper_video_on() - video on bridge chip
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_ops. Internally, this function does some bookkeeping to figure out
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_helper_video_on(void *client, bool on,
video/fbdev/msm/msm_dba/msm_dba_internal.h:			    struct msm_dba_video_cfg *cfg, u32 flags);
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_helper_interrupts_enable() - manage interrupt callbacks
video/fbdev/msm/msm_dba/msm_dba_internal.h: * function pointer in struct msm_dba_ops.
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_helper_interrupts_enable(void *client, bool on,
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_helper_get_caps() - return device capabilities
video/fbdev/msm/msm_dba/msm_dba_internal.h: * Helper function to replace get_caps function pointer in struct msm_dba_ops
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_helper_get_caps(void *client, struct msm_dba_capabilities *caps);
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_helper_register_irq() - register irq and handle interrupts.
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_helper_register_irq(struct msm_dba_device_info *dev,
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_register_hdcp_monitor() - kicks off monitoring for hdcp failures
video/fbdev/msm/msm_dba/msm_dba_internal.h: * is handled through msm dba helper functions.
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_register_hdcp_monitor(struct msm_dba_device_info *dev, bool enable);
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_helper_sysfs_init() - create sysfs attributes for debugging
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_helper_sysfs_init(struct device *dev);
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_helper_sysfs_remove() - remove sysfs attributes
video/fbdev/msm/msm_dba/msm_dba_internal.h:void msm_dba_helper_sysfs_remove(struct device *dev);
video/fbdev/msm/msm_dba/msm_dba_internal.h: * msm_dba_helper_force_reset() - force reset bridge chip
video/fbdev/msm/msm_dba/msm_dba_internal.h: * Helper function to replace force_reset function pointer in struct msm_dba_ops
video/fbdev/msm/msm_dba/msm_dba_internal.h:int msm_dba_helper_force_reset(void *client, u32 flags);
video/fbdev/msm/msm_mdss_io_8974.c:			rc = msm_dss_enable_vreg(
video/fbdev/msm/msm_mdss_io_8974.c:			rc = msm_dss_enable_vreg(
video/fbdev/msm/mdss_dsi.c:#include <linux/msm-bus.h>
video/fbdev/msm/mdss_dsi.c:		rc = msm_dss_config_vreg(&pdev->dev,
video/fbdev/msm/mdss_dsi.c:				msm_dss_config_vreg(&pdev->dev,
video/fbdev/msm/mdss_dsi.c:	ret = msm_dss_enable_vreg(
video/fbdev/msm/mdss_dsi.c:	ret = msm_dss_enable_vreg(
video/fbdev/msm/mdss_dsi.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_dsi.c:		mfd = (struct msm_fb_data_type *)fbi->par;
video/fbdev/msm/mdss_dsi.c:	sdata->bus_scale_table = msm_bus_cl_get_pdata(pdev);
video/fbdev/msm/mdss_dsi.c:		pr_err("%s: msm_bus_cl_get_pdata() failed, rc=%d\n", __func__,
video/fbdev/msm/mdss_dsi.c:		msm_bus_scale_register_client(sdata->bus_scale_table);
video/fbdev/msm/mdss_dsi.c:			msm_bus_scale_client_update_request(sdata->bus_handle,
video/fbdev/msm/mdss_dsi.c:		msm_bus_scale_unregister_client(sdata->bus_handle);
video/fbdev/msm/mdss_dsi.c:		if (msm_dss_config_vreg(&pdev->dev,
video/fbdev/msm/mdss_dsi.c:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_dsi.c:	if (msm_dss_config_vreg(&pdev->dev,
video/fbdev/msm/mdss_dsi.c:	msm_dss_iounmap(&ctrl_pdata->mmss_misc_io);
video/fbdev/msm/mdss_dsi.c:	msm_dss_iounmap(&ctrl_pdata->phy_io);
video/fbdev/msm/mdss_dsi.c:	msm_dss_iounmap(&ctrl_pdata->ctrl_io);
video/fbdev/msm/mdss_dsi.c:	rc = msm_dss_ioremap_byname(pdev, &ctrl->ctrl_io, "dsi_ctrl");
video/fbdev/msm/mdss_dsi.c:	rc = msm_dss_ioremap_byname(pdev, &ctrl->phy_io, "dsi_phy");
video/fbdev/msm/mdss_dsi.c:	rc = msm_dss_ioremap_byname(pdev, &ctrl->phy_regulator_io,
video/fbdev/msm/mdss_dsi.c:	rc = msm_dss_ioremap_byname(pdev, &ctrl->mmss_misc_io,
video/fbdev/msm/mdss_dsi.c:		pr_err("msm_dsi_irq_init request_irq() failed!\n");
video/fbdev/msm/mdss_dsi.c:	rc = msm_dss_config_vreg(&ctrl_pdev->dev,
video/fbdev/msm/mdss_dsi.c:		rc = msm_dss_enable_vreg(
video/fbdev/msm/mdss_dsi.h:	struct msm_bus_scale_pdata *bus_scale_table;
video/fbdev/msm/mdss_dsi.h:	struct msm_fb_data_type *mfd;
video/fbdev/msm/mdss_mdp_ctl.c:				       struct msm_fb_data_type *mfd)
video/fbdev/msm/mdss_mdp_ctl.c:int mdss_mdp_async_ctl_flush(struct msm_fb_data_type *mfd,
Kconfig:source "drivers/gpu/msm/Kconfig"
